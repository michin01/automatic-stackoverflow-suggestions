Id,Title,CommentCount,Body,Text
"24094973","What to use for two way binding in react js , props or state?","0","<p>I am trying to create a form using reactjs , I am trying out twoway binding .
I am not able to use props in the valueLink because it is can only take state .</p>

<p>Problem 1 : I am passing in properties when creating a component and in getInitial state I am setting it into state , as I cannot use props in valueLink . What is the better approach ?</p>

<p>I want to send every change in a text box to do some computation in server and get the computed values to state.</p>

<p>Problem 2 : I am unable to use method componentWillReceiveProps because , I use state .I am also unable use shouldComponentUpdate as I cannot do setState. What can I use here ?</p>
",""
"30078260","React.js shouldComponentUpdate() and react-router Link","2","<p>I currently have a doubt about the correct combined implementation of <strong>react-router Link navigation</strong> and <strong>shouldComponentUpdate()</strong> on the root application level.</p>

<p>That is, I have a root component called <strong>App.jsx</strong> which contains a global component with a <em>header, footer, sidebar</em> etc and this same component has an <em>ajax long-poll</em> which retrieves new registrations in the system and updates the state when new users register.</p>

<p>Since I don't want to push a re-render to the component <em>(and therefore all it's children)</em> on ajax responses that don't have updates I decided to make use of the lovely <strong>shouldComponentUpdate()</strong> method.</p>

<p>So, I came up with something like this - noting that I'm making use of lo-dash:</p>

<pre><code>shouldComponentUpdate (/*prevProps*/, prevState) {
  return !_.isEqual(this.state,prevState);
}
</code></pre>

<p>With this the component correctly ignores irrelevant responses about the latest registrations.</p>

<p>Now, the problem appears when I have to make the routing. To clarify before, this is the kind of structure of the <strong>render()</strong>:</p>

<p><em>Note: the _routerTransitionKey is just a helper I have to not make transitions when I'm navigating internal views state and it's working correctly.</em></p>

<pre><code>&lt;Grid key='app' id=""wrapper"" className=""no-padding""&gt;
  &lt;Header user={this.state.user} allRegistrations={this.state.allRegistrations}/&gt;
  &lt;section id=""page-wrapper""&gt;
    &lt;NotificationArea key='internalNotification' /&gt;
    &lt;RouteHandler key={_routerTransitionKey} user={this.state.user} allRegistrations={this.state.allRegistrations}/&gt;
  &lt;/section&gt;
&lt;/Grid&gt;
</code></pre>

<p>Because I have the RouteHandler inside this global component, I have the issue that a change in the route is completely ignored by it, <strong>since the application state itself didn't change</strong>. That causes the component to never trigger the <strong>render()</strong> on navigation and therefore <em>never update the RouteHandler</em>.</p>

<p>What I needed would be something like:</p>

<pre><code> shouldComponentUpdate (/*prevProps*/, prevState) {
   return !_.isEqual(this.state,prevState) || ROUTE_CHANGED ;
 }
</code></pre>

<p>My question is: does anybody out there knows of a clever approach to this issue? I'm trying to avoid having to create yet another wrapping component to handle the Routes before they reach this App component I currently have...</p>
","Hey @WayneC, I was trying your suggestion now and apparently the react-router props are not injected into the react props at this stage. That means it's not possible to use that to compare the previous and next paths. Thanks for the suggestion though."
"30078260","React.js shouldComponentUpdate() and react-router Link","2","<p>I currently have a doubt about the correct combined implementation of <strong>react-router Link navigation</strong> and <strong>shouldComponentUpdate()</strong> on the root application level.</p>

<p>That is, I have a root component called <strong>App.jsx</strong> which contains a global component with a <em>header, footer, sidebar</em> etc and this same component has an <em>ajax long-poll</em> which retrieves new registrations in the system and updates the state when new users register.</p>

<p>Since I don't want to push a re-render to the component <em>(and therefore all it's children)</em> on ajax responses that don't have updates I decided to make use of the lovely <strong>shouldComponentUpdate()</strong> method.</p>

<p>So, I came up with something like this - noting that I'm making use of lo-dash:</p>

<pre><code>shouldComponentUpdate (/*prevProps*/, prevState) {
  return !_.isEqual(this.state,prevState);
}
</code></pre>

<p>With this the component correctly ignores irrelevant responses about the latest registrations.</p>

<p>Now, the problem appears when I have to make the routing. To clarify before, this is the kind of structure of the <strong>render()</strong>:</p>

<p><em>Note: the _routerTransitionKey is just a helper I have to not make transitions when I'm navigating internal views state and it's working correctly.</em></p>

<pre><code>&lt;Grid key='app' id=""wrapper"" className=""no-padding""&gt;
  &lt;Header user={this.state.user} allRegistrations={this.state.allRegistrations}/&gt;
  &lt;section id=""page-wrapper""&gt;
    &lt;NotificationArea key='internalNotification' /&gt;
    &lt;RouteHandler key={_routerTransitionKey} user={this.state.user} allRegistrations={this.state.allRegistrations}/&gt;
  &lt;/section&gt;
&lt;/Grid&gt;
</code></pre>

<p>Because I have the RouteHandler inside this global component, I have the issue that a change in the route is completely ignored by it, <strong>since the application state itself didn't change</strong>. That causes the component to never trigger the <strong>render()</strong> on navigation and therefore <em>never update the RouteHandler</em>.</p>

<p>What I needed would be something like:</p>

<pre><code> shouldComponentUpdate (/*prevProps*/, prevState) {
   return !_.isEqual(this.state,prevState) || ROUTE_CHANGED ;
 }
</code></pre>

<p>My question is: does anybody out there knows of a clever approach to this issue? I'm trying to avoid having to create yet another wrapping component to handle the Routes before they reach this App component I currently have...</p>
","any reason you are ignoring props in the shouldComponentUpdate() ? React router injects the current path into [routehandler props](https://github.com/rackt/react-router/blob/master/doc/03%20Components/Route%20Handler.md), so they would change. (Is your app.jsx a routehandler too?)"
"30226313","How to check if react shouldComponentUpdate works correctly","1","<p>So I have lots of components and each of them has own <code>shouldComponentUpdate()</code> function. Most of them simply compare states based on immutable.js datasets. Some of them compares props. Some of them work with <a href=""https://facebook.github.io/react/docs/pure-render-mixin.html"" rel=""nofollow"">PureRenderMixin</a>. But with app's growth new states are added, new props are added, stores change their API and so on. So, at the moment I need something to check what actually going on while developing. I can use Chrome DevTools to review  and visualize where DOM is changed but have no idea how to check if react virtual DOM is changed.</p>

<p>I have an idea to cover <code>shouldComponentUpdate()</code>-s with tests but it seems to be a testing overhead as I test each possible state twice: its behavior in my app and its behaviour in <code>shouldComponentUpdate()</code>.</p>
","I don't understand what you're asking. Could you clarify your question?"
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","I'm facing the same questions and signs are pointing to using an addon library of some sort which handles this for you. Currently, I'm looking at https://omniscientjs.github.io/ which is exactly what you are trying to achieve."
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","The thing must hold onto its own state, and the owner component should hold onto whether it exists in that list. You're changing props, which is a big no-no."
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","I've written a boilerplate, which includes the example above, using Omniscient. Available here: https://github.com/datashaman/react-quickie"
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","Does adding a 'key' to the Thing help? It's required for lists of things to work correctly."
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","The omniscient documentation is a little fragmented, but this guide here is good at explaining what's going on in omniscient. Not sure if it warrants an answer for you, but it comes close. http://omniscientjs.github.io/guides/01-simpler-ui-reasoning-with-unidirectional/"
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","I will say that unless you start with omniscient, it's a PITA to migrate an existing codebase. But working with it from scratch, it's a thing of great beauty."
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","Thanks, I forgot to add a `key` prop to each `Thing` component -- I've updated the example. However that won't solve this issue as it's the `thing` prop that gets changed because the cursor changes on each update.

Omnicient seems to accomplish something similar using cursors and Immutable.js but I couldn't quite understand the implementation on the admittedly short time I've spent with it. I was hoping if there was no direct solution to the question someone could provide a high level explanation of how a tool like Omniscient accomplishes what we're trying to do here."
"30232219","Using React's shouldComponentUpdate with Immutable.js cursors","8","<p>I'm having trouble figuring out how to short circuit rendering a branch
of a tree of React components using Immutable.js cursors.</p>

<p>Take the following example:</p>

<pre><code>import React from 'react';
import Immutable from 'immutable';
import Cursor from 'immutable/contrib/cursor';

let data = Immutable.fromJS({
  things: [
    {title: '', key: 1},
    {title: '', key: 2}
  ]
});

class Thing extends React.Component {
  shouldComponentUpdate(nextProps) {
    return this.props.thing.deref() !== nextProps.thing.deref();
  }

  handleChangeTitle(e) {
    this.props.thing.set('title', e.target.value);
  }    

  render() {
    return &lt;div&gt;
      &lt;input value={this.props.thing.get('title')} 
        onChange={this.handleChangeTitle.bind(this)} /&gt;
    &lt;/div&gt;;
  }
}

class Container extends React.Component {
  render() {
    const cursor = Cursor.from(this.props.data, 'things', newThings =&gt; {
      data.set('things', newThings);
      renderContainer();
    });

    const things = cursor.map(thing =&gt; (
      &lt;Thing thing={thing} key={thing.get('key')} /&gt;
    ));

    return &lt;div&gt;
      {things}
    &lt;/div&gt;;
  }
}

const renderContainer = () =&gt; {
  React.render(&lt;Container data={data} /&gt;, document.getElementById('someDiv'));
};
</code></pre>

<p>Say I change the first <code>Thing</code>'s title. Only the first <code>Thing</code> will render with
the new title and the second <code>Thing</code> will not re-render due to
<code>shouldComponentUpdate</code>. However, if I change the second <code>Thing</code>'s title, the
  first <code>Thing</code>'s title will go back to <code>''</code> since the second <code>Thing</code>'s cursor
is still pointing at an older version of the root data.</p>

<p>We update the cursors on each render of <code>Container</code> but the ones that don't
render due to <code>shouldComponentUpdate</code> also don't get the new cursor with the updated
root data. The only way I can see keeping the cursors up to date is to remove
<code>shouldComponentUpdate</code> in the <code>Thing</code> component in this example.</p>

<p>Is there a way to change this example to use <code>shouldComponentUpdate</code> using fast referential
equality checks but also keep the cursors updated?</p>

<p>Or, if that's not possible, could you provide an overview of how you would generally work with cursors + React components and rendering only components with updated data?</p>
","Have you ever tried https://github.com/arqex/freezer instead of Immutable & cursors? Much more lightweight and easier to use."
"31061189","get data from external json with react and d3","0","<p>I am brand new to React. Am using v0.13.3. I have a functioning page (index.html with link to external css file and external js file). All works great.</p>

<p>JS file contains exactly what is in the JavaScript pane of this <a href=""http://jsfiddle.net/airwwwave/32284cze/13/"" rel=""nofollow"">JSFIDDLE</a>. (Apologies the fiddle doesn't run, I can't figure out why console says <code>Uncaught SyntaxError: Unexpected token &lt;</code>. I have <code>/** @jsx React.DOM */</code> at the top, but anyway...it makes a chart.)</p>

<p>QUESTION: How can I get what is in</p>

<pre><code>var data = [{""letter"":""A"",""frequency"":0.08167},""letter"":""B"",""frequency"":0.01492},{""letter"":""C"",""frequency"":0.02782},{""letter"":""D"",""frequency"":0.04253},...]
</code></pre>

<p>to come from an external JSON file instead? (I want the chart to update if the JSON file's contents change).</p>

<p>(I realize there is the option to use React to break all of the pieces of the d3 chart into separate components and do it that way instead of all of the d3 inside one function. But for now, I'd like it to remain this way - based on the conclusion of <a href=""http://ahmadchatha.com/writings/article1.html"" rel=""nofollow"">this article</a>.) </p>

<p>So, it didn't work to use <code>d3.json(path/to/file.js)</code> inside <code>function createChart</code>. And I've tried what is in <a href=""https://facebook.github.io/react/docs/tutorial.html"" rel=""nofollow"">this tutorial</a> under ""Hook Up the Data Model"" and ""Fetching from the server"", but I'm not having any luck. Also, looked at <a href=""https://facebook.github.io/react/tips/initial-ajax.html"" rel=""nofollow"">this article</a>. I'm suspecting I need to do something else with <code>componentDidMount</code> and <code>shouldComponentUpdate</code>, but a bit baffled. Searched for other examples, but having trouble finding one like this. Thanks for any suggestions.</p>
",""
"33523115","shouldComponentUpdate + deepEqual and arrays","0","<p><strong>Problem:</strong> <code>shouldComponentUpdate</code> retrieves previous state with <code>this.state</code>, that doesn't work if you keep reference to array at <code>UserList</code>, and update array entity at <code>UserStore</code>.</p>

<p><strong><em><code>PureRenderMixin.js</code></em></strong></p>

<pre><code>const deepEqual = require('deep-equal');

module.exports = function pureRenderMixin(Component) {
    Component.prototype.shouldComponentUpdate = function(nextProps, nextState) {
        return !deepEqual(this.props, nextProps) || !deepEqual(this.state, nextState);
    };
    return Component;
};
</code></pre>

<p><strong><em><code>UserList.react.js</code></em></strong></p>

<pre><code>class UserList extends React.Component {

    constructor(props) { 
        super(props);
        this._onChange = this._onChange.bind(this);
    }

    componentWillMount() {
        UsersStore.addChangeListener(this._onChange);
    }

    _onChange() {            
        this.setState({userList: UsersStore.getState()});
    }
}

module.exports = PureRenderMixin(UserList);
</code></pre>

<p><strong><em><code>UsersStore.js</code></em></strong></p>

<pre><code>......
getState() { return _userList; }

switch(action.type) {
   case ActionTypes.UPDATE_USER_FLAG:
       //!!!!!!!!!!!!!!
       //PROBLEM: since UserList.react keep userList reference, there is no way to retrieve previous state inside shouldComponentUpdate
       _userList[action.index].flag = action.flag;
       UsersStore.emitChange();
       break;
}
</code></pre>

<h2>@taggon solution</h2>

<p>thanks to taggon, now I know how to make <code>shouldComponentUpdate</code> keep the reference to previous state:</p>

<p><strong><em><code>UsersStore.js</code></em></strong></p>

<pre><code>......
getState() { return _userList; }

switch(action.type) {
   case ActionTypes.UPDATE_USER_FLAG:
       //SOLUTION: copy an array, so there will be two versions of _userList[action.index]
       _userList =  _.map(_userList, _.clone);

       _userList[action.index].flag = action.flag;
       UsersStore.emitChange();
       break;
}
</code></pre>
",""
"33747060","shouldComponentUpdate and child components","2","<p>I have a couple wrapper components which dynamically calculate the size and position they need to be. Normally this works and performs great with <code>shouldComponentUpdate</code>, but as soon as I add children inside these components I can no longer use this method. Why? Because if i return 'false' for the wrapper needing an update... the children never get updated themselves :(</p>

<p>Example JSX:</p>

<p><code>&lt;ReactWrapper&gt;
  &lt;ChildElement/&gt;
&lt;/ReactWrapper&gt;
</code></p>

<p>Is there any good way around this? Only idea I have is to add a new method shouldUpdateChildren like this other question detailed: <a href=""https://discuss.reactjs.org/t/shouldcomponentupdate-and-children/2055"" rel=""nofollow"">https://discuss.reactjs.org/t/shouldcomponentupdate-and-children/2055</a></p>
","Simply because it's not necessary to run any calculations for the x, y, width, height of the component. Why recalc when you know you don't have to?"
"33747060","shouldComponentUpdate and child components","2","<p>I have a couple wrapper components which dynamically calculate the size and position they need to be. Normally this works and performs great with <code>shouldComponentUpdate</code>, but as soon as I add children inside these components I can no longer use this method. Why? Because if i return 'false' for the wrapper needing an update... the children never get updated themselves :(</p>

<p>Example JSX:</p>

<p><code>&lt;ReactWrapper&gt;
  &lt;ChildElement/&gt;
&lt;/ReactWrapper&gt;
</code></p>

<p>Is there any good way around this? Only idea I have is to add a new method shouldUpdateChildren like this other question detailed: <a href=""https://discuss.reactjs.org/t/shouldcomponentupdate-and-children/2055"" rel=""nofollow"">https://discuss.reactjs.org/t/shouldcomponentupdate-and-children/2055</a></p>
","Can you show code of the logic you are using? Why do you need to `return false` in `shouldComponentUpdate`?"
"33784606","react-router html5 video re-rendering","3","<p>i have a React Video Component which renders:</p>

<pre><code>&lt;video autoPlay loop poster={this.props.poster}&gt;
    &lt;source src={this.props.video} type=""video/mp4"" /&gt;
&lt;/video&gt;
</code></pre>

<p>as a child of my routes Components:</p>

<pre><code>var Login = require('./containers/Login/Login.jsx');
var ForgotPassword = require('./containers/Login/ForgotPassword.jsx');

[
    &lt;Route path=""/login"" component={Login} /&gt;,
    &lt;Route path=""/login/forgot-password"" component={ForgotPassword}/&gt;
]
</code></pre>

<p>when changing routes the Video Component re-renders and i see the reload flash on the browser, along with the video restarting.
is there any way to avoid from re-rendering the Video Component while routing?</p>

<p>i managed to make it work by using the same component in both routes,
and making UI changes by reference to the url.</p>

<p>i lose the component events with this work around (componentWillUnmount, componentWillMount etc.)</p>

<p>will appreciate any help,
thanks</p>
","possible you are looking for _shouldComponentUpdate_ method [_**Link is here**_](http://buildwithreact.com/article/optimizing-with-shouldcomponentupdate)"
"34141207","react-router how to build app structure?","4","<p>I still search for a tutorial which explains how to build a structure for the following scenario</p>

<ul>
<li>on app boot <code>/</code> I have all listed items</li>
<li>click on specific item redirects to a new route /itemid and shows item details</li>
</ul>

<p>till now my structure</p>

<pre><code>app
-- dist
-- src
--- components
---- Layout.js
---- Items.js
---- Item.js
--- actions
--- stores
--- dispatchers
--- services
-- styles
Root.js
App.js
index.js
webpack.config.js
package.json
</code></pre>

<p>index.js</p>

<pre><code>import React from 'react';
import { createHistory, createHashHistory } from 'history';
import Root from './Root';

const rootEl = document.getElementById('workshop-booker');
// Use hash location for Workshop Pages
// but switch to HTML5 history locally.
const history = process.env.NODE_ENV === 'production' ?
    createHashHistory() :
    createHistory();

React.render(&lt;Root history={history} /&gt;, rootEl);
</code></pre>

<p>Root.js</p>

<pre><code>import React, { PropTypes, Component } from 'react';
import { Router, Route } from 'react-router';

import App from './App';
import Workshops from './components/Workshops';
import Workshop from './components/Workshop';

export default class Root extends Component {
    static propTypes = {
        history: PropTypes.object.isRequired
    }

    render() {
        const { history } = this.props;
        return (
            &lt;Router history={history}&gt;
                &lt;Route name='workshops' path='/' component={App}&gt;
                    &lt;Route name='workshop' path='/:slug' component={Workshop} /&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        );
    }
}
</code></pre>

<p>App.js</p>

<pre><code>import React, { PropTypes } from 'react';
import Layout from './components/Layout';
import DocumentTitle from 'react-document-title';

export default class App {
    static propTypes = {
        children: PropTypes.object
    };

    render() {
        return (
            &lt;DocumentTitle title='Workshop Booker'&gt;
                &lt;div className='App'&gt;
                    &lt;Layout {...this.props} /&gt;
                    &lt;hr /&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/DocumentTitle&gt;
        );
    }
}
</code></pre>

<p>Layout component</p>

<pre><code>import React, { Component, PropTypes, findDOMNode } from 'react';
import shouldPureComponentUpdate from 'react-pure-render/function';
import Workshops from './Workshops';

export default class Layout extends Component {
    static propTypes = {
        params: PropTypes.shape({
            login: PropTypes.string,
            name: PropTypes.string
        })
    };

    static contextTypes = {
        history: PropTypes.object.isRequired
    };

    shouldComponentUpdate = shouldPureComponentUpdate;

    constructor(props) {
        super(props);
    }

    componentWillReceiveProps(nextProps) {
        this.setState({
            loginOrRepo: parseFullName(nextProps.params)
        });
    }

    render() {
        return (
            &lt;div className='Explore'&gt;
                    &lt;Workshops /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>I have been following this e<a href=""http://gaearon.github.io/flux-react-router-example"" rel=""nofollow"">xample</a> and mainly my structure follows the idea behind but the thing is that all inherited components are warpped as child. How do I generate the structure to open a new view?</p>

<p>but</p>
","I have each time all the items wrapped under the list on slug  and under I have the clicked item. Desired have a new view without all items"
"34141207","react-router how to build app structure?","4","<p>I still search for a tutorial which explains how to build a structure for the following scenario</p>

<ul>
<li>on app boot <code>/</code> I have all listed items</li>
<li>click on specific item redirects to a new route /itemid and shows item details</li>
</ul>

<p>till now my structure</p>

<pre><code>app
-- dist
-- src
--- components
---- Layout.js
---- Items.js
---- Item.js
--- actions
--- stores
--- dispatchers
--- services
-- styles
Root.js
App.js
index.js
webpack.config.js
package.json
</code></pre>

<p>index.js</p>

<pre><code>import React from 'react';
import { createHistory, createHashHistory } from 'history';
import Root from './Root';

const rootEl = document.getElementById('workshop-booker');
// Use hash location for Workshop Pages
// but switch to HTML5 history locally.
const history = process.env.NODE_ENV === 'production' ?
    createHashHistory() :
    createHistory();

React.render(&lt;Root history={history} /&gt;, rootEl);
</code></pre>

<p>Root.js</p>

<pre><code>import React, { PropTypes, Component } from 'react';
import { Router, Route } from 'react-router';

import App from './App';
import Workshops from './components/Workshops';
import Workshop from './components/Workshop';

export default class Root extends Component {
    static propTypes = {
        history: PropTypes.object.isRequired
    }

    render() {
        const { history } = this.props;
        return (
            &lt;Router history={history}&gt;
                &lt;Route name='workshops' path='/' component={App}&gt;
                    &lt;Route name='workshop' path='/:slug' component={Workshop} /&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        );
    }
}
</code></pre>

<p>App.js</p>

<pre><code>import React, { PropTypes } from 'react';
import Layout from './components/Layout';
import DocumentTitle from 'react-document-title';

export default class App {
    static propTypes = {
        children: PropTypes.object
    };

    render() {
        return (
            &lt;DocumentTitle title='Workshop Booker'&gt;
                &lt;div className='App'&gt;
                    &lt;Layout {...this.props} /&gt;
                    &lt;hr /&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/DocumentTitle&gt;
        );
    }
}
</code></pre>

<p>Layout component</p>

<pre><code>import React, { Component, PropTypes, findDOMNode } from 'react';
import shouldPureComponentUpdate from 'react-pure-render/function';
import Workshops from './Workshops';

export default class Layout extends Component {
    static propTypes = {
        params: PropTypes.shape({
            login: PropTypes.string,
            name: PropTypes.string
        })
    };

    static contextTypes = {
        history: PropTypes.object.isRequired
    };

    shouldComponentUpdate = shouldPureComponentUpdate;

    constructor(props) {
        super(props);
    }

    componentWillReceiveProps(nextProps) {
        this.setState({
            loginOrRepo: parseFullName(nextProps.params)
        });
    }

    render() {
        return (
            &lt;div className='Explore'&gt;
                    &lt;Workshops /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>I have been following this e<a href=""http://gaearon.github.io/flux-react-router-example"" rel=""nofollow"">xample</a> and mainly my structure follows the idea behind but the thing is that all inherited components are warpped as child. How do I generate the structure to open a new view?</p>

<p>but</p>
","What precisely is being wrapped that you don't want wrapped?"
"34141207","react-router how to build app structure?","4","<p>I still search for a tutorial which explains how to build a structure for the following scenario</p>

<ul>
<li>on app boot <code>/</code> I have all listed items</li>
<li>click on specific item redirects to a new route /itemid and shows item details</li>
</ul>

<p>till now my structure</p>

<pre><code>app
-- dist
-- src
--- components
---- Layout.js
---- Items.js
---- Item.js
--- actions
--- stores
--- dispatchers
--- services
-- styles
Root.js
App.js
index.js
webpack.config.js
package.json
</code></pre>

<p>index.js</p>

<pre><code>import React from 'react';
import { createHistory, createHashHistory } from 'history';
import Root from './Root';

const rootEl = document.getElementById('workshop-booker');
// Use hash location for Workshop Pages
// but switch to HTML5 history locally.
const history = process.env.NODE_ENV === 'production' ?
    createHashHistory() :
    createHistory();

React.render(&lt;Root history={history} /&gt;, rootEl);
</code></pre>

<p>Root.js</p>

<pre><code>import React, { PropTypes, Component } from 'react';
import { Router, Route } from 'react-router';

import App from './App';
import Workshops from './components/Workshops';
import Workshop from './components/Workshop';

export default class Root extends Component {
    static propTypes = {
        history: PropTypes.object.isRequired
    }

    render() {
        const { history } = this.props;
        return (
            &lt;Router history={history}&gt;
                &lt;Route name='workshops' path='/' component={App}&gt;
                    &lt;Route name='workshop' path='/:slug' component={Workshop} /&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        );
    }
}
</code></pre>

<p>App.js</p>

<pre><code>import React, { PropTypes } from 'react';
import Layout from './components/Layout';
import DocumentTitle from 'react-document-title';

export default class App {
    static propTypes = {
        children: PropTypes.object
    };

    render() {
        return (
            &lt;DocumentTitle title='Workshop Booker'&gt;
                &lt;div className='App'&gt;
                    &lt;Layout {...this.props} /&gt;
                    &lt;hr /&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/DocumentTitle&gt;
        );
    }
}
</code></pre>

<p>Layout component</p>

<pre><code>import React, { Component, PropTypes, findDOMNode } from 'react';
import shouldPureComponentUpdate from 'react-pure-render/function';
import Workshops from './Workshops';

export default class Layout extends Component {
    static propTypes = {
        params: PropTypes.shape({
            login: PropTypes.string,
            name: PropTypes.string
        })
    };

    static contextTypes = {
        history: PropTypes.object.isRequired
    };

    shouldComponentUpdate = shouldPureComponentUpdate;

    constructor(props) {
        super(props);
    }

    componentWillReceiveProps(nextProps) {
        this.setState({
            loginOrRepo: parseFullName(nextProps.params)
        });
    }

    render() {
        return (
            &lt;div className='Explore'&gt;
                    &lt;Workshops /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>I have been following this e<a href=""http://gaearon.github.io/flux-react-router-example"" rel=""nofollow"">xample</a> and mainly my structure follows the idea behind but the thing is that all inherited components are warpped as child. How do I generate the structure to open a new view?</p>

<p>but</p>
","Where are all the items being rendered? It doesn't appear to be in the code you posted. Is that the complete listing?"
"34141207","react-router how to build app structure?","4","<p>I still search for a tutorial which explains how to build a structure for the following scenario</p>

<ul>
<li>on app boot <code>/</code> I have all listed items</li>
<li>click on specific item redirects to a new route /itemid and shows item details</li>
</ul>

<p>till now my structure</p>

<pre><code>app
-- dist
-- src
--- components
---- Layout.js
---- Items.js
---- Item.js
--- actions
--- stores
--- dispatchers
--- services
-- styles
Root.js
App.js
index.js
webpack.config.js
package.json
</code></pre>

<p>index.js</p>

<pre><code>import React from 'react';
import { createHistory, createHashHistory } from 'history';
import Root from './Root';

const rootEl = document.getElementById('workshop-booker');
// Use hash location for Workshop Pages
// but switch to HTML5 history locally.
const history = process.env.NODE_ENV === 'production' ?
    createHashHistory() :
    createHistory();

React.render(&lt;Root history={history} /&gt;, rootEl);
</code></pre>

<p>Root.js</p>

<pre><code>import React, { PropTypes, Component } from 'react';
import { Router, Route } from 'react-router';

import App from './App';
import Workshops from './components/Workshops';
import Workshop from './components/Workshop';

export default class Root extends Component {
    static propTypes = {
        history: PropTypes.object.isRequired
    }

    render() {
        const { history } = this.props;
        return (
            &lt;Router history={history}&gt;
                &lt;Route name='workshops' path='/' component={App}&gt;
                    &lt;Route name='workshop' path='/:slug' component={Workshop} /&gt;
                &lt;/Route&gt;
            &lt;/Router&gt;
        );
    }
}
</code></pre>

<p>App.js</p>

<pre><code>import React, { PropTypes } from 'react';
import Layout from './components/Layout';
import DocumentTitle from 'react-document-title';

export default class App {
    static propTypes = {
        children: PropTypes.object
    };

    render() {
        return (
            &lt;DocumentTitle title='Workshop Booker'&gt;
                &lt;div className='App'&gt;
                    &lt;Layout {...this.props} /&gt;
                    &lt;hr /&gt;
                    {this.props.children}
                &lt;/div&gt;
            &lt;/DocumentTitle&gt;
        );
    }
}
</code></pre>

<p>Layout component</p>

<pre><code>import React, { Component, PropTypes, findDOMNode } from 'react';
import shouldPureComponentUpdate from 'react-pure-render/function';
import Workshops from './Workshops';

export default class Layout extends Component {
    static propTypes = {
        params: PropTypes.shape({
            login: PropTypes.string,
            name: PropTypes.string
        })
    };

    static contextTypes = {
        history: PropTypes.object.isRequired
    };

    shouldComponentUpdate = shouldPureComponentUpdate;

    constructor(props) {
        super(props);
    }

    componentWillReceiveProps(nextProps) {
        this.setState({
            loginOrRepo: parseFullName(nextProps.params)
        });
    }

    render() {
        return (
            &lt;div className='Explore'&gt;
                    &lt;Workshops /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>I have been following this e<a href=""http://gaearon.github.io/flux-react-router-example"" rel=""nofollow"">xample</a> and mainly my structure follows the idea behind but the thing is that all inherited components are warpped as child. How do I generate the structure to open a new view?</p>

<p>but</p>
","I added my Layout component, this component is getting called on boot"
"34359251","React-Router Rerendering with Immutable shouldComponentUpdate","4","<p>I have got a problem with rerendering the component, when I switch to a different route and then back to my component.
I am using React 0.14.3, react-router 1.0.2 and Immutable.js.</p>

<p>The reason is, that I compare props in my <code>shouldComponentUpdate</code> method.</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
    return !Immutable.is(nextProps.articles, this.props.articles);
}
</code></pre>

<p>If I change the route and go back, <code>props.articles</code> does not change, but I need to rerender the page anyways.</p>

<p>The question is, what do I need to consider in my <code>shouldComponentUpdate</code> method, to track, if the route has just changed?</p>

<p>Thanks in advance!
Rico</p>
","Haven't you tried? I suspect that you don't need to care about that since when you change the route your component will be re-mounted."
"34359251","React-Router Rerendering with Immutable shouldComponentUpdate","4","<p>I have got a problem with rerendering the component, when I switch to a different route and then back to my component.
I am using React 0.14.3, react-router 1.0.2 and Immutable.js.</p>

<p>The reason is, that I compare props in my <code>shouldComponentUpdate</code> method.</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
    return !Immutable.is(nextProps.articles, this.props.articles);
}
</code></pre>

<p>If I change the route and go back, <code>props.articles</code> does not change, but I need to rerender the page anyways.</p>

<p>The question is, what do I need to consider in my <code>shouldComponentUpdate</code> method, to track, if the route has just changed?</p>

<p>Thanks in advance!
Rico</p>
","For instance, here are folks trying to solve the opposite problem - http://stackoverflow.com/questions/33431319/prevent-component-be-unmounted-with-react-router
In other words, what you're trying to achieve is react router's default behavior."
"34359251","React-Router Rerendering with Immutable shouldComponentUpdate","4","<p>I have got a problem with rerendering the component, when I switch to a different route and then back to my component.
I am using React 0.14.3, react-router 1.0.2 and Immutable.js.</p>

<p>The reason is, that I compare props in my <code>shouldComponentUpdate</code> method.</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
    return !Immutable.is(nextProps.articles, this.props.articles);
}
</code></pre>

<p>If I change the route and go back, <code>props.articles</code> does not change, but I need to rerender the page anyways.</p>

<p>The question is, what do I need to consider in my <code>shouldComponentUpdate</code> method, to track, if the route has just changed?</p>

<p>Thanks in advance!
Rico</p>
","Well, your shouldComponentUpdate shouldn't even be called when you go back to the /articles. Because it isn't updating, it's mounting, componentDidMount is called."
"34359251","React-Router Rerendering with Immutable shouldComponentUpdate","4","<p>I have got a problem with rerendering the component, when I switch to a different route and then back to my component.
I am using React 0.14.3, react-router 1.0.2 and Immutable.js.</p>

<p>The reason is, that I compare props in my <code>shouldComponentUpdate</code> method.</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
    return !Immutable.is(nextProps.articles, this.props.articles);
}
</code></pre>

<p>If I change the route and go back, <code>props.articles</code> does not change, but I need to rerender the page anyways.</p>

<p>The question is, what do I need to consider in my <code>shouldComponentUpdate</code> method, to track, if the route has just changed?</p>

<p>Thanks in advance!
Rico</p>
","My component is displaying a table of data. That data comes from an API and is stored in ""articles"". The route leading to that component is /articles.
When I switch the the route / and then back to /articles, the component does not update, since the articles are the same as before. If I comment out my shouldComponentUpdate, it works.

TL;DR - I tried, it did not work."
"34941646","Is there reactjs have auto switch render? (renderToStaticMarkup, renderToString)","0","<p>I render server and client side with same jsx. I need some element only have html, and do not need data-reactid. (e.g. A pure html jsx layout has some dynamic variable but do not need data-reactid).</p>

<p>And i except i can reuse the server side render dom which contains data-reactid, and do not need rerender the view.</p>

<p>The other element has data-reactid which can do not need rerender by reactjs. 
Cannot use <code>shouldComponentUpdate</code> because 'renderToString' method do not call <code>shouldComponentUpdate</code>.</p>

<p>I don't except i should render two element with different function( e.g. renderToStaticMarkup, renderToString) and combine it because the element could be include by many element. Render split and combine could cause mistake when element is much more.</p>

<p>Here is my fantasy:</p>

<p>In this case, i want {this.props.children} have data-reactid but the outside html and budy (DefaultLayout) do not.</p>

<pre><code>class DefaultLayout extends  React.Component{   
        if (typeof window !== 'undefined') {
            return (
                &lt;div&gt;{this.props.children}&lt;/div&gt;
            );
        } 
        return (
        &lt;html&gt;
            &lt;head&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;div id=""container"" className='container'&gt;
                    &lt;div&gt;{this.props.children}&lt;/div&gt;
                &lt;/div&gt;
                &lt;script src='/js/index.js'type='text/javascript'&gt;&lt;/script&gt;
            &lt;/body&gt;
        &lt;/html&gt;
        );
    }
};
DefaultLayout.noNeedDiffCompoment = true;
export default DefaultLayout;
</code></pre>

<p>or a new pure html Compoment</p>

<pre><code>class DefaultLayout extends  React.PureHtmlComponent{    

        if (typeof window !== 'undefined') {
            return (
                &lt;div&gt;{this.props.children}&lt;/div&gt;
            );
        }
        return (
        &lt;html&gt;
            &lt;head&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;div id=""container"" className='container'&gt;
                    &lt;div&gt;{this.props.children}&lt;/div&gt;
                &lt;/div&gt;
                &lt;script src='/js/index.js'type='text/javascript'&gt;&lt;/script&gt;
            &lt;/body&gt;
        &lt;/html&gt;
        );
    }
};
export default DefaultLayout;
</code></pre>

<p>and i can use this layout easly and not error in client side and server side.</p>

<pre><code>class Somepage extends  React.Component {
    constructor(props) {
        super(props);
    }

    render(){
        return (
            &lt;DefaultLayout&gt;
                &lt;h1&gt;Hello world&lt;/h1&gt;
            &lt;/DefaultLayout&gt;
        );
    }
};
</code></pre>

<p>If i write as above, the render function can auto swap render function to render elements.</p>

<p>Is there any graceful solution like this?</p>
",""
"36339032","react immutability helper to render only changed subset of data","1","<p>Please see the example here  <a href=""http://jsfiddle.net/8xzxkteu/1/"" rel=""nofollow"">http://jsfiddle.net/8xzxkteu/1/</a></p>

<p>I'm trying to only render part of the data which is changed. In this example, state of component <code>Main</code>, <code>data</code>, is indexed by <code>id</code> and I am using react immutability helper to set only the changed one. But, if you click on the output, it renders all the children, as indicated by the counter. I though using immutability helper react can detect only part of the data changed hence only render it. I probably could use <code>shouldComponentUpdate</code> and compare object values for each child, but is there a better way doing this with immutability helper.</p>

<pre><code> class Child extends React.Component {
    constructor(props) {
      super(props);
      this.onClick = this.onClick.bind(this)
      this.state = {
            count: 0
      };
    }

    componentWillReceiveProps(nextProps) {
        var count = this.state.count + 1;
        this.setState({ count: count });
    }

    onClick() {
        this.props.onClick(this.props.name);
    }

    render() {
        return &lt;p onClick={this.onClick}&gt;{this.props.name}: {this.props.value} {this.state.count}&lt;/p&gt;;
    }
  }

  class Main extends React.Component{
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this)
      this.state = {
            data: {
                ""a"" : ""a"",
              ""b"" : ""b"",
            }
      };
    }

    handleChange(id) {
      this.setState({
        data: React.addons.update(this.state.data, { [id]: { $set: 'x' } })
      });
    }  

    render() {
      const keys = Object.keys(this.state.data);
        const children = keys.map(k =&gt; {
            return &lt;Child name={k} value={this.state.data[k]} onClick={this.handleChange}/&gt;
        })
        return &lt;div&gt;
            {children}
          &lt;/div&gt;;
    }
  }

  React.render(&lt;Main /&gt;, document.getElementById('container'));
</code></pre>
","Remember that when `Main` re-renders, all children will re-render as well. You definitely need to use `shouldComponentUpdate` in the `Child` to check whether it should re-render or not."
"36588059","How to import google map in react project","0","<p>I a using webpack and reactjs in my project and now I want to integrate google map api. First I added ""react-google-maps"": ""^4.9.1"" on my package.json file. Below is my component class.</p>

<pre><code>import React, {PropTypes, Component} from 'react';

import { GoogleMap, Marker, SearchBox } from ""react-google-maps"";
import shouldPureComponentUpdate from 'react-pure-render/function';

const greatPlaceStyle = {
  // initially any map object has left top corner at lat lng coordinates
  // it's on you to set object origin to 0,0 coordinates
  position: 'absolute',
  width: 512,
  height: 512,
  left: 512 / 2,
  top: 512 / 2,

  border: '5px solid #f44336',
  borderRadius: 512,
  backgroundColor: 'white',
  textAlign: 'center',
  color: '#3f51b5',
  fontSize: 16,
  fontWeight: 'bold',
  padding: 4
};

export default class SimpleMapPage extends Component {
  static defaultProps = {
    center: {lat: 59.938043, lng: 30.337157},
    zoom: 1,
    greatPlaceCoords: {lat: 59.724465, lng: 30.080121}
  };

  shouldComponentUpdate = shouldPureComponentUpdate;

  constructor(props) {
    super(props);
  }

  render() {
    return (
       &lt;GoogleMap&gt;

        defaultCenter={this.props.center}
        defaultZoom={this.props.zoom}&gt;

        &lt;MyGreatPlace lat={59.955413} lng={30.337844} text={'A'} /&gt;
        &lt;MyGreatPlace {...this.props.greatPlaceCoords} text={'B'} /&gt;

      &lt;/GoogleMap&gt;
    );
  }
}

export default class MyGreatPlace extends Component {
  static propTypes = {
    text: PropTypes.string
  };

  static defaultProps = {};

  //shouldComponentUpdate = shouldPureComponentUpdate;

  constructor(props) {
    super(props);
  }

  render() {
    return (
       &lt;div style={greatPlaceStyle}&gt;
          {this.props.text}
       &lt;/div&gt;
    );
  }
}
</code></pre>

<p>In my index.html file, I added below javascripts. The first one is goold map api dependency. The second one is the bundle.js which is packaged by webpack. When I access my application, the google map didn't show up. I think the problem would be failed to import google map api on my component class. What is the correct way to import googleapis? </p>

<pre><code>&lt;script src=""https://maps.googleapis.com/maps/api/js?key=AIzaSyA2sDQZ-36NLlY4iMvoiuQ7mS1n-v8iq2M"" async defer&gt;&lt;/script&gt;
    &lt;script type=""text/javascript"" src=""bundle.js"" charset=""utf-8""&gt;&lt;/script&gt;
</code></pre>
",""
"36630140","What is the best implememtation of react shouldComponentUpdate with immutable.js","2","<p>I'm new to <a href=""https://facebook.github.io/immutable-js/"">ImmutableJS</a>. My app implements large Redux Store &amp; multiple react components.</p>

<p>Correct me if I'm wrong:</p>

<ul>
<li>I understand that the benefits of Immutable is to protect Flux Store and to avoid unnecessary vDom rendering on component getting unchanged props.</li>
<li>To benefit from better rendering performance with ImmutableJS, <code>shouldComponentUpdate()</code> must be implemented.</li>
</ul>

<p>What is the best implementation of this function?</p>

<p>I already found several implementations of it, all using shallowEqual() with some modifications:</p>

<ul>
<li>Facebook implements <a href=""https://github.com/facebook/fbjs/blob/master/src/core/shallowEqual.js"">shallowEqual</a> for React and more I imagine.</li>
<li>Jurassix offers <a href=""https://github.com/jurassix/react-immutable-render-mixin"">an implementation</a> that implements <a href=""https://github.com/jurassix/react-immutable-render-mixin/blob/master/src/shallowEqualImmutable.js"">shallowEqualImmutable</a>. It the function from Facebook except that the <code>is()</code> function is replaced by the one given by ImmutableJS. The first equality is different too.</li>
<li>Dan does the same thing with a <a href=""https://github.com/gaearon/react-dnd/blob/master/src/utils/shallowEqual.js"">different shalllowEqual function</a> that implement parts of the two previous implementation.</li>
</ul>

<p>Someone knows which implementation I should use in my case? or none and implement specific <code>shouldComponentUpdate()</code>? I am slightly at a loss on this point</p>

<p>Thank you a lot for any help!!</p>
","Have you looked at PureRenderMixin? https://facebook.github.io/react/docs/pure-render-mixin.html This also makes a shallow comparison, but with ImmutableJs that is sufficient."
"36630140","What is the best implememtation of react shouldComponentUpdate with immutable.js","2","<p>I'm new to <a href=""https://facebook.github.io/immutable-js/"">ImmutableJS</a>. My app implements large Redux Store &amp; multiple react components.</p>

<p>Correct me if I'm wrong:</p>

<ul>
<li>I understand that the benefits of Immutable is to protect Flux Store and to avoid unnecessary vDom rendering on component getting unchanged props.</li>
<li>To benefit from better rendering performance with ImmutableJS, <code>shouldComponentUpdate()</code> must be implemented.</li>
</ul>

<p>What is the best implementation of this function?</p>

<p>I already found several implementations of it, all using shallowEqual() with some modifications:</p>

<ul>
<li>Facebook implements <a href=""https://github.com/facebook/fbjs/blob/master/src/core/shallowEqual.js"">shallowEqual</a> for React and more I imagine.</li>
<li>Jurassix offers <a href=""https://github.com/jurassix/react-immutable-render-mixin"">an implementation</a> that implements <a href=""https://github.com/jurassix/react-immutable-render-mixin/blob/master/src/shallowEqualImmutable.js"">shallowEqualImmutable</a>. It the function from Facebook except that the <code>is()</code> function is replaced by the one given by ImmutableJS. The first equality is different too.</li>
<li>Dan does the same thing with a <a href=""https://github.com/gaearon/react-dnd/blob/master/src/utils/shallowEqual.js"">different shalllowEqual function</a> that implement parts of the two previous implementation.</li>
</ul>

<p>Someone knows which implementation I should use in my case? or none and implement specific <code>shouldComponentUpdate()</code>? I am slightly at a loss on this point</p>

<p>Thank you a lot for any help!!</p>
","Yes PureRenderMixin actually call `shallowEqual` from Facebook. it is the first point I mention. What do you mean by ""it is sufficient""?"
"37627648","Correct way to fetch data when switching route on same level in react-router?","0","<p>What is the correct way to fetch data when switching route on same level?
Because, according to <a href=""https://github.com/reactjs/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow"">this</a>, switching route on same level will
only call <code>componentWillReceiveProps</code> and <code>componentDidUpdate</code>.
And <code>componentDidMount</code> is only called the first time route is entered.</p>

<p>With route configuration like this:</p>

<pre><code>render((
  &lt;Provider store={store}&gt;
    &lt;Router&gt;
      &lt;Route path=""/"" component={App}&gt;
        &lt;Route path=""/:userId"" component={Profile}/&gt;
      &lt;/Route&gt;
    &lt;/Router&gt;
  &lt;/Provider&gt;
), document.getElementById('root'));
</code></pre>

<p>The Profile component is:</p>

<pre><code>class Profile extends React.Component {
  componentDidMount() {
    // initial data
    this.fetchUserData();
  }
  componentWillReceiveProps(nextProps) {
    if (this.props.params.userId !== nextProps.params.userId) {
      this.fetchUserData();
    }
  }
  shouldComponentUpdate(nextProps) {
    return this.props.params.userId !== nextProps.params.userId;
  }
  render() {
    return (
      &lt;div className=""profile""&gt;&lt;/div&gt;
    );
  }
}
</code></pre>

<p>The data will be stored in application state field (<code>props.userData</code>). But,
that's obviously will mess up with rendering cycle because route is
switched before fetch data is finished.</p>

<p>But, if I change to this:</p>

<pre><code>// deepEqual is function to check object equality recursively
componentWillReceiveProps(nextProps) {
  if (!deepEqual(this.props.userData, nextProps.userData)) {
    this.fetchUserData();
  }
}
shouldComponentUpdate(nextProps) {
  return !deepEqual(this.props.userData, nextProps.userData);
}
</code></pre>

<p>This won't work because before <code>userData</code> is fetched, those props is
deeply equal.</p>

<p>So, how to fetch data when switching route on same route level?</p>
",""
"37804199","How to update state of reactjs app by building on existing state?","0","<p>I am writing a reactjs chat client and came across <a href=""https://facebook.github.io/react/docs/component-api.html"" rel=""nofollow"">this</a> in the documentation, which says  </p>

<blockquote>
  <p>NEVER mutate this.state directly, as calling setState() afterwards may
  replace the mutation you made. Treat this.state as if it were
  immutable.</p>
  
  <p>setState() does not immediately mutate this.state but creates a
  pending state transition. Accessing this.state after calling this
  method can potentially return the existing value.</p>
  
  <p>There is no guarantee of synchronous operation of calls to setState
  and calls may be batched for performance gains.</p>
  
  <p>setState() will always trigger a re-render unless conditional
  rendering logic is implemented in shouldComponentUpdate(). If mutable
  objects are being used and the logic cannot be implemented in
  shouldComponentUpdate(), calling setState() only when the new state
  differs from the previous state will avoid unnecessary re-renders.</p>
</blockquote>

<p>When a message is sent this function is called:</p>

<pre><code>sendMessage: function(msg) {
    //Update the state of the app
    var message = {username:'User', message:msg};
    console.log(message.toString());
    this.state.datas.push(message);
    this.setState({datas: this.state.datas});
  },
</code></pre>

<p>What I am trying to do is append the new message to the list of messages then reset the state so the components rerender. This works fine but based on the documentation quoted above this isn't how this should be done. How should I go about updating the list of messages and updating the state without directly calling <code>this.state.datas.push(message)</code>?</p>
",""
"38044989","react component state not updating (FLUX App)","0","<p>I'm trying to hand build a react/flux app, roughly following:
<a href=""https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture"" rel=""nofollow"">https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture</a></p>

<p>I've got most of it working but when I update the state the component doesn't re-render. Can anyone help?</p>

<p>Thanks. :)</p>

<hr>

<p>Repo is <a href=""https://github.com/jmsherry/flux_hand"" rel=""nofollow"">https://github.com/jmsherry/flux_hand</a></p>

<p><strong>CounterStore.js</strong></p>

<pre><code>import Dispatcher from 'Flux';
import AppDispatcher from './../dispatcher/AppDispatcher';
import CounterConstants from '../constants/constants';
import { EventEmitter } from 'events';
import assign from 'object-assign';


let _count = 5;

function increment() {
  _count +=1;
}

function decrement() {
  _count -=1;
}

let CounterStore = assign({}, EventEmitter.prototype, {

  getCount() {
    return _count;
  },

  emitChange() {
    this.emit(CounterConstants.CHANGE_EVENT);
  },

  /**
   * @param {function} callback
   */
  addChangeListener(callback) {
    this.on(CounterConstants.CHANGE_EVENT, callback);
  },

  /**
   * @param {function} callback
   */
  removeChangeListener(callback) {
    this.removeListener(CounterConstants.CHANGE_EVENT, callback);
  },

  dispatcherIndex: AppDispatcher.register(function(payload) {
    console.log('blah', arguments);
    var action = payload.action;
    var text;

    switch(action.actionType) {
      case CounterConstants.INCREMENT:
          console.log('inc', _count);
          increment();
          console.log(_count);
          CounterStore.emitChange();
        break;

      case CounterConstants.DECREMENT:
      console.log('dec', _count);
        decrement();
        console.log(_count);
        CounterStore.emitChange();
        break;
    }

    return true; // No errors. Needed by promise in Dispatcher.
  })

});

export default CounterStore;
</code></pre>

<p><strong>AppDispatcher.js</strong></p>

<pre><code>import { Dispatcher } from 'Flux';

const AppDispatcher = new Dispatcher();

AppDispatcher.handleViewAction = function(action) {
  console.log('in', arguments);
  this.dispatch({
    source: 'VIEW_ACTION',
    action
  });
}

export default AppDispatcher;
</code></pre>

<p><strong>constants.js</strong></p>

<pre><code>import keyMirror from 'keymirror';

const CounterConstants = keyMirror({
  INCREMENT: null,
  DECREMENT: null
});

CounterConstants.CHANGE_EVENT = 'change';

export default CounterConstants;
</code></pre>

<p><strong>actions.js</strong></p>

<pre><code>import AppDispatcher from '../dispatcher/AppDispatcher';
var CounterConstants = require('../constants/constants');

const CounterActions = {

  /**
   * @param  {string} text
   */
  increment() {
    AppDispatcher.handleViewAction({
      actionType: CounterConstants.INCREMENT
    });
  },

  decrement() {
    AppDispatcher.handleViewAction({
      actionType: TodoConstants.DECREMENT
    });
  }

};

export default CounterActions;
</code></pre>

<p><strong>counter.js &lt;-- parent view</strong></p>

<pre><code>import React,{Component} from 'react';
import ReactDOM from 'react-dom';
import CounterConstants from './../constants/constants';
import AppDispatcher from './../Dispatcher/AppDispatcher.js';
import Controls from './Controls';
import Display from './Display';

class Counter extends Component {
  render(){
    return (
      &lt;div className=""counter""&gt;
        &lt;h1&gt;My counter&lt;/h1&gt;
        &lt;Display /&gt;
        &lt;Controls /&gt;
      &lt;/div&gt;
    )
  }
}

export default Counter;
</code></pre>

<p><strong>controls.js</strong></p>

<pre><code>import React,{Component} from 'react';
import ReactDOM from 'react-dom';
import CounterConstants from './../constants/constants';
import AppDispatcher from './../dispatcher/AppDispatcher';
import CounterActions from './../actions/actions';

class Controls extends Component {
  render(){
    console.log('here', AppDispatcher);
    return (
      &lt;div className=""controls""&gt;
        &lt;button onClick={CounterActions.increment}&gt;+&lt;/button&gt;
        &lt;button onClick={CounterActions.decrement}&gt;-&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

export default Controls;
</code></pre>

<p><strong>display.js</strong></p>

<pre><code>import React,{Component} from 'react';
import ReactDOM from 'react-dom';
import CounterConstants from './../constants/constants';
import CounterStore from './../stores/CounterStore';

// Method to retrieve application state from store
function getAppState() {
  console.log('getting app state...');
  return {
    count: CounterStore.getCount()
  };
}

class Display extends Component {
  constructor(props) {
    super(props);
    this.state = getAppState();
  }

  // Update view state when change event is received
  _onChange() {
    console.log('prechange', this.state);
    const newState = getAppState();
    console.log('newState', newState);
    (newState) =&gt; this.setState;
  }

  // Listen for changes
  componentDidMount() {
    CounterStore.addChangeListener(this._onChange.bind(this));
  }

  // Unbind change listener
  componentWillUnmount() {
    CounterStore.removeChangeListener(this._onChange.bind(this));
  }

  shouldComponentUpdate( newProps, newState ) {
    console.log('shouldComponentUpdate', arguments);
  }

  render() {
    let count = getAppState().count;
    console.log('rendering', count, this.state);
    return (
      &lt;div className = ""display"" &gt;
        &lt;p&gt;State: { this.state.count }&lt;/p&gt;
        &lt;p&gt;count: { count }&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}

export default Display;
</code></pre>
",""
"38284074","Immutablejs and shouldComponentUpdate","0","<p>Can react-redux still make use of shouldComponentUpdate if i'm using Immutable.js? The connect() method uses shallowEqual in shouldComponentUpdate() but from the Immutable.js docs i see that we have to use Immutable's own equals() method to check equality rather than the === operator (which shallowEqual uses)</p>

<p>Consider this:</p>

<pre><code>const map1 = Immutable.Map({a:1, b:2, c:3});
const map2 = Immutable.Map({a:1, b:2, c:3});

map1 === map2 // returns false
map1.equals(map2) // returns true
</code></pre>
",""
"38440629","react native navigationExperimental NavigationCardStack renderScene didn't re-render for previous routes","0","<p>I already checked similar existing issues on stack-overflow or gihub, like: 
<a href=""https://github.com/facebook/react-native/issues/7720"" rel=""nofollow"">NavigationCard will only re-render when the route changes</a>, <a href=""https://github.com/jlyman/RN-NavigationExperimental-Redux-Example/issues/20"" rel=""nofollow"">Help: renderScene is executed just once and does not refresh updated props</a>, etc. But my case is different. </p>

<p><strong>Page list:</strong></p>

<ol>
<li>sign in page</li>
<li>home page: user can only see this page after sign in;</li>
</ol>

<p><strong>Transition logic:</strong></p>

<ol>
<li>In ""sign in page"", after sign in, it shall go to ""home page""</li>
<li>In ""home page"", there is a sign out button, after user click, it shall go back to ""sign in"" page. </li>
</ol>

<p><strong>My implementation</strong></p>

<p>I created a top level component called App, and the code looks like the below:</p>

<pre><code>// app.js
class App extends Component {
    componentWillMount() {
        const {doNavigateReplaceAtIndex} = this.props;
        let {isSignedIn} = this.props;
        doNavigateReplaceAtIndex(isSignedIn? 'home': 'sign-in');
    }

    render() {
        const {globalNavigationState} = this.props;
        return (
            &lt;NavigationCardStack
                navigationState={globalNavigationState}
                style={styles.container}
                onNavigate={()=&gt;{}}
                renderScene={this._renderScene}
            /&gt;
        );
    }

    _renderScene({scene}) {
        const { route } = scene;
        switch(route.key) {
            case 'home':
                return &lt;Home /&gt;
            case 'sign-in':
                return &lt;SignIn /&gt;
        }
    }
}

export default connect (
    state =&gt;({
        isSignedIn: !! state.auth.token,
        token: state.auth.token,
        globalNavigationState: state.globalNavigation
    }),
    dispatch =&gt; ({
        doNavigateReplaceAtIndex: (key) =&gt; dispatch(navigateReplaceAtIndex(0, key))
    })
)(App);

// sign in page
// after signin, it will doNavigateReplaceAtIndex(0, 'home');

// home page
// after clicking ""sign out"", it will doNavigateReplaceAtIndex(0, 'sign-in');

// doNavigateReplaceAtIndex basically is just call NavigationStateUtils.replaceAtIndex
</code></pre>

<p><strong>Symptoms</strong>
At beginning, it shows sign in page, after signing in, it goes to home page, it is good. In home page, when click the sign out button, it didn't move anywhere, but when refresh, it shows sign in page. </p>

<p><strong>What I got so far</strong></p>

<ul>
<li>It is not because of this issue: <a href=""https://github.com/facebook/react-native/issues/7720"" rel=""nofollow"">NavigationCard will only re-render
when the route
changes</a>,
because I debugged into rn source code, the shouldComponentUpdate didn't block;</li>
<li>I am not sure if I didn't right for doNavigateReplaceAtIndex, usually we use push or pop, but my case I cannot use push/pop, because after sign in, we should not allow use to go back sign in page by clicking ""BACK"" button on Android. </li>
<li>I think the issue may because of NavigationScenesReducer(which is called by NavigationAnimatedView used in NavigationCardStack), it will mark all previous routes as stale, and will not show it them.</li>
</ul>

<p>Any help will be welcome, thanks.  </p>

<p><strong>My environment</strong></p>

<p>react native: 0.29.1
react native cli: 1.0.0
node: 5.6.0
OS: ios 9.3</p>
",""
"38561660","How to tell react.js NOT to reconcile or interfere from a certain element?","1","<p>One of my components has a <code>div</code> element into which I would like to spill and handle/mutate my own DOM - without React interfering. </p>

<p>I am using d3.js for that manual DOM manipulation, and no I am not looking for react-d3 solutions, I need plain d3 in there. </p>

<p>All works well for me, except the reacts console warnings:</p>

<p><code>
warning.js:44Warning: Unknown prop `xmlns` on &lt;svg&gt; tag. Remove this prop from the element. For details, see
</code></p>

<p>and</p>

<p><code>
warning.js:44 Warning: Unknown DOM property class. Did you mean className?
</code></p>

<p>So It complains about me using <code>class</code> instead of <code>className</code> or about having some html attributes which are not react style etc.. </p>

<p>I'd like to tell React that from this component and below, it shouldn’t interfere, I will manage the DOM below this component manually.</p>

<p>Code looks something like this:</p>

<pre><code>import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import SomeD3CustomComp from '../some-d3-custom-comp.js';

export default class MyComponent extends Component {

  componentDidMount() {
   this.injectChart();
  }

  componentDidUpdate() {
   this.injectChart();
  }

  injectChart() {
    const comp = findDOMNode(this.refs.nonReactContainer);
    const { chart } = this.props;
    const { shouldRender, data } = chart;
    if (shouldRender) {
      SomeD3CustomComp.render(comp, data);
    }
  }

  render() {
    const { chart, someOtherData } = this.props;
    const { shouldRender } = chart;
    return(
      &lt;article&gt;
        {
          shouldRender &amp;&amp;
          &lt;div className=""non-react-element"" ref=""nonReactContainer""&gt;&lt;/div&gt;
        }
        &lt;div className=""react-element""&gt;{someOtherData}&lt;/div&gt;
      &lt;/article&gt;
    );
  }
}
</code></pre>

<hr>

<h2>Update:</h2>

<p>The suggestion of returning <code>false</code> on <code>shouldComponentUpdate</code> doesnt take away the error messages I have stated above, maybe because of the fact that <code>shouldComponentUpdate</code> happens only when there is an update - after the first inject on <code>componentDidMount</code>. </p>

<p>Another problem with that approach is that if return <code>false</code> code never gets to the render method where more logic is implemented such as in the example above where I check if to render the container non react element. This is the way I simply remove all previously injected elements, in the previous state. </p>

<p>So I am still looking for help with that...</p>

<hr>

<h2>Solved!</h2>

<p>false alarm :/ just found out that those warning messages were related to a different part of the code. Was a strange coincidence from the time this new feature was developed and some older problem. Conclusion: look harder at the warning messages! 
So this integration with d3 actually works nice.</p>
","Possible duplicate of [React - Ignore subnodes](http://stackoverflow.com/questions/24864947/react-ignore-subnodes)"
"38641018","react-virtualized WindowScroller performance issues","4","<p>I am using the react-virtualized library to create efficient news feed. The library is awesome. I combined WindowScroller, AutoSizer and VirtualScroll components to have inifinite scrolling behavior. The problem is that when I set the VirtualScroll height manually and don't use WindowScroller the performance is great in all browsers. However when I add the WindowScroller component, performance reduces significantly, especially in Firefox (v47.0). How can I optimize this so that it is feasible to use window scrolling?</p>

<p>This is the News component, where the react-virtualized is used,
I have 2 types of list items - header item and simple item, header item contains a date of a group of news, thus it is a little bit longer.</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes, Component } from 'react';
import Divider from 'material-ui/Divider';
import Subheader from 'material-ui/Subheader';
import { Grid, Row, Col } from 'react-flexbox-grid';
import NewsItem from '../NewsItem';
import styles from './styles.css';
import CircularProgress from 'material-ui/CircularProgress';
import Paper from 'material-ui/Paper';
import classNames from 'classnames';
import { InfiniteLoader, WindowScroller, AutoSizer, VirtualScroll } from 'react-virtualized';
import shallowCompare from 'react-addons-shallow-compare';

class News extends Component {

  componentDidMount() {
    this.props.onFetchPage(0);
  }

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  getRowHeight({ index }) {
    const elementHeight = 200;
    const headerHeight = 78;
    if (!this.isRowLoaded(index)) {
      return elementHeight;
    }
    return this.props.articles[index].isHeader ?
      headerHeight + elementHeight : elementHeight;
  }

  displayElement(article, isScrolling) {
    return (
      &lt;Paper
        key={article.id}
        className={classNames(styles.newsItemContainer, {
          [styles.scrolling]: isScrolling
        })}
      &gt;
        &lt;NewsItem {...article} /&gt;
        &lt;Divider /&gt;
      &lt;/Paper&gt;
    );
  }

  isRowLoaded(index) {
    return !this.props.hasNextPage || index &lt; this.props.articles.length;
  }

  renderRow(index, isScrolling) {
    if (!this.isRowLoaded(index)) {
      return (
        &lt;div className={styles.spinnerContainer}&gt;
          {this.props.isFetching ? &lt;CircularProgress /&gt; : null}
        &lt;/div&gt;
      );
    }
    const { isHeader, date, article } = this.props.articles[index];
    if (isHeader) {
      return (
        &lt;div&gt;
          &lt;Subheader
            key={date}
            className={styles.groupHeader}
          &gt;
            {date}
          &lt;/Subheader&gt;
          {this.displayElement(article, isScrolling)}
        &lt;/div&gt;
      );
    }
    return this.displayElement(article, isScrolling);
  }

  noRowsRenderer() {
    return (&lt;p&gt;No articles found&lt;/p&gt;);
  }

  render() {
    const {
      articles,
      onFetchPage,
      pageNumber,
      isFetching,
      hasNextPage
    } = this.props;

    const loadMoreRows = isFetching ?
      () =&gt; {} :
      () =&gt; onFetchPage(pageNumber + 1);

    const rowCount = hasNextPage ? articles.length + 1 : articles.length;

    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12} sm={8} smOffset={2}&gt;
            &lt;InfiniteLoader
              isRowLoaded={({ index }) =&gt; this.isRowLoaded(index)}
              loadMoreRows={loadMoreRows}
              rowCount={rowCount}
            &gt;
              {({ onRowsRendered, registerChild, isScrolling }) =&gt; (
                &lt;WindowScroller&gt;
                  {({ height, scrollTop }) =&gt; (
                    &lt;AutoSizer disableHeight&gt;
                      {({ width }) =&gt; (
                        &lt;VirtualScroll
                          autoHeight
                          ref={registerChild}
                          height={height}
                          rowCount={rowCount}
                          rowHeight={(...args) =&gt; this.getRowHeight(...args)}
                          rowRenderer={({ index }) =&gt; this.renderRow(index, isScrolling)}
                          width={width}
                          noRowsRenderer={this.noRowsRenderer}
                          onRowsRendered={onRowsRendered}
                          overscanRowCount={10}
                          scrollTop={scrollTop}
                        /&gt;
                      )}
                    &lt;/AutoSizer&gt;
                  )}
                &lt;/WindowScroller&gt;
              )}
            &lt;/InfiniteLoader&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }
}

News.propTypes = {
  articles: PropTypes.array.isRequired,
  onFetchPage: PropTypes.func.isRequired,
  isFetching: PropTypes.bool.isRequired,
  pageNumber: PropTypes.number.isRequired,
  hasNextPage: PropTypes.bool.isRequired
};

export default News;
</code></pre>

<p>And the list item is the following component:</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes } from 'react';
import styles from './styles.css';
import { Row, Col } from 'react-flexbox-grid';
import shallowCompare from 'react-addons-shallow-compare';
import pick from 'lodash/pick';
import NewsItemContent from '../NewsItemContent';

class NewsItem extends React.Component {

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  render() {
    const contentProps = pick(this.props, [
      'title', 'description', 'seedUrl', 'seedCode', 'date'
    ]);
    return (
      &lt;div
        onClick={() =&gt; window.open(this.props.url, '_blank')}
        className={styles.newsItem}
      &gt;
        {this.props.imageUrl ?
          &lt;Row&gt;
            &lt;Col xs={3}&gt;
              &lt;div
                role=""presentation""
                style={{ backgroundImage: `url(${this.props.imageUrl})` }}
                className={styles.previewImage}
              /&gt;
            &lt;/Col&gt;
            &lt;Col xs={9}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt; :
          &lt;Row&gt;
            &lt;Col xs={12}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
        }
      &lt;/div&gt;
    );
  }
}

NewsItem.propTypes = {
  imageUrl: PropTypes.string,
  description: PropTypes.string.isRequired,
  title: PropTypes.string.isRequired,
  url: PropTypes.string.isRequired,
  date: PropTypes.object.isRequired,
  seedUrl: PropTypes.string.isRequired,
  seedCode: PropTypes.string.isRequired
};

export default NewsItem;
</code></pre>

<p>NewsItemContent here is a simple pure component without any logic, so I won't put it here.</p>

<p>Thank you!</p>

<p>Update:
I've recorded performance timelines in firefox both in case of window scrolling and block scrolling:</p>

<ul>
<li><a href=""https://www.dropbox.com/s/19fctwllgwvxgct/blocked.json?dl=0"" rel=""nofollow"">Block scrolling</a></li>
<li><a href=""https://www.dropbox.com/s/p66xe22miu884dk/windowed.json?dl=0"" rel=""nofollow"">Window scrolling</a></li>
</ul>
","@brianvaughn thanks for noticing that isScrolling is coming from the wrong place, but it didn't fix scrolling problems. I will try to create a Plunker to demonstrate the problem."
"38641018","react-virtualized WindowScroller performance issues","4","<p>I am using the react-virtualized library to create efficient news feed. The library is awesome. I combined WindowScroller, AutoSizer and VirtualScroll components to have inifinite scrolling behavior. The problem is that when I set the VirtualScroll height manually and don't use WindowScroller the performance is great in all browsers. However when I add the WindowScroller component, performance reduces significantly, especially in Firefox (v47.0). How can I optimize this so that it is feasible to use window scrolling?</p>

<p>This is the News component, where the react-virtualized is used,
I have 2 types of list items - header item and simple item, header item contains a date of a group of news, thus it is a little bit longer.</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes, Component } from 'react';
import Divider from 'material-ui/Divider';
import Subheader from 'material-ui/Subheader';
import { Grid, Row, Col } from 'react-flexbox-grid';
import NewsItem from '../NewsItem';
import styles from './styles.css';
import CircularProgress from 'material-ui/CircularProgress';
import Paper from 'material-ui/Paper';
import classNames from 'classnames';
import { InfiniteLoader, WindowScroller, AutoSizer, VirtualScroll } from 'react-virtualized';
import shallowCompare from 'react-addons-shallow-compare';

class News extends Component {

  componentDidMount() {
    this.props.onFetchPage(0);
  }

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  getRowHeight({ index }) {
    const elementHeight = 200;
    const headerHeight = 78;
    if (!this.isRowLoaded(index)) {
      return elementHeight;
    }
    return this.props.articles[index].isHeader ?
      headerHeight + elementHeight : elementHeight;
  }

  displayElement(article, isScrolling) {
    return (
      &lt;Paper
        key={article.id}
        className={classNames(styles.newsItemContainer, {
          [styles.scrolling]: isScrolling
        })}
      &gt;
        &lt;NewsItem {...article} /&gt;
        &lt;Divider /&gt;
      &lt;/Paper&gt;
    );
  }

  isRowLoaded(index) {
    return !this.props.hasNextPage || index &lt; this.props.articles.length;
  }

  renderRow(index, isScrolling) {
    if (!this.isRowLoaded(index)) {
      return (
        &lt;div className={styles.spinnerContainer}&gt;
          {this.props.isFetching ? &lt;CircularProgress /&gt; : null}
        &lt;/div&gt;
      );
    }
    const { isHeader, date, article } = this.props.articles[index];
    if (isHeader) {
      return (
        &lt;div&gt;
          &lt;Subheader
            key={date}
            className={styles.groupHeader}
          &gt;
            {date}
          &lt;/Subheader&gt;
          {this.displayElement(article, isScrolling)}
        &lt;/div&gt;
      );
    }
    return this.displayElement(article, isScrolling);
  }

  noRowsRenderer() {
    return (&lt;p&gt;No articles found&lt;/p&gt;);
  }

  render() {
    const {
      articles,
      onFetchPage,
      pageNumber,
      isFetching,
      hasNextPage
    } = this.props;

    const loadMoreRows = isFetching ?
      () =&gt; {} :
      () =&gt; onFetchPage(pageNumber + 1);

    const rowCount = hasNextPage ? articles.length + 1 : articles.length;

    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12} sm={8} smOffset={2}&gt;
            &lt;InfiniteLoader
              isRowLoaded={({ index }) =&gt; this.isRowLoaded(index)}
              loadMoreRows={loadMoreRows}
              rowCount={rowCount}
            &gt;
              {({ onRowsRendered, registerChild, isScrolling }) =&gt; (
                &lt;WindowScroller&gt;
                  {({ height, scrollTop }) =&gt; (
                    &lt;AutoSizer disableHeight&gt;
                      {({ width }) =&gt; (
                        &lt;VirtualScroll
                          autoHeight
                          ref={registerChild}
                          height={height}
                          rowCount={rowCount}
                          rowHeight={(...args) =&gt; this.getRowHeight(...args)}
                          rowRenderer={({ index }) =&gt; this.renderRow(index, isScrolling)}
                          width={width}
                          noRowsRenderer={this.noRowsRenderer}
                          onRowsRendered={onRowsRendered}
                          overscanRowCount={10}
                          scrollTop={scrollTop}
                        /&gt;
                      )}
                    &lt;/AutoSizer&gt;
                  )}
                &lt;/WindowScroller&gt;
              )}
            &lt;/InfiniteLoader&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }
}

News.propTypes = {
  articles: PropTypes.array.isRequired,
  onFetchPage: PropTypes.func.isRequired,
  isFetching: PropTypes.bool.isRequired,
  pageNumber: PropTypes.number.isRequired,
  hasNextPage: PropTypes.bool.isRequired
};

export default News;
</code></pre>

<p>And the list item is the following component:</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes } from 'react';
import styles from './styles.css';
import { Row, Col } from 'react-flexbox-grid';
import shallowCompare from 'react-addons-shallow-compare';
import pick from 'lodash/pick';
import NewsItemContent from '../NewsItemContent';

class NewsItem extends React.Component {

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  render() {
    const contentProps = pick(this.props, [
      'title', 'description', 'seedUrl', 'seedCode', 'date'
    ]);
    return (
      &lt;div
        onClick={() =&gt; window.open(this.props.url, '_blank')}
        className={styles.newsItem}
      &gt;
        {this.props.imageUrl ?
          &lt;Row&gt;
            &lt;Col xs={3}&gt;
              &lt;div
                role=""presentation""
                style={{ backgroundImage: `url(${this.props.imageUrl})` }}
                className={styles.previewImage}
              /&gt;
            &lt;/Col&gt;
            &lt;Col xs={9}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt; :
          &lt;Row&gt;
            &lt;Col xs={12}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
        }
      &lt;/div&gt;
    );
  }
}

NewsItem.propTypes = {
  imageUrl: PropTypes.string,
  description: PropTypes.string.isRequired,
  title: PropTypes.string.isRequired,
  url: PropTypes.string.isRequired,
  date: PropTypes.object.isRequired,
  seedUrl: PropTypes.string.isRequired,
  seedCode: PropTypes.string.isRequired
};

export default NewsItem;
</code></pre>

<p>NewsItemContent here is a simple pure component without any logic, so I won't put it here.</p>

<p>Thank you!</p>

<p>Update:
I've recorded performance timelines in firefox both in case of window scrolling and block scrolling:</p>

<ul>
<li><a href=""https://www.dropbox.com/s/19fctwllgwvxgct/blocked.json?dl=0"" rel=""nofollow"">Block scrolling</a></li>
<li><a href=""https://www.dropbox.com/s/p66xe22miu884dk/windowed.json?dl=0"" rel=""nofollow"">Window scrolling</a></li>
</ul>
","@brianvaughn added the performance records (both recorded in react development mode, so those are a bit slower than the optimized build), hope this will help. It is quite hard to put my example to Plunker, but if it makes difference, I absolutely will."
"38641018","react-virtualized WindowScroller performance issues","4","<p>I am using the react-virtualized library to create efficient news feed. The library is awesome. I combined WindowScroller, AutoSizer and VirtualScroll components to have inifinite scrolling behavior. The problem is that when I set the VirtualScroll height manually and don't use WindowScroller the performance is great in all browsers. However when I add the WindowScroller component, performance reduces significantly, especially in Firefox (v47.0). How can I optimize this so that it is feasible to use window scrolling?</p>

<p>This is the News component, where the react-virtualized is used,
I have 2 types of list items - header item and simple item, header item contains a date of a group of news, thus it is a little bit longer.</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes, Component } from 'react';
import Divider from 'material-ui/Divider';
import Subheader from 'material-ui/Subheader';
import { Grid, Row, Col } from 'react-flexbox-grid';
import NewsItem from '../NewsItem';
import styles from './styles.css';
import CircularProgress from 'material-ui/CircularProgress';
import Paper from 'material-ui/Paper';
import classNames from 'classnames';
import { InfiniteLoader, WindowScroller, AutoSizer, VirtualScroll } from 'react-virtualized';
import shallowCompare from 'react-addons-shallow-compare';

class News extends Component {

  componentDidMount() {
    this.props.onFetchPage(0);
  }

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  getRowHeight({ index }) {
    const elementHeight = 200;
    const headerHeight = 78;
    if (!this.isRowLoaded(index)) {
      return elementHeight;
    }
    return this.props.articles[index].isHeader ?
      headerHeight + elementHeight : elementHeight;
  }

  displayElement(article, isScrolling) {
    return (
      &lt;Paper
        key={article.id}
        className={classNames(styles.newsItemContainer, {
          [styles.scrolling]: isScrolling
        })}
      &gt;
        &lt;NewsItem {...article} /&gt;
        &lt;Divider /&gt;
      &lt;/Paper&gt;
    );
  }

  isRowLoaded(index) {
    return !this.props.hasNextPage || index &lt; this.props.articles.length;
  }

  renderRow(index, isScrolling) {
    if (!this.isRowLoaded(index)) {
      return (
        &lt;div className={styles.spinnerContainer}&gt;
          {this.props.isFetching ? &lt;CircularProgress /&gt; : null}
        &lt;/div&gt;
      );
    }
    const { isHeader, date, article } = this.props.articles[index];
    if (isHeader) {
      return (
        &lt;div&gt;
          &lt;Subheader
            key={date}
            className={styles.groupHeader}
          &gt;
            {date}
          &lt;/Subheader&gt;
          {this.displayElement(article, isScrolling)}
        &lt;/div&gt;
      );
    }
    return this.displayElement(article, isScrolling);
  }

  noRowsRenderer() {
    return (&lt;p&gt;No articles found&lt;/p&gt;);
  }

  render() {
    const {
      articles,
      onFetchPage,
      pageNumber,
      isFetching,
      hasNextPage
    } = this.props;

    const loadMoreRows = isFetching ?
      () =&gt; {} :
      () =&gt; onFetchPage(pageNumber + 1);

    const rowCount = hasNextPage ? articles.length + 1 : articles.length;

    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12} sm={8} smOffset={2}&gt;
            &lt;InfiniteLoader
              isRowLoaded={({ index }) =&gt; this.isRowLoaded(index)}
              loadMoreRows={loadMoreRows}
              rowCount={rowCount}
            &gt;
              {({ onRowsRendered, registerChild, isScrolling }) =&gt; (
                &lt;WindowScroller&gt;
                  {({ height, scrollTop }) =&gt; (
                    &lt;AutoSizer disableHeight&gt;
                      {({ width }) =&gt; (
                        &lt;VirtualScroll
                          autoHeight
                          ref={registerChild}
                          height={height}
                          rowCount={rowCount}
                          rowHeight={(...args) =&gt; this.getRowHeight(...args)}
                          rowRenderer={({ index }) =&gt; this.renderRow(index, isScrolling)}
                          width={width}
                          noRowsRenderer={this.noRowsRenderer}
                          onRowsRendered={onRowsRendered}
                          overscanRowCount={10}
                          scrollTop={scrollTop}
                        /&gt;
                      )}
                    &lt;/AutoSizer&gt;
                  )}
                &lt;/WindowScroller&gt;
              )}
            &lt;/InfiniteLoader&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }
}

News.propTypes = {
  articles: PropTypes.array.isRequired,
  onFetchPage: PropTypes.func.isRequired,
  isFetching: PropTypes.bool.isRequired,
  pageNumber: PropTypes.number.isRequired,
  hasNextPage: PropTypes.bool.isRequired
};

export default News;
</code></pre>

<p>And the list item is the following component:</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes } from 'react';
import styles from './styles.css';
import { Row, Col } from 'react-flexbox-grid';
import shallowCompare from 'react-addons-shallow-compare';
import pick from 'lodash/pick';
import NewsItemContent from '../NewsItemContent';

class NewsItem extends React.Component {

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  render() {
    const contentProps = pick(this.props, [
      'title', 'description', 'seedUrl', 'seedCode', 'date'
    ]);
    return (
      &lt;div
        onClick={() =&gt; window.open(this.props.url, '_blank')}
        className={styles.newsItem}
      &gt;
        {this.props.imageUrl ?
          &lt;Row&gt;
            &lt;Col xs={3}&gt;
              &lt;div
                role=""presentation""
                style={{ backgroundImage: `url(${this.props.imageUrl})` }}
                className={styles.previewImage}
              /&gt;
            &lt;/Col&gt;
            &lt;Col xs={9}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt; :
          &lt;Row&gt;
            &lt;Col xs={12}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
        }
      &lt;/div&gt;
    );
  }
}

NewsItem.propTypes = {
  imageUrl: PropTypes.string,
  description: PropTypes.string.isRequired,
  title: PropTypes.string.isRequired,
  url: PropTypes.string.isRequired,
  date: PropTypes.object.isRequired,
  seedUrl: PropTypes.string.isRequired,
  seedCode: PropTypes.string.isRequired
};

export default NewsItem;
</code></pre>

<p>NewsItemContent here is a simple pure component without any logic, so I won't put it here.</p>

<p>Thank you!</p>

<p>Update:
I've recorded performance timelines in firefox both in case of window scrolling and block scrolling:</p>

<ul>
<li><a href=""https://www.dropbox.com/s/19fctwllgwvxgct/blocked.json?dl=0"" rel=""nofollow"">Block scrolling</a></li>
<li><a href=""https://www.dropbox.com/s/p66xe22miu884dk/windowed.json?dl=0"" rel=""nofollow"">Window scrolling</a></li>
</ul>
","Looks like your `isScrolling` argument is in the wrong function (so it will never be true). That should be coming from `WindowScroller` (not `InfiniteLoader`). Not sure if this would have much of an impact on your scrolling performance as I'm not sure what that parameter is being used for."
"38641018","react-virtualized WindowScroller performance issues","4","<p>I am using the react-virtualized library to create efficient news feed. The library is awesome. I combined WindowScroller, AutoSizer and VirtualScroll components to have inifinite scrolling behavior. The problem is that when I set the VirtualScroll height manually and don't use WindowScroller the performance is great in all browsers. However when I add the WindowScroller component, performance reduces significantly, especially in Firefox (v47.0). How can I optimize this so that it is feasible to use window scrolling?</p>

<p>This is the News component, where the react-virtualized is used,
I have 2 types of list items - header item and simple item, header item contains a date of a group of news, thus it is a little bit longer.</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes, Component } from 'react';
import Divider from 'material-ui/Divider';
import Subheader from 'material-ui/Subheader';
import { Grid, Row, Col } from 'react-flexbox-grid';
import NewsItem from '../NewsItem';
import styles from './styles.css';
import CircularProgress from 'material-ui/CircularProgress';
import Paper from 'material-ui/Paper';
import classNames from 'classnames';
import { InfiniteLoader, WindowScroller, AutoSizer, VirtualScroll } from 'react-virtualized';
import shallowCompare from 'react-addons-shallow-compare';

class News extends Component {

  componentDidMount() {
    this.props.onFetchPage(0);
  }

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  getRowHeight({ index }) {
    const elementHeight = 200;
    const headerHeight = 78;
    if (!this.isRowLoaded(index)) {
      return elementHeight;
    }
    return this.props.articles[index].isHeader ?
      headerHeight + elementHeight : elementHeight;
  }

  displayElement(article, isScrolling) {
    return (
      &lt;Paper
        key={article.id}
        className={classNames(styles.newsItemContainer, {
          [styles.scrolling]: isScrolling
        })}
      &gt;
        &lt;NewsItem {...article} /&gt;
        &lt;Divider /&gt;
      &lt;/Paper&gt;
    );
  }

  isRowLoaded(index) {
    return !this.props.hasNextPage || index &lt; this.props.articles.length;
  }

  renderRow(index, isScrolling) {
    if (!this.isRowLoaded(index)) {
      return (
        &lt;div className={styles.spinnerContainer}&gt;
          {this.props.isFetching ? &lt;CircularProgress /&gt; : null}
        &lt;/div&gt;
      );
    }
    const { isHeader, date, article } = this.props.articles[index];
    if (isHeader) {
      return (
        &lt;div&gt;
          &lt;Subheader
            key={date}
            className={styles.groupHeader}
          &gt;
            {date}
          &lt;/Subheader&gt;
          {this.displayElement(article, isScrolling)}
        &lt;/div&gt;
      );
    }
    return this.displayElement(article, isScrolling);
  }

  noRowsRenderer() {
    return (&lt;p&gt;No articles found&lt;/p&gt;);
  }

  render() {
    const {
      articles,
      onFetchPage,
      pageNumber,
      isFetching,
      hasNextPage
    } = this.props;

    const loadMoreRows = isFetching ?
      () =&gt; {} :
      () =&gt; onFetchPage(pageNumber + 1);

    const rowCount = hasNextPage ? articles.length + 1 : articles.length;

    return (
      &lt;Grid&gt;
        &lt;Row&gt;
          &lt;Col xs={12} sm={8} smOffset={2}&gt;
            &lt;InfiniteLoader
              isRowLoaded={({ index }) =&gt; this.isRowLoaded(index)}
              loadMoreRows={loadMoreRows}
              rowCount={rowCount}
            &gt;
              {({ onRowsRendered, registerChild, isScrolling }) =&gt; (
                &lt;WindowScroller&gt;
                  {({ height, scrollTop }) =&gt; (
                    &lt;AutoSizer disableHeight&gt;
                      {({ width }) =&gt; (
                        &lt;VirtualScroll
                          autoHeight
                          ref={registerChild}
                          height={height}
                          rowCount={rowCount}
                          rowHeight={(...args) =&gt; this.getRowHeight(...args)}
                          rowRenderer={({ index }) =&gt; this.renderRow(index, isScrolling)}
                          width={width}
                          noRowsRenderer={this.noRowsRenderer}
                          onRowsRendered={onRowsRendered}
                          overscanRowCount={10}
                          scrollTop={scrollTop}
                        /&gt;
                      )}
                    &lt;/AutoSizer&gt;
                  )}
                &lt;/WindowScroller&gt;
              )}
            &lt;/InfiniteLoader&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }
}

News.propTypes = {
  articles: PropTypes.array.isRequired,
  onFetchPage: PropTypes.func.isRequired,
  isFetching: PropTypes.bool.isRequired,
  pageNumber: PropTypes.number.isRequired,
  hasNextPage: PropTypes.bool.isRequired
};

export default News;
</code></pre>

<p>And the list item is the following component:</p>

<pre class=""lang-js prettyprint-override""><code>import React, { PropTypes } from 'react';
import styles from './styles.css';
import { Row, Col } from 'react-flexbox-grid';
import shallowCompare from 'react-addons-shallow-compare';
import pick from 'lodash/pick';
import NewsItemContent from '../NewsItemContent';

class NewsItem extends React.Component {

  shouldComponentUpdate(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  }

  render() {
    const contentProps = pick(this.props, [
      'title', 'description', 'seedUrl', 'seedCode', 'date'
    ]);
    return (
      &lt;div
        onClick={() =&gt; window.open(this.props.url, '_blank')}
        className={styles.newsItem}
      &gt;
        {this.props.imageUrl ?
          &lt;Row&gt;
            &lt;Col xs={3}&gt;
              &lt;div
                role=""presentation""
                style={{ backgroundImage: `url(${this.props.imageUrl})` }}
                className={styles.previewImage}
              /&gt;
            &lt;/Col&gt;
            &lt;Col xs={9}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt; :
          &lt;Row&gt;
            &lt;Col xs={12}&gt;
              &lt;NewsItemContent {...contentProps} /&gt;
            &lt;/Col&gt;
          &lt;/Row&gt;
        }
      &lt;/div&gt;
    );
  }
}

NewsItem.propTypes = {
  imageUrl: PropTypes.string,
  description: PropTypes.string.isRequired,
  title: PropTypes.string.isRequired,
  url: PropTypes.string.isRequired,
  date: PropTypes.object.isRequired,
  seedUrl: PropTypes.string.isRequired,
  seedCode: PropTypes.string.isRequired
};

export default NewsItem;
</code></pre>

<p>NewsItemContent here is a simple pure component without any logic, so I won't put it here.</p>

<p>Thank you!</p>

<p>Update:
I've recorded performance timelines in firefox both in case of window scrolling and block scrolling:</p>

<ul>
<li><a href=""https://www.dropbox.com/s/19fctwllgwvxgct/blocked.json?dl=0"" rel=""nofollow"">Block scrolling</a></li>
<li><a href=""https://www.dropbox.com/s/p66xe22miu884dk/windowed.json?dl=0"" rel=""nofollow"">Window scrolling</a></li>
</ul>
","Any chance you could point me somewhere that I could look at the 2 side by side and check out the Timeline?"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","Try with the named import? `import { shallowCompare } from 'react-addons-shallow-compare'`"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","Yeah because after looking at the library, it looks like it only has a default export. Not sure why it isn't working for you. Either `import shallowCompare from 'react-addons-shallow-compare'` or `const shallowCompare = require('react-addons-shallow-compare')` should work. It's either how you're babelifying/bundling your app or a syntax error. The examples you wrote are all wrong since can't type `import foo` followed by an equals sign."
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","@ZekeDroid I posted the typings I have in the answer above and there is no default export. Where did you see that it has a default export?"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","`module.exports = shallowCompare;`"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","@ZekeDroid `error TS2305: Module '""react-addons-shallow-compare""' has no exported member 'shallowCompare'. ` This doesn't go past compilation."
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","When the `module.exports` of a library contains a single value, it is the default export. A named export would like like this: `module.exports = { shallowCompare }`"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","@ZekeDroid Thanks! Would posting my webpack config helpful in solving the issue?"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","Yeah though someone else will have to comment on it and you may need to post another question"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","@ZekeDroid I posted an answer. It's fixed like that if you'd like to check."
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","@QoP `error TS1192: Module '""react-addons-shallow-compare""' has no default export.` I tried that before :) Thanks though :)"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","yeah you can use import -> `import shallowCompare from 'react-addons-shallow-compare'`"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","@QoP I get an error if I try to do that: `error TS2349: Cannot invoke an expression whose type lacks a call signature.` Isn't there supposed to be an `import` somewhere?"
"38687981","Cannot import react-addons-shallow-compare, Typescript","13","<p>I need to use the shallowCompare function within the shouldComponentUpdate function of a custom react component. I get the following error:</p>

<blockquote>
  <p>app.js:95084 Uncaught TypeError: Cannot read property 'shallowCompare' of undefined</p>
</blockquote>

<p>I have installed react-addons-shallow-compare version 15.3.0 and I found it in the node_modules. It looks like this:</p>

<pre><code>module.exports = require('react/lib/shallowCompare');
</code></pre>

<p>And this is the shallowCompare.js referenced.</p>

<pre><code>/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule shallowCompare
*/

'use strict';

var shallowEqual = require('fbjs/lib/shallowEqual');

/**
 * Does a shallow comparison for props and state.
 * See ReactComponentWithPureRenderMixin
 * See also https://facebook.github.io/react/docs/shallow-compare.html
 */
function shallowCompare(instance, nextProps, nextState) {
  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
}

module.exports = shallowCompare;
</code></pre>

<p>I have also installed the typings. I have this version:</p>

<pre><code>// Generated by typings
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/6a36f6d5b61602b6c4ad932599097135e80abaf4/react/react-addons-shallow-compare.d.ts
declare namespace __React {
    namespace __Addons {
        export function shallowCompare&lt;P, S&gt;(
            component: __React.Component&lt;P, S&gt;,
            nextProps: P,
            nextState: S): boolean;
    }
}

declare module ""react-addons-shallow-compare"" {
    var shallowCompare: typeof __React.__Addons.shallowCompare;
    export = shallowCompare;
}
</code></pre>

<p>And now I am trying to import it and use it in one of my files. I have tried every strategy for importing it.</p>

<pre><code>import { __Addons as ReactAddons } from ""react"";

/* ... other stuff ... */

ReactAddons.shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = require(""react-addons-shallow-compare"");

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>Or</p>

<pre><code>import shallowCompare = __React.__Addons.shallowCompare;

/* ... other stuff ... */

shallowCompare(this, nextProps, nextState);
</code></pre>

<p>In the last case, the error I get is not the one mentioned above, but</p>

<blockquote>
  <p>Uncaught ReferenceError: __React is not defined</p>
</blockquote>

<p>As a mention, I am using Typescript 1.8.10.</p>

<p>For what it's worth, I am also getting the following error:</p>

<blockquote>
  <p>Failed to parse SourceMap</p>
</blockquote>

<p>I am quite stuck on this for a while now. Some help would be greatly appreciated.</p>

<p>Thanks!</p>
","have you tried const shallowCompare = require('react-addons-shallow-compare'); ?"
"39424061","React + Immutable - Implementing shouldComponentUpdate with shallow equality","0","<p>so I'm using react and I'm taking the approach of using Immutable data in my project with facebook's immutable.js library.</p>

<p>I know that React is way faster than every other library because it updates only the neccesarry DOM, I knew that it does a reconciliation process before updating and that in the process it creates Virtual DOM and compares them, but I never really knew how it knows what to update.
So I did some research and its true, the reconciling algorithm of react is really awesome and saves time, but then something hit me, where does the shouldComponentUpdate method enters?
So react invokes the shouldComponentUpdate for each component and if it returns true, the react does the reconciling process which includes creating virtual doms and comparing them.
So why shouldn't we implement the SCU method for every component? Well react also gives you an answer that includes comparing mutable object and that the equality in this cases should be a deep one, and that would take too long, so you might as well not implement it.</p>

<p>And here is the part where I ask my question, if my entire data on my project is in fact immutable, why shouldn't I implements the SCU with a simple shallow equality on all of my components? This way we spare the reconcile process and our app will be much faster.</p>
",""
"39607174","react-redux can update child smart components without updating parents?","0","<p>Imagine the following React structure:</p>

<p>SmartComponentA -> DumbComponentB -> SmartComponentC</p>

<p>Also imagine that SmartComponentA and SmartComponentC each get connected to different slices of the state in their <code>mapStateToProps</code> functions.</p>

<p>Lastly, imagine that we put a <code>console.log</code> in the render method of each of these components.</p>

<p>When I actually try this, on the first render, I see that all components log as expected. But then if I change the data for SmartComponentC, I only see a single log message (C's log message), and I don't see SmartComponentA or DumbComponentB logging anything. How is that possible? <strong>How is react-redux getting React to update a child without updating its parents?</strong></p>

<p>I would have assumed that <a href=""https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L76-L78"" rel=""nofollow"">the overriding</a> of <code>shouldComponentUpdate</code> inside of the <code>connect</code> method would mean SmartComponentA would not get re-rendered (since its slice of the state didn't change), and therefore would cause a short-circuiting that would prevent SmartComponentC from getting re-rendered. While <code>connect</code>'s implementation is not the same as the pure render mixin, both work by changing <code>shouldComponentUpdate</code>, but the pure render docs clearly state that React will ""bail out"" (as they put it) if a parent doesn't need to re-render:</p>

<blockquote>
  <p>for C2's subtree and C7, it didn't even have to compute the virtual DOM as we bailed out on <code>shouldComponentUpdate</code>.</p>
</blockquote>

<p><a href=""https://facebook.github.io/react/docs/advanced-performance.html#shouldcomponentupdate-in-action"" rel=""nofollow"">source</a></p>

<p>If my question still isn't clear, here is sort of pseudo-code for the setup, and <strong>I'm asking why I can keep typing in C's input and it only log's C's messages to the console and not A's and B's (why is it not short-circuiting)</strong>?</p>

<pre><code>//////////////////////////////////////////////

const SmartComponentA = (props) =&gt; {
  console.log('rendering SmartComponentA');

  return &lt;DumbComponentB bData={props.bData} /&gt;;
};

const mapStateToProps = (state) =&gt; { bData: state.bData };

export default connect(mapStateToProps)(SmartComponentA);

//////////////////////////////////////////////

const DumbComponentB = (props) =&gt; {
  console.log('rendering DumbComponentB');

  return (
    &lt;div&gt;
      {props.bData}
      &lt;SmartComponentC /&gt;
    &lt;/div&gt;
  );
}

export default DumbComponentB;

//////////////////////////////////////////////

const SmartComponentC = (props) =&gt; {
  console.log('rendering SmartComponentC');

  return (
    &lt;div&gt;
      &lt;input value={props.cValue} onChange={props.changeCValue} /&gt;
    &lt;/div&gt;
  );
}

const mapStateToProps = (state) =&gt; { cValue: state.cValue };

export default connect(mapStateToProps, { changeCValue })(SmartComponentC);
//////////////////////////////////////////////
</code></pre>

<p>On the first render I see all log messages, then if I keep typing in the input, I only see C's log message each time I press a key.</p>
",""
"39617344","Would it be possible to utilize Immutable.js in a React-Redux Application for comparing props in shouldComponentUpdate?","1","<p>I am currently working on an React-Application where I use Immutable.js in my Redux-Reducers. The reducers will return the previous state as a reference if they have not changed it (as recommended). 
If I now compared the previous state with the next state <code>(state===nextState)</code> it would return true, since the reference has not changed, right?</p>

<p>Now if the reducer changed the state, it would return a new Immutable.js Map.</p>

<p>Doing the same comparision now it would return false, since it is a new Map.</p>

<p>Would it be reasonable to somehow detect prop changes within shouldComponentUpdate like that?</p>

<p>If so, is there a way to modify the react-redux connect function to use my custom shouldComponentUpdate method? Because apparently it is not possible to pass an Immutable.js Object as props to a component.</p>
","Welcome to SO. We prefer questions that can be answered, not just discussed. Please visit the help center and take [this tour](http://stackoverflow.com/tour) to see what to ask and how."
"40111642","React: shouldComponentUpdate wait for an asynchronous operation","3","<p>I'm trying to show a confirm modal (using react-confirm) to warn the user when he's trying to move to another section that the information completed in the form will be lost.</p>

<p>The confirm of js does block the code so I can do this:</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
        if (confirm('Hay cambios sin guardar, si continua se perderán. ¿Desea continuar?')) {
            return true;
        } else {
            return false;
        }
}
</code></pre>

<p>But when I replace the confirm method by the one of the library react-confirm I can't wait for the result of this asynchronous operation.</p>

<pre><code>async shouldComponentUpdate(nextProps, nextState) {
    const response = await confirm('Hay cambios sin guardar, si continua se perderán. ¿Desea continuar?', { title: ""Cambios sin guardar"", okLabbel: ""Sí"", cancelLabel: ""No!"" })
        .then(
            () =&gt; {
                return true;
            },
            () =&gt; {
                return false;
            }
        );
    return (response);
</code></pre>

<p>}</p>

<p>Does anyone know how can I get this?</p>
","Why don't you call the confirm when user click the link/button to another section. In the success callback you can redirect user to the new section."
"40111642","React: shouldComponentUpdate wait for an asynchronous operation","3","<p>I'm trying to show a confirm modal (using react-confirm) to warn the user when he's trying to move to another section that the information completed in the form will be lost.</p>

<p>The confirm of js does block the code so I can do this:</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
        if (confirm('Hay cambios sin guardar, si continua se perderán. ¿Desea continuar?')) {
            return true;
        } else {
            return false;
        }
}
</code></pre>

<p>But when I replace the confirm method by the one of the library react-confirm I can't wait for the result of this asynchronous operation.</p>

<pre><code>async shouldComponentUpdate(nextProps, nextState) {
    const response = await confirm('Hay cambios sin guardar, si continua se perderán. ¿Desea continuar?', { title: ""Cambios sin guardar"", okLabbel: ""Sí"", cancelLabel: ""No!"" })
        .then(
            () =&gt; {
                return true;
            },
            () =&gt; {
                return false;
            }
        );
    return (response);
</code></pre>

<p>}</p>

<p>Does anyone know how can I get this?</p>
","Because Im not using different routes to each section. A component manage the render of the information for each section, that's why Im trying to use shouldComponentUpdate."
"40111642","React: shouldComponentUpdate wait for an asynchronous operation","3","<p>I'm trying to show a confirm modal (using react-confirm) to warn the user when he's trying to move to another section that the information completed in the form will be lost.</p>

<p>The confirm of js does block the code so I can do this:</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
        if (confirm('Hay cambios sin guardar, si continua se perderán. ¿Desea continuar?')) {
            return true;
        } else {
            return false;
        }
}
</code></pre>

<p>But when I replace the confirm method by the one of the library react-confirm I can't wait for the result of this asynchronous operation.</p>

<pre><code>async shouldComponentUpdate(nextProps, nextState) {
    const response = await confirm('Hay cambios sin guardar, si continua se perderán. ¿Desea continuar?', { title: ""Cambios sin guardar"", okLabbel: ""Sí"", cancelLabel: ""No!"" })
        .then(
            () =&gt; {
                return true;
            },
            () =&gt; {
                return false;
            }
        );
    return (response);
</code></pre>

<p>}</p>

<p>Does anyone know how can I get this?</p>
","So there is a change of state involved in the transition to another section. You have nextProps, nextState parameters in shouldComponentUpdate, so you can check the state and return yes or no accordingly."
"40198780","React-Router Match-component does not trigger shouldComponentUpdate()","2","<p>In my React app build on estejs (devstack), which uses react-router, I ran into the following problem:</p>

<p><code>&lt;Match pattern=""/cards/:sub?"" component={Cards}/&gt;</code></p>

<p>Matches <code>localhost:3000/cards</code> and <code>localhost:3000/cards/test</code> perfectly,
but does not call <code>shouldComponentUpdate()</code> as expected from the 
<a href=""https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate"" rel=""nofollow"">documentation</a>. Since <code>:sub</code> is a parameter, it should just change the prop <code>this.props.params.sub</code> of the <code>card</code> component and because of that also call <code>shouldComponentUpdate()</code> where I then want to <code>return false</code> to denie the <code>render()</code>-call.</p>

<p>Why does the Match component not just update the prop but trigger a not denieable rerender of my component?
Any suggestions?</p>

<p>Thanks!</p>
","Doc of react-router match component for further information: https://react-router.now.sh/Match"
"40198780","React-Router Match-component does not trigger shouldComponentUpdate()","2","<p>In my React app build on estejs (devstack), which uses react-router, I ran into the following problem:</p>

<p><code>&lt;Match pattern=""/cards/:sub?"" component={Cards}/&gt;</code></p>

<p>Matches <code>localhost:3000/cards</code> and <code>localhost:3000/cards/test</code> perfectly,
but does not call <code>shouldComponentUpdate()</code> as expected from the 
<a href=""https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate"" rel=""nofollow"">documentation</a>. Since <code>:sub</code> is a parameter, it should just change the prop <code>this.props.params.sub</code> of the <code>card</code> component and because of that also call <code>shouldComponentUpdate()</code> where I then want to <code>return false</code> to denie the <code>render()</code>-call.</p>

<p>Why does the Match component not just update the prop but trigger a not denieable rerender of my component?
Any suggestions?</p>

<p>Thanks!</p>
","another thing: the constructor of the card component is called on every URL change. Seems like its re-created everytime?! Shouldnt it just update?"
"40287253","Performance issue with react-tether inside item in a react-virtualized list","3","<p><strong>Description</strong></p>

<p>I have a potentially long list of items rendered in a react-virtualized <code>VirtualScroll</code>.<br>
Each item (row) in the list has a fairly large amount of elements, one of which opens a context menu. I'm trying to use <code>react-tether</code> to render that menu on the HTML <code>body</code> (so that it's not hidden when the item is at the bottom/top of the scrollable list) and keep the menu 'stuck' to my item while the user scrolls through the list.<br>
My problem is that there is a noticeable lag in updating the position of the tethered menu.</p>

<p><strong>Some of the steps I've taken so far:</strong></p>

<ol>
<li>Rendered a simple list, without <code>VirtualScroll</code>. The tethered menu was rendered smoothly, no noticeable jank. That's how I concluded that the problem is with <code>react-virtualized</code></li>
<li>Simplified my <code>rowRenderer</code> down to only the menu trigger, as <a href=""https://stackoverflow.com/a/37054717/507240"">recommended here</a>. </li>
<li>Implemented <code>shouldComponentUpdate</code> in the row component. This has improved the perceived performance greatly, reduced the delay greatly but it is still noticeable.</li>
<li>Checked Chrome devtools' timeline. I see reflows triggered by both <code>Grid.js</code> and <code>tether.js</code>.</li>
</ol>

<p><strong>Library Versions:</strong></p>

<ul>
<li>react-virtualized v. 7.24.3 (Large project, not ready to make the step to 8.x yet)  </li>
<li>react-tether v. 0.5.2</li>
<li>react v. 15.2.1</li>
</ul>

<p><strong>Working Demo</strong></p>

<p><a href=""https://plnkr.co/edit/f7OhCoCXkDsWbyjxhR3f"" rel=""nofollow noreferrer"">https://plnkr.co/edit/f7OhCoCXkDsWbyjxhR3f</a></p>

<p><strong>Screenshot:</strong></p>

<p><a href=""https://i.stack.imgur.com/Ml7on.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ml7on.gif"" alt=""screenshot""></a></p>
","@brianvaughn thanks for the quick reply. 
1. I do not use `AutoSizer`, but rather our own custom resize handler. If it comes to that, I may try to upgrade to 8.x and switch to `AutoSizer`
2. I'll see if I can set up a shareable example. Probably a good idea anyway to isolate the issue"
"40287253","Performance issue with react-tether inside item in a react-virtualized list","3","<p><strong>Description</strong></p>

<p>I have a potentially long list of items rendered in a react-virtualized <code>VirtualScroll</code>.<br>
Each item (row) in the list has a fairly large amount of elements, one of which opens a context menu. I'm trying to use <code>react-tether</code> to render that menu on the HTML <code>body</code> (so that it's not hidden when the item is at the bottom/top of the scrollable list) and keep the menu 'stuck' to my item while the user scrolls through the list.<br>
My problem is that there is a noticeable lag in updating the position of the tethered menu.</p>

<p><strong>Some of the steps I've taken so far:</strong></p>

<ol>
<li>Rendered a simple list, without <code>VirtualScroll</code>. The tethered menu was rendered smoothly, no noticeable jank. That's how I concluded that the problem is with <code>react-virtualized</code></li>
<li>Simplified my <code>rowRenderer</code> down to only the menu trigger, as <a href=""https://stackoverflow.com/a/37054717/507240"">recommended here</a>. </li>
<li>Implemented <code>shouldComponentUpdate</code> in the row component. This has improved the perceived performance greatly, reduced the delay greatly but it is still noticeable.</li>
<li>Checked Chrome devtools' timeline. I see reflows triggered by both <code>Grid.js</code> and <code>tether.js</code>.</li>
</ol>

<p><strong>Library Versions:</strong></p>

<ul>
<li>react-virtualized v. 7.24.3 (Large project, not ready to make the step to 8.x yet)  </li>
<li>react-tether v. 0.5.2</li>
<li>react v. 15.2.1</li>
</ul>

<p><strong>Working Demo</strong></p>

<p><a href=""https://plnkr.co/edit/f7OhCoCXkDsWbyjxhR3f"" rel=""nofollow noreferrer"">https://plnkr.co/edit/f7OhCoCXkDsWbyjxhR3f</a></p>

<p><strong>Screenshot:</strong></p>

<p><a href=""https://i.stack.imgur.com/Ml7on.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ml7on.gif"" alt=""screenshot""></a></p>
","""_Checked Chrome devtools' timeline. I see reflows triggered by both Grid.js and tether.js._"" - Not sure about tether, but in react-virtualized v8 I made 2 important perf optimizations to the up-stream `detect-element-resize` library that prevented it from doing a lot of unnecessary reflows. If you're using `AutoSizer`, this change may help you. (If you're not then it would not be relevant.) I'd be happy to take a look at your issue if you could share some code with me- even if it's just a small Plnkr."
"40287253","Performance issue with react-tether inside item in a react-virtualized list","3","<p><strong>Description</strong></p>

<p>I have a potentially long list of items rendered in a react-virtualized <code>VirtualScroll</code>.<br>
Each item (row) in the list has a fairly large amount of elements, one of which opens a context menu. I'm trying to use <code>react-tether</code> to render that menu on the HTML <code>body</code> (so that it's not hidden when the item is at the bottom/top of the scrollable list) and keep the menu 'stuck' to my item while the user scrolls through the list.<br>
My problem is that there is a noticeable lag in updating the position of the tethered menu.</p>

<p><strong>Some of the steps I've taken so far:</strong></p>

<ol>
<li>Rendered a simple list, without <code>VirtualScroll</code>. The tethered menu was rendered smoothly, no noticeable jank. That's how I concluded that the problem is with <code>react-virtualized</code></li>
<li>Simplified my <code>rowRenderer</code> down to only the menu trigger, as <a href=""https://stackoverflow.com/a/37054717/507240"">recommended here</a>. </li>
<li>Implemented <code>shouldComponentUpdate</code> in the row component. This has improved the perceived performance greatly, reduced the delay greatly but it is still noticeable.</li>
<li>Checked Chrome devtools' timeline. I see reflows triggered by both <code>Grid.js</code> and <code>tether.js</code>.</li>
</ol>

<p><strong>Library Versions:</strong></p>

<ul>
<li>react-virtualized v. 7.24.3 (Large project, not ready to make the step to 8.x yet)  </li>
<li>react-tether v. 0.5.2</li>
<li>react v. 15.2.1</li>
</ul>

<p><strong>Working Demo</strong></p>

<p><a href=""https://plnkr.co/edit/f7OhCoCXkDsWbyjxhR3f"" rel=""nofollow noreferrer"">https://plnkr.co/edit/f7OhCoCXkDsWbyjxhR3f</a></p>

<p><strong>Screenshot:</strong></p>

<p><a href=""https://i.stack.imgur.com/Ml7on.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ml7on.gif"" alt=""screenshot""></a></p>
","@brianvaughn I updated my question with a link to working demo on splunkr. The delay is visible."
"40319786","Idiomatic implementation of shouldComponentUpdate?","1","<p>I am trying to figure out the most idiomatic implementation of the react lifecycle method <code>shouldComponentUpdate</code>. I feel that I, and possibly others, don't utilize this method to the extent it could be because it is optional.</p>

<p>Generally I want to check if if the <code>props</code> or <code>state</code> of an object has changed between updates.</p>

<p>This does not work as this equality is pointing at the object reference:</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
  return this.props !== nextProps;
}
</code></pre>

<p>So then we go down the rabbit hole of object cloning, which seems like a little bit of an ugly solution:</p>

<pre><code> return JSON.parse(JSON.stringify(this.props) !== JSON.parse(JSON.stringify(nextProps));

 // lodash cloning method
 return _.cloneDeep(this.props) !== _.cloneDeep(nextProps);
</code></pre>

<p>Another possibility is using an immutable library like <a href=""https://facebook.github.io/immutable-js/"" rel=""nofollow"">immutablejs</a>, but that is another dependency I'm not sure I want to add to the project, and another API to learn. </p>

<p>Am I missing something? Is there a more concise approach to this?</p>
","The most concise is definitely ImmutableJS, everything else isn't going to be simple."
"40992304","How to avoid repeated rendering of react component?","2","<p>The <code>startUpload</code> method inside <code>&lt;Items /&gt;</code> will call the callback function to update the state of the parent component each time it receives a response, This causes <code>&lt;Items /&gt;</code> to be rendered unnecessarily multiple times.</p>

<p>My expected effect is that after the state is updated, only the <code>&lt;Results /&gt;</code> component needs to be re-rendered</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Parent extends React.Component {
    constructor(props) {
        super(props);
        this.getResponseData = this.getResponseData.bind(this);
        this.state = {
            responseData: [],
        }
    }
  
    getResponseData(data) {
        this.setState({
            responseData: this.state.responseData.concat(data),
        })
    }

    render() {
        return (
            &lt;div&gt;
                &lt;Items files={this.props.files} updateData={this.getResponseData}/&gt;
                &lt;Results data={this.state.responseData}/&gt;
            &lt;/div&gt;
        )
    }
}

class Items extends React.Component {
    componentDidMount() {
        this.startUpload(this.props.files)
    }

    startUpload(files) {
        const URL = 'http://localhost:3000/upload';

        for (let i = 0, len = files.length; i &lt; len; i++) {
            const data = new FormData();
            data.append('img', files[i]);

            fetch(URL, {
                method: 'post',
                body: data,
            })
                .then(checkStatus)
                .then(parseJSON)
                .then(data =&gt; {
                    this.props.updateData(data);
                })
        }
    }

    render() {
        const filesData = this.getFilesData(this.props.files);

        let imageItems = filesData.map((current) =&gt; {
            return (
                &lt;div&gt;
                    &lt;img src={current.objectURL} alt=""preview""/&gt;
                &lt;/div&gt;
            )
        });

        return &lt;div&gt;{imageItems}&lt;/div&gt;;
    }
}

function Results(props) {
    const responseData = props.data;
    let result = [];

    if (responseData.length) {
        result = responseData.map(current =&gt; {
            return &lt;p&gt;{current}&lt;/p&gt;
        });

        return &lt;div&gt;{result}&lt;/div&gt;
    }
}</code></pre>
</div>
</div>
</p>
","Look into the `React` method: ""shouldComponentUpdate"". [LifeCycle](https://facebook.github.io/react/docs/react-component.html)"
"42048462","Where would I add existing JS Code to react-boilerplate","0","<p>I spent a while toying around with <a href=""https://github.com/react-boilerplate/react-boilerplate"" rel=""nofollow noreferrer"">react-boilerplate</a>, reading the docs, searching the web etc. I built up some simple components and containers no problem. </p>

<p>I have a large amount of code that creates DOM nodes and returns them using javascript. For a simple example </p>

<pre><code>  function makeSomething(){    
        let div = document.createElement('div');
        div.innerHTML = 'where would this go in reactjs boilerplate';
        return div
  }
</code></pre>

<p>My code does a ton of DOM manipulation, adding table rows, deleting rows and columns, moving rows, fetching data from remote sources. It is all written in javascript except for ajax calls which use jquery.</p>

<p>My question is how do I call and place the returned nodes into a container? </p>

<p>here is a simplified example of trying to add a js created node in a container:</p>

<pre><code>export default class VendorsPage extends React.Component { // eslint-disable-line react/prefer-stateless-function

  // Since state and props are static,
  // there's no need to re-render this component
  shouldComponentUpdate() {
    return false;
  }
  renderdiv(){
    let div = document.createElement('div');
    div.innerHTML = 'hi there'
      return div
  }
  render() {
    return (
        //how do I put renderdiv in here
    );
  }
}
</code></pre>
",""
"42093066","Webpack react HMR without router","0","<p>I need to start react js project without <code>react-router</code>, but I cannot setup hot module replacement without that one, please can you help me.<br>
My server </p>

<pre><code>const app = express()

// Apply gzip compression
app.use(compress())

if (project.env === 'development') {
  const compiler = webpack(webpackConfig)

   debug('Enabling webpack dev and HMR middleware')
   app.use(require('webpack-dev-middleware')(compiler, {
   publicPath  : webpackConfig.output.publicPath,
   contentBase : project.paths.client(),
   hot         : true,
   quiet       : project.compiler_quiet,
   noInfo      : project.compiler_quiet,
   lazy        : false,
   stats       : project.compiler_stats
 }))
 app.use(require('webpack-hot-middleware')(compiler, {
   path: '/__webpack_hmr'
 }))
} else {
    ....
}
</code></pre>

<p>My application entry point. </p>

<pre><code>const MOUNT_NODE = document.getElementById('root')

let render = () =&gt; {
   ReactDOM.render(
    &lt;App store={store} /&gt;,
    MOUNT_NODE)
 }

 if (__DEV__) {
    if (module.hot) {
      // Development render functions
      const renderApp = render
      const renderError = (error) =&gt; {
      const RedBox = require('redbox-react').default

      ReactDOM.render(&lt;RedBox error={error} /&gt;, MOUNT_NODE)
    }

    // Wrap render in try/catch
   render = () =&gt; {
      try {
         renderApp()
      } catch (error) {
         console.error(error)
         renderError(error)
      }
   }

  // Setup hot module replacement
   module.hot.accept('./App', () =&gt;
     setImmediate(() =&gt; {
        ReactDOM.unmountComponentAtNode(MOUNT_NODE)
        render()
     })
   )
 }
</code></pre>

<p>}</p>

<p>Where <code>./App</code> is simple component wrapping my application inside provider. </p>

<pre><code>shouldComponentUpdate = () =&gt; false;

 render () {
    return (
    &lt;Provider store={this.props.store}&gt;
       &lt;RootComponent /&gt;
    &lt;/Provider&gt;  )
 }
</code></pre>

<p>And the main problem is - that when I save this, or child file, HMR rebuilding and nothing changed, but even, I use router, and pass as entry point of application, instead of simple component - its working fine.</p>

<pre><code>export const createRoutes = (store) =&gt; ({
  path        : '/',
  component   : CoreLayout,
  indexRoute  : { onEnter: (nextState, replace) =&gt; replace('/songs') },
  childRoutes : [
    ...
 ]
 })
</code></pre>

<p>What I am doing wrong?</p>
",""
"42490049","react-native-router-flux refreshing component with Replace, Reset, and Refresh","0","<p>So I've been using ignite CLI which includes react-native-router-flux.</p>

<p>My question is, I'm having a data from props which will be uploaded to the database when the user press 'apply' here's the code </p>

<p><code>&lt;TouchableOpacity style={styles.button} onPress={this.onApply.bind(this)}&gt;
              &lt;Text style={styles.buttonText}&gt;Apply&lt;/Text&gt;
 &lt;/TouchableOpacity&gt;</code></p>

<pre><code>async onApply(){

var token = await AsyncStorage.getItem(STORAGE_KEY)
var url = ""http://purwadhikaconnect.southeastasia.cloudapp.azure.com/api/applicants""
var jobId = this.props.jobData.Id
console.log('int?', jobId);
var config = {
  method: ""POST"",
  headers:{
    'Content-Type' : 'application/json',
    'Accept' : 'application/json',
    ""Authorization"" : 'Bearer ' + token
  },
  body: JSON.stringify({
    JobId : parseInt(jobId)
  })
}

return fetch(url, config).then((response) =&gt; response.json())
.then(this.setState({
  isApplied: true,
})).then((response) =&gt;{Alert.alert('Job Applied Successfully')})
.then(this.setState({currentApplicant: this.state.currentApplicant + 1})) //trying to manipulate the value
.then(NavigationActions.Jobs({type: 'reset'}))
.catch((exception) =&gt; {Alert.alert('You have applied for this job!')})
</code></pre>

<p>}</p>

<p>now the data is successfully uploaded but it wont automatically refresh. I've been using component update lifecycle such as <code>shouldComponentUpdate()</code>
and you could see that my Action type there is <code>reset</code>. Now the issue with using <code>Actionconst.replace</code> is that my menu button will be replaced with back button. And if I use
<code>ActionConst.refresh()</code> it wont refresh as well. Please help me I've been dealing with this for months and I've tried almost everything to solve it but to no avail and its getting frustrating...;(</p>
",""
"42517672","Upgrading react-virtualized gives error: Super expression must either be null or a function, not undefined","1","<p>I upgraded from react-virtualized 8.11 --> 9.1, and receiving the above error. Accounting for the docs breaking changes:</p>

<p>1- I'm using React version 0.15.X</p>

<p>2- I'm not using the CellMeasurer component.  </p>

<p>Have any of you experienced a breaking change upgrading to react-virtualized 9 outside of the above mentioned?  I have made no other changes when upgrading.</p>

<p>VirtualizedTable.js</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import React, { Component, PropTypes }        from 'react';
import { AutoSizer, Table, Column, defaultTableRowRenderer }       from 'react-virtualized';
import classnames                             from 'classnames';
import { Input } from 'react-bootstrap';
import 'react-virtualized/styles.css';
// import '../sass/components/virtualized-table.scss';

export default class VirtualizedTable extends Component {
  static propTypes = {
    schema: PropTypes.shape({
      instanceType: PropTypes.string,
      searchable: PropTypes.bool,
      skeleton: PropTypes.arrayOf(PropTypes.shape({
        key: PropTypes.string,
        label: PropTypes.string,
        display: PropTypes.string,
        sortable: PropTypes.bool
      }))
    }).isRequired,
    data: PropTypes.arrayOf(PropTypes.object).isRequired,
    onRowClick: PropTypes.func,
    rowClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    rowRenderFn: PropTypes.func,
    statusRenderFn: PropTypes.func,
    actionsRenderFn: PropTypes.func,
    sortBy: PropTypes.string,
    sortDirection: PropTypes.oneOf(['ASC', 'DESC']),
    maxHeight: PropTypes.number
  };
  constructor(props) {
    super(props);
    this.state = {
      sortBy: 'name',
      sortDirection: 'ASC',
      tableFilter: ''
    };
    this.sort = this.sort.bind(this);
    this.onFilterChange = this.onFilterChange.bind(this);
  }
  componentDidMount() {
    if (this.props.sortBy) {
      this.setState({
        sortBy: this.props.sortBy
      });
    }
    if (this.props.sortDirection) {
      this.setState({
        sortDirection: this.props.sortDirection
      });
    }
  }
  sort({ sortBy, sortDirection }) {
    if (this.state.sortBy !== sortBy) {
      this.setState({ sortBy });
    } else {
      this.setState({ sortBy, sortDirection });
    }
  }
  onFilterChange (e) {
    this.setState({ tableFilter: e.target.value });
  }
  escapeRegex (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&amp;');
  }
  render() {
    const { showFilter } = this.props;
    let sortedList = this.props.data;
    if (this.state.tableFilter) {
      let regex = new RegExp(this.escapeRegex(this.state.tableFilter), 'i');
      sortedList = this.props.data.filter(
        item =&gt; {
          let bool = false;
          for (let key in item) {
            bool = (regex.test(item[key]));
            if (bool) break;
          }
          if (bool) return item;
        }
      );
    }
    if (this.state.sortBy) {
      sortedList = sortedList.sort(
        (a, b) =&gt; typeof a[this.state.sortBy] === 'string' ?
          a[this.state.sortBy] &lt; b[this.state.sortBy]
        :
          a[this.state.sortBy] - b[this.state.sortBy]
      );
      if (this.state.sortDirection === 'DESC') {
        sortedList.reverse();
      }
    }
    let columns = this.props.schema.skeleton.filter(item =&gt; item.display !== 'hidden');
    const rowHeight = this.props.rowHeight || 40;
    const headerHeight = this.props.headerHight || 40;
    return (
      &lt;div className='table-container'&gt;
        {
          (showFilter) ?
            &lt;div className='ac-filter-container' style={{ width: '15%' }}&gt;
              &lt;Input
                type='text'
                onChange={this.onFilterChange.bind(this)}
                value={this.state.tableFilter}
                placeholder={this.props.filterText || 'Filter results...'}
              /&gt;
            &lt;/div&gt;
          :
            null
        }
        &lt;AutoSizer disableHeight&gt;
          {({ width: autoWidth }) =&gt; {
            // Use Static width if provided - NOTE: For Testing Purposes
            const width = this.props.width || autoWidth;
            return (
              &lt;Table
                className={classnames('table', {'collapsed': width &lt; 1000})}
                width={width}
                height={(sortedList.length + 1) * rowHeight &gt; this.props.maxHeight ? this.props.maxHeight : (sortedList.length + 1) * rowHeight}
                headerHeight={headerHeight}
                rowHeight={rowHeight}
                rowClassName={this.props.rowClassName}
                rowRenderer={this.props.rowRenderFn || defaultTableRowRenderer}
                rowCount={sortedList.length}
                rowGetter={({ index }) =&gt; sortedList[index]}
                sort={this.sort}
                sortBy={this.state.sortBy}
                sortDirection={this.state.sortDirection}
                onRowClick={({index}) =&gt; this.props.onRowClick(this.props.data[index])}
              &gt;
                {
                  columns.map((column, i) =&gt; {
                    return (
                      &lt;Column
                        key={i}
                        label={column.label}
                        dataKey={column.key}
                        disableSort={column.sortable}
                        width={width / columns.length}
                      /&gt;
                    );
                  })
                }
              &lt;/Table&gt;
            );
          }}
        &lt;/AutoSizer&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
</div>
</div>
</p>

<p>TablContainer.js</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import React, {Component} from 'react';

// Components
import VirtualizedTable from '../../components/VirtualizedTable3';
import {objects} from '../objects';
import shouldComponentUpdate from '../../utils/shouldComponentUpdate';


export default class TableContainer extends Component {

  constructor(props) {
    super(props);
    this.shouldComponentUpdate = shouldComponentUpdate.bind(this);
  }

  render() {
    let schema = {
      instanceType: 'integer',
      searchable: true,
      skeleton: [{
        key: 'id',
        label: 'id',
        display: 'true',
        sotrable: true
      }, {
        key: 'name',
        label: 'name',
        display: 'true',
        sotrable: true
      }]
    };

    return (
      &lt;div className='container'&gt;
        &lt;h1&gt;React Virtualized Table&lt;/h1&gt;

        {
          &lt;VirtualizedTable
            schema={schema}
            data={objects}
            onRowClick={() =&gt; console.log('U did it!')}
            sortByDefault='id'
            sortDirection='DESC'
          /&gt;
        }

      &lt;/div&gt;
    );
  }
}</code></pre>
</div>
</div>
</p>
","There is no React `0.15.X`."
"42986196","Get react router path in props with redux ownProps","1","<p>I'm trying to get the current path of the react router in a container so I can pass it to a child component that will change it's visibility filter. </p>

<p>More specifically, I'm trying to make a navigation menu highlight the currently active page. </p>

<p>I'm using react, redux, react-router, and react-router-redux so I can access the router state from the redux store. </p>

<p>From the docs for <a href=""https://github.com/reactjs/react-router-redux"" rel=""nofollow noreferrer"">react-router-redux</a>, it says to do something like this: </p>

<pre><code>function mapStateToProps(state, ownProps) {
  return {
    id: ownProps.params.id,
    filter: ownProps.location.query.filter
  };
}
</code></pre>

<p>Here is my container component:</p>

<pre><code>import React, { Component, PropTypes } from 'react'
import { connect } from 'react-redux'
import { Link } from 'react-router'
import {
  Segment as UISegment,
} from 'semantic-ui-react'
import NavMenu from '../components/NavMenu'

class MenuBar extends Component {
  static propTypes = {
    path: PropTypes.string.isRequired
  }

  render() {
    const { path, } = this.props

    return (
      &lt;UISegment&gt;
        &lt;NavMenu activePath={path} /&gt;
      &lt;/UISegment&gt;
    )
  }
}

const mapStateToProps = (state, ownProps) =&gt; {   
  return {
    path: ownProps.route ? ownProps.route.path : ""/""
  }
}

export default connect(mapStateToProps)(MenuBar)
</code></pre>

<p>Inside the NavMenu component, a semantic-ui menu component will compare <code>activePath</code> with its own path and highlight the active button.</p>

<p>Everything seems to work in theory; when I click on the different parts of the menu, a <code>@@router/LOCATION_CHANGE</code> action is emitted. In the redux dev tools, I see the state changing. However, <code>mapStateToProps</code> is never called and this component is never re-rendered. </p>

<p>Any ideas? I thought about using the react methods like <code>shouldComponentUpdate</code>, but it seems that react doesn't even realize the state or props are changing.</p>
","to change a state in redux, you need to do it through dispatch."
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","which version of `react-router`?"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","by deps: ""dependencies"": {
    ""react"": ""^15.4.1"",
    ""react-dom"": ""^15.4.1"",
    ""react-redux"": ""^4.4.6"",
    ""react-router-dom"": ""^4.0.0"",
    ""react-router-redux"": ""^5.0.0-alpha.4"",
    ""redux"": ""^3.6.0""
  } @AnthonyKong"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","@JohnRuddell I do have react-router and I'm able to import Route without a problem. It would appear perhaps that this version of react-router  react-router@^4.0.0 does not export browserHistory. P.s I'm relying on the react-router defined by react-router-redux. I do not explicitly define it as a dep."
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","@micahblu do you not have the package react-router? and how are you setting up your routes?"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","@JohnRuddell I get: bundle.js:44241 ./src/containers/AddStory.js
25:19-33 ""export 'browserHistory' was not found in 'react-router'"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","@JohnRuddell ""dependencies"": {
    ""react"": ""^15.4.1"",
    ""react-dom"": ""^15.4.1"",
    ""react-redux"": ""^4.4.6"",
    ""react-router-dom"": ""^4.0.0"",
    ""react-router-redux"": ""^5.0.0-alpha.4"",
    ""redux"": ""^3.6.0""
  }"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","why not just use browserHistory ? `browserHistory.push(...)` and import it like so `import { browserHistory } from 'react-router';`"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","This is poorly documented but I believe this is the solution you guys are looking for: https://github.com/ReactTraining/react-router/issues/4732#issuecomment-286289384"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","@micahblu Did you manage to find a solution to this problem?"
"43331655","How do I redirect the url after a state update in a react redux application?","10","<p>I have a simple react redux application using react-router-redux. I have 2 routes, one is <code>feed</code> the other <code>add</code>. The add view provides a form. On form submission an <code>ADD_STORY</code> action is dispatched and my reducer properly sets a new state with the added story. Problem is I would like to redirect at that point to the <code>feed</code> view. My current approach below is not working. Any help would be greatly appreciated.</p>

<p>my deps:</p>

<pre><code>""react"": ""^15.4.1"",
""react-dom"": ""^15.4.1"",
""react-redux"": ""^4.4.6"",
""react-router-dom"": ""^4.0.0"",
""react-router-redux"": ""^5.0.0-alpha.4"",
""redux"": ""^3.6.0""
</code></pre>

<p>index.js</p>

<pre><code>//... other imports above
import { HashRouter } from 'react-router-dom'
import createHistory from 'history/createBrowserHistory'
import { Route } from 'react-router'

import { ConnectedRouter, routerReducer, routerMiddleware, push } from 'react-router-redux'

// Create a history of your choosing (we're using a browser history in this case)
const history = createHistory()

// Build the middleware for intercepting and dispatching navigation actions
const middleware = routerMiddleware(history)

// Add the reducer to your store on the `router` key
// Also apply our middleware for navigating
const store = createStore(
  reducers,
  applyMiddleware(middleware)
)

const render = () =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;HashRouter&gt;
            &lt;div className={styles.app}&gt;
          &lt;Header /&gt;
                &lt;div&gt;
                  &lt;Route exact path=""/"" component={Feed} /&gt;
                  &lt;Route exact path=""/add"" component={AddStory} /&gt;
                &lt;/div&gt;
              &lt;Footer /&gt;
            &lt;/div&gt;
          &lt;/HashRouter&gt;
     &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    &lt;/AppContainer&gt;,
    document.getElementById('root')
  );
};
</code></pre>

<p>I then at another part of my code attempt to redirect from a container component</p>

<pre><code>const mapDispatchToProps = (dispatch, ownProps) =&gt; {
  console.log('ownProps', ownProps)

  return {
    submitStory: (story) =&gt; {
      dispatch(createStory({
        title: story.match(/^(.+)\n?/)[1],
        body: story
      }))
    },
    doAction: (action) =&gt; {
      switch(action) {
        case ""STORY_ADDED"":
          console.log('PUSHING');
          ownProps.history.push('/')
          dispatch(push('/'))
          break;
        default: 
          return null
      }
    }
  }
}
</code></pre>

<p>There are several issues I'm encountering. One is if I attempt <code>dispatch(ownProps.history.push('/')</code> I get an error in the middleware about the <code>action</code> being undefined. This is easy to understand since <code>ownProps.history.push('/')</code> returns undefined; though it will redirect; but only once. If I try to use the <code>push</code> that comes from <code>react-router-redux</code> I get a proper <code>action</code> object returned, but no redirect with <code>dispatch(push('/'))</code>.</p>

<p>As you can see I attempted to remedy the situation by calling <code>ownProps.history.push('/')</code> then dispatching with react-router-redux push so I have proper action object but this only works once as well. My component's <code>shouldComponentUpdate</code> method never triggers on the state update; even though a new state is clearly produced; adding a new story in the view I'm attempting to redirect to.</p>

<p>Thanks again.</p>
","@RakeshPai No. It appears that the new react-router-redux is not working correctly? The recommendations above were based on the old react-router-redux repo."
"43726814","How to fix warning caused by Flow Function Types using eslint-plugin-react?","1","<p>I'm getting a warning on the following line on my react component</p>

<pre><code>handleToggle: Function;
</code></pre>

<p>I'm using <a href=""https://github.com/yannickcr/eslint-plugin-react"" rel=""nofollow noreferrer"">eslint-plugin-react</a> and <a href=""https://flow.org/"" rel=""nofollow noreferrer"">Flow</a> and I'm getting a warning ""handleToggle should be placed after constructor"". This is related to rule react/sort-comp. I tried with the following on my .eslintrc.json</p>

<pre><code> ""react/sort-comp"": [1, {
  ""order"": [
    ""static-methods"",
    ""lifecycle"",
    ""everything-else"",
    ""render""
  ],
  ""groups"": {
    ""lifecycle"": [
      ""displayName"",
      ""propTypes"",
      ""contextTypes"",
      ""childContextTypes"",
      ""/^.*: Function$/"",
      ""mixins"",
      ""statics"",
      ""defaultProps"",
      ""state"",
      ""constructor"",
      ""getDefaultProps"",
      ""getInitialState"",
      ""getChildContext"",
      ""componentWillMount"",
      ""componentDidMount"",
      ""componentWillReceiveProps"",
      ""shouldComponentUpdate"",
      ""componentWillUpdate"",
      ""componentDidUpdate"",
      ""componentWillUnmount""
    ]
  }
}]
</code></pre>

<p>But I'm unable to fix the warning. I want the Function Types before constructor the same as the other Type Definition. How can I achieve this?</p>
","It would help if you included a code snippet that illustrates how you want your code to be organized, and exhibits the undesirable warning."
"44441794","Warning: SceneView has a method called shouldComponentUpdate()","0","<p>Hi everyone: I'm using react-native-router-flux (v.3.39.2) in a react-native project, but today its showing this warning:</p>

<p>Warning: SceneView has a method called shouldComponentUpdate().
shouldComponentUpdate should nt be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.</p>

<p>This is my Entry Point:</p>

<p>import React from 'react';
import { AppRegistry, StyleSheet, Platform } from 'react-native';</p>

<p>import {Scene, Router} from 'react-native-router-flux';</p>

<p>import HomeView from './src/components/HomeView'
import ArtistDetailView from './src/components/ArtistDetailView'</p>

<p>export default class platzimusic extends React.Component {
  render() {</p>

<pre><code>const isAndroid = Platform.OS === 'android'
return (
  &lt;Router&gt;
    &lt;Scene key=""root""&gt;
      &lt;Scene key=""home"" component={HomeView} hideNavBar/&gt;
      &lt;Scene key=""artistDetail"" component={ArtistDetailView} hideNavBar={isAndroid}/&gt;
    &lt;/Scene&gt;
  &lt;/Router&gt;
)
</code></pre>

<p>}
}</p>

<p>AppRegistry.registerComponent('platzimusic', () => platzimusic);</p>

<p>and this is my package.json:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>{
  ""name"": ""platzimusic"",
  ""version"": ""0.0.1"",
  ""private"": true,
  ""scripts"": {
    ""start"": ""node node_modules/react-native/local-cli/cli.js start"",
    ""test"": ""jest""
  },
  ""dependencies"": {
    ""react"": ""16.0.0-alpha.12"",
    ""react-native"": ""^0.45.0"",
    ""react-native-router-flux"": ""^3.39.2"",
    ""react-native-vector-icons"": ""^4.2.0""
  },
  ""devDependencies"": {
    ""babel-jest"": ""20.0.3"",
    ""babel-preset-react-native"": ""1.9.2"",
    ""jest"": ""20.0.4"",
    ""react-test-renderer"": ""16.0.0-alpha.12""
  },
  ""jest"": {
    ""preset"": ""react-native""
  }
}</code></pre>
</div>
</div>
</p>

<p>What's wrong?</p>

<p>Thanks</p>
",""
"44599328","React JS - shouldComponentUpdate on list items","0","<p>I cannot find anywhere how to implement this feature that looks so easy to implement.</p>

<p>This feature is mentioned in this dev talk <a href=""https://youtu.be/-DX3vJiqxm4?t=1741"" rel=""nofollow noreferrer"">https://youtu.be/-DX3vJiqxm4?t=1741</a></p>

<p>He mentions that for every object in array he checks upvotes and downvotes to check if list row needs updating, but I just can't implement it.</p>

<p>I have an app in react JS with alot of items, and I am changing only one random item. React of course rerenders the whole list in virtual DOM and diffs the previous and current virtual DOMs of the whole list and it takes long time.</p>

<p>But I would like to avoid rendering the unchanged list items. In my app - if ""todo"" property hasn't changed, the item doesn't need to be updated.
Here is a demo of my app: <a href=""https://jsfiddle.net/2Lk1hr6v/29/"" rel=""nofollow noreferrer"">https://jsfiddle.net/2Lk1hr6v/29/</a></p>

<pre><code>shouldComponentUpdate:function(nextProps, nextState){
return this.props.todo!==nextProps.todo;
},
</code></pre>

<p>I am using this method in the list item component, but the this.props.todo is the same as nextProps.todo so no rows are updated when I change a random item of the first five items.</p>
",""
"44612624","how to use external jquery plugin in react","5","<p>I've built a <strong>React</strong> project using <strong>CRA</strong>. I need to use a plugin that is built using <strong>jquery</strong>. It's a datepicker but the calendar it's using is Bikram Sambat. The link to the datepicker code is <a href=""https://github.com/leapfrogtechnology/Nepali-Date-Picker"" rel=""nofollow noreferrer"">Nepali Date Picker</a> . I've done the following:</p>

<p><strong>public/index.html</strong></p>

<pre><code>&lt;link href=""%PUBLIC_URL%/assets/nepaliDatePicker.min.css"" rel=""stylesheet""&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""%PUBLIC_URL%/assets/nepaliDatePicker.min.js""&gt;&lt;/script&gt;
</code></pre>

<p><strong>NepaliDate Component</strong></p>

<pre><code>import React, { Component } from 'react';

const $ = window.$;

export default class NepaliDate extends Component {
    shouldComponentUpdate() {
        return false;
    }
    componentDidMount() {
        $('.date-picker').nepaliDatePicker({
            dateFormat: '%D, %M %d, %y',
            closeOnDateSelect: true
        });
    }
    showDatePicker = () =&gt; {
        $('.date-picker').nepaliDatePicker();
    };
    render() {
        return (
            &lt;input
                type=""text""
                value=""""
                name=""date""
                className=""date-picker""
                onFocus={this.showDatePicker}
            /&gt;
        );
    }
}
</code></pre>

<p>The datepicker isn't showing up.</p>
","Do you get any errors in the console?"
"44612624","how to use external jquery plugin in react","5","<p>I've built a <strong>React</strong> project using <strong>CRA</strong>. I need to use a plugin that is built using <strong>jquery</strong>. It's a datepicker but the calendar it's using is Bikram Sambat. The link to the datepicker code is <a href=""https://github.com/leapfrogtechnology/Nepali-Date-Picker"" rel=""nofollow noreferrer"">Nepali Date Picker</a> . I've done the following:</p>

<p><strong>public/index.html</strong></p>

<pre><code>&lt;link href=""%PUBLIC_URL%/assets/nepaliDatePicker.min.css"" rel=""stylesheet""&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""%PUBLIC_URL%/assets/nepaliDatePicker.min.js""&gt;&lt;/script&gt;
</code></pre>

<p><strong>NepaliDate Component</strong></p>

<pre><code>import React, { Component } from 'react';

const $ = window.$;

export default class NepaliDate extends Component {
    shouldComponentUpdate() {
        return false;
    }
    componentDidMount() {
        $('.date-picker').nepaliDatePicker({
            dateFormat: '%D, %M %d, %y',
            closeOnDateSelect: true
        });
    }
    showDatePicker = () =&gt; {
        $('.date-picker').nepaliDatePicker();
    };
    render() {
        return (
            &lt;input
                type=""text""
                value=""""
                name=""date""
                className=""date-picker""
                onFocus={this.showDatePicker}
            /&gt;
        );
    }
}
</code></pre>

<p>The datepicker isn't showing up.</p>
","Nothing on the console. But the `input` gets disabled after clicking on it. When I console.log something on the ** showDatePicker** function, it logs for the first time."
"44612624","how to use external jquery plugin in react","5","<p>I've built a <strong>React</strong> project using <strong>CRA</strong>. I need to use a plugin that is built using <strong>jquery</strong>. It's a datepicker but the calendar it's using is Bikram Sambat. The link to the datepicker code is <a href=""https://github.com/leapfrogtechnology/Nepali-Date-Picker"" rel=""nofollow noreferrer"">Nepali Date Picker</a> . I've done the following:</p>

<p><strong>public/index.html</strong></p>

<pre><code>&lt;link href=""%PUBLIC_URL%/assets/nepaliDatePicker.min.css"" rel=""stylesheet""&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""%PUBLIC_URL%/assets/nepaliDatePicker.min.js""&gt;&lt;/script&gt;
</code></pre>

<p><strong>NepaliDate Component</strong></p>

<pre><code>import React, { Component } from 'react';

const $ = window.$;

export default class NepaliDate extends Component {
    shouldComponentUpdate() {
        return false;
    }
    componentDidMount() {
        $('.date-picker').nepaliDatePicker({
            dateFormat: '%D, %M %d, %y',
            closeOnDateSelect: true
        });
    }
    showDatePicker = () =&gt; {
        $('.date-picker').nepaliDatePicker();
    };
    render() {
        return (
            &lt;input
                type=""text""
                value=""""
                name=""date""
                className=""date-picker""
                onFocus={this.showDatePicker}
            /&gt;
        );
    }
}
</code></pre>

<p>The datepicker isn't showing up.</p>
","really? Let me try creating a new project and test it :)."
"44612624","how to use external jquery plugin in react","5","<p>I've built a <strong>React</strong> project using <strong>CRA</strong>. I need to use a plugin that is built using <strong>jquery</strong>. It's a datepicker but the calendar it's using is Bikram Sambat. The link to the datepicker code is <a href=""https://github.com/leapfrogtechnology/Nepali-Date-Picker"" rel=""nofollow noreferrer"">Nepali Date Picker</a> . I've done the following:</p>

<p><strong>public/index.html</strong></p>

<pre><code>&lt;link href=""%PUBLIC_URL%/assets/nepaliDatePicker.min.css"" rel=""stylesheet""&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""%PUBLIC_URL%/assets/nepaliDatePicker.min.js""&gt;&lt;/script&gt;
</code></pre>

<p><strong>NepaliDate Component</strong></p>

<pre><code>import React, { Component } from 'react';

const $ = window.$;

export default class NepaliDate extends Component {
    shouldComponentUpdate() {
        return false;
    }
    componentDidMount() {
        $('.date-picker').nepaliDatePicker({
            dateFormat: '%D, %M %d, %y',
            closeOnDateSelect: true
        });
    }
    showDatePicker = () =&gt; {
        $('.date-picker').nepaliDatePicker();
    };
    render() {
        return (
            &lt;input
                type=""text""
                value=""""
                name=""date""
                className=""date-picker""
                onFocus={this.showDatePicker}
            /&gt;
        );
    }
}
</code></pre>

<p>The datepicker isn't showing up.</p>
","Your code works for me. It shows up the datepicker when I click on it."
"44612624","how to use external jquery plugin in react","5","<p>I've built a <strong>React</strong> project using <strong>CRA</strong>. I need to use a plugin that is built using <strong>jquery</strong>. It's a datepicker but the calendar it's using is Bikram Sambat. The link to the datepicker code is <a href=""https://github.com/leapfrogtechnology/Nepali-Date-Picker"" rel=""nofollow noreferrer"">Nepali Date Picker</a> . I've done the following:</p>

<p><strong>public/index.html</strong></p>

<pre><code>&lt;link href=""%PUBLIC_URL%/assets/nepaliDatePicker.min.css"" rel=""stylesheet""&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""%PUBLIC_URL%/assets/nepaliDatePicker.min.js""&gt;&lt;/script&gt;
</code></pre>

<p><strong>NepaliDate Component</strong></p>

<pre><code>import React, { Component } from 'react';

const $ = window.$;

export default class NepaliDate extends Component {
    shouldComponentUpdate() {
        return false;
    }
    componentDidMount() {
        $('.date-picker').nepaliDatePicker({
            dateFormat: '%D, %M %d, %y',
            closeOnDateSelect: true
        });
    }
    showDatePicker = () =&gt; {
        $('.date-picker').nepaliDatePicker();
    };
    render() {
        return (
            &lt;input
                type=""text""
                value=""""
                name=""date""
                className=""date-picker""
                onFocus={this.showDatePicker}
            /&gt;
        );
    }
}
</code></pre>

<p>The datepicker isn't showing up.</p>
","@TharakaWijebandara it's working on a new project. Might be the `z-index` or `position` issue with my current project style. Thank you so much for pointing that out for me."
"45052656","Should component update in redux/react-router v4","4","<p>I am passing a property from my ""Root"" to my a react-route, ""Home"".</p>

<p>When the ""state"" (state.loggedIn) of my app changes, ""Home"" is updated (the appearance changes as expected) but ""shouldComponentUpdate"" is not called.</p>

<p>I want to use ""shouldComponentUpdate"" to detect if a property (""loggedIn"") changed in the Root, and do some extra work.</p>

<pre><code>// Root.js
import {Provider} from 'react-redux';
import {
  BrowserRouter as Router,
  Redirect,
  Route,
  Switch} from 'react-router-dom';

...

render() {
  const store = this.props.store;
  const loggedIn = this.state.loggedIn;
  const handleLogin = this.handleLogin;
  const handleLogout = this.handleLogout;

  return (
    &lt;Provider store={store}&gt;
      &lt;Router history={browserHistory}&gt;
        &lt;Switch&gt;
          &lt;Route exact path=""/"" component={
            (props) =&gt; (
              &lt;Home
                history={props.history}
                loggedIn={loggedIn}
                handleLogout={handleLogout}/&gt;)} /&gt;
          &lt;Route path=""/login"" component={
            (props) =&gt; (
              &lt;Login
                history={props.history}
                handleLogin={handleLogin}/&gt;)} /&gt;
         &lt;Route path=""/workflow"" component={
            loggedIn ?
            ((props) =&gt; (
              &lt;Workflows
                history={props.history}
                match={props.match}/&gt;)) :
            ((props) =&gt; (
              &lt;Redirect to={
                {
                  pathname: '/',
                  state: {from: props.location},
               }
              }/&gt;)) }/&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/Provider&gt;
);
</code></pre>

<p>}</p>

<pre><code>// Home.js
shouldComponentUpdate(nextProps, nextState) {
  console.log(nextProps);
  console.log(nextState);
  if(nextProps.loggedIn !== nextState.loggedIn) {
    if(nextState.loggedIn) {
      this.socket.connect();
    } else {
      this.socket.disconnect();
    }
  }

  return true;
}
</code></pre>
","@Skribja no luck with that"
"45052656","Should component update in redux/react-router v4","4","<p>I am passing a property from my ""Root"" to my a react-route, ""Home"".</p>

<p>When the ""state"" (state.loggedIn) of my app changes, ""Home"" is updated (the appearance changes as expected) but ""shouldComponentUpdate"" is not called.</p>

<p>I want to use ""shouldComponentUpdate"" to detect if a property (""loggedIn"") changed in the Root, and do some extra work.</p>

<pre><code>// Root.js
import {Provider} from 'react-redux';
import {
  BrowserRouter as Router,
  Redirect,
  Route,
  Switch} from 'react-router-dom';

...

render() {
  const store = this.props.store;
  const loggedIn = this.state.loggedIn;
  const handleLogin = this.handleLogin;
  const handleLogout = this.handleLogout;

  return (
    &lt;Provider store={store}&gt;
      &lt;Router history={browserHistory}&gt;
        &lt;Switch&gt;
          &lt;Route exact path=""/"" component={
            (props) =&gt; (
              &lt;Home
                history={props.history}
                loggedIn={loggedIn}
                handleLogout={handleLogout}/&gt;)} /&gt;
          &lt;Route path=""/login"" component={
            (props) =&gt; (
              &lt;Login
                history={props.history}
                handleLogin={handleLogin}/&gt;)} /&gt;
         &lt;Route path=""/workflow"" component={
            loggedIn ?
            ((props) =&gt; (
              &lt;Workflows
                history={props.history}
                match={props.match}/&gt;)) :
            ((props) =&gt; (
              &lt;Redirect to={
                {
                  pathname: '/',
                  state: {from: props.location},
               }
              }/&gt;)) }/&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/Provider&gt;
);
</code></pre>

<p>}</p>

<pre><code>// Home.js
shouldComponentUpdate(nextProps, nextState) {
  console.log(nextProps);
  console.log(nextState);
  if(nextProps.loggedIn !== nextState.loggedIn) {
    if(nextState.loggedIn) {
      this.socket.connect();
    } else {
      this.socket.disconnect();
    }
  }

  return true;
}
</code></pre>
","@MattWatson watching the constructor or componentWillMount works - Please submit an answer for me to accept it!"
"45052656","Should component update in redux/react-router v4","4","<p>I am passing a property from my ""Root"" to my a react-route, ""Home"".</p>

<p>When the ""state"" (state.loggedIn) of my app changes, ""Home"" is updated (the appearance changes as expected) but ""shouldComponentUpdate"" is not called.</p>

<p>I want to use ""shouldComponentUpdate"" to detect if a property (""loggedIn"") changed in the Root, and do some extra work.</p>

<pre><code>// Root.js
import {Provider} from 'react-redux';
import {
  BrowserRouter as Router,
  Redirect,
  Route,
  Switch} from 'react-router-dom';

...

render() {
  const store = this.props.store;
  const loggedIn = this.state.loggedIn;
  const handleLogin = this.handleLogin;
  const handleLogout = this.handleLogout;

  return (
    &lt;Provider store={store}&gt;
      &lt;Router history={browserHistory}&gt;
        &lt;Switch&gt;
          &lt;Route exact path=""/"" component={
            (props) =&gt; (
              &lt;Home
                history={props.history}
                loggedIn={loggedIn}
                handleLogout={handleLogout}/&gt;)} /&gt;
          &lt;Route path=""/login"" component={
            (props) =&gt; (
              &lt;Login
                history={props.history}
                handleLogin={handleLogin}/&gt;)} /&gt;
         &lt;Route path=""/workflow"" component={
            loggedIn ?
            ((props) =&gt; (
              &lt;Workflows
                history={props.history}
                match={props.match}/&gt;)) :
            ((props) =&gt; (
              &lt;Redirect to={
                {
                  pathname: '/',
                  state: {from: props.location},
               }
              }/&gt;)) }/&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/Provider&gt;
);
</code></pre>

<p>}</p>

<pre><code>// Home.js
shouldComponentUpdate(nextProps, nextState) {
  console.log(nextProps);
  console.log(nextState);
  if(nextProps.loggedIn !== nextState.loggedIn) {
    if(nextState.loggedIn) {
      this.socket.connect();
    } else {
      this.socket.disconnect();
    }
  }

  return true;
}
</code></pre>
","Is it possible the component is being remounted every time rather than just re-rendered?  That would possibly explain why the component is redrawn, but that lifecycle method isn't called.  If you stick a log statement in `componentWillMount()` you'll be able to see if it's being called multiple times."
"45052656","Should component update in redux/react-router v4","4","<p>I am passing a property from my ""Root"" to my a react-route, ""Home"".</p>

<p>When the ""state"" (state.loggedIn) of my app changes, ""Home"" is updated (the appearance changes as expected) but ""shouldComponentUpdate"" is not called.</p>

<p>I want to use ""shouldComponentUpdate"" to detect if a property (""loggedIn"") changed in the Root, and do some extra work.</p>

<pre><code>// Root.js
import {Provider} from 'react-redux';
import {
  BrowserRouter as Router,
  Redirect,
  Route,
  Switch} from 'react-router-dom';

...

render() {
  const store = this.props.store;
  const loggedIn = this.state.loggedIn;
  const handleLogin = this.handleLogin;
  const handleLogout = this.handleLogout;

  return (
    &lt;Provider store={store}&gt;
      &lt;Router history={browserHistory}&gt;
        &lt;Switch&gt;
          &lt;Route exact path=""/"" component={
            (props) =&gt; (
              &lt;Home
                history={props.history}
                loggedIn={loggedIn}
                handleLogout={handleLogout}/&gt;)} /&gt;
          &lt;Route path=""/login"" component={
            (props) =&gt; (
              &lt;Login
                history={props.history}
                handleLogin={handleLogin}/&gt;)} /&gt;
         &lt;Route path=""/workflow"" component={
            loggedIn ?
            ((props) =&gt; (
              &lt;Workflows
                history={props.history}
                match={props.match}/&gt;)) :
            ((props) =&gt; (
              &lt;Redirect to={
                {
                  pathname: '/',
                  state: {from: props.location},
               }
              }/&gt;)) }/&gt;
        &lt;/Switch&gt;
      &lt;/Router&gt;
    &lt;/Provider&gt;
);
</code></pre>

<p>}</p>

<pre><code>// Home.js
shouldComponentUpdate(nextProps, nextState) {
  console.log(nextProps);
  console.log(nextState);
  if(nextProps.loggedIn !== nextState.loggedIn) {
    if(nextState.loggedIn) {
      this.socket.connect();
    } else {
      this.socket.disconnect();
    }
  }

  return true;
}
</code></pre>
","Try changing `component` to `render`"
"45516188","Avoid re-rendering not possible - but docs say should be no need of shouldComponentUpdate","0","<p>The redux docs state that when using redux with react, so using the <code>connect</code> from the <code>react-redux</code> package. That there should be no need for <code>shouldComponentUpdate</code> - <a href=""http://redux.js.org/docs/basics/UsageWithReact.html#implementing-container-components"" rel=""nofollow noreferrer"">http://redux.js.org/docs/basics/UsageWithReact.html#implementing-container-components</a></p>

<blockquote>
  <p>Redux library's connect() function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the React performance suggestion of implementing shouldComponentUpdate yourself.)</p>
</blockquote>

<p>However my component is unnecesarily updated because I am returing a new array every time even though the contents of the array is the same. Here is my code:</p>

<pre><code>const AssetManagerSmart = connect(
    function(state) {
        const { assets } = state;
        return {
            assetIds: assets.map( asset =&gt; asset.id )
        }
    }
)
</code></pre>

<p>See this <code>assetIds</code>, it is a map of an array from the redux state. This is causing my component to re-render. To simplify the code above, we can imagine <code>assetIds</code> is assigned to a new shallowly equal array everytime, like this:</p>

<pre><code>const AssetManagerSmart = connect(
    function(state) {
        const { assets } = state;
        return {
            assetIds: ['hi']
        }
    }
)
</code></pre>

<p>How come the docs say I should not need <code>shouldComponentUpdate</code> when I am encountering the above? The above I see everyone doing, even in the ""usage with react"" section on official redux docs.</p>
",""
"45657321","TypeError: Cannot read property 'length' of null in react component","2","<p>Okay so I've gotten pretty far in creating the React Component for ChartJS, however when testing I get the following error:</p>

<pre><code>FAIL  lib\chart\chart.test.tsx
  ● renders without crashing

    TypeError: Cannot read property 'length' of null

      at Object.acquireContext (node_modules/chart.js/src/platforms/platform.dom.js:189:19)
      at Chart.construct (node_modules/chart.js/src/core/core.controller.js:72:27)
      at new Chart (node_modules/chart.js/src/core/core.js:7:8)
      at Chart.Object.&lt;anonymous&gt;.Chart.renderChart (lib/chart/chart.tsx:233:26)
      at Chart.Object.&lt;anonymous&gt;.Chart.componentDidMount (lib/chart/chart.tsx:42:10)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:264:25
      at measureLifeCyclePerf (node_modules/react-dom/lib/ReactCompositeComponent.js:75:12)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:263:11
      at CallbackQueue.notifyAll (node_modules/react-dom/lib/CallbackQueue.js:76:22)
      at ReactReconcileTransaction.close (node_modules/react-dom/lib/ReactReconcileTransaction.js:80:26)
      at ReactReconcileTransaction.closeAll (node_modules/react-dom/lib/Transaction.js:209:25)
      at ReactReconcileTransaction.perform (node_modules/react-dom/lib/Transaction.js:156:16)
      at batchedMountComponentIntoNode (node_modules/react-dom/lib/ReactMount.js:126:15)
      at ReactDefaultBatchingStrategyTransaction.perform (node_modules/react-dom/lib/Transaction.js:143:20)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:26)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:27)
      at Object._renderNewRootComponent (node_modules/react-dom/lib/ReactMount.js:319:18)
      at Object._renderSubtreeIntoContainer (node_modules/react-dom/lib/ReactMount.js:401:32)
      at Object.render (node_modules/react-dom/lib/ReactMount.js:422:23)
      at Object.&lt;anonymous&gt; (lib/chart/chart.test.tsx:7:12)
          at Promise (&lt;anonymous&gt;)
      at Promise.resolve.then.el (node_modules/p-map/index.js:42:16)
          at &lt;anonymous&gt;
      at process._tickCallback (internal/process/next_tick.js:169:7)

  × renders without crashing (275ms)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.314s, estimated 3s
Ran all test suites related to changed files.
</code></pre>

<p>However, I've spent a long time looking over the code and haven't been able to figure out why it refuses to work properly. The error starts at the <code>renderChart()</code> function at creating a new chart instance. My first guess would be the for some reason it's not registering the canvas element despite being called by its id.  But when the content of renderChart is moved into the render() function it still gives the same error. Here's the code being tested:</p>

<pre><code>import * as React from 'react'
import * as ClassNames from 'classnames'
import * as ChartJS from 'chart.js'
const IsEqual = require('lodash.isequal')
const Find = require('lodash.find')
const subChart = require('chart.js')

interface IChartProps {
  /** The user-defined classes */
  readonly className?: string
  readonly width?: number
  readonly height?: number
  readonly reRender?: boolean

  readonly type: ChartJS.ChartType
  readonly data: ChartJS.ChartData
  readonly options: ChartJS.ChartOptions
  readonly getDatasetAtEvent?: Function
  readonly getElementAtEvent?: Function
  readonly getElementsAtEvent?: Function
  readonly onElementsClick?: Function
  readonly datasetKeyProvider?: Function
}

interface IChartState {
  /** Add your states here */
}

export class Chart extends React.Component&lt;IChartProps, IChartState&gt; {
  // tslint:disable-next-line
  private chartInstance: any
  private shadowData: {}
  constructor(props: IChartProps) {
    super(props)
  }

  public componentWillMount() {
    // this.chartInstance = undefined
  }

  public componentDidMount() {
    this.renderChart()
  }

  // public componentWillReceiveProps(nextProps: IChartProps) {}

  public shouldComponentUpdate(nextProps: IChartProps, nextState: IChartState) {
    const props = this.props
    if (nextProps.reRender === true) {
      return true
    }

    if (props.height !== nextProps.height || props.width !== nextProps.width) {
      return true
    }

    if (props.type !== nextProps.type) {
      return true
    }

    if (!IsEqual(props.options, nextProps.options)) {
      return true
    }

    const nextData = this.transformDataProp(nextProps)

    if (!IsEqual(this.shadowData, nextData)) {
      return true
    }

    return false
  }

  // public componentWillUpdate(nextProps: IChartProps, nextState: IChartState) {}

  public componentDidUpdate(prevProps: IChartProps, prevState: IChartState) {
    if (this.props.reRender) {
      this.chartInstance.destroy()
      this.renderChart()
      return
    }
    this.updateChart()
  }

  public transformDataProp(props: IChartProps) {
    const data = props.data
    if (typeof data === 'function') {
      const node = document.getElementById('bar-chart') as HTMLCanvasElement
      return data(node)
    } else {
      return data
    }
  }

  public memoizeDataProps(props?: IChartProps) {
    if (!this.props.data) {
      return
    }
    const data = this.transformDataProp(this.props)

    this.shadowData = {
      ...data,
      datasets:
        data.datasets &amp;&amp;
        data.datasets.map((set: string[]) =&gt; {
          return { ...set }
        })
    }
    return data
  }

  public updateChart() {
    const options = this.props.options

    const data = this.memoizeDataProps(this.props)

    if (!this.chartInstance) {
      return
    }

    if (options) {
      this.chartInstance.options = subChart.helpers.configMerge(
        this.chartInstance.options,
        options
      )
    }

    let currentDatasets =
      (this.chartInstance.config.data &amp;&amp;
        this.chartInstance.config.data.datasets) ||
      []
    const nextDatasets = data.datasets || []

    const currentDatasetKeys = currentDatasets.map(
      this.props.datasetKeyProvider
    )
    const nextDatasetKeys = nextDatasets.map(this.props.datasetKeyProvider)
    const newDatasets = nextDatasets.filter(
      (d: object) =&gt;
        currentDatasetKeys.indexOf(this.props.datasetKeyProvider(d)) === -1
    )

    for (let idx = currentDatasets.length - 1; idx &gt;= 0; idx -= 1) {
      const currentDatasetKey = this.props.datasetKeyProvider(
        currentDatasets[idx]
      )
      if (nextDatasetKeys.indexOf(currentDatasetKey) === -1) {
        // deleted series
        currentDatasets.splice(idx, 1)
      } else {
        const retainedDataset = Find(
          nextDatasets,
          (d: object) =&gt; this.props.datasetKeyProvider(d) === currentDatasetKey
        )
        if (retainedDataset) {
          // update it in place if it is a retained dataset
          currentDatasets[idx].data.splice(retainedDataset.data.length)
          retainedDataset.data.forEach((point: number, pid: number) =&gt; {
            currentDatasets[idx].data[pid] = retainedDataset.data[pid]
          })
          // const { data, ...otherProps } = retainedDataset
          currentDatasets[idx] = {
            data: currentDatasets[idx].data,
            ...currentDatasets[idx],
            ...retainedDataset.otherProps
          }
        }
      }
    }
    // finally add any new series
    newDatasets.forEach((d: object) =&gt; currentDatasets.push(d))
    const { datasets, ...rest } = data

    this.chartInstance.config.data = {
      ...this.chartInstance.config.data,
      ...rest
    }

    this.chartInstance.update()
  }

  public componentWillUnmount() {
    this.chartInstance.destroy()
  }

  public onClickEvent = (event: React.MouseEvent&lt;HTMLCanvasElement&gt;) =&gt; {
    // this.props.getDatasetAtEvent &amp;&amp;
    this.props.getDatasetAtEvent(
      this.chartInstance.getDatasetAtEvent(event),
      event
    )

    // this.props.getElementAtEvent &amp;&amp;
    this.props.getElementAtEvent(
      this.chartInstance.getElementAtEvent(event),
      event
    )

    // this.props.getElementsAtEvent &amp;&amp;
    this.props.getElementsAtEvent(
      this.chartInstance.getElementsAtEvent(event),
      event
    )

    // this.props.onElementsClick &amp;&amp;
    this.props.onElementsClick(
      this.chartInstance.getElementsAtEvent(event),
      event
    )
  }

  public render() {
    const className = ClassNames('chart', this.props.className)

    // bar.update()
    return (
      &lt;div className={className}&gt;
        &lt;canvas
          id=""chart-instance""
          width={this.props.width ? this.props.width : '400'}
          height={this.props.height ? this.props.height : '400'}
          onClick={this.onClickEvent}
        /&gt;
      &lt;/div&gt;
    )
  }

  public renderChart() {
    const { options, type, data } = this.props
    const node = document.getElementById('chart-instance') as HTMLCanvasElement
    // const data = this.memoizeDataProps()

    this.chartInstance = new ChartJS(node, {
      type,
      data,
      options
    })
  }
}
</code></pre>

<p>can someone help me figure out why this won't work properly?</p>
","Since you haven't posted test itself, I suppose `length` is a property of some element. Try like this:
`const wrapper = mount(<YourElement />);
wrapper.find('ElementYourWantLengthOf').props().length`

You might also be calling `length` on an array of nodes returned by `find()`. Then, obviously, `find()` finds nothing which might be a consequence of a component not being mounted properly.

Anyways, post your test code, then we'll see."
"45657321","TypeError: Cannot read property 'length' of null in react component","2","<p>Okay so I've gotten pretty far in creating the React Component for ChartJS, however when testing I get the following error:</p>

<pre><code>FAIL  lib\chart\chart.test.tsx
  ● renders without crashing

    TypeError: Cannot read property 'length' of null

      at Object.acquireContext (node_modules/chart.js/src/platforms/platform.dom.js:189:19)
      at Chart.construct (node_modules/chart.js/src/core/core.controller.js:72:27)
      at new Chart (node_modules/chart.js/src/core/core.js:7:8)
      at Chart.Object.&lt;anonymous&gt;.Chart.renderChart (lib/chart/chart.tsx:233:26)
      at Chart.Object.&lt;anonymous&gt;.Chart.componentDidMount (lib/chart/chart.tsx:42:10)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:264:25
      at measureLifeCyclePerf (node_modules/react-dom/lib/ReactCompositeComponent.js:75:12)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:263:11
      at CallbackQueue.notifyAll (node_modules/react-dom/lib/CallbackQueue.js:76:22)
      at ReactReconcileTransaction.close (node_modules/react-dom/lib/ReactReconcileTransaction.js:80:26)
      at ReactReconcileTransaction.closeAll (node_modules/react-dom/lib/Transaction.js:209:25)
      at ReactReconcileTransaction.perform (node_modules/react-dom/lib/Transaction.js:156:16)
      at batchedMountComponentIntoNode (node_modules/react-dom/lib/ReactMount.js:126:15)
      at ReactDefaultBatchingStrategyTransaction.perform (node_modules/react-dom/lib/Transaction.js:143:20)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:26)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:27)
      at Object._renderNewRootComponent (node_modules/react-dom/lib/ReactMount.js:319:18)
      at Object._renderSubtreeIntoContainer (node_modules/react-dom/lib/ReactMount.js:401:32)
      at Object.render (node_modules/react-dom/lib/ReactMount.js:422:23)
      at Object.&lt;anonymous&gt; (lib/chart/chart.test.tsx:7:12)
          at Promise (&lt;anonymous&gt;)
      at Promise.resolve.then.el (node_modules/p-map/index.js:42:16)
          at &lt;anonymous&gt;
      at process._tickCallback (internal/process/next_tick.js:169:7)

  × renders without crashing (275ms)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.314s, estimated 3s
Ran all test suites related to changed files.
</code></pre>

<p>However, I've spent a long time looking over the code and haven't been able to figure out why it refuses to work properly. The error starts at the <code>renderChart()</code> function at creating a new chart instance. My first guess would be the for some reason it's not registering the canvas element despite being called by its id.  But when the content of renderChart is moved into the render() function it still gives the same error. Here's the code being tested:</p>

<pre><code>import * as React from 'react'
import * as ClassNames from 'classnames'
import * as ChartJS from 'chart.js'
const IsEqual = require('lodash.isequal')
const Find = require('lodash.find')
const subChart = require('chart.js')

interface IChartProps {
  /** The user-defined classes */
  readonly className?: string
  readonly width?: number
  readonly height?: number
  readonly reRender?: boolean

  readonly type: ChartJS.ChartType
  readonly data: ChartJS.ChartData
  readonly options: ChartJS.ChartOptions
  readonly getDatasetAtEvent?: Function
  readonly getElementAtEvent?: Function
  readonly getElementsAtEvent?: Function
  readonly onElementsClick?: Function
  readonly datasetKeyProvider?: Function
}

interface IChartState {
  /** Add your states here */
}

export class Chart extends React.Component&lt;IChartProps, IChartState&gt; {
  // tslint:disable-next-line
  private chartInstance: any
  private shadowData: {}
  constructor(props: IChartProps) {
    super(props)
  }

  public componentWillMount() {
    // this.chartInstance = undefined
  }

  public componentDidMount() {
    this.renderChart()
  }

  // public componentWillReceiveProps(nextProps: IChartProps) {}

  public shouldComponentUpdate(nextProps: IChartProps, nextState: IChartState) {
    const props = this.props
    if (nextProps.reRender === true) {
      return true
    }

    if (props.height !== nextProps.height || props.width !== nextProps.width) {
      return true
    }

    if (props.type !== nextProps.type) {
      return true
    }

    if (!IsEqual(props.options, nextProps.options)) {
      return true
    }

    const nextData = this.transformDataProp(nextProps)

    if (!IsEqual(this.shadowData, nextData)) {
      return true
    }

    return false
  }

  // public componentWillUpdate(nextProps: IChartProps, nextState: IChartState) {}

  public componentDidUpdate(prevProps: IChartProps, prevState: IChartState) {
    if (this.props.reRender) {
      this.chartInstance.destroy()
      this.renderChart()
      return
    }
    this.updateChart()
  }

  public transformDataProp(props: IChartProps) {
    const data = props.data
    if (typeof data === 'function') {
      const node = document.getElementById('bar-chart') as HTMLCanvasElement
      return data(node)
    } else {
      return data
    }
  }

  public memoizeDataProps(props?: IChartProps) {
    if (!this.props.data) {
      return
    }
    const data = this.transformDataProp(this.props)

    this.shadowData = {
      ...data,
      datasets:
        data.datasets &amp;&amp;
        data.datasets.map((set: string[]) =&gt; {
          return { ...set }
        })
    }
    return data
  }

  public updateChart() {
    const options = this.props.options

    const data = this.memoizeDataProps(this.props)

    if (!this.chartInstance) {
      return
    }

    if (options) {
      this.chartInstance.options = subChart.helpers.configMerge(
        this.chartInstance.options,
        options
      )
    }

    let currentDatasets =
      (this.chartInstance.config.data &amp;&amp;
        this.chartInstance.config.data.datasets) ||
      []
    const nextDatasets = data.datasets || []

    const currentDatasetKeys = currentDatasets.map(
      this.props.datasetKeyProvider
    )
    const nextDatasetKeys = nextDatasets.map(this.props.datasetKeyProvider)
    const newDatasets = nextDatasets.filter(
      (d: object) =&gt;
        currentDatasetKeys.indexOf(this.props.datasetKeyProvider(d)) === -1
    )

    for (let idx = currentDatasets.length - 1; idx &gt;= 0; idx -= 1) {
      const currentDatasetKey = this.props.datasetKeyProvider(
        currentDatasets[idx]
      )
      if (nextDatasetKeys.indexOf(currentDatasetKey) === -1) {
        // deleted series
        currentDatasets.splice(idx, 1)
      } else {
        const retainedDataset = Find(
          nextDatasets,
          (d: object) =&gt; this.props.datasetKeyProvider(d) === currentDatasetKey
        )
        if (retainedDataset) {
          // update it in place if it is a retained dataset
          currentDatasets[idx].data.splice(retainedDataset.data.length)
          retainedDataset.data.forEach((point: number, pid: number) =&gt; {
            currentDatasets[idx].data[pid] = retainedDataset.data[pid]
          })
          // const { data, ...otherProps } = retainedDataset
          currentDatasets[idx] = {
            data: currentDatasets[idx].data,
            ...currentDatasets[idx],
            ...retainedDataset.otherProps
          }
        }
      }
    }
    // finally add any new series
    newDatasets.forEach((d: object) =&gt; currentDatasets.push(d))
    const { datasets, ...rest } = data

    this.chartInstance.config.data = {
      ...this.chartInstance.config.data,
      ...rest
    }

    this.chartInstance.update()
  }

  public componentWillUnmount() {
    this.chartInstance.destroy()
  }

  public onClickEvent = (event: React.MouseEvent&lt;HTMLCanvasElement&gt;) =&gt; {
    // this.props.getDatasetAtEvent &amp;&amp;
    this.props.getDatasetAtEvent(
      this.chartInstance.getDatasetAtEvent(event),
      event
    )

    // this.props.getElementAtEvent &amp;&amp;
    this.props.getElementAtEvent(
      this.chartInstance.getElementAtEvent(event),
      event
    )

    // this.props.getElementsAtEvent &amp;&amp;
    this.props.getElementsAtEvent(
      this.chartInstance.getElementsAtEvent(event),
      event
    )

    // this.props.onElementsClick &amp;&amp;
    this.props.onElementsClick(
      this.chartInstance.getElementsAtEvent(event),
      event
    )
  }

  public render() {
    const className = ClassNames('chart', this.props.className)

    // bar.update()
    return (
      &lt;div className={className}&gt;
        &lt;canvas
          id=""chart-instance""
          width={this.props.width ? this.props.width : '400'}
          height={this.props.height ? this.props.height : '400'}
          onClick={this.onClickEvent}
        /&gt;
      &lt;/div&gt;
    )
  }

  public renderChart() {
    const { options, type, data } = this.props
    const node = document.getElementById('chart-instance') as HTMLCanvasElement
    // const data = this.memoizeDataProps()

    this.chartInstance = new ChartJS(node, {
      type,
      data,
      options
    })
  }
}
</code></pre>

<p>can someone help me figure out why this won't work properly?</p>
","the error is telling you what the problem is. Whatever you're calling ```length``` on doesn't exist. Can you post the test that is failing? Does the component render even though that test is failing?"
"46197241","React shouldComponentUpdate() = false not stopping re-render","1","<p>Basically, I've got this pretty simple react component. What it does is, is wrap around 'react-intercom' and only render it if there is a change in the state. To simplify the question, I've hardwired the <code>shouldCompoenentUpdate()</code> method to always return false.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    import React from 'react';
    import Intercom from 'react-intercom';
    
    class IntercomWrapper extends React.Component {
        shouldComponentUpdate(nextProps, nextState) {
            // console.log(!!nextProps.user &amp;&amp; nextProps.user.userId !== this.props.user.userId);
            // return !!nextProps.user &amp;&amp; nextProps.user.userId !== this.props.user.userId;
            return false;
        }
    
        render() {
            console.log('rendering');
            return &lt;Intercom {...this.props} /&gt;;
        }
    };
    
    export default IntercomWrapper;</code></pre>
</div>
</div>
</p>

<p>What happens is that it always rerenders, which should not happen.</p>

<p>Anyone has any idea why would that happen?</p>
","add console.log to `componentDidMount`, `componentWillUpdate` and `componentDidUpdate`see which one of them firing. If the component is unmounting and remounting shouldComponentUpdate won't work"
"46402938","Re-render only set of UI elements of the screen in react-native","4","<p>I'm writing a reat-native app which contains a set of text boxes, section list and a popup dialog (react-native-popup). In every 15 second I'm fetching the data from the remote server using a timer and updates data in the section list. Due to the state change the app re-renders the whole screen. Is there anyway that I can render only the section list and keep other UI elements as it is (stop popup being dismissed by the render) without re-rendering them in every 15 seconds?</p>
","Why don't you move your forms (component that you want to re-render) into separate component and fetch data their? You can also use [shouldComponentUpdate](https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate) to restrict your component to re-render. Use [Redux](http://redux.js.org/) for state management."
"46563235","Are react stateless components equal to ReacDOM.PureComponents","1","<p>As per documentation(<a href=""https://reactjs.org/docs/react-api.html#react.purecomponent"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-api.html#react.purecomponent</a>)</p>

<blockquote>
  <p>""React.PureComponent is exactly like React.Component but implements
  shouldComponentUpdate() with a shallow prop and state comparison.""</p>
</blockquote>

<p>So if I define something like following,</p>

<pre><code>const MyView = () =&gt; {
  return (
    &lt;div&gt;Hello Stateless Component&lt;/div&gt;
  )
};
</code></pre>

<p>is it a React.PureComponent? Does it do a shallow prop and state comparison?</p>
","I don't think it is. A component that extends `React.PureComponent` is considered a pure component."
"46942476","avoid constant re-render from ""input"" or ""textarea"" in react js","0","<p>Currently in react js, when I want to bind a text area or an input with a ""state"", I will need to set the onChange method and setState() everytime user type in a single letter</p>

<p>I heard if you setState react js refresh and re-render everything in this component</p>

<p>Is there any more efficient way to do so? using ""shouldComponentUpdate"" will be improper in this case since if I don't make ""state"" update, all user input will be stuck..</p>
",""
"47389495","React shouldComponentUpdate() does not prevent re-render","0","<p>I'm using the <code>ThreeDisplay</code> React component shown below for holding a WebGL/Three.js canvas (the canvas itself is not part of the component, it gets appended to the container <code>div</code> by an initialization script).</p>

<p>I want the component only to update after every <code>RUN</code> and <code>UPDATE</code> action. Those actions get dispatched by the parent component of <code>ThreeDisplay</code>.</p>

<p>Now for some reason, the component also gets updated/re-rendered if the last action was <code>FADE_COLOR</code> or <code>SWITCH_COLOR</code>. Those actions get dispatched by ThreeDisplay, they are triggered by mouse events, as shown in the code below.</p>

<p>I'm trying to use <code>shouldComponentUpdate()</code> to update only after the aforementioned actions. But for some reason, this does not prevent the component to re-render on every mouse event.</p>

<p>The full code of my application/prototype can be found in <a href=""https://github.com/lysigk/react-redux-three"" rel=""nofollow noreferrer"">this repository</a></p>

<pre><code>    import React from 'react'
    import {connect} from 'react-redux'

    import {fadeColor, switchColor} from '../actions'

    class ThreeDisplay extends React.Component {
        shouldComponentUpdate(nextProps) {
            const shouldUpdate =
                nextProps.lastAction === 'RUN' || nextProps.lastAction === 'UPDATE'

            if (!shouldUpdate) {
                console.log('ThreeDisplay will not update on ' + nextProps.lastAction)
            }

            return shouldUpdate
        }

        componentWillUpdate() {
            // This gets logged even if lastAction ist not 'RUN' or 'UPDATE'
            console.log('ThreeDisplay will update on ' + this.props.lastAction)
        }

        render() {
            return (
                &lt;div
                    id=""container""
                    className={
                        this.props.running
                            ? 'three-display'
                            : 'three-display hidden'
                    }
                    onClick={this.props.switchColor}
                    onMouseMove={this.props.fadeColor}
                /&gt;
            )
        }
    }

    const mapStateToProps = state =&gt; {
        return {
            running: state.running,
            lastAction: state.lastAction
        }
    }

    const mapDispatchTopProps = dispatch =&gt; {
        return {
            fadeColor: e =&gt; dispatch(fadeColor(e)),
            switchColor: () =&gt; dispatch(switchColor())
        }
    }

    export default connect(mapStateToProps, mapDispatchTopProps)(ThreeDisplay)
</code></pre>
",""
"47415413","In react, if I set shouldComponentUpdate to false, will any state I send to children be updated?","0","<p>I have the following scenario: </p>

<p>1) There is a parent component ""ModuleListContainer"".</p>

<p>2) A module (in the module list, also a child component, but not interesting in this context) gets selected when hovering over it a module item in the list.</p>

<p>3) When hovering over a module, a menu should be shown in the corner of the module.</p>

<p>4) The whole parent component should NOT be updated when a module is selected, since it can be quite a long list of modules, that is why I set <code>shouldComponentUpdate = false</code> when updating which module should be selected.</p>

<p>5) The menu is loaded when the parent component loads, and only its position is updated when hovering over a module.</p>

<p>This is the parent component (simplified)...</p>

<pre><code>class ModuleListContainer extends Component {

    constructor(props) {
        super(props);
        this.state = {
            selectingModule: false,
            currentlySelectedModule: nextProps.currentModule
        }
    }

    shouldComponentUpdate(nextProps, nextState) {
        if (nextState.selectingModule === true) {
            this.setState({
                selectingModule: false,
                currentlySelectedModule: null
            })
            return false;
        }
        return true;
    }

    mouseEnterModule = (e, moduleItem) =&gt; {
        const menu = document.getElementById('StickyMenu');
        const menuPosition = calculateModuleMenuPosition(e.currentTarget);

        if (moduleItem.ModuleId !== this.props.currentModuleId) {
            this.props.actions.selectModule(moduleItem);
            this.setState({
               selectingModule: true
            });
        }

        menu.style.top = menuPosition.topPos + 'px';
        menu.style.left = menuPosition.leftPos + 'px';
    }

    render() {
        return (
            &lt;div&gt;
                &lt;section id=""module-listing""&gt;
                    {/* ... list of mapped modules with mouseEnterModule event */}
                &lt;/section&gt;

                &lt;ModuleMenu {... this.props} currentlySelectedModule={this.state.currentlySelectedModule} /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>This is the menu component (simplified)...</p>

<pre><code>class ModuleMenu extends Component {

    constructor(props) {
        super(props);
        this.state = {
            currentModule: this.props.currentlySelectedModule
        };
    }

    clickMenuButton = () =&gt; {
        console.log('CURRENT MODULE', this.state.currentModule);
    }

    render() {
        return (
            &lt;div id=""StickyMenu""&gt;
                &lt;button type=""button"" onClick={this.clickMenuButton}&gt;
                    &lt;span className=""fa fa-pencil""&gt;&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>When, in my menu component, I try to <code>console.log</code> the current module from the state, I keep getting <code>null</code>.</p>

<p>My question is if this is because...</p>

<ol>
<li><p>I have set the shouldComponentUpdate to false and the menu's state does not get updated?</p></li>
<li><p>Or could it be because I do not re-render the whole component?</p></li>
<li><p>Or is it because I load the menu together with the parent component
    and it does not get re-rendered when a module is selected?</p></li>
<li><p>Or is it possibly a combination of some of the above?</p></li>
</ol>

<p>The react docs (<a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a>) says:</p>

<blockquote>
  <p>Returning false does not prevent child components from re-rendering
  when their state changes.</p>
</blockquote>

<p>Therefore, I am hoping that it is none of the above since I really don't want to have to re-render the entire component when selecting a module.</p>
",""
"47521544","Making react children NOT to refresh when parents state changes","3","<p>So here is my problem. I have an root component that contains navigation and Switch with every component in my page. Navigation is sliding in and out from the left and the way I'm doing this, I'm changing the state in root component, passing prop to  and deciding whether or not, should I add class to my nav. The problem is that every component in my app is re-rendering on opening/closing nav. Here is my root component:</p>

<pre><code>class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      navOpen: false
    }
  }
  toggleNav = () =&gt; {
    this.setState({
      navOpen: !this.state.navOpen
    })
  }
  closeNav = (e) =&gt; {
    if (this.state.navOpen) {
      this.setState({navOpen: false})
    }
  }

  render() {
    return (
      &lt;main&gt;
        &lt;Header/&gt;
        &lt;Hamburger navOpen={this.state.navOpen} toggleNav={this.toggleNav}/&gt;
        &lt;Navigation navOpen={this.state.navOpen} toggleNav={this.toggleNav}/&gt;
        &lt;section className=""container-fluid content"" onClick={this.closeNav}&gt;
          &lt;Switch&gt;
            &lt;Route path=""/add-recipe/:groupId?"" component={NewRecipe}/&gt;
            &lt;Route path=""/recipes/:page?/:sortType?/:size?"" component={RecipeList}/&gt;
            &lt;Route path=""/recipe/:id"" component={Recipe}/&gt;
            &lt;Route path=""/sign/"" component={SignForm}/&gt;
            &lt;Route path=""/user/:id"" component={User}/&gt;
          &lt;/Switch&gt;
        &lt;/section&gt;
      &lt;/main&gt;

    );
  }
  componentDidMount() {
    this.props.userActions.getUser(this.props.url);
  }
}

function mapStateToProps(state) {
  return {url: state.url.url, user: state.user.loggedUser}
}

function mapDispatchToProps(dispatch) {
  return {
    userActions: bindActionCreators(userActions, dispatch)
  }
}

export default withRouter(connect(mapStateToProps, mapDispatchToProps)(App));
</code></pre>

<p>Navigation is the only component ( besides hamburger) that cares about his parents state so I have no idea why everything is re-rendering. Does anyone have some ideas?</p>

<p>EDIT:</p>

<p>I've added sCU to my nested components like that:</p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
    // console.log(this.props)
    // console.log(""next"")
    // console.log(nextProps)
    if (this.props == nextProps) {
      return false
    }
    return true
  }
</code></pre>

<p>But it didn't change anything. When I open the navigation props for routes remain the same but they still rerender. I tried to move ""navOpen"" state to navigation and open it from root component via ""ref"" but every time I call its method I get ""Cannot read property 'toggleNav' of null""</p>
","You may want to check out the shouldComponentUpdate lifecycle method: https://reactjs.org/docs/react-component.html#shouldcomponentupdate"
"47909691","react-native-maps: How do I add markers without re-rendering the entire map?","3","<p>I'm building a map that displays markers to show the location of nearby merchants. I'm passing a 'data' array as props to the map. I've set an interval such that every two seconds, I fetch more merchants from my API, and the 'data' array grows.</p>

<p>I'm fetching the data inside componentWillReceiveProps. fetchData() appends more merchants to the data array.</p>

<pre><code>componentWillReceiveProps(nextProps) {
    if(nextProps.loading == false) {
        setTimeout(nextProps.fetchData,2000);
    }
</code></pre>

<p>And inside my MapView component -</p>

<pre><code>{
    this.props.data.length &gt; 0 &amp;&amp; this.props.data.map(merchant =&gt; (
        &lt;MapView.Marker
            coordinate={{latitude: Number(merchant.latitude), longitude: Number(merchant.longitude)}}
            title={merchant.name}
            description={merchant.address}
            identifier={"""" + merchant.id}
            key={merchant.id}
        /&gt;
    ))
}
</code></pre>

<p><strong>My problem:</strong> Whenever I call fetchData(), the new markers are rendered. However, the whole map is rendered again. I do not want this kind of blinking behaviour.</p>

<p>I'd be very grateful for any kind of help/suggestions. Thanks in advance!</p>

<p>P.S. You can find the visual <a href=""https://user-images.githubusercontent.com/31779922/34214184-c2770e80-e5c7-11e7-99f5-3f6bd833501e.gif"" rel=""nofollow noreferrer"">here</a></p>
","And there is a lifecycle event for React component [shouldComponentUpdate](https://reactjs.org/docs/react-component.html#shouldcomponentupdate) where you can control when you want component to update."
"48270880","React.Component doesn’t implement shouldComponentUpdate?","2","<p>According to the docs, React.Component doesn't implement <code>shouldComponentUpdate</code> ?</p>

<p>So how about a lifecycle of a component (<a href=""https://reactjs.org/docs/react-component.html#the-component-lifecycle"" rel=""nofollow noreferrer"">the-component-lifecycle</a>) (<a href=""https://reactjs.org/docs/react-component.html#shouldcomponentupdate"" rel=""nofollow noreferrer"">shouldcomponentupdate</a>) ?</p>

<blockquote>
  <p>React.PureComponent is similar to React.Component. The difference
  between them is that React.Component doesn’t implement
  shouldComponentUpdate(), but React.PureComponent implements it with a
  shallow prop and state comparison.</p>
</blockquote>
","@DanielReina As you can see, in one part of the docs, they say that `React.Component` doesn't implements `shouldComponentUpdate` function, which seem not to be true, accroding to the other part of the docs."
"48270880","React.Component doesn’t implement shouldComponentUpdate?","2","<p>According to the docs, React.Component doesn't implement <code>shouldComponentUpdate</code> ?</p>

<p>So how about a lifecycle of a component (<a href=""https://reactjs.org/docs/react-component.html#the-component-lifecycle"" rel=""nofollow noreferrer"">the-component-lifecycle</a>) (<a href=""https://reactjs.org/docs/react-component.html#shouldcomponentupdate"" rel=""nofollow noreferrer"">shouldcomponentupdate</a>) ?</p>

<blockquote>
  <p>React.PureComponent is similar to React.Component. The difference
  between them is that React.Component doesn’t implement
  shouldComponentUpdate(), but React.PureComponent implements it with a
  shallow prop and state comparison.</p>
</blockquote>
","What is the question here?"
"48560366","In react, will change in props in parent result in a corresponding updation in the child?","1","<p>The official documentation of react ( <a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a> ) says that an update in props results in the child being updated, but it does not happen in my code. Am I missing something?</p>

<p>I created a parent component (Y) and a child component (X). The parent passes currentTime to the child as props. Even though after the props change in the parent after 3 seconds (due to setTimeout), the value in the h2 tag in the child does not change. </p>

<p>I found on the official page of react though ( <a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a> ) that ""An update can be caused by changes to props or state."" (I'm attaching a screenshot as well of the text on the official site below) Moreover I found that there that ""These methods are called when a component is being re-rendered:""</p>

<pre><code>componentWillReceiveProps()
shouldComponentUpdate()
componentWillUpdate()
render()
componentDidUpdate()
</code></pre>

<p>But in my case the change in props does not cause the value in h2 tag in the child to change. The official documentation says that an update in props results in the child being updated, but it does not happen in my code. Am I missing something? </p>

<p>I've pasted my code here for reference.</p>

<pre><code>const Y = () =&gt; {

    let currentTime=""09:00"";
    setTimeout(()=&gt; {
            currentTime = ""10:00:""
        }, 3000);

    return (
        &lt;X time={currentTime}/&gt;
    );
};


class X extends Component {
    time = ""11:00"";

    render = () =&gt; {
        return (
            &lt;h2&gt;{this.props.time}&lt;/h2&gt;
        );
    };
}
</code></pre>

<p>Screenshot:
<a href=""https://prnt.sc/i8kvaw"" rel=""nofollow noreferrer"">https://prnt.sc/i8kvaw</a></p>

<p><strong>Update:
The comment from Shubham Khatri ""The props for the child will only change if the parent re-renders"", really helped me understand. :)</strong></p>
","props are immutable within the component, use state to achieve what you want here :)"
"48614499","What does nextState do in shouldComponentUpdate?","0","<p>In the React lifecycle function <a href=""https://reactjs.org/docs/react-component.html#shouldcomponentupdate"" rel=""nofollow noreferrer"">shouldComponentUpdate(nextProps, nextState)</a>, nextProps is self explanatory.</p>

<p>But what does nextState do?</p>

<p>It doesn't sound right that I can evaluate upcoming state before even deciding if the component should be rendered/modified or not.</p>
",""
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","Prehaps you need to apply the `key` to the DOM element that `ConnectedReduxForm` returns?"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Sidney Unfortunately, I have tried with that and it doesn't work."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","sounds like `ConnectedReduxForm` just needs to implement [`shouldComponentUpdate`](https://reactjs.org/docs/react-component.html#shouldcomponentupdate)"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@leuction If returning `false` from `shouldComponentUpdate` doesn't work, the re-render is likely being caused by a class decorator (probably Redux's `connect` decorator). You should post the source for `ConnectedReduxForm`."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@SimpleJ I just tried to directly import MyReduxForm instead connect the redux. shouldComponentUpdate doesn't work. it is quite wired."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Hamms I have tried with set the shouldComponentUpdate function return false, and it doesn't work. Furthermore, the ConntectedReduxForm have been unmounted, I think there is nothing to do with the update."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","Can you post your complete code somewhere? My feeling is that the parent component was unmounted and mounted again, but I can't be sure without trying the code myself."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","`shouldComponentUpdate` should only return false if the component shouldn't update. It seems like you want the component to update only when its schemaName changes, so your `shouldComponentUpdate` method should reflect that"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Hamms I just return false for the test. The problem is I have no way to prevent the schemaForm to re-mount. All of three schemaForm are re-mounted. the multipleForm is not."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@brickingup Hello, I have just uploaded all the code. But I think that the parent component has not been re-mounted."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","One thing I noticed is that in MultipleForm you put 'key' in SchemaForm while you should put it in Element. This may be the issue because each time MultipleForm re-renders Element will be re-mounted. So SchemaForm will also be re-mounted regardless of it's key."
"49269705","Can't get shouldComponenUpdate() to work in react native","2","<p>Does <code>shouldComponentUpdate</code> not work in React Native, or am I missing something? I'm just trying to log the arguments so that I can compare but it's not even being logged. All I see when I run the JS is ""######### render called"".</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';

class MyComponent extends Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    shouldComponentUpdate(nextProps, nextState) {
        console.log(""######### shouldComponentUpdate called"");
        console.log(nextProps);
        return true;
    }

    render() {
        console.log(""######### render called"");
        return &lt;SomeJSX&gt;
    }
}

export default MyComponent;
  </code></pre>
</div>
</div>
</p>
","its because you never call setState"
"49269705","Can't get shouldComponenUpdate() to work in react native","2","<p>Does <code>shouldComponentUpdate</code> not work in React Native, or am I missing something? I'm just trying to log the arguments so that I can compare but it's not even being logged. All I see when I run the JS is ""######### render called"".</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';

class MyComponent extends Component {
    constructor(props) {
        super(props);
        this.state = {}
    }

    shouldComponentUpdate(nextProps, nextState) {
        console.log(""######### shouldComponentUpdate called"");
        console.log(nextProps);
        return true;
    }

    render() {
        console.log(""######### render called"");
        return &lt;SomeJSX&gt;
    }
}

export default MyComponent;
  </code></pre>
</div>
</div>
</p>
","shouldComponentUpdate works as expected. A higher order component wrapping my component is causing my re-rendering issues."
"49278511","How do I update only one trace in react plotly?","0","<p>I am using react-plotly to generate a large timeline of data (10,000-100,000 points) and I animate across the data in another window. I need to get a scrubber (vertical line) that moves with a react-property representing time, but I need to update the scrubber without updating the rest of the timeline, since it would take so long to do so. How can I get just the vertical line to update?</p>

<p>Edit: Was asked for code</p>

<p>In the following code, the <code>backtracks</code> and <code>thresholds</code> objects are <code>Uint32Array</code>s and represent the y-axis of traces, where the x-axes are the <code>Uint32Array</code>s <code>backtracksTime</code> and <code>thresholdsTime</code>. What I am trying to get is a vertical line at the x-coordinate <code>currentTime</code>.</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';

import Plotly from 'plotly.js';
import Plot from 'react-plotly.js';

import styles from './style.scss';

export default class ThresholdWindow extends Component {
  static propTypes = {
    name: PropTypes.string,
    backtracks: PropTypes.object,
    backtracksTime: PropTypes.object,
    thresholds: PropTypes.object,
    thresholdsTime: PropTypes.object,
    currentTime: PropTypes.number,
  }

  constructor(props) {
    super(props);
    this.state = {
      plotRevision: 0,
      width: 0,
      height: 0,
    };
  }

  componentDidMount() {
    const resizeObserver = new ResizeObserver(entries =&gt; {
      const oldPlotRevision = this.state.plotRevision;
      const rect = entries[0].contentRect;
      this.setState({
        plotRevision: oldPlotRevision + 1,
        height: rect.height,
        width: rect.width,
      });
    });
    resizeObserver.observe(this.container);
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.state.plotRevision !== nextState.plotRevision) {
      return true;
    } else if (this.props.currentTime !== nextProps.currentTime) {
      return true;
    }
    return false;
  }

  render() {
    const data = [
      {
        name: 'Threshold',
        type: 'scattergl',
        mode: 'lines',
        x: this.props.thresholdsTime,
        y: this.props.thresholds,
        side: 'above',
      },
      {
        name: 'Backtracks',
        type: 'scattergl',
        mode: 'lines',
        x: this.props.backtracksTime,
        y: this.props.backtracks,
      },
      {
        name: 'Current Time',
        type: 'scattergl',
        mode: 'lines',
        x: [this.props.currentTime, this.props.currentTime],
        y: [0, 1],
        yaxis: 'y2',
      },
    ];

    return (
      &lt;div className={styles['threshold-window']} ref={(el) =&gt; { this.container = el; }}&gt;
        &lt;Plot
          divId={`backtracks-${this.props.name}`}
          className={styles['threshold-graph']}
          ref={(el) =&gt; { this.plot = el; }}
          layout={{
            width: this.state.width,
            height: this.state.height,
            yaxis: {
              fixedrange: true,
            },
            yaxis2: {
              side: 'right',
              range: [0, 1],
            },
            margin: {
              l: 35,
              r: 15,
              b: 20,
              t: 15,
            },
            legend: {
              orientation: 'h',
              y: 1,
            },
          }}
          revision={this.state.plotRevision}
          data={data}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>Edit2: I don't actually see the <code>currentTime</code> line anywhere, so I'm pretty sure there's a bug somewhere.</p>
",""
"49671048","style activityIndicator in react-native","4","<p>I am trying to set the <code>color</code> of my <code>ActivityIndicator</code>:</p>

<pre><code> &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
      &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner.color} /&gt;
    &lt;/View&gt;
</code></pre>

<p>I am setting my style here:</p>

<pre><code>   import React, {Component} from 'react';
import {Text, View, ActivityIndicator} from 'react-native';
import Calendar from '../calendar';
import styleConstructor from './style';

class CalendarListItem extends Component {
  constructor(props) {
    super(props);
    this.style = styleConstructor(props.theme);
  }

  shouldComponentUpdate(nextProps) {
    const r1 = this.props.item;
    const r2 = nextProps.item;
    return r1.toString('yyyy MM') !== r2.toString('yyyy MM') || !!(r2.propbump &amp;&amp; r2.propbump !== r1.propbump);
  }

  render() {
    const row = this.props.item;
    if (row.getTime) {
      return (
        &lt;Calendar
          theme={this.props.theme}
          style={[{height: this.props.calendarHeight}, this.style.calendar]}
          current={row}
          hideArrows
          hideExtraDays={this.props.hideExtraDays === undefined ? true : this.props.hideExtraDays}
          disableMonthChange
          markedDates={this.props.markedDates}
          markingType={this.props.markingType}
          hideDayNames={this.props.hideDayNames}
          onDayPress={this.props.onDayPress}
          minDate={this.props.minDate}
          maxDate={this.props.maxDate}
          firstDay={this.props.firstDay}
          monthFormat={this.props.monthFormat}
          dayComponent={this.props.dayComponent}
          disabledByDefault={this.props.disabledByDefault}
          showWeekNumbers={this.props.showWeekNumbers}
        /&gt;);
    } else {
      const text = row.toString();
      return (

        &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
          &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner} /&gt;
        &lt;/View&gt;
      );
    }
  }
}

export default CalendarListItem;
</code></pre>

<p>My <code>style.js</code> is:</p>

<pre><code>import {StyleSheet} from 'react-native';
import * as defaultStyle from '../style';

const STYLESHEET_ID = 'stylesheet.calendar-list.main';

export default function getStyle(theme={}) {
  const appStyle = {...defaultStyle, ...theme};
  return StyleSheet.create({
    container: {
      backgroundColor: appStyle.calendarBackground
    },
    placeholder: {
      backgroundColor: appStyle.calendarBackground,
      alignItems: 'center',
      justifyContent: 'center'
    },
    placeholderText: {
      fontSize: 30,
      fontWeight: '200',
      color: appStyle.dayTextColor
    },
    loadingSpinner: {
      color: '#fff'
    },
    calendar: {
      paddingLeft: 15,
      paddingRight: 15
    },
    ...(theme[STYLESHEET_ID] || {})
  });
}
</code></pre>

<p>However, <code>this.style.loadingSpinner.color</code> is undefined.</p>

<p>How can set the color?</p>
","Updated question with complete code"
"49671048","style activityIndicator in react-native","4","<p>I am trying to set the <code>color</code> of my <code>ActivityIndicator</code>:</p>

<pre><code> &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
      &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner.color} /&gt;
    &lt;/View&gt;
</code></pre>

<p>I am setting my style here:</p>

<pre><code>   import React, {Component} from 'react';
import {Text, View, ActivityIndicator} from 'react-native';
import Calendar from '../calendar';
import styleConstructor from './style';

class CalendarListItem extends Component {
  constructor(props) {
    super(props);
    this.style = styleConstructor(props.theme);
  }

  shouldComponentUpdate(nextProps) {
    const r1 = this.props.item;
    const r2 = nextProps.item;
    return r1.toString('yyyy MM') !== r2.toString('yyyy MM') || !!(r2.propbump &amp;&amp; r2.propbump !== r1.propbump);
  }

  render() {
    const row = this.props.item;
    if (row.getTime) {
      return (
        &lt;Calendar
          theme={this.props.theme}
          style={[{height: this.props.calendarHeight}, this.style.calendar]}
          current={row}
          hideArrows
          hideExtraDays={this.props.hideExtraDays === undefined ? true : this.props.hideExtraDays}
          disableMonthChange
          markedDates={this.props.markedDates}
          markingType={this.props.markingType}
          hideDayNames={this.props.hideDayNames}
          onDayPress={this.props.onDayPress}
          minDate={this.props.minDate}
          maxDate={this.props.maxDate}
          firstDay={this.props.firstDay}
          monthFormat={this.props.monthFormat}
          dayComponent={this.props.dayComponent}
          disabledByDefault={this.props.disabledByDefault}
          showWeekNumbers={this.props.showWeekNumbers}
        /&gt;);
    } else {
      const text = row.toString();
      return (

        &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
          &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner} /&gt;
        &lt;/View&gt;
      );
    }
  }
}

export default CalendarListItem;
</code></pre>

<p>My <code>style.js</code> is:</p>

<pre><code>import {StyleSheet} from 'react-native';
import * as defaultStyle from '../style';

const STYLESHEET_ID = 'stylesheet.calendar-list.main';

export default function getStyle(theme={}) {
  const appStyle = {...defaultStyle, ...theme};
  return StyleSheet.create({
    container: {
      backgroundColor: appStyle.calendarBackground
    },
    placeholder: {
      backgroundColor: appStyle.calendarBackground,
      alignItems: 'center',
      justifyContent: 'center'
    },
    placeholderText: {
      fontSize: 30,
      fontWeight: '200',
      color: appStyle.dayTextColor
    },
    loadingSpinner: {
      color: '#fff'
    },
    calendar: {
      paddingLeft: 15,
      paddingRight: 15
    },
    ...(theme[STYLESHEET_ID] || {})
  });
}
</code></pre>

<p>However, <code>this.style.loadingSpinner.color</code> is undefined.</p>

<p>How can set the color?</p>
","just give <ActivitytIndicator color='red' />"
"49671048","style activityIndicator in react-native","4","<p>I am trying to set the <code>color</code> of my <code>ActivityIndicator</code>:</p>

<pre><code> &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
      &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner.color} /&gt;
    &lt;/View&gt;
</code></pre>

<p>I am setting my style here:</p>

<pre><code>   import React, {Component} from 'react';
import {Text, View, ActivityIndicator} from 'react-native';
import Calendar from '../calendar';
import styleConstructor from './style';

class CalendarListItem extends Component {
  constructor(props) {
    super(props);
    this.style = styleConstructor(props.theme);
  }

  shouldComponentUpdate(nextProps) {
    const r1 = this.props.item;
    const r2 = nextProps.item;
    return r1.toString('yyyy MM') !== r2.toString('yyyy MM') || !!(r2.propbump &amp;&amp; r2.propbump !== r1.propbump);
  }

  render() {
    const row = this.props.item;
    if (row.getTime) {
      return (
        &lt;Calendar
          theme={this.props.theme}
          style={[{height: this.props.calendarHeight}, this.style.calendar]}
          current={row}
          hideArrows
          hideExtraDays={this.props.hideExtraDays === undefined ? true : this.props.hideExtraDays}
          disableMonthChange
          markedDates={this.props.markedDates}
          markingType={this.props.markingType}
          hideDayNames={this.props.hideDayNames}
          onDayPress={this.props.onDayPress}
          minDate={this.props.minDate}
          maxDate={this.props.maxDate}
          firstDay={this.props.firstDay}
          monthFormat={this.props.monthFormat}
          dayComponent={this.props.dayComponent}
          disabledByDefault={this.props.disabledByDefault}
          showWeekNumbers={this.props.showWeekNumbers}
        /&gt;);
    } else {
      const text = row.toString();
      return (

        &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
          &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner} /&gt;
        &lt;/View&gt;
      );
    }
  }
}

export default CalendarListItem;
</code></pre>

<p>My <code>style.js</code> is:</p>

<pre><code>import {StyleSheet} from 'react-native';
import * as defaultStyle from '../style';

const STYLESHEET_ID = 'stylesheet.calendar-list.main';

export default function getStyle(theme={}) {
  const appStyle = {...defaultStyle, ...theme};
  return StyleSheet.create({
    container: {
      backgroundColor: appStyle.calendarBackground
    },
    placeholder: {
      backgroundColor: appStyle.calendarBackground,
      alignItems: 'center',
      justifyContent: 'center'
    },
    placeholderText: {
      fontSize: 30,
      fontWeight: '200',
      color: appStyle.dayTextColor
    },
    loadingSpinner: {
      color: '#fff'
    },
    calendar: {
      paddingLeft: 15,
      paddingRight: 15
    },
    ...(theme[STYLESHEET_ID] || {})
  });
}
</code></pre>

<p>However, <code>this.style.loadingSpinner.color</code> is undefined.</p>

<p>How can set the color?</p>
","why you use `this.style.loadingSpinner.color` when you set the function name is `getStyle`?, maybe `this.getStyle.loadingSpinner.color` worked?"
"49671048","style activityIndicator in react-native","4","<p>I am trying to set the <code>color</code> of my <code>ActivityIndicator</code>:</p>

<pre><code> &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
      &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner.color} /&gt;
    &lt;/View&gt;
</code></pre>

<p>I am setting my style here:</p>

<pre><code>   import React, {Component} from 'react';
import {Text, View, ActivityIndicator} from 'react-native';
import Calendar from '../calendar';
import styleConstructor from './style';

class CalendarListItem extends Component {
  constructor(props) {
    super(props);
    this.style = styleConstructor(props.theme);
  }

  shouldComponentUpdate(nextProps) {
    const r1 = this.props.item;
    const r2 = nextProps.item;
    return r1.toString('yyyy MM') !== r2.toString('yyyy MM') || !!(r2.propbump &amp;&amp; r2.propbump !== r1.propbump);
  }

  render() {
    const row = this.props.item;
    if (row.getTime) {
      return (
        &lt;Calendar
          theme={this.props.theme}
          style={[{height: this.props.calendarHeight}, this.style.calendar]}
          current={row}
          hideArrows
          hideExtraDays={this.props.hideExtraDays === undefined ? true : this.props.hideExtraDays}
          disableMonthChange
          markedDates={this.props.markedDates}
          markingType={this.props.markingType}
          hideDayNames={this.props.hideDayNames}
          onDayPress={this.props.onDayPress}
          minDate={this.props.minDate}
          maxDate={this.props.maxDate}
          firstDay={this.props.firstDay}
          monthFormat={this.props.monthFormat}
          dayComponent={this.props.dayComponent}
          disabledByDefault={this.props.disabledByDefault}
          showWeekNumbers={this.props.showWeekNumbers}
        /&gt;);
    } else {
      const text = row.toString();
      return (

        &lt;View style={[{height: this.props.calendarHeight}, this.style.placeholder]}&gt;
          &lt;ActivityIndicator size=""large"" color={this.style.loadingSpinner} /&gt;
        &lt;/View&gt;
      );
    }
  }
}

export default CalendarListItem;
</code></pre>

<p>My <code>style.js</code> is:</p>

<pre><code>import {StyleSheet} from 'react-native';
import * as defaultStyle from '../style';

const STYLESHEET_ID = 'stylesheet.calendar-list.main';

export default function getStyle(theme={}) {
  const appStyle = {...defaultStyle, ...theme};
  return StyleSheet.create({
    container: {
      backgroundColor: appStyle.calendarBackground
    },
    placeholder: {
      backgroundColor: appStyle.calendarBackground,
      alignItems: 'center',
      justifyContent: 'center'
    },
    placeholderText: {
      fontSize: 30,
      fontWeight: '200',
      color: appStyle.dayTextColor
    },
    loadingSpinner: {
      color: '#fff'
    },
    calendar: {
      paddingLeft: 15,
      paddingRight: 15
    },
    ...(theme[STYLESHEET_ID] || {})
  });
}
</code></pre>

<p>However, <code>this.style.loadingSpinner.color</code> is undefined.</p>

<p>How can set the color?</p>
","ActivityIndicator  `color` props accept the only string. try putting it into `{this.style.colorValue}` inside `` these symbols"
"50061200","PureComponent decorated by mobx-react throws error about `shouldComponentUpdate` presence","0","<p>In console I see this warning:</p>

<blockquote>
  <p>index.js:2178 Warning: Body has a method called
  shouldComponentUpdate(). shouldComponentUpdate should not be used when
  extending React.PureComponent. Please extend React.Component if
  shouldComponentUpdate is used.</p>
</blockquote>

<p><code>Body</code> component is using</p>

<pre><code>...
import { observer, inject } from 'mobx-react';
...
@inject('store')
@observer
class Body extends React.PureComponent&lt;BodyProps&gt; {
...
</code></pre>

<p>but doesn't have this <code>shouldComponentUpdate</code> method anywhere.</p>

<p><strong>Is this coming from <code>mobx-react</code>? Can I use <code>PureComponent</code> in components decorated by <code>@observable</code> or <code>@inject</code> ?</strong></p>
",""
"50131597","Why is this react component rendering twice?","3","<p>The problem is that the component is being rendered twice, once with the initial state, again after the setState method in axios promise. Why is this happening and how can I solve this.</p>

<p>I have used both componentWillMount and componentDidMount. I, being a noob, tried hard and failed to figure out why.</p>

<pre><code>export default class Dashboard extends Component{

  constructor(props) {
    super(props)
    this.state = {
      data: {
        okay: 'lul'
      }
    }
  }

  componentWillMount() {
    axios
      .get('/api/data?param1='+this.props.location.state.param1+'&amp;param2='+this.props.location.state.param2)
      .then(res =&gt; {
        if (res.status != 401) {
          if(res.err)
            console.log('Error while retrieving: ', res.err)
          else {
            this.setState({
              data: res.data.data
            })
          }
        } else {
          console.log('Unauthorized!');
        }
      })
  }

  render() {
    return (
        &lt;Segment inverted vertical&gt;
          &lt;CardContainer data={this.state.data}/&gt;
        &lt;/Segment&gt;
    )
  }
}
</code></pre>

<p>Even basic suggestions related to react / JS / general programming is highly appreciated</p>
","This behaviour is how react is supposed to work. It's not a bug. Calling `render` is really quite cheap, since react will take care of updating the dom in a efficient manner. In some cases you might want to tweak when rerendering happens. This is discussed in the react documentation here: [shouldComponentUpdate In Action](https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action)"
"50856248","shouldComponentUpdate(): Returned undefined instead of a boolean value.","1","<p>Before anyone marks this as a duplicate, I went through this question 
<a href=""https://stackoverflow.com/questions/45351446/reactjs-warning-thumbnails-shouldcomponentupdate-returned-undefined-instead"">ReactJS Warning: Thumbnails.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false</a> and it doesn't answer my question (or I wasn't able to get it (to say the least) </p>

<p>so this my code </p>

<pre><code>  shouldComponentUpdate(nextProps, nextState) {
    console.log(this.props.order, nextProps.order)
    if (nextProps.order !== this.props.order) {
      return true;
    }
  }
</code></pre>

<p>Here when I check the console log in chrome, it throws a warning saying </p>

<blockquote>
  <p>shouldComponentUpdate(): Returned undefined instead of a boolean
  value. Make sure to return true or false</p>
</blockquote>

<p>But everything works as expected (or the way I want to), Also when I do something like </p>

<pre><code>shouldComponentUpdate(nextProps, nextState) {
    console.log(this.props.order, nextProps.order)
      return nextProps.order !== this.props.order
  }
</code></pre>

<p>It doesn't throw an error. </p>

<p><strong>[Question]</strong> Why am i getting that warning? when I clearly return true?</p>
","add `else return false` after if, you only returned true"
"51113462","Components are rendering again and again after i set mouse move event listener for body in react js","2","<p>I wrote a event listener for body to get the mouse position in react js</p>

<pre><code>getMousePosition = (event) =&gt; {
        if(this.props.navActiveClass === ""active-sm""){
            var mouseX = 0, mouseY = 0;
            this.setState({
                mouseX:event.pageX,
                mouseY:event.pageY,
            })
        }
    }

    componentDidMount(){
        document.body.addEventListener('mousemove', this.getMousePosition);
    }
    componentWillUnmount() {
        document.body.removeEventListener('mousemove', this.getMousePosition);
    }
</code></pre>

<p>after that whenever i move the mouse showing component is re-rendering again and again.</p>
","If you are not using `mouseX` or `mouseY` in your rendering, and you definitely don't want it to re-render, you could check if just `mouseX` and `mouseY` updated in [shouldComponentUpdate](https://reactjs.org/docs/react-component.html#shouldcomponentupdate)."