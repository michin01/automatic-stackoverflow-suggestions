Id,Title,CommentCount,Body,Text
"23656359","Listening for models inside reactjs components","0","<p>I'm currently trying out reactjs, trying to make a MVC based card game with it. I find that ReactJS is a very capable and good performing view library, but I have some troubles mapping it to a more traditional MVC pattern where the views listen to the models.</p>

<p>In the card game I have 2 rows of cards on the table, one of the current player and one of the opponent player. The cards of the current player are in the bottom row and they are selectable. In my GameView i render 2 child views, like this:</p>

<p><code>
&lt;SlotView key=""slotview1"" slot={this.state.otherPlayer.slot} selectable={false} /&gt;
&lt;SlotView key=""slotview2"" slot={this.state.currentPlayer.slot} selectable={this.state.playing_cards} on_select={this.handlePlayCard}&gt;
</code></p>

<p>when the turn is over I swap the current player and the other player (in the game model) and notify the gameview via an event. The gameview's state is updated, and then it rerenders itself from the perspective of the other player. </p>

<p>This works fine, the cards of the other player show in the bottom row. But, the problem I am running into is that the SlotView (child view of the game view) also listens to its model (it updates itself when a card is played). </p>

<p>I bind the listeners in SlotView#ComponentDidMount and unbind them in SlotView#ComponentDidUnmount. However, the component is only mounted during the first render, and never unmounted and mounted again. Its property (slot) is being updated to the other player, but it still listens to events from the first player. Is there a way I can listen to property changes to bind/unbind event handlers? Or should I not listen to models at all in child components and replace the MVC model with a more push oriented model (but this seems to produce a lot of boilerplate code with nested views)?
Should I unbind/rebind in the render method itself (but that seems wrong too)?</p>

<p>Curious to hear how other people do this....</p>
",""
"24015312","How do you remount a component in reactjs?","1","<p>I have a component that I need to re-mount. I need to destroy everything and make it's code re-execute to appear again on my page.</p>

<p>What I've tried:
<a href=""https://groups.google.com/forum/#!topic/reactjs/8JgClU9jol0"" rel=""nofollow noreferrer"">https://groups.google.com/forum/#!topic/reactjs/8JgClU9jol0</a> I put key=""1"" and then with javascript changed its key to something else, it did not remount</p>

<p><a href=""https://stackoverflow.com/questions/21662153/unmounting-react-js-node"">Unmounting React.js node</a> this won't work because my component is already rendered.</p>

<p>Please help, how do I do this?</p>
","Can you expand on ""destroy everything and make its code re-execute to appear again on my page""? When a component re-renders, it re-renders all of its children. What event is causing you to want to re-render? Renders in React should be driven by changes to the data or state that represent the page."
"27042456","reactjs bootstrap modal does not re-render the first time","1","<p>I am using a react-bootstrap modal for login.
The user hits 'Log in' and a request is sent to our server.
If the login fails - we set the state - LOGIN_FAILED</p>

<p>At this point the react application re-renders.</p>

<p>The reason the login failed is available in state as an error message e.g. ""Incorrect username or password"". Since the modal is already active, we re-render it with the error message below the 'Log in' button.</p>

<p>This works fine - apart from the very first time you use the modal(or after refreshing the page)</p>

<p>In this case the modal disappears.</p>

<p>I debugged it and see this code is executed and the modal gets unmounted:</p>

<p><strong>OverlayMixin.js</strong></p>

<pre><code>componentWillUnmount: function () {
    this._unrenderOverlay();
    if (this._overlayTarget) {
      this.getContainerDOMNode()
        .removeChild(this._overlayTarget);
      this._overlayTarget = null;
    }
  },
</code></pre>

<p>.
.
.</p>

<pre><code>_unrenderOverlay: function () {
    React.unmountComponentAtNode(this._overlayTarget);
    this._overlayInstance = null;
  },
</code></pre>

<p>Has anyone come across this before? I am considering using a OverlayMixin to see if it makes any difference but would like to know the root cause.</p>

<p>Any help appreciated.</p>

<p>Here is the LoginModal react component:</p>

<pre><code>var LoginModal = React.createClass({

propTypes:{
    errorText: React.PropTypes.string,
    onRequestHide: React.PropTypes.func,
    state: React.PropTypes.string
},

getInitialState: function() {
    return {
        fbNotAuthorisedOn: false,
       fbLoginErrorOn: false,
        valid: false,
        showErrors: false
    };
},

componentWillReceiveProps: function(nextProps) {
    if(this.props.state === 'LOGIN_FAILED'){
        this.setState({
          showErrors: true
        });
    }
},

_onSubmit: function(e) {
    if(e &amp;&amp; typeof e !== 'undefined') {
        e.stopPropagation();
        e.preventDefault();
    }
    var email = this.refs.email.getValue();
    var password = this.refs.password.getValue();

    UserAPIUtils.login(email, password);
},

_onKeyDown: function(event) {
    if (event.keyCode === AppConstants.ENTER_KEY_CODE &amp;&amp; this.state.valid) {
        this._onSubmit(event);
    }
},

_handleHide: function() {
    this.refs.loginModal.props.onRequestHide();
},

_handleFBNotAuthorised: function(message) {
    Router.transitionTo('facebook-error', { errorMessage:      AppConstants.FACEBOOK_INSUFFICENT_PERMISSIONS_ERROR });
},

_handleFBLoginError: function(errorMessage) {
    Router.transitionTo('facebook-error', { errorMessage: errorMessage});
},

_onChange: function(){
    if(this.refs.email.getValue() &amp;&amp; this.refs.password.getValue()){
        this.setState({valid:true});
    }else{
        this.setState({valid:false});
    }
},

render: function () {
var errorText = '';
if(this.state.showErrors){
    if(this.props.errorText){
        errorText = this.props.errorText;
    }else{
        errorText = 'Login failed, please try again';
    }
}

return this.transferPropsTo(
    &lt;Modal className=""signPopUpModal""
        title=""Log In""
        backdrop={true}
        animation={true}
        ref=""loginModal""
        id=""loginModal""
        className=""signPopUpModal""&gt;
          &lt;div className=""modal-body""&gt;
            &lt;form role=""form"" onSubmit={this._onSubmit}&gt;
                &lt;Input id=""email""
                    ref=""email""
                    type=""email""
                    placeholder=""Enter your email address""
                    groupClassName=""group-class""
                    wrapperClassName=""wrapper-class""
                    labelClassName=""label-class""
                    addonBefore={Glyphicon({glyph:'user'})}
                    onKeyDown={this._onKeyDown}
                    onChange={this._onChange}/&gt;
                &lt;Input id=""password"" type=""password"" ref=""password""
                    placeholder=""Enter your password""
                    groupClassName=""group-class""
                    wrapperClassName=""wrapper-class""
                    labelClassName=""label-class""
                    addonBefore={Glyphicon({glyph:'lock'})}
                    onKeyDown={this._onKeyDown}
                    onChange={this._onChange}/&gt;
            &lt;div className=""row""&gt;
                {errorText}
            &lt;/div&gt;
            &lt;div className=""row""&gt;
              &lt;div className=""col-md-3 col-xs-6""&gt;
                &lt;div className=""remember-me link""&gt;
                    &lt;input type=""checkbox""&gt;Remember me&lt;/input&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=""col-md-3 col-md-offset-6 col-xs-6""&gt;
                &lt;div className=""pass link""&gt;
                    &lt;ResetPasswordModalTrigger modal={this.transferPropsTo(&lt;ResetPasswordModal
                        closeLoginHandler={this._handleHide} /&gt;)}&gt;
                        &lt;a href=""#""&gt;Forgot Password?&lt;/a&gt;
                    &lt;/ResetPasswordModalTrigger&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=""row""&gt;
              &lt;Button id=""loginBtn"" type=""submit""
                    ref=""loginButton""
                    disabled={!this.state.valid}
                    block={true}
                    className=""btn-highlight col-md-12""&gt;Log in&lt;/Button&gt;
            &lt;/div&gt;
            &lt;div className=""row""&gt;
              &lt;p className=""or""&gt;or&lt;/p&gt;
            &lt;/div&gt;
            &lt;div className=""row""&gt;
                &lt;FacebookLogin  closeLoginHandler={this._handleHide}
                                onNotAuthorizedResponse={this._handleFBNotAuthorised}
                                onErrorResponse={this._handleFBLoginError} /&gt;
            &lt;/div&gt;
            &lt;div className=""row signup""&gt;
                &lt;p&gt;Don't have an account?
                &lt;RegisterModalTrigger modal={&lt;RegisterModal closeLoginHandler={this._handleHide} /&gt;}&gt;
                    &lt;a href=""#""&gt;Sign Up&lt;/a&gt;
                &lt;/RegisterModalTrigger&gt;
            &lt;/p&gt;
            &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/Modal&gt;
);

}
});

module.exports = LoginModal ;`
</code></pre>
","We found as we rendered this Modal, there was an extra <div> around it. Removing it fixed the problem. This can be closed."
"27227792","react.js: removing a component","2","<p>I'm fairly new at react.js, so any help is greatly appreciated.</p>

<p>I have this: <a href=""http://jsfiddle.net/rzjyhf91/"">http://jsfiddle.net/rzjyhf91/</a></p>

<p>Wherein I have made 2 components: an image and a button.</p>

<p>The goal is to remove the image with a click of the button, I use <code>unmountComponentAtNode</code> for that, but it does not work:</p>

<pre><code>var App = React.createClass({
  render: function() {
    return (
    &lt;div&gt;&lt;MyImage /&gt;&lt;RemoveImageButton /&gt;&lt;/div&gt;
    );
  }
});

var MyImage = React.createClass({
  render: function() {
    return (
      &lt;img id=""kitten"" src={'http://placekitten.com/g/200/300'} /&gt;
    );
  }
});

var RemoveImageButton = React.createClass ({
  render: function() {
    return (
      &lt;button onClick={this.handleClick}&gt;remove image&lt;/button&gt;
    )
  },
  handleClick: function(){
    React.unmountComponentAtNode(document.getElementById('kitten'));   
  }
});

React.render(&lt;App /&gt;, document.body);
</code></pre>

<p>How can I remove a react component from another component?</p>
","wow, this seems to be a bug... you should have done something like this: <div><div id=""someid""><MyImage /></div><RemoveImageButton /></div> and then unmount on the ""someid""... but this doesnt work either. I think you would have to forceUpdate() the App component or something..."
"27227792","react.js: removing a component","2","<p>I'm fairly new at react.js, so any help is greatly appreciated.</p>

<p>I have this: <a href=""http://jsfiddle.net/rzjyhf91/"">http://jsfiddle.net/rzjyhf91/</a></p>

<p>Wherein I have made 2 components: an image and a button.</p>

<p>The goal is to remove the image with a click of the button, I use <code>unmountComponentAtNode</code> for that, but it does not work:</p>

<pre><code>var App = React.createClass({
  render: function() {
    return (
    &lt;div&gt;&lt;MyImage /&gt;&lt;RemoveImageButton /&gt;&lt;/div&gt;
    );
  }
});

var MyImage = React.createClass({
  render: function() {
    return (
      &lt;img id=""kitten"" src={'http://placekitten.com/g/200/300'} /&gt;
    );
  }
});

var RemoveImageButton = React.createClass ({
  render: function() {
    return (
      &lt;button onClick={this.handleClick}&gt;remove image&lt;/button&gt;
    )
  },
  handleClick: function(){
    React.unmountComponentAtNode(document.getElementById('kitten'));   
  }
});

React.render(&lt;App /&gt;, document.body);
</code></pre>

<p>How can I remove a react component from another component?</p>
","I don't know the answer, but I would set the image as the state of the `App`, and then change/remove the state's value which triggers a re-render."
"27636947","Get value from a textbox in popupbox using reactjs","0","<p>I have a program which opens a dialog box on button click.</p>

<p>The dialog box contains : <code>inputbox</code>, <code>submit</code> and <code>cancel</code> button. I am just wondering how do I get the value of the input box after submitting the form. Posting code and Fiddle below.</p>

<p><a href=""http://jsbin.com/zunud/8/edit?html,js,output"" rel=""nofollow"">JSBIN</a></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;link href=""//code.jquery.com/ui/1.11.1/themes/smoothness/jquery-ui.min.css"" rel=""stylesheet""     type=""text/css"" /&gt;
&lt;script src=""//code.jquery.com/jquery-1.11.0.min.js""&gt;&lt;/script&gt;
&lt;script src=""//code.jquery.com/ui/1.11.1/jquery-ui.min.js""&gt;&lt;/script&gt;
&lt;script src=""http://fb.me/react-0.3.0.js""&gt;&lt;/script&gt;
&lt;script src=""http://fb.me/JSXTransformer-0.3.0.js""&gt;&lt;/script&gt;

 &lt;meta charset=""utf-8""&gt;
 &lt;title&gt;JS Bin&lt;/title&gt;
 &lt;/head&gt;
&lt;body&gt;
&lt;div id=""component""&gt;&lt;/div&gt;
&lt;script type=""text/jsx""&gt;
  /** @jsx React.DOM */

var DialogContent = React.createClass({
  render: function(){
  return(
  &lt;div&gt;
    &lt;form onSubmit={this.handleSubmit}&gt;
      &lt;input ref=""inputText"" /&gt;
      &lt;input type=""submit"" /&gt;
      &lt;button onClick = {this.props.closeDialog}&gt;Cancel&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  )
   }
  });


  var DialogExample = React.createClass({

  openDialog: function(e){
  e.preventDefault();

  var $dialog = $('&lt;div&gt;').dialog({
    title: 'Example Dialog Title',
    width: 400,
    close: function(e){
      React.unmountAndReleaseReactRootNode(this);
      $( this ).remove();
    }
  });

  var closeDialog = function(e){
    e.preventDefault();
    $dialog.dialog('close');
  }

  React.renderComponent(&lt;DialogContent closeDialog={closeDialog} /&gt;, $dialog[0])
  },
  render: function(){
  return(
      &lt;button onClick= {this.openDialog}&gt;Open Dialog&lt;/button&gt;
    )
  }
  });

 React.renderComponent(&lt;DialogExample /&gt;, document.getElementById('component'));

  &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Note: I am new to reactjs.</p>
",""
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","You'll need to add some specific examples of what's not working in order to help you. Show us the minimum code necessary to reproduce the problem."
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","i updated the post @WiredPrairie"
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","I typically use a [flux architecture](http://facebook.github.io/flux/) for managing async data"
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","can you give me example of how to use history Api with flux ?? @MattiJohn"
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","Your ""object specification"" (the argument to `React.createClass`) is not a proper javascript object literal. Please fix it and see if the problem persists."
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","[Here](http://stackoverflow.com/questions/28012356/proper-way-to-initialize-data/28101529#28101529) is a question I answered a few weeks ago about async data using reflux.js (a flux implementation). Instead of rendering your component in the success callback, render the component and have the component listen for data from the AJAX response. You can use local storage if you need the data to still be in the store when you navigate back."
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","Thanks for your efforts to fix the question. Get the indentation fixed and I will vote for reopening."
"28470560","History into react","8","<p>I am using History Api to switch between pages in my website using the ajaxify plugin
that depends on historyjs from this site <a href=""http://4nf.org/"" rel=""nofollow"">http://4nf.org/</a>.  It's using requests just to update only div in page and leave everything else (header,footer).</p>

<p>It works so well, but when using reactjs components in some pages it doesn't work so well.</p>

<p>I am using reactjs to render data from the server and represent it in the page but when I switch pages react doesn't reload content in a page but it gives me a blank page.</p>

<p>How to get history into react and make react re-fetch content again every time I get the page?</p>

<p>I downloaded react devtool for chrome and I recognized that the react component still in can i unmount and remount react every time the page changes !!?</p>

<p>React code:</p>

<pre><code>var Postlist = React.createClass({
    getInitialState: function () {
        socket.on(""new"",this.Updatepost);
        return {posts: [], hasMore: true, onView: 5};
    },
    componentWillMount: function () {
        this.state.posts.push(this.props.newposts);
        this.setState({posts: this.props.newposts});
    },
    $.ajax({
        url: 'load_posts.php',
        dataType: 'json',
        success: function (data) {
            var x = data;
            React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
        }.bind(this),
        error: function (xhr, status, err) {
            console.error(this.props.url, status, err.toString());
        }.bind(this)
    });
</code></pre>

<p>and this code to navigate between pages.</p>

<pre><code>       $(document).ready(function() {
         $(""#r_sec"").ajaxify({
          previewoff: true, 
          fade: 500,
          inline:false,
          selector : "".nav_ul a""});});
</code></pre>

<p>React code works so well when I load the homepage but when I navigate and return to the home page it gaves me a blank page so how can I re-render react?</p>
","what i can do now ?? @PauloScardine"
"28502317","react unmouting when navigate away","1","<p>i have this react component which works so will when i render it</p>

<pre><code>var Postlist = React.createClass({
getInitialState: function () {
    socket.on(""new"",this.Updatepost);
    return {posts: [], hasMore: true, onView: 5};
},
componentWillMount: function () {
    this.state.posts.push(this.props.newposts);
    this.setState({posts: this.props.newposts});
},
$.ajax({
    url: 'load_posts.php',
    dataType: 'json',
    success: function (data) {
        var x = data;
        React.render(&lt;Postlist newposts={x} /&gt;,document.getElementById(""main""));
    }.bind(this),
    error: function (xhr, status, err) {
        console.error(this.props.url, status, err.toString());
    }.bind(this)
});
</code></pre>

<p>but iam using history api to navigate between pages </p>

<p>so how can i unmount and remount react component when navigating and how to unmounting it outside react code</p>
","Have you looked into using any of the React-friendly routing components?"
"28955140","componentWillUnMount not being called for reactjs 0.13","0","<p>Code:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
&lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;meta name=description content=""""&gt;
    &lt;meta name=viewport content=""width=device-width, initial-scale=1""&gt;
    &lt;title&gt;Component Lifecycle: Mounting&lt;/title&gt;
    &lt;link rel=""stylesheet"" type=""text/css"" href=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.css""&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/0.13.0-beta.1/react.min.js""&gt;&lt;/script&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/0.13.0-beta.1/JSXTransformer.js""&gt;&lt;/script&gt;
    &lt;style type=""text/css""&gt;
        body{margin: 25px;}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button onClick=""render()""&gt;Render&lt;/button&gt;
    &lt;button onClick=""unmount()""&gt;Unmount&lt;/button&gt;
    &lt;hr /&gt;
    &lt;div id=""panel""&gt;&lt;/div&gt;

    &lt;script type=""text/jsx;harmony=true""&gt;
    /** @jsx React.DOM */
    var APP = React.createClass({
        update:function() {
            var newVal = this.props.val + 1;
            this.setProps({val:newVal});
        },
        componentWillMount:function() {
            this.setState({m:2});
            if (this.props.val === 0) {
                this.btnStyle = {'color' : 'red'};
            }
        },
        render: function() {
            console.log(""hello world"");
            return &lt;button 
                        style={this.btnStyle}
                        onClick={this.update}&gt;
                        {this.props.val*this.state.m}
                    &lt;/button&gt;
        },
        componentDidMount:function(rootNode) {
            this.inc = setInterval(this.update, 500);
        },
        componentWillUnMount:function() {
            console.log(""goodbye cruel world!"");
            clearInterval(this.inc);
        }
    });
    window.render = function() {
        React.render(
            &lt;APP val={0} /&gt;,
            document.getElementById('panel')
        );  
    };

    window.unmount = function() {
        React.unmountComponentAtNode(
            document.getElementById('panel')
        );  
    };

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>My result:</p>

<p><img src=""https://i.stack.imgur.com/v5Tgz.png"" alt=""enter image description here""></p>

<p>As you can see, somehow the unmount is not being called in order for me to clearInterval. Everything else is working though.</p>

<p>Where did I go wrong?</p>
",""
"29656743","I am having trouble passing in my backbone collection in to a react component","5","<p>my backbone collection collection doesn't populate when i just pass it in as props to a react component. I have tried first fetching the collection using componentDidmount and componentWillMount, but that still didn't populate the collection. If I test the code by setting a window variable pointing to DecksIndex and in the console tools call getInstance() and then fetch
,the data loads fine. my code is as follows:</p>

<pre><code> //router.js
var DeckComponent = require(""./views/deck.jsx"")
var DecksIndex = React.createFactory(require(""./views/decks.jsx""))
var decksCollection = require(""./component/collections/decks.js"");

module.exports = Backbone.Router.extend({

    initialize: function(){
        this.rootEl = document.getElementById('container');
    },

    routes: {
        """":""index"",
        ""decks/:id"":""deckShow""
    },

    index: function(){

        var decks = new DecksIndex({decks: decksCollection.getInstance()});
        this._swapView(decks)
        console.log(""hooray!"")
    },

    deckShow: function(id){
        //var deck = Flashcards.Collections.decks.getOrFetch(id);
        var showDeck = new DeckComponent();
        this._swapView(showDeck);
    },

    _swapView: function(view){
        if (this.currentView) {
            React.unmountComponentAtNode(this.rootEl);
        }
        this.currentView = view
        React.render(view, document.getElementById('container'));
    }   

});


//decks.js

var deck = require('../models/deck.js')
var decks = Backbone.Collection.extend({
  url: ""/api/decks"",
  model: deck,
  getOrFetch: function(id){
        var model = this.get(id);
        var that = this;
        if (model) {
            model.fetch();
        }else{
            model = new deck({id: id})
            model.fetch({
                success: function(){
                    that.add(model)
                }
            })
        }
        return model;
    },

    parse: function (data) {
        debugger;
        return data.objects
    },

});

decks.getInstance = _.memoize(function () {
  return new decks();
});

module.exports = decks;

//decks.jsx
var DecksList = React.createClass({

    render: function() {

            return (
              &lt;div className=""deck-list""&gt;
              {
                this.props.decks.map(function (deck) {
                    var title = deck.name
                    debugger;
                  return (
                    &lt;div key={deck.id} className=""note-summary""&gt;
                      {title}
                    &lt;/div&gt;
                  );
                })
              }
              &lt;/div&gt;
            );
      }
});

module.exports = DecksList;
</code></pre>
","Have you tried `SetInitialProps` to create `decks` and then fetched them on `componentDidMount`?"
"29656743","I am having trouble passing in my backbone collection in to a react component","5","<p>my backbone collection collection doesn't populate when i just pass it in as props to a react component. I have tried first fetching the collection using componentDidmount and componentWillMount, but that still didn't populate the collection. If I test the code by setting a window variable pointing to DecksIndex and in the console tools call getInstance() and then fetch
,the data loads fine. my code is as follows:</p>

<pre><code> //router.js
var DeckComponent = require(""./views/deck.jsx"")
var DecksIndex = React.createFactory(require(""./views/decks.jsx""))
var decksCollection = require(""./component/collections/decks.js"");

module.exports = Backbone.Router.extend({

    initialize: function(){
        this.rootEl = document.getElementById('container');
    },

    routes: {
        """":""index"",
        ""decks/:id"":""deckShow""
    },

    index: function(){

        var decks = new DecksIndex({decks: decksCollection.getInstance()});
        this._swapView(decks)
        console.log(""hooray!"")
    },

    deckShow: function(id){
        //var deck = Flashcards.Collections.decks.getOrFetch(id);
        var showDeck = new DeckComponent();
        this._swapView(showDeck);
    },

    _swapView: function(view){
        if (this.currentView) {
            React.unmountComponentAtNode(this.rootEl);
        }
        this.currentView = view
        React.render(view, document.getElementById('container'));
    }   

});


//decks.js

var deck = require('../models/deck.js')
var decks = Backbone.Collection.extend({
  url: ""/api/decks"",
  model: deck,
  getOrFetch: function(id){
        var model = this.get(id);
        var that = this;
        if (model) {
            model.fetch();
        }else{
            model = new deck({id: id})
            model.fetch({
                success: function(){
                    that.add(model)
                }
            })
        }
        return model;
    },

    parse: function (data) {
        debugger;
        return data.objects
    },

});

decks.getInstance = _.memoize(function () {
  return new decks();
});

module.exports = decks;

//decks.jsx
var DecksList = React.createClass({

    render: function() {

            return (
              &lt;div className=""deck-list""&gt;
              {
                this.props.decks.map(function (deck) {
                    var title = deck.name
                    debugger;
                  return (
                    &lt;div key={deck.id} className=""note-summary""&gt;
                      {title}
                    &lt;/div&gt;
                  );
                })
              }
              &lt;/div&gt;
            );
      }
});

module.exports = DecksList;
</code></pre>
","so should I update the component before I call _swapView in the router?"
"29656743","I am having trouble passing in my backbone collection in to a react component","5","<p>my backbone collection collection doesn't populate when i just pass it in as props to a react component. I have tried first fetching the collection using componentDidmount and componentWillMount, but that still didn't populate the collection. If I test the code by setting a window variable pointing to DecksIndex and in the console tools call getInstance() and then fetch
,the data loads fine. my code is as follows:</p>

<pre><code> //router.js
var DeckComponent = require(""./views/deck.jsx"")
var DecksIndex = React.createFactory(require(""./views/decks.jsx""))
var decksCollection = require(""./component/collections/decks.js"");

module.exports = Backbone.Router.extend({

    initialize: function(){
        this.rootEl = document.getElementById('container');
    },

    routes: {
        """":""index"",
        ""decks/:id"":""deckShow""
    },

    index: function(){

        var decks = new DecksIndex({decks: decksCollection.getInstance()});
        this._swapView(decks)
        console.log(""hooray!"")
    },

    deckShow: function(id){
        //var deck = Flashcards.Collections.decks.getOrFetch(id);
        var showDeck = new DeckComponent();
        this._swapView(showDeck);
    },

    _swapView: function(view){
        if (this.currentView) {
            React.unmountComponentAtNode(this.rootEl);
        }
        this.currentView = view
        React.render(view, document.getElementById('container'));
    }   

});


//decks.js

var deck = require('../models/deck.js')
var decks = Backbone.Collection.extend({
  url: ""/api/decks"",
  model: deck,
  getOrFetch: function(id){
        var model = this.get(id);
        var that = this;
        if (model) {
            model.fetch();
        }else{
            model = new deck({id: id})
            model.fetch({
                success: function(){
                    that.add(model)
                }
            })
        }
        return model;
    },

    parse: function (data) {
        debugger;
        return data.objects
    },

});

decks.getInstance = _.memoize(function () {
  return new decks();
});

module.exports = decks;

//decks.jsx
var DecksList = React.createClass({

    render: function() {

            return (
              &lt;div className=""deck-list""&gt;
              {
                this.props.decks.map(function (deck) {
                    var title = deck.name
                    debugger;
                  return (
                    &lt;div key={deck.id} className=""note-summary""&gt;
                      {title}
                    &lt;/div&gt;
                  );
                })
              }
              &lt;/div&gt;
            );
      }
});

module.exports = DecksList;
</code></pre>
","Is your collection async? Unless you update the component when the collection has updated, I wouldn't expect to see any of the list. You're also creating React components incorrectly. You should be using something more like: `React.createElement(DecksIndex, { decks: collection });`"
"29656743","I am having trouble passing in my backbone collection in to a react component","5","<p>my backbone collection collection doesn't populate when i just pass it in as props to a react component. I have tried first fetching the collection using componentDidmount and componentWillMount, but that still didn't populate the collection. If I test the code by setting a window variable pointing to DecksIndex and in the console tools call getInstance() and then fetch
,the data loads fine. my code is as follows:</p>

<pre><code> //router.js
var DeckComponent = require(""./views/deck.jsx"")
var DecksIndex = React.createFactory(require(""./views/decks.jsx""))
var decksCollection = require(""./component/collections/decks.js"");

module.exports = Backbone.Router.extend({

    initialize: function(){
        this.rootEl = document.getElementById('container');
    },

    routes: {
        """":""index"",
        ""decks/:id"":""deckShow""
    },

    index: function(){

        var decks = new DecksIndex({decks: decksCollection.getInstance()});
        this._swapView(decks)
        console.log(""hooray!"")
    },

    deckShow: function(id){
        //var deck = Flashcards.Collections.decks.getOrFetch(id);
        var showDeck = new DeckComponent();
        this._swapView(showDeck);
    },

    _swapView: function(view){
        if (this.currentView) {
            React.unmountComponentAtNode(this.rootEl);
        }
        this.currentView = view
        React.render(view, document.getElementById('container'));
    }   

});


//decks.js

var deck = require('../models/deck.js')
var decks = Backbone.Collection.extend({
  url: ""/api/decks"",
  model: deck,
  getOrFetch: function(id){
        var model = this.get(id);
        var that = this;
        if (model) {
            model.fetch();
        }else{
            model = new deck({id: id})
            model.fetch({
                success: function(){
                    that.add(model)
                }
            })
        }
        return model;
    },

    parse: function (data) {
        debugger;
        return data.objects
    },

});

decks.getInstance = _.memoize(function () {
  return new decks();
});

module.exports = decks;

//decks.jsx
var DecksList = React.createClass({

    render: function() {

            return (
              &lt;div className=""deck-list""&gt;
              {
                this.props.decks.map(function (deck) {
                    var title = deck.name
                    debugger;
                  return (
                    &lt;div key={deck.id} className=""note-summary""&gt;
                      {title}
                    &lt;/div&gt;
                  );
                })
              }
              &lt;/div&gt;
            );
      }
});

module.exports = DecksList;
</code></pre>
","Can you share your React component? Also, this article might be helpful: http://revelry.co/development/2014/11/11/getting-backbone-to-talk-to-react/"
"29656743","I am having trouble passing in my backbone collection in to a react component","5","<p>my backbone collection collection doesn't populate when i just pass it in as props to a react component. I have tried first fetching the collection using componentDidmount and componentWillMount, but that still didn't populate the collection. If I test the code by setting a window variable pointing to DecksIndex and in the console tools call getInstance() and then fetch
,the data loads fine. my code is as follows:</p>

<pre><code> //router.js
var DeckComponent = require(""./views/deck.jsx"")
var DecksIndex = React.createFactory(require(""./views/decks.jsx""))
var decksCollection = require(""./component/collections/decks.js"");

module.exports = Backbone.Router.extend({

    initialize: function(){
        this.rootEl = document.getElementById('container');
    },

    routes: {
        """":""index"",
        ""decks/:id"":""deckShow""
    },

    index: function(){

        var decks = new DecksIndex({decks: decksCollection.getInstance()});
        this._swapView(decks)
        console.log(""hooray!"")
    },

    deckShow: function(id){
        //var deck = Flashcards.Collections.decks.getOrFetch(id);
        var showDeck = new DeckComponent();
        this._swapView(showDeck);
    },

    _swapView: function(view){
        if (this.currentView) {
            React.unmountComponentAtNode(this.rootEl);
        }
        this.currentView = view
        React.render(view, document.getElementById('container'));
    }   

});


//decks.js

var deck = require('../models/deck.js')
var decks = Backbone.Collection.extend({
  url: ""/api/decks"",
  model: deck,
  getOrFetch: function(id){
        var model = this.get(id);
        var that = this;
        if (model) {
            model.fetch();
        }else{
            model = new deck({id: id})
            model.fetch({
                success: function(){
                    that.add(model)
                }
            })
        }
        return model;
    },

    parse: function (data) {
        debugger;
        return data.objects
    },

});

decks.getInstance = _.memoize(function () {
  return new decks();
});

module.exports = decks;

//decks.jsx
var DecksList = React.createClass({

    render: function() {

            return (
              &lt;div className=""deck-list""&gt;
              {
                this.props.decks.map(function (deck) {
                    var title = deck.name
                    debugger;
                  return (
                    &lt;div key={deck.id} className=""note-summary""&gt;
                      {title}
                    &lt;/div&gt;
                  );
                })
              }
              &lt;/div&gt;
            );
      }
});

module.exports = DecksList;
</code></pre>
","yea, the component is at the very bottom of the posted code"
"30359028","Progress Bar with react.js","5","<p>I'm trying to implement a progress bar, but react doesn't seem to like the idea. I get </p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>as an error, though the element is mounted at the time the function is called. Here's the code:</p>

<p>SocketAction.js</p>

<pre><code>var x = new MainApplication;
window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
    x.showProgress(event);
});
</code></pre>

<p>MainApplication.js</p>

<pre><code>showProgress(e){
    console.log(window.performance.now());
    this.setState({
        progressBar:{
            height:'4px',
            background: 'green',
            position:'absolute',
            left:250,
            top: 70,
            width: e + '%'
        }
    })
},
</code></pre>

<p>ProgressBar is in MainApplication.js:</p>

<pre><code>&lt;div style={this.state.progressBar}&gt;&lt;/div&gt;
</code></pre>

<p>The element's set initial state is this</p>

<pre><code>        progressBar:{
            height:'4px',
            background: 'green',
            width:1,
            position:'absolute',
            left:250,
            top: 70
        }
</code></pre>

<p>I don't get why it shouldn't be mounted... </p>

<p>EDIT:</p>

<p>This is the file that I pass to browserfy:</p>

<pre><code>import MainApplication from './project/MainApplication';
import MainSocketActions from './project/MainSocketActions';
React.render(&lt;MainApplication /&gt;, document.getElementById('content'));
</code></pre>

<p>Complete MainSocketAction.js:</p>

<pre><code>import MainApplication from './MainApplication';
var x = new MainApplication;

    window.socket = io('http://localhost:3000');
    window.socket.on('connect', function () {
    });
    window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
        x.showProgress(event);
    });
</code></pre>
","I figured as much, but I don't see `React.render(x, someNode);`"
"30359028","Progress Bar with react.js","5","<p>I'm trying to implement a progress bar, but react doesn't seem to like the idea. I get </p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>as an error, though the element is mounted at the time the function is called. Here's the code:</p>

<p>SocketAction.js</p>

<pre><code>var x = new MainApplication;
window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
    x.showProgress(event);
});
</code></pre>

<p>MainApplication.js</p>

<pre><code>showProgress(e){
    console.log(window.performance.now());
    this.setState({
        progressBar:{
            height:'4px',
            background: 'green',
            position:'absolute',
            left:250,
            top: 70,
            width: e + '%'
        }
    })
},
</code></pre>

<p>ProgressBar is in MainApplication.js:</p>

<pre><code>&lt;div style={this.state.progressBar}&gt;&lt;/div&gt;
</code></pre>

<p>The element's set initial state is this</p>

<pre><code>        progressBar:{
            height:'4px',
            background: 'green',
            width:1,
            position:'absolute',
            left:250,
            top: 70
        }
</code></pre>

<p>I don't get why it shouldn't be mounted... </p>

<p>EDIT:</p>

<p>This is the file that I pass to browserfy:</p>

<pre><code>import MainApplication from './project/MainApplication';
import MainSocketActions from './project/MainSocketActions';
React.render(&lt;MainApplication /&gt;, document.getElementById('content'));
</code></pre>

<p>Complete MainSocketAction.js:</p>

<pre><code>import MainApplication from './MainApplication';
var x = new MainApplication;

    window.socket = io('http://localhost:3000');
    window.socket.on('connect', function () {
    });
    window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
        x.showProgress(event);
    });
</code></pre>
","The div is inside MainApplication's render function @RobM."
"30359028","Progress Bar with react.js","5","<p>I'm trying to implement a progress bar, but react doesn't seem to like the idea. I get </p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>as an error, though the element is mounted at the time the function is called. Here's the code:</p>

<p>SocketAction.js</p>

<pre><code>var x = new MainApplication;
window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
    x.showProgress(event);
});
</code></pre>

<p>MainApplication.js</p>

<pre><code>showProgress(e){
    console.log(window.performance.now());
    this.setState({
        progressBar:{
            height:'4px',
            background: 'green',
            position:'absolute',
            left:250,
            top: 70,
            width: e + '%'
        }
    })
},
</code></pre>

<p>ProgressBar is in MainApplication.js:</p>

<pre><code>&lt;div style={this.state.progressBar}&gt;&lt;/div&gt;
</code></pre>

<p>The element's set initial state is this</p>

<pre><code>        progressBar:{
            height:'4px',
            background: 'green',
            width:1,
            position:'absolute',
            left:250,
            top: 70
        }
</code></pre>

<p>I don't get why it shouldn't be mounted... </p>

<p>EDIT:</p>

<p>This is the file that I pass to browserfy:</p>

<pre><code>import MainApplication from './project/MainApplication';
import MainSocketActions from './project/MainSocketActions';
React.render(&lt;MainApplication /&gt;, document.getElementById('content'));
</code></pre>

<p>Complete MainSocketAction.js:</p>

<pre><code>import MainApplication from './MainApplication';
var x = new MainApplication;

    window.socket = io('http://localhost:3000');
    window.socket.on('connect', function () {
    });
    window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
        x.showProgress(event);
    });
</code></pre>
","Did you mount the component? I don't see it mounted in the code you posted."
"30359028","Progress Bar with react.js","5","<p>I'm trying to implement a progress bar, but react doesn't seem to like the idea. I get </p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>as an error, though the element is mounted at the time the function is called. Here's the code:</p>

<p>SocketAction.js</p>

<pre><code>var x = new MainApplication;
window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
    x.showProgress(event);
});
</code></pre>

<p>MainApplication.js</p>

<pre><code>showProgress(e){
    console.log(window.performance.now());
    this.setState({
        progressBar:{
            height:'4px',
            background: 'green',
            position:'absolute',
            left:250,
            top: 70,
            width: e + '%'
        }
    })
},
</code></pre>

<p>ProgressBar is in MainApplication.js:</p>

<pre><code>&lt;div style={this.state.progressBar}&gt;&lt;/div&gt;
</code></pre>

<p>The element's set initial state is this</p>

<pre><code>        progressBar:{
            height:'4px',
            background: 'green',
            width:1,
            position:'absolute',
            left:250,
            top: 70
        }
</code></pre>

<p>I don't get why it shouldn't be mounted... </p>

<p>EDIT:</p>

<p>This is the file that I pass to browserfy:</p>

<pre><code>import MainApplication from './project/MainApplication';
import MainSocketActions from './project/MainSocketActions';
React.render(&lt;MainApplication /&gt;, document.getElementById('content'));
</code></pre>

<p>Complete MainSocketAction.js:</p>

<pre><code>import MainApplication from './MainApplication';
var x = new MainApplication;

    window.socket = io('http://localhost:3000');
    window.socket.on('connect', function () {
    });
    window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
        x.showProgress(event);
    });
</code></pre>
","@RobM. yeah, now I get it..."
"30359028","Progress Bar with react.js","5","<p>I'm trying to implement a progress bar, but react doesn't seem to like the idea. I get </p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>as an error, though the element is mounted at the time the function is called. Here's the code:</p>

<p>SocketAction.js</p>

<pre><code>var x = new MainApplication;
window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
    x.showProgress(event);
});
</code></pre>

<p>MainApplication.js</p>

<pre><code>showProgress(e){
    console.log(window.performance.now());
    this.setState({
        progressBar:{
            height:'4px',
            background: 'green',
            position:'absolute',
            left:250,
            top: 70,
            width: e + '%'
        }
    })
},
</code></pre>

<p>ProgressBar is in MainApplication.js:</p>

<pre><code>&lt;div style={this.state.progressBar}&gt;&lt;/div&gt;
</code></pre>

<p>The element's set initial state is this</p>

<pre><code>        progressBar:{
            height:'4px',
            background: 'green',
            width:1,
            position:'absolute',
            left:250,
            top: 70
        }
</code></pre>

<p>I don't get why it shouldn't be mounted... </p>

<p>EDIT:</p>

<p>This is the file that I pass to browserfy:</p>

<pre><code>import MainApplication from './project/MainApplication';
import MainSocketActions from './project/MainSocketActions';
React.render(&lt;MainApplication /&gt;, document.getElementById('content'));
</code></pre>

<p>Complete MainSocketAction.js:</p>

<pre><code>import MainApplication from './MainApplication';
var x = new MainApplication;

    window.socket = io('http://localhost:3000');
    window.socket.on('connect', function () {
    });
    window.socket.on('label-downloads:Shipping\\Events\\ShippingProgress',function(event){
        x.showProgress(event);
    });
</code></pre>
","I've posted an edit, I browserfy the files, there's the render function."
"30447767","how to remove / unmount nested react components","0","<p>I'd like to unmount a single react component, which belongs to a parent component containing three components total. The parent component has this render function:</p>

<pre><code>render: function () {
  return (
    &lt;div className={classes}&gt;
      &lt;Navbar ref=""navbar""/&gt;
      &lt;Home ref=""home""/&gt;
      &lt;Footer ref=""footer""/&gt;
    &lt;/div&gt;
),

handleNavbarClick: function () {
  // remove Home
}
</code></pre>

<p>if a user then clicks on a link in the navbar and I want to unmount the Home component, how would I do that? it seems like my only option is to do something like this (taken from <a href=""https://stackoverflow.com/questions/27227792/react-js-removing-a-component"">react.js: removing a component</a>), but this seems pretty gross:</p>

<pre><code>render: function () {
  var home = this.state.remove_home ? null : &lt;Home ref=""home /&gt;
  return (
    &lt;div className={classes}&gt;
      &lt;Navbar ref=""navbar""/&gt;
      {home}
      &lt;Footer ref=""footer""/&gt;
    &lt;/div&gt;
),

handleNavbarClick: function () {
  this.setState({remove_home: true});
}
</code></pre>

<p>Is that the appropriate react way to do things?</p>
",""
"30768595","react-native component lifecycle methods not firing on navigation","0","<p>I am having an issue where I setState in multiple components based on the same key in AsyncStorage. Since the state is set in componentDidMount, and these components don't necessarily unmount and mount on navigation, the state value and the AsyncStorage value can get out of sync. </p>

<p>Here is the simplest example I could make. </p>

<h2>Component A</h2>

<p>A just sets up the navigation and app.</p>

<pre class=""lang-js prettyprint-override""><code>var React = require('react-native');
var B = require('./B');

var {
    AppRegistry,
    Navigator
} = React;

var A = React.createClass({
    render() {
        return (
            &lt;Navigator
                initialRoute={{
                    component: B
                }}
                renderScene={(route, navigator) =&gt; {
                    return &lt;route.component navigator={navigator} /&gt;;
                }} /&gt;
        );
    }
});

AppRegistry.registerComponent('A', () =&gt; A);
</code></pre>

<h2>Component B</h2>

<p>B reads from AsyncStorage on mount, and then sets to state.</p>

<pre class=""lang-js prettyprint-override""><code>var React = require('react-native');
var C = require('./C');

var {
    AsyncStorage,
    View,
    Text,
    TouchableHighlight
} = React;

var B = React.createClass({
    componentDidMount() {
        AsyncStorage.getItem('some-identifier').then(value =&gt; {
            this.setState({
                isPresent: value !== null
            });
        });
    },

    getInitialState() {
        return {
            isPresent: false
        };
    },

    goToC() {
        this.props.navigator.push({
            component: C
        });
    },

    render() {
        return (
            &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
                &lt;Text&gt;
                    {this.state.isPresent
                        ? 'Value is present'
                        : 'Value is not present'}
                &lt;/Text&gt;

                &lt;TouchableHighlight onPress={this.goToC}&gt;
                    &lt;Text&gt;Click to go to C&lt;/Text&gt;
                &lt;/TouchableHighlight&gt;
            &lt;/View&gt;
        );
    }
});

module.exports = B;
</code></pre>

<h2>Component C</h2>

<p>C reads the same value from AsyncStorage as B, but allows you to change the value. Changing toggles both the value in state and in AsyncStorage. </p>

<pre class=""lang-js prettyprint-override""><code>var React = require('react-native');
var {
    AsyncStorage,
    View,
    Text,
    TouchableHighlight
} = React;

var C = React.createClass({
    componentDidMount() {
        AsyncStorage.getItem('some-identifier').then(value =&gt; {
            this.setState({
                isPresent: value !== null
            });
        });
    },

    getInitialState() {
        return {
            isPresent: false
        };
    },

    toggle() {
        if (this.state.isPresent) {
            AsyncStorage.removeItem('some-identifier').then(() =&gt; {
                this.setState({
                    isPresent: false
                });
            })
        } else {
            AsyncStorage.setItem('some-identifier', 'some-value').then(() =&gt; {
                this.setState({
                    isPresent: true
                });
            });
        }
    },

    goToB() {
        this.props.navigator.pop();
    },

    render() {
        return (
            &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
                &lt;Text&gt;
                    {this.state.isPresent
                        ? 'Value is present'
                        : 'Value is not present'}
                &lt;/Text&gt;

                &lt;TouchableHighlight onPress={this.toggle}&gt;
                    &lt;Text&gt;Click to toggle&lt;/Text&gt;
                &lt;/TouchableHighlight&gt;

                &lt;TouchableHighlight onPress={this.goToB}&gt;
                    &lt;Text&gt;Click to go back&lt;/Text&gt;
                &lt;/TouchableHighlight&gt;
            &lt;/View&gt;
        );
    }
});

module.exports = C;
</code></pre>

<p>If you toggle in C and then return to B, the state in B and value in AsyncStorage are now out of sync. As far as I can tell, navigator.pop() does not trigger any component lifecycle functions I can use to tell B to refresh the value. </p>

<p>One solution I am aware of, but isn't ideal, is to make B's state a prop to C, and give C a callback prop to toggle it. That would work well if B and C would always be directly parent and child, but in a real app, the navigation hierarchy could be much deeper. </p>

<p>Is there anyway to trigger a function on a component after a navigation event, or something else that I'm missing? </p>
",""
"32494034","react-router not waiting for animation before changing route","2","<p>A <a href=""https://jsfiddle.net/69z2wepo/15832/"">sample jsfiddle is here</a> that demonstrates my problem.</p>

<p><em>Hello</em> and <em>World</em> links change the routes. The animation has been applied on Hello route when it leaves. Actually, the transition is set up such that when the <code>Hello</code> page leaves, it asks it child component <code>&lt;h1&gt;</code> to animate in its own <code>componentWillLeave</code>, completing which it can unmount happily. I did this because in my real app, when the Hello page leaves, its child components are required to animate in different ways - so its not a single transition for the full page.</p>

<p>To see the problem, click on <em>Hello</em> to load <code>Hello</code> page. Then click on <em>World</em> link for the <code>World</code> page. You will see that the <code>World</code> page is loaded even while the <code>Hello</code> is animating. </p>

<p>So how do I make the <code>World</code> wait for the animation to complete?
Another thing I want to confirm is if the approach I employed to make the child component animate before the parent component leaves is correct or not.</p>

<p>For reference, I am using the latest <em>react-router</em> in <em>master</em> branch: <code>1.0b4</code></p>
","@xcatliu Thanks for pointing out. react-router has a fast-changing github repo which 404'd my links, and there are no cdn hosting this beta version. Anyway, I have updated the jsfiddle linked to my own repo. [Here is the link for the same](https://jsfiddle.net/69z2wepo/15832/)"
"32494034","react-router not waiting for animation before changing route","2","<p>A <a href=""https://jsfiddle.net/69z2wepo/15832/"">sample jsfiddle is here</a> that demonstrates my problem.</p>

<p><em>Hello</em> and <em>World</em> links change the routes. The animation has been applied on Hello route when it leaves. Actually, the transition is set up such that when the <code>Hello</code> page leaves, it asks it child component <code>&lt;h1&gt;</code> to animate in its own <code>componentWillLeave</code>, completing which it can unmount happily. I did this because in my real app, when the Hello page leaves, its child components are required to animate in different ways - so its not a single transition for the full page.</p>

<p>To see the problem, click on <em>Hello</em> to load <code>Hello</code> page. Then click on <em>World</em> link for the <code>World</code> page. You will see that the <code>World</code> page is loaded even while the <code>Hello</code> is animating. </p>

<p>So how do I make the <code>World</code> wait for the animation to complete?
Another thing I want to confirm is if the approach I employed to make the child component animate before the parent component leaves is correct or not.</p>

<p>For reference, I am using the latest <em>react-router</em> in <em>master</em> branch: <code>1.0b4</code></p>
","The jsfiddle imported two 404 files, please fix the issue."
"32494407","unit testing a react component with mocha","0","<p>I'm working through a TodoMVC example for the <a href=""http://rackt.github.io/redux/"" rel=""nofollow"">Redux</a> ecosystem. I've completed working code for the example and am now working through the creation of tests for each of the elements of the application.</p>

<p>For actions and reducers, the testing is very straightforward, but for the components, writing tests has proven somewhat more challenging.</p>

<p>My general component architecture looks like this:</p>

<pre><code>Home.js
      \-App.js
              \-TodoList.js
                          \-TodoItem.js
                                       \-TodoInput.js
</code></pre>

<p>Writing the unit tests for TodoInput.js has been relatively straightforward:</p>

<p>TodoInput.js:</p>

<pre><code>handleChange(e) {
    this.setState({ text: e.target.value });
  }

...

  render() {

    return (
      &lt;input type=""text"" autoFocus='true'
            className={classnames({
              edit: this.props.editing,
              'new-todo': this.props.newTodo
             })}
            value={this.state.text}
            placeholder={this.props.placeholder}
            onKeyDown={this.handleKeyDown.bind(this)}
            onBlur={this.handleBlur.bind(this)}
            onChange={this.handleChange.bind(this)}&gt;
      &lt;/input&gt;
    );
  }
</code></pre>

<p>TodoInput-test.js:</p>

<pre><code>const mockedTodo = {
  text: 'abc123',
  complete: false
};


it(`should update text from user input`, () =&gt; {
      const component = TestUtils.renderIntoDocument(
        &lt;TodoInput
          text = {mockedTodo.text}
          editing = {false}
          onSave = {_.noop}
        /&gt;
      );

      const inputComponent = TestUtils.findRenderedDOMComponentWithTag(component, 'input');

      expect(React.findDOMNode(inputComponent).value).toBe(mockedTodo.text);

      TestUtils.Simulate.change(React.findDOMNode(inputComponent), {target: {value: ""newValue""}});

      expect(React.findDOMNode(inputComponent).value).toBe(""newValue"");

      React.unmountComponentAtNode(React.findDOMNode(component));
});
</code></pre>

<p>But for TodoItem.js, testing has been a little trickier.</p>

<p>The render code branches based on whether or not an <code>editing</code> flag has been set on the item:</p>

<p>TodoItem.js:</p>

<pre><code>import React, { Component, PropTypes } from 'react';
import TodoInput from './TodoInput';
import classnames from 'classnames';

export default class TodoItem extends Component {

  static propTypes = {
    todo: PropTypes.object.isRequired,
    editTodo: PropTypes.func.isRequired,
    markTodoAsComplete: PropTypes.func.isRequired,
    deleteTodo: PropTypes.func.isRequired
  }

  constructor(props, context) {
    super(props, context);
    this.state = {
      editing: false
    };
  }

  handleDoubleClick() {
    this.setState({ editing: true });
  }


  handleSave(id, text) {
    if (text.length === 0) {
      this.props.deleteTodo(id);
    } else {
      this.props.editTodo(id, text);
    }
    this.setState({ editing: false });
  }

  render() {
    const {todo, markTodoAsComplete, deleteTodo} = this.props;
    let element;

    if (this.state.editing) {
      element = (
        &lt;TodoInput text={todo.text}
                       editing={this.state.editing}
                       onSave={(text) =&gt; this.handleSave(todo.id, text)} /&gt;
      );
    } else {
      element = (
        &lt;div className='view'&gt;
          &lt;label onDoubleClick={this.handleDoubleClick.bind(this)}&gt;
            {todo.text}
          &lt;/label&gt;
          &lt;input className='markComplete'
                 type='checkbox'
                 checked={todo.complete}
                 onChange={() =&gt; markTodoAsComplete(todo)} /&gt;
          &lt;button className='destroy'
                  onClick={() =&gt; deleteTodo(todo)} /&gt;
        &lt;/div&gt;
      );
    }

    return (
      &lt;li className={classnames({
        completed: todo.complete,
        editing: this.state.editing
      })}&gt;
        {element}
      &lt;/li&gt;
    )
  }
}
</code></pre>

<p>I'm a little stumped on how to go about writing a test that, for instance, would verify that a double-click on the component had successfully set the state to <code>editing: true</code>. </p>

<p>Typically, I have my tests divided into two parts, ""rendering"" and ""events"", i.e. for TodoItem-test.js:</p>

<pre><code>import React, { addons } from 'react/addons';
import _ from 'lodash';
import expect from 'expect';
const { TestUtils } = addons;

import TodoItem from '../TodoItem';

describe('TodoItem', () =&gt; {

  const mockedTodo = {
    text: 'abc123',
    complete: false
  };

describe('rendering', () =&gt; {
    let component;

    before(() =&gt; {
      component = TestUtils.renderIntoDocument(
        &lt;TodoItem
          todo={mockedTodo}
          editTodo={_.noop}
          markTodoAsComplete={_.noop}
          deleteTodo={_.noop}
        /&gt;
      );
    });

    afterEach(() =&gt; {
      React.unmountComponentAtNode(React.findDOMNode(component));
    });

    it('should render the element', () =&gt; {
      const liComponent = TestUtils.findRenderedDOMComponentWithTag(component, 'li');

      expect(liComponent).toExist();
    });

    it('should render text in label', () =&gt; {
      const labelComponent = TestUtils.findRenderedDOMComponentWithTag(component, 'label');

      expect(labelComponent).toExist();
      expect(React.findDOMNode(labelComponent).textContent).toEqual('abc123');
    });
  });

 describe('events', () =&gt; {
  ...

});
</code></pre>

<p>but in this case, I want to see if double-clicking on the component leads to the following:</p>

<ol>
<li>the component state should now have an <code>editing</code> flag associated with it</li>
<li>the <code>element</code> should have changed, and <code>TodoItem.js</code> should now render a <code>&lt;TodoInput/&gt;</code> component instead.</li>
</ol>

<p>What is the most efficient way to structure a test against this expected behavior? I am thinking that I should do two things:</p>

<p>First, test to see if a double-click on the component adds the expected <code>""editing: true""</code> flag. <strong>I am not sure how to do this</strong>. If I set up a test as follows:</p>

<pre><code>describe('events', () =&gt; {
    let component;
    let deleteTodoCallback = sinon.stub();

    beforeEach(() =&gt; {
      component = TestUtils.renderIntoDocument(
        &lt;TodoItem
          todo={mockedTodo}
          editTodo={_.noop}
          markTodoAsComplete={_.noop}
          deleteTodo={deleteTodoCallback}
        /&gt;
      );
    });

    afterEach(() =&gt; {
      React.unmountComponentAtNode(React.findDOMNode(component));
    });

    it(`should change the editing state to be true if a user double-clicks
          on the todo`, () =&gt; {

        const liComponent = TestUtils.findRenderedDOMComponentWithTag(component, 'li');

        // expect the editing flag to be false

        TestUtils.Simulate.doubleClick(React.findDOMNode(liComponent));

        // expect the editing flag to be true

    });
  });
</code></pre>

<p><strong>how do I go about testing to ensure that the editing flag has been set?</strong> <code>liComponent.props.editing</code> returns <code>undefined.</code></p>

<p>Second, have a <code>context(""if the component is editing mode"")</code> that tests to make sure that the following has been rendered correctly:</p>

<pre><code>  &lt;li className={classnames({
    completed: todo.complete,
    editing: this.state.editing
  })}&gt;
      &lt;TodoInput text={todo.text}
                   editing={this.state.editing}
                   onSave={(text) =&gt; this.handleSave(todo.id, text)} /&gt;
  &lt;/li&gt;
</code></pre>

<p>I'm also not sure how I would go about testing this rigorously as well.</p>
",""
"32903001","React - setState() on unmounted component","2","<p>In my react component im trying to implement a simple spinner while an ajax request is in progress - im using state to store the loading status. </p>

<p>For some reason this piece of code below in my React component throws this error </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means
  you called setState() on an unmounted component. This is a no-op.
  Please check the code for the undefined component.</p>
</blockquote>

<p>If I get rid of the first setState call the error goes away.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>constructor(props) {
  super(props);
  this.loadSearches = this.loadSearches.bind(this);

  this.state = {
    loading: false
  }
}

loadSearches() {

  this.setState({
    loading: true,
    searches: []
  });

  console.log('Loading Searches..');

  $.ajax({
    url: this.props.source + '?projectId=' + this.props.projectId,
    dataType: 'json',
    crossDomain: true,
    success: function(data) {
      this.setState({
        loading: false
      });
    }.bind(this),
    error: function(xhr, status, err) {
      console.error(this.props.url, status, err.toString());
      this.setState({
        loading: false
      });
    }.bind(this)
  });
}

componentDidMount() {
  setInterval(this.loadSearches, this.props.pollInterval);
}

render() {

    let searches = this.state.searches || [];


    return (&lt;div&gt;
          &lt;Table striped bordered condensed hover&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Name&lt;/th&gt;
              &lt;th&gt;Submit Date&lt;/th&gt;
              &lt;th&gt;Dataset &amp;amp; Datatype&lt;/th&gt;
              &lt;th&gt;Results&lt;/th&gt;
              &lt;th&gt;Last Downloaded&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          {
          searches.map(function(search) {

                let createdDate = moment(search.createdDate, 'X').format(""YYYY-MM-DD"");
                let downloadedDate = moment(search.downloadedDate, 'X').format(""YYYY-MM-DD"");
                let records = 0;
                let status = search.status ? search.status.toLowerCase() : ''

                return (
                &lt;tbody key={search.id}&gt;
                  &lt;tr&gt;
                    &lt;td&gt;{search.name}&lt;/td&gt;
                    &lt;td&gt;{createdDate}&lt;/td&gt;
                    &lt;td&gt;{search.dataset}&lt;/td&gt;
                    &lt;td&gt;{records}&lt;/td&gt;
                    &lt;td&gt;{downloadedDate}&lt;/td&gt;
                  &lt;/tr&gt;
                &lt;/tbody&gt;
              );
          }
          &lt;/Table &gt;
          &lt;/div&gt;
      );
  }</code></pre>
</div>
</div>
</p>

<p>The question is why am I getting this error when the component should already be mounted (as its being called from componentDidMount) I thought it was safe to set state once the component is mounted ?</p>
","in my constructor i am setting ""this.loadSearches = this.loadSearches.bind(this);"" - ill add that to the question"
"32903001","React - setState() on unmounted component","2","<p>In my react component im trying to implement a simple spinner while an ajax request is in progress - im using state to store the loading status. </p>

<p>For some reason this piece of code below in my React component throws this error </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means
  you called setState() on an unmounted component. This is a no-op.
  Please check the code for the undefined component.</p>
</blockquote>

<p>If I get rid of the first setState call the error goes away.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>constructor(props) {
  super(props);
  this.loadSearches = this.loadSearches.bind(this);

  this.state = {
    loading: false
  }
}

loadSearches() {

  this.setState({
    loading: true,
    searches: []
  });

  console.log('Loading Searches..');

  $.ajax({
    url: this.props.source + '?projectId=' + this.props.projectId,
    dataType: 'json',
    crossDomain: true,
    success: function(data) {
      this.setState({
        loading: false
      });
    }.bind(this),
    error: function(xhr, status, err) {
      console.error(this.props.url, status, err.toString());
      this.setState({
        loading: false
      });
    }.bind(this)
  });
}

componentDidMount() {
  setInterval(this.loadSearches, this.props.pollInterval);
}

render() {

    let searches = this.state.searches || [];


    return (&lt;div&gt;
          &lt;Table striped bordered condensed hover&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;Name&lt;/th&gt;
              &lt;th&gt;Submit Date&lt;/th&gt;
              &lt;th&gt;Dataset &amp;amp; Datatype&lt;/th&gt;
              &lt;th&gt;Results&lt;/th&gt;
              &lt;th&gt;Last Downloaded&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          {
          searches.map(function(search) {

                let createdDate = moment(search.createdDate, 'X').format(""YYYY-MM-DD"");
                let downloadedDate = moment(search.downloadedDate, 'X').format(""YYYY-MM-DD"");
                let records = 0;
                let status = search.status ? search.status.toLowerCase() : ''

                return (
                &lt;tbody key={search.id}&gt;
                  &lt;tr&gt;
                    &lt;td&gt;{search.name}&lt;/td&gt;
                    &lt;td&gt;{createdDate}&lt;/td&gt;
                    &lt;td&gt;{search.dataset}&lt;/td&gt;
                    &lt;td&gt;{records}&lt;/td&gt;
                    &lt;td&gt;{downloadedDate}&lt;/td&gt;
                  &lt;/tr&gt;
                &lt;/tbody&gt;
              );
          }
          &lt;/Table &gt;
          &lt;/div&gt;
      );
  }</code></pre>
</div>
</div>
</p>

<p>The question is why am I getting this error when the component should already be mounted (as its being called from componentDidMount) I thought it was safe to set state once the component is mounted ?</p>
","have you tried setting **loading** to null in your constructor? That might work. `this.state = { loading : null };`"
"34805462","The correct way of developing a react-native app","0","<p>I am a react-native newbie. I am wondering if there is a ""correct"" way to develop a react-native app? As the documentation is still very insufficient, I am afraid I may develop it in the very incorrect manner, and I prefer correct the mistake now, rather than after the project expands. From what I understand from my previous experience, we should not combine all pages in a single .js file, but how can each component communicate with each other?</p>

<p>I am currently doing like this inside index.android.js:</p>

<pre><code>import Login from './Login';
import Register from './Register';
import Home from './Home';

class TheProject extends Component {
    renderScene (route, navigator) {
        _navigator = navigator;
        switch (route.index) {
            case 'Login':
                return (
                    &lt;View style={styles.container}&gt;
                        &lt;Login navigator={navigator} /&gt;
                    &lt;/View&gt;
                );
            case 'Register':
                return (
                    &lt;View style={styles.container}&gt;
                        &lt;Register navigator={navigator} /&gt;
                    &lt;/View&gt;
                );
        }
    }
    render() {
        return (
            &lt;Navigator
                initialRoute={{index: 'Login'}}
                renderScene={this.renderScene}
            /&gt;
        );
    }
}

var styles = StyleSheet.create({
    container: {
        flex: 1,
        justifyContent: 'space-around',
        backgroundColor: '#F0F0F0',
        flexWrap:'wrap'
    },
});

AppRegistry.registerComponent('TheProject', function() { return TheProject });
module.exports = TheProject;
</code></pre>

<p>and in my Login.js (other.js file will be similar):</p>

<pre><code>export default class Login extends React.Component {
    constructor(props) {
        super(props);
        this.state = { 
            username: '',
            password: '',
        };
    }
    registerOnPress() {
        this.props.navigator.push({
            index: 'Register'
        });
    }
    loginOnPress() {
        if (this.state.username != '' &amp;&amp;  this.state.password != '') {
            Alert.alert('Success!', 'Successfully logged in.');
            this.props.navigator.push({
                index: 'Home'
            });
        } else {
            Alert.alert('Failed to log-in', 'Wrong username or password');
        }
    }
    render () {
        return (
            &lt;View style={styles.individualContainer}&gt;
                &lt;View style={styles.content}&gt;
                    &lt;View style={styles.formField}&gt;
                        &lt;View style={styles.input}&gt;
                            &lt;Text style={styles.label}&gt;Username : &lt;/Text&gt;
                            &lt;View style={styles.fieldBox}&gt;
                                &lt;TextInput 
                                    style={styles.field}
                                    underlineColorAndroid={'transparent'}
                                    onChangeText={(data) =&gt; this.setState({ username: data })}
                                /&gt;
                            &lt;/View&gt;
                        &lt;/View&gt;
                        &lt;View style={styles.input}&gt;
                            &lt;Text style={styles.label}&gt;Password : &lt;/Text&gt;
                            &lt;View style={styles.fieldBox}&gt;
                                &lt;TextInput 
                                    style={styles.field}
                                    underlineColorAndroid={'transparent'}
                                    secureTextEntry={true}
                                    onChangeText={(data) =&gt; this.setState({ password: data })}
                                /&gt;
                            &lt;/View&gt;
                        &lt;/View&gt;
                    &lt;/View&gt;
                    &lt;View style={styles.input}&gt;
                        &lt;TouchableHighlight style={styles.buttonBox} onPress={this.loginOnPress.bind(this)}&gt;
                            &lt;Text style={styles.buttonText}&gt;Login&lt;/Text&gt;
                        &lt;/TouchableHighlight&gt;
                    &lt;/View&gt;
                    &lt;View style={styles.input}&gt;
                        &lt;TouchableHighlight style={styles.buttonBox} onPress={this.registerOnPress.bind(this)}&gt;
                            &lt;Text style={styles.buttonText}&gt;Register&lt;/Text&gt;
                        &lt;/TouchableHighlight&gt;
                    &lt;/View&gt;
                &lt;/View&gt;
            &lt;/View&gt;
        );
    }
}
</code></pre>

<p>I know there are a lot of ways to develop, but am I on the right track? I am quite blurred when it comes to component mount and unmount.</p>
",""
"34996916","Going to another route must unmount current route component","0","<p>Here is my use case, I made a simple example in order to ask this question, let's say I have two routes, /view1 and /view2, each mounting a component, View1 and View2, I need View1 to unmount when I go to /view2.</p>

<p>Here is the code if you want to try:
<div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import ReactDOM from 'react-dom';
import {Router, Route, Link, browserHistory} from 'react-router';
import Portal from 'react-portal';

class View1 extends React.Component {
    constructor(context, props) {
        super(context, props)
    }

    componentDidMount() {
        console.log('view 1 mounted');
    }

    componentWillUnmout() {
        console.log('view 1 unmount');
    }

    render() {
        return (
            &lt;h2&gt;hanta&lt;/h2&gt;
        );
    }
}

class View2 extends React.Component {
    constructor(context, props) {
        super(context, props)
    }

    componentDidMount() {
        console.log('view 2 mounted');
    }

    componentWillUnmout() {
        console.log('view 2 unmount');
    }

    render() {
        return (
            &lt;h2&gt;View 2&lt;/h2&gt;
        );
    }
}

class View extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt;View&lt;/h1&gt;
                &lt;Link to=""/view1""&gt;view 1&lt;/Link&gt;
                &lt;Link to=""/view2""&gt;view 2&lt;/Link&gt;
                {this.props.children}
            &lt;/div&gt;
        );
    }
}

ReactDOM.render(
    &lt;Router history={browserHistory}&gt;
        &lt;Route path=""/"" component={View}&gt;
            &lt;Route path=""/view1"" component={View1} /&gt;
            &lt;Route path=""/view2"" component={View2} /&gt;
        &lt;/Route&gt;
    &lt;/Router&gt; 
    , document.getElementById(""container""))</code></pre>
</div>
</div>
</p>

<p>ComponentWillUnmout doesn't get called in any case, I'm using:</p>

<p>├── react@0.14.6</p>

<p>├── react-dom@0.14.6</p>

<p>├── react-router@2.0.0-rc5</p>
",""
"35485741","Unable to set the key for react.js components","0","<p>Once again, what seems like the most trivial of tasks has brought my project to a halt. Here is my situation:</p>

<p>I'm using react.js inside an ASP.NET 4.5 MVC 6 SPA. I have designed such that I have three main areas where I use react: a top menu, a side menu and a main content area. Because of the timing and loading requirements of the different areas, i have 3 separate react component hierarchies, one for each major section. Perhaps that is part of the issue right there, but somewhere i got the idea that this is allowable. </p>

<p>So at a point, I pull a list of top menu nodes from a web service, and bind them to a top menu react component, then do the same for the side menu. When someone clicks on one of the menu items, it loads new data into the content panel area, and these are react components which i load into a div.</p>

<p>Everything works as expected to a point, until i attempt to unload the component in the content panel, before i load a new one into it. When i call <code>ReactDOM.unmountComponentAtNode()</code> passing in my div I get the following: </p>

<p><code>Uncaught Error: Invariant Violation: ReactMount: Two valid but unequal nodes with the same</code>data-reactid<code>: .0(…)</code></p>

<p>I have a couple of qualms at this point: </p>

<ul>
<li>first off i don't understand why it seems to be looking everywhere in the DOM for react nodes, when I've passed in a specific element i want unmounted. within the scope of the DOM element i've specified there's only one react component; i would expect that to suffice.</li>
<li><p>secondly, my many attempts to set specific keys on the top-level react components have failed. I read and understand the advice/rule that you have to set the key from outside the component as you create it, and not directly on the elements from inside, so my components are created as: </p>

<p><code>ReactDom.render(&lt;ManageCommunitiesContainer brandData={mcmData} key=""manageComms"" /&gt;, $(""#reactRoot"")[0]);</code></p></li>
</ul>

<p>i've added unique keys to each of the three top-level components i'm using, and yet when i inspect them in the react plug-in for chrome's developer tools, all 3 have the same <code>data-reactid</code>, which is simply '.0'.</p>

<p>I have set keys on child objects from inside react within loops with no issues. But on my top-level components added via javascript nothing i do results in them having meaningful run-time values...what does a person have to do to assign unique keys to root components, and thus be able to un-mount them later? because i can't un-mount them, they're piling up in memory. </p>

<p>thanks.</p>
",""
"36011222","Managing form validation in react - Trying to relegate validation to subcomponents","0","<p>I have a form in react, which is huge. It has around 80 fields and when checking/unchecking some checkbox, fields are mounted or unmounted.</p>

<p>I've got one problem when I want to warn of an error in one of this fields.</p>

<p>The structure of this form is something like this:</p>

<pre class=""lang-js prettyprint-override""><code>//parentNode.js
render: function() {
  if(this.refs.tab1 &amp;&amp; this.refs.tab1.isError()) var tab1icon = &lt;img src=""my..""/&gt;
  if(this.refs.tab2 &amp;&amp; this.refs.tab2.isError()) var tab2icon = &lt;img src=""my..""/&gt;
  if(this.refs.tab3 &amp;&amp; this.refs.tab3.isError()) var tab3icon = &lt;img src=""my..""/&gt;

  return(
    &lt;div&gt;
      &lt;tab1&gt;
        {tab1icon}
        &lt;subform ref=""tab1"" data={this.state.form.tab1}/&gt;
      &lt;/tab1&gt;
      &lt;tab2&gt;
        {tab2icon}
        &lt;subform ref=""tab2"" data={this.state.form.tab2}/&gt;
      &lt;/tab2&gt;
      &lt;tab3&gt;
        {tab3icon}
        &lt;subform ref=""tab3"" data={this.state.form.tab3}/&gt;
      &lt;/tab3&gt;
    &lt;/div&gt;
  );
},


//middleNode.js

isError: function() {
  for (field in this.refs) {
     //... Filter prototype properties.
     if(this.refs[field].isError()) return true;
  }
  return false;
}


//leafNode.js

isError: function() {
  //Validate this.refs.myLeafNode.getValue()
}
</code></pre>

<p>The problem here is that, I'm checking for errors before this tabs are re-rendered so if some fields are going to be unmounted isError is going to validate them. Suppose one of those fields contains a non-valid value, after unmounting it this value is no-longer important, but with this solution the Error Icon will be shown.</p>

<p>So, which is the best way of implementing this kind of validation? 
I try to relegate the responsability of managing each subform to its react component because as I said this form is very complex and differnt subforms have different rules.</p>
",""
"36358671","Using react's context to allow rendering of a child component into a parent/grandparent/great-grandparent.... Anti-pattern?","2","<p>I have a proof of concept for this, which seems to work, but a part of me is wondering if this is really a good idea and if there is perhaps a better solution out there using something like Redux or an alternative strategy.</p>

<p><strong>The Problem</strong></p>

<p>Basically, I have a base React component for my entire application which has a bunch of typical components that you might expect, header, menu, footer etc etc.</p>

<p>Further down my tree (much further) I have a component for which it would be awesome if I could mount a new menu item for within my header component.  The header component of course lives right at the top of my application so access is denied.  </p>

<p>That is just one such example, but it's a problem case I have hit from many angles.</p>

<p><strong>My Crazy Solution</strong></p>

<p>I looked into using React's context in order to expose functions that would to allow child components to declare any additional elements they would like to appear within the header.  </p>

<p>After playing around with the concept I eventually refactored it into a pretty generic solution that is essentially a React Element messaging system. There are three parts to this solution.</p>

<p><em>1. The Provider</em></p>

<p>Single instance component much in the same vein as Redux's Connect component. She's essentially the engine that receives and passes the messages along.  Her basic structure (Context focused) is:</p>

<pre><code>class ElementInjectorProvider extends Component {
  childContextTypes: {

    // :: (namespace, [element]) -&gt; void
    produceElements: PropTypes.func.isRequired,

    // :: (namespace, [element]) -&gt; void
    removeElements: PropTypes.func.isRequired,

    // :: (listener, namespace, ([element]) -&gt; void) -&gt; void
    consumeElements: PropTypes.func.isRequired,

    // :: (listener) -&gt; void
    stopConsumingElements: PropTypes.func.isRequired,

  }

  /* ... Implementation ... */
}
</code></pre>

<p><em>2. The Producer</em></p>

<p>A higher order component.  Each instance can ""produce"" elements via the <code>produceElements</code> context item, providing elements for a specific namespace, and then remove the elements (in case of component unmount) via <code>removeElements</code>.</p>

<pre><code>function ElementInjectorProducer(config) {
  const { namespace } = config;

  return function WrapComponent(WrappedComponent) {
    class ElementInjectorConsumerComponent {
      contextTypes = {
        produceElements: PropTypes.func.isRequired,
        removeElements: PropTypes.func.isRequired
      }

      /* ... Implementation ... */
    }

    return ElementInjectorProducerComponent;
  };
}
</code></pre>

<p><em>3. The Consumer</em></p>

<p>A higher order component. Each instance is configured to ""watch"" for elements attached to a given namespace.  It uses <code>consumeElements</code> to ""start"" the listening via a callback function registration and <code>stopConsumingElements</code> to deregister the consumption.</p>

<pre><code>function ElementInjectorConsumer(config) {
  const { namespace } = config;

  return function WrapComponent(WrappedComponent) {
    class ElementInjectorConsumerComponent {
      contextTypes = {
        consumeElements: PropTypes.func.isRequired,
        stopConsumingElements: PropTypes.func.isRequired
      }

      /* ... Implementation ... */
    }

    return ElementInjectorConsumerComponent;
  };
}
</code></pre>

<hr>

<p>That's a rough overview of what I am intending on doing.  Basically it's a messaging system when you look at it.  And perhaps could be abstracted even further.</p>

<p>I already have redux in play, and guess what Redux is good for?  So I can't help but feel that although this is working for me, perhaps it's not a good design and that I have inadvertently stood on Redux's toes or produced a general anti-pattern.</p>

<p>I guess the only reason I didn't jump straight into using Redux for this is is that because I am producing Elements, not simple state.  I could go down the route of creating element descriptor objects and then pass that down through Redux, but that's complicated in itself.</p>

<hr>

<p>Any words of wisdom? </p>

<hr>

<p><strong>UPDATE No 1</strong></p>

<p>Some additional clarification on the above.  </p>

<p>This allows me to inject Elements both up and down, and even left to right, on my full component tree.  I know most React Context examples describe the injection of data from a Grandparent into a Grandchild component.</p>

<p>Also, I would want the above implementation to abstract away from the developer any knowledge of Context usage.  In fact I would most likely use these HOFS to create additional wrappers that are specific to use cases and far more explicit.</p>

<p>i.e. </p>

<p>A consumer implementation:</p>

<pre><code>&lt;InjectableHeader /&gt;
</code></pre>

<p>A producer implementation:</p>

<pre><code>InjectIntoHeader(&lt;FooButton /&gt;)(FooPage)
</code></pre>

<p>It's pretty explicitly I think and easy to follow.  I do like that I can create the button where it is most cared about which grants me the ability to create stronger relationships with it's peers.</p>

<p>I also get that redux flow is probably the right idea.  It just feels like I make it a lot harder for myself - I can't help but think there may be some merit to this technique.</p>

<p>Is there any reason this is specifically a bad idea?</p>

<hr>

<p><strong>UPDATE No 2</strong></p>

<p>Ok, I am now convinced this is a bad idea. I am basically breaking the predictability of the application and null'ifying all the benefits that a uni-directional data model provides.</p>

<p>I am still not convinced that using Redux is specifically the best solution for this case, and I have dreamt up a more explicit uni-directional solution that uses some of the concepts from above, without any context magic though.</p>

<p>I'll post any solution as an answer if I think it works.  Failing that, I'll go Redux and kick myself for not listening to you all sooner.</p>

<hr>

<p><strong>Other examples</strong></p>

<p>Here are a few other projects/ideas trying to solve the same(ish) problem using a variety of techniques:</p>

<p><a href=""https://joecritchley.svbtle.com/portals-in-reactjs"" rel=""nofollow"">https://joecritchley.svbtle.com/portals-in-reactjs</a></p>

<p><a href=""https://github.com/davidtheclark/react-displace"" rel=""nofollow"">https://github.com/davidtheclark/react-displace</a></p>

<p><a href=""https://github.com/carlsverre/react-outlet"" rel=""nofollow"">https://github.com/carlsverre/react-outlet</a></p>
","I would prefer to use Redux, if anything else because of consistency, which will help a lot when maintaining the code in the future."
"36358671","Using react's context to allow rendering of a child component into a parent/grandparent/great-grandparent.... Anti-pattern?","2","<p>I have a proof of concept for this, which seems to work, but a part of me is wondering if this is really a good idea and if there is perhaps a better solution out there using something like Redux or an alternative strategy.</p>

<p><strong>The Problem</strong></p>

<p>Basically, I have a base React component for my entire application which has a bunch of typical components that you might expect, header, menu, footer etc etc.</p>

<p>Further down my tree (much further) I have a component for which it would be awesome if I could mount a new menu item for within my header component.  The header component of course lives right at the top of my application so access is denied.  </p>

<p>That is just one such example, but it's a problem case I have hit from many angles.</p>

<p><strong>My Crazy Solution</strong></p>

<p>I looked into using React's context in order to expose functions that would to allow child components to declare any additional elements they would like to appear within the header.  </p>

<p>After playing around with the concept I eventually refactored it into a pretty generic solution that is essentially a React Element messaging system. There are three parts to this solution.</p>

<p><em>1. The Provider</em></p>

<p>Single instance component much in the same vein as Redux's Connect component. She's essentially the engine that receives and passes the messages along.  Her basic structure (Context focused) is:</p>

<pre><code>class ElementInjectorProvider extends Component {
  childContextTypes: {

    // :: (namespace, [element]) -&gt; void
    produceElements: PropTypes.func.isRequired,

    // :: (namespace, [element]) -&gt; void
    removeElements: PropTypes.func.isRequired,

    // :: (listener, namespace, ([element]) -&gt; void) -&gt; void
    consumeElements: PropTypes.func.isRequired,

    // :: (listener) -&gt; void
    stopConsumingElements: PropTypes.func.isRequired,

  }

  /* ... Implementation ... */
}
</code></pre>

<p><em>2. The Producer</em></p>

<p>A higher order component.  Each instance can ""produce"" elements via the <code>produceElements</code> context item, providing elements for a specific namespace, and then remove the elements (in case of component unmount) via <code>removeElements</code>.</p>

<pre><code>function ElementInjectorProducer(config) {
  const { namespace } = config;

  return function WrapComponent(WrappedComponent) {
    class ElementInjectorConsumerComponent {
      contextTypes = {
        produceElements: PropTypes.func.isRequired,
        removeElements: PropTypes.func.isRequired
      }

      /* ... Implementation ... */
    }

    return ElementInjectorProducerComponent;
  };
}
</code></pre>

<p><em>3. The Consumer</em></p>

<p>A higher order component. Each instance is configured to ""watch"" for elements attached to a given namespace.  It uses <code>consumeElements</code> to ""start"" the listening via a callback function registration and <code>stopConsumingElements</code> to deregister the consumption.</p>

<pre><code>function ElementInjectorConsumer(config) {
  const { namespace } = config;

  return function WrapComponent(WrappedComponent) {
    class ElementInjectorConsumerComponent {
      contextTypes = {
        consumeElements: PropTypes.func.isRequired,
        stopConsumingElements: PropTypes.func.isRequired
      }

      /* ... Implementation ... */
    }

    return ElementInjectorConsumerComponent;
  };
}
</code></pre>

<hr>

<p>That's a rough overview of what I am intending on doing.  Basically it's a messaging system when you look at it.  And perhaps could be abstracted even further.</p>

<p>I already have redux in play, and guess what Redux is good for?  So I can't help but feel that although this is working for me, perhaps it's not a good design and that I have inadvertently stood on Redux's toes or produced a general anti-pattern.</p>

<p>I guess the only reason I didn't jump straight into using Redux for this is is that because I am producing Elements, not simple state.  I could go down the route of creating element descriptor objects and then pass that down through Redux, but that's complicated in itself.</p>

<hr>

<p>Any words of wisdom? </p>

<hr>

<p><strong>UPDATE No 1</strong></p>

<p>Some additional clarification on the above.  </p>

<p>This allows me to inject Elements both up and down, and even left to right, on my full component tree.  I know most React Context examples describe the injection of data from a Grandparent into a Grandchild component.</p>

<p>Also, I would want the above implementation to abstract away from the developer any knowledge of Context usage.  In fact I would most likely use these HOFS to create additional wrappers that are specific to use cases and far more explicit.</p>

<p>i.e. </p>

<p>A consumer implementation:</p>

<pre><code>&lt;InjectableHeader /&gt;
</code></pre>

<p>A producer implementation:</p>

<pre><code>InjectIntoHeader(&lt;FooButton /&gt;)(FooPage)
</code></pre>

<p>It's pretty explicitly I think and easy to follow.  I do like that I can create the button where it is most cared about which grants me the ability to create stronger relationships with it's peers.</p>

<p>I also get that redux flow is probably the right idea.  It just feels like I make it a lot harder for myself - I can't help but think there may be some merit to this technique.</p>

<p>Is there any reason this is specifically a bad idea?</p>

<hr>

<p><strong>UPDATE No 2</strong></p>

<p>Ok, I am now convinced this is a bad idea. I am basically breaking the predictability of the application and null'ifying all the benefits that a uni-directional data model provides.</p>

<p>I am still not convinced that using Redux is specifically the best solution for this case, and I have dreamt up a more explicit uni-directional solution that uses some of the concepts from above, without any context magic though.</p>

<p>I'll post any solution as an answer if I think it works.  Failing that, I'll go Redux and kick myself for not listening to you all sooner.</p>

<hr>

<p><strong>Other examples</strong></p>

<p>Here are a few other projects/ideas trying to solve the same(ish) problem using a variety of techniques:</p>

<p><a href=""https://joecritchley.svbtle.com/portals-in-reactjs"" rel=""nofollow"">https://joecritchley.svbtle.com/portals-in-reactjs</a></p>

<p><a href=""https://github.com/davidtheclark/react-displace"" rel=""nofollow"">https://github.com/davidtheclark/react-displace</a></p>

<p><a href=""https://github.com/carlsverre/react-outlet"" rel=""nofollow"">https://github.com/carlsverre/react-outlet</a></p>
","I can appreciate it's best to keep with the single pattern, but I don't know if my producer/consumer pattern add's that much additional maintenance overhead.  I have to match two strings together (find all) to see where a produced is being consumed.  With Redux I have to go into the action, then check which reducers are being called, then select through the state, and when components unmount I need to do cleanup procedures on my state.  Although, even saying all of this, I think you are probably still right.  I just want to try and explore this further and see if there is more to it."
"36859798","ReactDOM.unmountComponentAtNode: Uncaught ReferenceError: ReactDOM is not defined","0","<p>I practice react<br>
I met this error :  <code>Uncaught ReferenceError: ReactDOM is not defined</code><br>
when type <code>ReactDOM.unmountComponentAtNode(document.body)</code> on chrome console </p>

<p>Please help me check the problem<br>
I try the code on JSbin and works well,so I think it's webpack problem,but I have no idea .  </p>

<p>And I notice there are many way write <code>React.render</code> part when I google ,what's the difference?? which one is correct??  </p>

<pre><code>React.render(&lt;App name='Vipul' /&gt;,document.body); 
ReactDOM.render(&lt;App name='Vipul' /&gt;,document.body);
React.renderComponents(&lt;App name='Vipul' /&gt;,document.body);
</code></pre>

<p>Here is my code: </p>

<p><strong>main.jsx</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';

console.log('Start')
var App = React.createClass({
  render: function(){
    console.log('render');
    return &lt;h1 onClick={this.toggleState}&gt;Hello&lt;/h1&gt;
  },
  componentWillUnmount: function(){
  //在console執行 ReactDOM.unmountComponentAtNode(document.body)
    console.log('componentWillUnmount');
  },

  toggleState: function(){
    this.setState({status: !this.state.status})
  }

});

ReactDOM.render(&lt;App name='Vipul' /&gt;,document.body);
</code></pre>

<p><strong>webpack.config.js</strong> </p>

<pre><code>var WebpackNotifierPlugin = require('webpack-notifier');

module.exports = {
    entry: ""./src/main.js"",
    output: {
        filename: ""./dist/bundle.js""
//        filename: ""./public/dist/bundle.js""
    },
    plugins: [

    new WebpackNotifierPlugin()

  ],
    module: {
        loaders: [
            {
                test: /\.jsx?$/,
                exclude: /node_modules/,
                loader: ""babel-loader"",
                query: {
                    presets: ['es2015', 'react']
                }
            }
        ]
    },devtool: 'source-map'
};
</code></pre>
",""
"38219399","Keep a reference of a DOM node when mounting / unmounting a React component in a non-React application","0","<p>I'm using webpack to use react components in a non-react applications. The idea is to export these in a way so they can be mounted and dismounted on any DOM.</p>

<p>This is the html page where I'm testing the component:</p>

<pre class=""lang-php prettyprint-override""><code>&lt;script type=""text/javascript"" src=""&lt;?php echo base_url('assets/javascripts/build/component.js') ?&gt;""&gt;&lt;/script&gt;
&lt;button onclick=""showComponent()"" /&gt;show component&lt;/button&gt;
&lt;button onclick=""hideComponent()"" /&gt;hide component&lt;/button&gt;
&lt;div id='mainContainer'&gt;&lt;/div&gt;

&lt;script &gt;
  function showComponent() {
    MyComponent.mount(document.getElementById('mainContainer'))
  }

  function hideComponent() {
    MyComponent.unmount()
  }
&lt;/script&gt;
</code></pre>

<p>This is the webpack entry point:</p>

<pre class=""lang-jsx prettyprint-override""><code>import React from 'react'
import MyComponent from '/path/to/MyComponent'
import ComponentMounter from '/path/to/ComponentMounter'

let componentMounter = new ComponentMounter(&lt;MyComponent /&gt;)

export let mount = componentMounter.mount
export let unmount = componentMounter.unmount
</code></pre>

<p>In the webpack config, I'm exporting the bundle as a library, using:</p>

<pre class=""lang-json prettyprint-override""><code>output: {
    path: './assets/javascripts/build/',
    filename: 'component.js',
    libraryTarget: 'var',
    library: 'MyComponent'
}
</code></pre>

<p>The ComponentMounter class:</p>

<pre class=""lang-jsx prettyprint-override""><code>import ReactDOM from 'react-dom'

class ComponentMounter {

  constructor(component) {
    this.component = component
  }

  mount = (element) =&gt; {
    // This renders the react 'component', mounting it in the DOM 'element'
    this.element = ReactDOM.render(this.component, element)
  }

  unmount = () =&gt; {
    // This unmounts the react 'component', removing the DOM 'element'
    ReactDOM.unmountComponentAtNode(this.element)
  }

}

export default ComponentMounter
</code></pre>

<p>Hopefully you can see what I'm trying to do there. When clicking on the show button, the component mounts without problems.</p>

<p>But when I try to unmount it, it seems the element is not a valid DOM element, as I get this warning:</p>

<p><code>invariant.js:38 Uncaught Invariant Violation: unmountComponentAtNode(...): Target container is not a DOM element.</code></p>

<p>How can I keep a reference to a React component mounted in a DOM node within ComponentMounter object so I can easily unmount it when needed?</p>
",""
"38639896","Return raw html as from jQuery('<div></div>'), from an unmounted react component","0","<p>I'm using <code>jsPlumb</code> (which I'm sure is not that relevant) and at a certain point I'm making a custom overlay, which needs a <code>$()</code> html constructor:</p>

<pre><code>create:function(component) {
    return $(""&lt;select id='myDropDown'&gt;&lt;option value='foo'&gt;foo&lt;/option&gt;&lt;option   value='bar'&gt;bar&lt;/option&gt;&lt;/select&gt;"");
}
</code></pre>

<p>I've tried to return a string, or just a React element, but that won't work.</p>

<p>I'm pretty sure the method just wants some raw <code>html</code> element, so it shouldn't matter if it's jQuery I use. (Like how you console it out in Chrome, it prints the html, which I'm sure is some native DOM-format?)</p>

<p>How do I return the <strong>raw HTML</strong> <em>from an unmounted react component?</em></p>

<p>All I can find is how to convert HTML to a React component, which is the reverse. And I'd like to <strong>avoid jQuery altogether</strong></p>
",""
"39723826","How to handle 'popout/popup' of react component","2","<p>I'm trying to implement a 'popout' feature for my react app which uses video.js for streaming services.</p>

<p>Essentially , the below component renders a video stream on the site.</p>

<pre><code>              &lt;Player
                ready={this.props.ready}
                stream={stream}
                streamName={ streamName }
                ownStream={this.props.ownStream}
                ref={`player-${stream.id}`}
                unmount={this.props.unmount}
                isSignedIn={this.props.isSignedIn}
                dispatch={this.props.dispatch}
                /&gt;
</code></pre>

<p>On clicking the popout icon , I would like to have only the video (and not any other components on the page) open in a new window.</p>

<p>So i implemented the below in my routes file</p>

<pre><code>&lt;Route path=""/watch/popout_stream/:streamId"" component={StreamPopout} /&gt;
</code></pre>

<p>So now i have a separate page only for rendering the player. </p>

<p>But there doesnt seem to be a way for me to pass all my props from the existing window to the new component (since its on a different window - my redux state is also refreshed).</p>

<p>Is there any way i can pass props to a new component in a completely new window?</p>

<p>Thanks</p>
","I think that this is discussed [here](https://github.com/ReactTraining/react-router/issues/3080). The solution seems to be related with using `window.open` and sending the state with `postMessage` to the new window."
"39723826","How to handle 'popout/popup' of react component","2","<p>I'm trying to implement a 'popout' feature for my react app which uses video.js for streaming services.</p>

<p>Essentially , the below component renders a video stream on the site.</p>

<pre><code>              &lt;Player
                ready={this.props.ready}
                stream={stream}
                streamName={ streamName }
                ownStream={this.props.ownStream}
                ref={`player-${stream.id}`}
                unmount={this.props.unmount}
                isSignedIn={this.props.isSignedIn}
                dispatch={this.props.dispatch}
                /&gt;
</code></pre>

<p>On clicking the popout icon , I would like to have only the video (and not any other components on the page) open in a new window.</p>

<p>So i implemented the below in my routes file</p>

<pre><code>&lt;Route path=""/watch/popout_stream/:streamId"" component={StreamPopout} /&gt;
</code></pre>

<p>So now i have a separate page only for rendering the player. </p>

<p>But there doesnt seem to be a way for me to pass all my props from the existing window to the new component (since its on a different window - my redux state is also refreshed).</p>

<p>Is there any way i can pass props to a new component in a completely new window?</p>

<p>Thanks</p>
","@CésarLandesa - Thanks :) i'll have a look"
"39972785","Sync redux store with react-router route location (update header on route change)","3","<p>I am using <code>react-router-redux</code> and I'm trying to update the header of my app, that receives it's state from the store, whenever the route changes (<code>@@router/UPDATE_LOCATION</code>)</p>

<p>Currently I'm dispatching actions in a <code>componentWillMount</code> like:</p>

<pre><code>  componentWillMount() {
    this.props.appActions.setHeader('New Block')
  }
</code></pre>

<p>When I manually set the header in <code>componentWillMount</code> on route <code>/blocks/new</code>, and it is a child of a route 'blocks', who both have a different header, it doesn't work when I go back in <code>history</code>, because the component of route <code>blocks</code> does not mount again, it is <em>still</em> mounted. Thus the header is still <code>New Block</code>. And not what its own header was before, when <code>blocks</code> mounted, and <code>new</code> was still unmounted as child.</p>

<p>(And when I try to <em>reverse time</em> with the <code>redux-devtools</code>, what seems to happen then, every time I go back to a point where a component mounts again, it will dispatch the action again, and the devtool will receive another dispatch.)</p>

<p>The routes:</p>

<pre><code>&lt;Route path=""begin"" component={PlayerBeginContainer}&gt;
    &lt;IndexRoute component={PlayerOverview}/&gt;
       &lt;Route path=""blocks"" component={PlayerBlocks}&gt;
         &lt;Route path=""new"" component={PlayerNewBlock}/&gt;
       &lt;/Route&gt;
&lt;/Route&gt;
...
</code></pre>

<p>I've tried to sync the store whenever a route changes, but:</p>

<pre><code>if (action &amp;&amp; action.type === UPDATE_LOCATION) {
 let path = action.payload.pathname.split('/')
 // Laboriously iterate through array to figure out what the new header state should be.
  // i.e. if (1 in split &amp;&amp; split[1] === 'routeName')
  // or let lastPath = path[path.length - 1]
  // and getting parentPath would require more checking of whether it is the parent itself or not etc.
  // appHeader = 'routeHeader'
  return Object.assign({}, state, { appHeader: appHeader});
}
</code></pre>

<p>This gets very tedious when you just need it to trigger on a specific sub-route, 
And I want to avoid making another nested structure, while I already have that defined in the router.</p>

<p>In the header I can't use anything other than <code>this.props.location.pathname</code> either to try and figure out which route i'm on, and the components themselves should not bother with setting the header themselves (i.e. in <code>componentWillMount</code>).</p>

<p>Last option would be to use the router <code>onEnter</code>, but I'd like to keep the router clean, but perhaps I need to compromise on this.</p>

<p>Is there something I'm missing here? Or some sort of lib that can help me with this?</p>

<p>TL;DR: How can I make my <code>header</code> component aware of which route we are on, without having to break down the <code>location.pathname</code> to figure out where we are?</p>
","Does this help: https://github.com/reactjs/react-router-redux#how-do-i-access-router-state-in-a-container-component ?"
"39995030","when I change the url, react-router onEnter function didn't work","6","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var routeMap = {
    ""/login"": Login,
    ""/place"": Place,
    ""/article"": Arcticle
};
function initBar(url){
    if(document.getElementById('bar')){
        ReactDOM.unmountComponentAtNode(document.getElementById('bar'));
    }
    var Bar;
    if(url==""/login""){
        Bar = null;
    }else{
        Bar = &lt;NavBar items={itemArray} /&gt;;
    }

    if(Bar){
        ReactDOM.render(
            &lt;div&gt;
                {Bar}
            &lt;/div&gt;,
            document.getElementById('bar')
        )
    }
}
ReactDOM.render(
        // &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        &lt;div id=""container""&gt;
           &lt;Router path='/' component={routeMap[url]} &gt;
            {
                Object.keys(routeMap).map(function (item) {
                    return (
                        &lt;Router path={item} component={routeMap[item]} onEnter={item}/&gt;
                    )
                })
            }
        &lt;/Router&gt;
        &lt;/div&gt;,
        document.getElementById('content')
    );</code></pre>
</div>
</div>
</p>

<p>the onEnter event only work when the component init, when I change the url from /login to /place, the onEnter event didn't work. If anywhere is wrong?I am learning react by myself.</p>
","https://github.com/ReactTraining/react-router/blob/master/docs/API.md#onenternextstate-replace-callback"
"39995030","when I change the url, react-router onEnter function didn't work","6","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var routeMap = {
    ""/login"": Login,
    ""/place"": Place,
    ""/article"": Arcticle
};
function initBar(url){
    if(document.getElementById('bar')){
        ReactDOM.unmountComponentAtNode(document.getElementById('bar'));
    }
    var Bar;
    if(url==""/login""){
        Bar = null;
    }else{
        Bar = &lt;NavBar items={itemArray} /&gt;;
    }

    if(Bar){
        ReactDOM.render(
            &lt;div&gt;
                {Bar}
            &lt;/div&gt;,
            document.getElementById('bar')
        )
    }
}
ReactDOM.render(
        // &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        &lt;div id=""container""&gt;
           &lt;Router path='/' component={routeMap[url]} &gt;
            {
                Object.keys(routeMap).map(function (item) {
                    return (
                        &lt;Router path={item} component={routeMap[item]} onEnter={item}/&gt;
                    )
                })
            }
        &lt;/Router&gt;
        &lt;/div&gt;,
        document.getElementById('content')
    );</code></pre>
</div>
</div>
</p>

<p>the onEnter event only work when the component init, when I change the url from /login to /place, the onEnter event didn't work. If anywhere is wrong?I am learning react by myself.</p>
","you've passed a `string` to onEnter hook, but it should be a `function`"
"39995030","when I change the url, react-router onEnter function didn't work","6","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var routeMap = {
    ""/login"": Login,
    ""/place"": Place,
    ""/article"": Arcticle
};
function initBar(url){
    if(document.getElementById('bar')){
        ReactDOM.unmountComponentAtNode(document.getElementById('bar'));
    }
    var Bar;
    if(url==""/login""){
        Bar = null;
    }else{
        Bar = &lt;NavBar items={itemArray} /&gt;;
    }

    if(Bar){
        ReactDOM.render(
            &lt;div&gt;
                {Bar}
            &lt;/div&gt;,
            document.getElementById('bar')
        )
    }
}
ReactDOM.render(
        // &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        &lt;div id=""container""&gt;
           &lt;Router path='/' component={routeMap[url]} &gt;
            {
                Object.keys(routeMap).map(function (item) {
                    return (
                        &lt;Router path={item} component={routeMap[item]} onEnter={item}/&gt;
                    )
                })
            }
        &lt;/Router&gt;
        &lt;/div&gt;,
        document.getElementById('content')
    );</code></pre>
</div>
</div>
</p>

<p>the onEnter event only work when the component init, when I change the url from /login to /place, the onEnter event didn't work. If anywhere is wrong?I am learning react by myself.</p>
","try `onEnter={ initBar.bind(this, item) }`"
"39995030","when I change the url, react-router onEnter function didn't work","6","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var routeMap = {
    ""/login"": Login,
    ""/place"": Place,
    ""/article"": Arcticle
};
function initBar(url){
    if(document.getElementById('bar')){
        ReactDOM.unmountComponentAtNode(document.getElementById('bar'));
    }
    var Bar;
    if(url==""/login""){
        Bar = null;
    }else{
        Bar = &lt;NavBar items={itemArray} /&gt;;
    }

    if(Bar){
        ReactDOM.render(
            &lt;div&gt;
                {Bar}
            &lt;/div&gt;,
            document.getElementById('bar')
        )
    }
}
ReactDOM.render(
        // &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        &lt;div id=""container""&gt;
           &lt;Router path='/' component={routeMap[url]} &gt;
            {
                Object.keys(routeMap).map(function (item) {
                    return (
                        &lt;Router path={item} component={routeMap[item]} onEnter={item}/&gt;
                    )
                })
            }
        &lt;/Router&gt;
        &lt;/div&gt;,
        document.getElementById('content')
    );</code></pre>
</div>
</div>
</p>

<p>the onEnter event only work when the component init, when I change the url from /login to /place, the onEnter event didn't work. If anywhere is wrong?I am learning react by myself.</p>
","currently `initBar` invokes  immediately. Since  the `initBar` function doesnt return a function , so `onEnter` hook won't get a function to invoke."
"39995030","when I change the url, react-router onEnter function didn't work","6","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var routeMap = {
    ""/login"": Login,
    ""/place"": Place,
    ""/article"": Arcticle
};
function initBar(url){
    if(document.getElementById('bar')){
        ReactDOM.unmountComponentAtNode(document.getElementById('bar'));
    }
    var Bar;
    if(url==""/login""){
        Bar = null;
    }else{
        Bar = &lt;NavBar items={itemArray} /&gt;;
    }

    if(Bar){
        ReactDOM.render(
            &lt;div&gt;
                {Bar}
            &lt;/div&gt;,
            document.getElementById('bar')
        )
    }
}
ReactDOM.render(
        // &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        &lt;div id=""container""&gt;
           &lt;Router path='/' component={routeMap[url]} &gt;
            {
                Object.keys(routeMap).map(function (item) {
                    return (
                        &lt;Router path={item} component={routeMap[item]} onEnter={item}/&gt;
                    )
                })
            }
        &lt;/Router&gt;
        &lt;/div&gt;,
        document.getElementById('content')
    );</code></pre>
</div>
</div>
</p>

<p>the onEnter event only work when the component init, when I change the url from /login to /place, the onEnter event didn't work. If anywhere is wrong?I am learning react by myself.</p>
","sorry, In my code i was  write the ""onEnter={initBar(item)} "", here i write wrong. but it also didn't work when I change the url. only work when component init."
"39995030","when I change the url, react-router onEnter function didn't work","6","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var routeMap = {
    ""/login"": Login,
    ""/place"": Place,
    ""/article"": Arcticle
};
function initBar(url){
    if(document.getElementById('bar')){
        ReactDOM.unmountComponentAtNode(document.getElementById('bar'));
    }
    var Bar;
    if(url==""/login""){
        Bar = null;
    }else{
        Bar = &lt;NavBar items={itemArray} /&gt;;
    }

    if(Bar){
        ReactDOM.render(
            &lt;div&gt;
                {Bar}
            &lt;/div&gt;,
            document.getElementById('bar')
        )
    }
}
ReactDOM.render(
        // &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        &lt;div id=""container""&gt;
           &lt;Router path='/' component={routeMap[url]} &gt;
            {
                Object.keys(routeMap).map(function (item) {
                    return (
                        &lt;Router path={item} component={routeMap[item]} onEnter={item}/&gt;
                    )
                })
            }
        &lt;/Router&gt;
        &lt;/div&gt;,
        document.getElementById('content')
    );</code></pre>
</div>
</div>
</p>

<p>the onEnter event only work when the component init, when I change the url from /login to /place, the onEnter event didn't work. If anywhere is wrong?I am learning react by myself.</p>
","It works. Thank you very much!"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","`state = {
      inputValue: """"
}`
try assigning state above constructor instead inside"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","@M.Holmes so what do you do next to get that warning?"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","@FurkanO can you please elaborate on this?"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","@zerkms I'm using webpack to load the index.html which has a root entry point. The only component is this one `<SearchInput />`"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","@zerkms check the UPDATE"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","Oh I see. I just type into the input field"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","And under what circumstances do you get a warning?"
"40454028","react this.setState Warning on mounted or mounting","8","<p>I am consistently getting:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmounted
  component. This is a no-op. Please check the code for the SearchInput
  component.</p>
</blockquote>

<p>I have tried following these:<br>
<a href=""https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after"" rel=""nofollow noreferrer"" title=""example"">https://facebook.github.io/react/docs/two-way-binding-helpers.html#linkedstatemixin-before-and-after</a></p>

<p><a href=""https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler"" title=""onChange"">https://stackoverflow.com/questions/21029999/react-js-identifying-different-inputs-with-one-onchange-handler</a></p>

<p><a href=""https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind"" title=""one step behind"">https://stackoverflow.com/questions/28773839/react-form-onchange-setstate-one-step-behind</a></p>

<p>The problem is simple: when a user types into the input field capture the input via the <code>onChange</code> attribute and <code>setState</code></p>

<pre><code>import React, { Component } from 'react';

class SearchInput extends Component {
  constructor() {
    super();
    this.state = {
      inputValue: ''
    };
    this.onChange = this.onChange.bind(this);
  }

  render() {
    return (
      &lt;input
        type=""text""
        value={this.state.inputValue}
        onChange={this.onChange} /&gt;
    );
  }

  onChange(e) {
    console.log('yo');
    this.setState({ inputValue: e.target.value });
  }
}

export default SearchInput;
</code></pre>

<p>How do I mount my component so that the warning goes away and I can update user input state?</p>

<p><strong>UPDATE</strong><br>
I recently changed my <code>.babelrc</code> file to this:</p>

<pre><code>{
  ""presets"": [""latest-minimal"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>following this: <a href=""https://github.com/gabmontes/babel-preset-latest-minimal"" rel=""nofollow noreferrer"">https://github.com/gabmontes/babel-preset-latest-minimal</a></p>

<p>But as soon as I revert back to what I had before: </p>

<pre><code>{
  ""presets"": [""es2015"", ""stage-1"", ""react""],
  ""plugins"": [""react-hot-loader/babel""]
}
</code></pre>

<p>the warning went away.</p>

<p>Something in the <code>latest-minimal</code> not jiving.</p>
","100% percent sure that the error is not about the code above."
"40823843","Component is not unmount after its delete in store","0","<p>Project (Todolist) was created with <code>immutable</code> library, <a href=""https://github.com/BjornMelgaard/react-test"" rel=""nofollow noreferrer"">source here</a></p>

<p>Store structure: <code>project</code> have many <code>tasks</code>, In redux store: <code>State</code> - map, <code>projects, tasks</code> - Records</p>

<p>When I asyncly remove project ...</p>

<pre><code>export const removeProject = project =&gt; (dispatch) =&gt; {
  if (!isProjectExist(project)) return Promise.resolve()
  return projectService
    .delete(project)
    .then(
      () =&gt; {
        dispatch(remove(project))
        console.log(""post removeProject resolved"")
      },
      handleError,
    )
}
</code></pre>

<p>.... that was created after initialization - it will be deleted and properly unmounted, but when project was passed as <code>initialState</code> -  <code>ProjectList</code> will not be rerendered, and <code>ProjectItem</code> try to render itself with stale data, and fail, as in picture <a href=""https://i.stack.imgur.com/a0WHn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/a0WHn.png"" alt=""enter image description here""></a></p>

<hr>

<p><a href=""https://github.com/BjornMelgaard/react-test/blob/master/spec/javascripts/actions/projectActionsSpec.js"" rel=""nofollow noreferrer"">It have tests</a></p>

<hr>

<p>It looks like reducer returs changed data, but I use immutablejs, and previously i use <code>normalizr-immutable</code>, but I thought that source of issue in this library and write my own <code>normalizeInitialState</code> (<a href=""https://github.com/BjornMelgaard/react-test/blob/master/app/assets/javascripts/normalizers.js"" rel=""nofollow noreferrer"">source</a>), it did not help, now I think that maybe source of problem in <code>redux-immutable</code></p>

<hr>

<p>I struggled entire day on solving of this problem </p>

<hr>

<p><a href=""https://github.com/reactjs/react-redux/issues/86#issuecomment-137160004"" rel=""nofollow noreferrer"">creator of redux says</a> </p>

<blockquote>
  <p>I don't think this is something we can fix. React state changes are
  asynchronous and React may (or may not) batch them. Therefore, the
  moment you press “Remove”, the Redux store updates, and both Item and
  App receive the new state. Even if the App state change results in
  unmounting of Items, that will happen later than mapStateToProps is
  called for Item.</p>
  
  <p>Unless I'm mistaken, there is nothing we can do. You have two options:</p>
  
  <p>Request all required state at App (or a lower, e.g. ItemList) level
  and pass it down to “dumb” Items. Add safeguards to mapStateToProps
  for “currently unmounting” state. For example, you may return null
  from render in this case. Potentially we could have the component
  generated by connect() return null from its render if mapStateToProps
  returned null. Does this make any sense? Is this too surprising?</p>
</blockquote>

<p>Hm, I never saw stubs like <code>return (&lt;div&gt;&lt;/div&gt;)</code> or safeguards in mapStateToProps in others code</p>
",""
"40998630","Can I delay 'unmount' of a component in React js project?","2","<p>I'm working on a react project, in a problem.</p>

<p>I'd like to run a script before a component is unmounted.</p>

<p>So I made a code like below.</p>

<pre><code>componentWillUnmount () {
 const scripts = [
  'template/js/inline-home-view.js'
 ]
 appendInlineScripts(scripts)
}
</code></pre>

<p>and below is <code>inline-home-view.js</code></p>

<pre><code>$('#main-banner').revkill()
</code></pre>

<p>function <code>appendInlineScripts</code> is appending .js files to body tag like below.</p>

<pre><code>export const appendInlineScripts = scriptsSrcsArr =&gt; {
 for (const src of scriptsSrcsArr) {
  const script = document.createElement('script')
  script.src = src
  script.async = false
  document.body.appendChild(script)
 }
}
</code></pre>

<p><code>&lt;div id='main-banner'&gt;</code> is an element of the component.</p>

<p>I guess the problem is that unmounting of the component is faster then running the script <code>inline-home-view.js</code>. So I'd like to have unmounting of the component delayed, but can't find an appropriate solution.</p>

<p>Or I'm thinking of event trigger when <code>&lt;div id='main-banner'&gt;</code> is removing. But I'm not sure which event happens to the <code>&lt;div&gt;</code> when the parent component is unmounting.</p>

<p>There's a good solution in <code>jquery-ui</code> which is <code>.on('remove')</code> function, which triggers event when a element is removing.</p>

<p>But as my test result, when a component is unmounting, it seems it doesn't remove its element. (doesn't trigger 'remove' event). </p>

<p>Please somebody help me.</p>
","Because there are some js files appended in body tag,  also `revkill()` is declared in the scripts appended body tag. Running `revkill()` has to also be appended to body tag."
"40998630","Can I delay 'unmount' of a component in React js project?","2","<p>I'm working on a react project, in a problem.</p>

<p>I'd like to run a script before a component is unmounted.</p>

<p>So I made a code like below.</p>

<pre><code>componentWillUnmount () {
 const scripts = [
  'template/js/inline-home-view.js'
 ]
 appendInlineScripts(scripts)
}
</code></pre>

<p>and below is <code>inline-home-view.js</code></p>

<pre><code>$('#main-banner').revkill()
</code></pre>

<p>function <code>appendInlineScripts</code> is appending .js files to body tag like below.</p>

<pre><code>export const appendInlineScripts = scriptsSrcsArr =&gt; {
 for (const src of scriptsSrcsArr) {
  const script = document.createElement('script')
  script.src = src
  script.async = false
  document.body.appendChild(script)
 }
}
</code></pre>

<p><code>&lt;div id='main-banner'&gt;</code> is an element of the component.</p>

<p>I guess the problem is that unmounting of the component is faster then running the script <code>inline-home-view.js</code>. So I'd like to have unmounting of the component delayed, but can't find an appropriate solution.</p>

<p>Or I'm thinking of event trigger when <code>&lt;div id='main-banner'&gt;</code> is removing. But I'm not sure which event happens to the <code>&lt;div&gt;</code> when the parent component is unmounting.</p>

<p>There's a good solution in <code>jquery-ui</code> which is <code>.on('remove')</code> function, which triggers event when a element is removing.</p>

<p>But as my test result, when a component is unmounting, it seems it doesn't remove its element. (doesn't trigger 'remove' event). </p>

<p>Please somebody help me.</p>
","why not calling the script in componentDidMount directly instead of injecting?"
"41030724","How react-static-boilerplate make use of react's ref for mounting and umounting?","0","<p>I quite new to react. What is <code>ref={node =&gt; (this.root = node)}</code> for in: </p>

<pre><code>import React from 'react';
import Navigation from './Navigation';
import Link from '../Link';
import s from './Header.css';

class Header extends React.Component {

  componentDidMount() {
    window.componentHandler.upgradeElement(this.root);
  }

  componentWillUnmount() {
    window.componentHandler.downgradeElements(this.root);
  }

  render() {
    return (
      &lt;header className={`mdl-layout__header ${s.header}`} ref={node =&gt; (this.root = node)}&gt;
        &lt;div className={`mdl-layout__header-row ${s.row}`}&gt;
          &lt;Link className={`mdl-layout-title ${s.title}`} to=""/""&gt;
            Igene Logo Here
          &lt;/Link&gt;
          &lt;div className=""mdl-layout-spacer""&gt;&lt;/div&gt;
          &lt;Navigation /&gt;
        &lt;/div&gt;
      &lt;/header&gt;
    );
  }

}

export default Header;
</code></pre>

<p><em>( from <a href=""https://github.com/kriasoft/react-static-boilerplate/blob/master/components/Layout/Header.js"" rel=""nofollow noreferrer"">react-static-boilerplate (RSB)</a> )</em></p>

<p>and it's relationship to mount and unmounting?</p>

<p>I get the concept of ref based on reading <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">this</a>, but still find it quite hard to understand when it is used in RSB. Can someone enlighten me how it works and also it's relationship to the <code>componentDidMount()</code> and <code>componentWillMount()</code></p>
",""
"41445865","Unit Test react-router onEnter/onLeave","2","<p>I've some logic runs at onEnter/onLeave. I've used some <code>setInterval</code> at onEnter and clear them at onLeave using <code>clearInterval</code>.</p>

<p>How can I unit test above case?  </p>

<pre><code>&lt;Route
        component={App}
        onEnter={onEnterApp}
        onLeave={onLeaveApp}
        path=""/app""&gt;
</code></pre>

<p>Below is my test case but it fails ,</p>

<pre><code>import React from 'react';
import App from '../components/views/app.jsx';
import {shallow, mount, render} from 'enzyme';
import {expect, assert} from 'chai';
import sinon from 'sinon';
import {mountWithIntl} from '../test_utils/intl-enzyme-test-helper.js';





describe(‘App renders correctly', () =&gt; {

    it('When mounting set intervals', () =&gt; {
        const wrapper = mountWithIntl(&lt;App/&gt;);
        expect(window.x).to.exist;
        expect(window.y).to.exist;
    });

    it('When unmounting clear intervals', () =&gt; {

        const wrapper = mountWithIntl(&lt;App/&gt;);
        wrapper.unmount();
        expect(window.x).to.not.exist;
        expect(window.y).to.not.exist;
    });

});
</code></pre>
","have you tried `global` instead of `windows`"
"41445865","Unit Test react-router onEnter/onLeave","2","<p>I've some logic runs at onEnter/onLeave. I've used some <code>setInterval</code> at onEnter and clear them at onLeave using <code>clearInterval</code>.</p>

<p>How can I unit test above case?  </p>

<pre><code>&lt;Route
        component={App}
        onEnter={onEnterApp}
        onLeave={onLeaveApp}
        path=""/app""&gt;
</code></pre>

<p>Below is my test case but it fails ,</p>

<pre><code>import React from 'react';
import App from '../components/views/app.jsx';
import {shallow, mount, render} from 'enzyme';
import {expect, assert} from 'chai';
import sinon from 'sinon';
import {mountWithIntl} from '../test_utils/intl-enzyme-test-helper.js';





describe(‘App renders correctly', () =&gt; {

    it('When mounting set intervals', () =&gt; {
        const wrapper = mountWithIntl(&lt;App/&gt;);
        expect(window.x).to.exist;
        expect(window.y).to.exist;
    });

    it('When unmounting clear intervals', () =&gt; {

        const wrapper = mountWithIntl(&lt;App/&gt;);
        wrapper.unmount();
        expect(window.x).to.not.exist;
        expect(window.y).to.not.exist;
    });

});
</code></pre>
","thank you. It was an improvement but did not resolve the problem."
"41738810","Reactjs - Higher Order Component unmount not working correctly","3","<p>I created a HOC to listen for clicks outside its wrapped component, so that the wrapped component can listen and react as needed.</p>

<p>The HOC looks like this :</p>

<pre><code>const addOutsideClickListener = (WrappedComponent) =&gt; {

    class wrapperComponent extends React.Component {

        componentDidMount() {
            console.log('*** component did MOUNT called ***');
            document.addEventListener('click', this._handleClickOutside.bind(this), true);
        }

        componentWillUnmount() {
            console.log('*** component will UNMOUNT called ***');
            document.removeEventListener('click', this._handleClickOutside.bind(this), true);
        }

        _handleClickOutside(e) {
            const domNode = ReactDOM.findDOMNode(this);

            if ((!domNode || !domNode.contains(e.target))) {

                this.wrapped.handleClickOutside();
            }
        }

        render() {

            return (
                &lt;WrappedComponent
                    ref={(wrapped) =&gt; { this.wrapped = wrapped }}
                    {...this.props}
                /&gt;
            );
        }
    }

    return wrapperComponent;
}
</code></pre>

<p>It works fine... most of the time.</p>

<p>When the wrapped component is unmounted, the method ""componentWillUnmount"" gets called, but ""removeEventListener"" continues to listen for events, and so I get error messages 
""Uncaught Error: findDOMNode was called on an unmounted component.""</p>

<p>Any ideas what could be causing this ?</p>
","I posted a new question so that the correct answer here will get credit. Please see http://stackoverflow.com/questions/41740360/reactjs-higher-order-component-unmount-not-working-correctly-part-2"
"41766384","React Modal always unmounts and mounts children so ref callbacks have weird behavior. Why doesn't it just rerender the children?","2","<p>I have a react modal, which renders it's children:</p>

<pre><code>// base_modal.js  
import React, { Component } from 'react';
import Modal from 'react-modal';

export default class BaseModal extends Component {
  componentDidMount() {
    console.log(""BaseModal mounted"");
  }

  render() {
    return (
      &lt;Modal
        isOpen={this.props.showModal}
        className=""base-modal""
        overlayClassName=""base-modal-overlay""
        onRequestClose={this.props.onRequestClose}
        contentLabel=""base-modal""
      &gt;
        {this.props.children}
      &lt;/Modal&gt;
    );
  }
}
</code></pre>

<p>I have another component that renders BaseModal passes in some children:</p>

<pre><code>// my_modal.js
import BaseModal from './base_modal'

export default class MyModal extends Component {
  constructor(props) {
    super(props);
    this.doSomeSetup = this.doSomeSetup.bind(this);
  }

  componentDidMount() {
    console.log(""MyModal mounted"");
    this.doSomeSetup();
  }

  doSomeSetup() {
    console.log(this.dateInput); // undefined
  }

  render() {
    return (
       &lt;BaseModal
        showModal={this.props.showModal}
        onRequestClose={this.props.onClose}
       &gt;
        &lt;form&gt;
          &lt;div&gt;
            &lt;input
              ref={ input =&gt; { console.log(""In the input ref""); this.dateInput = input; }}
              type='text'
              value={this.state.inputVal}
              onChange={this.handleChange}
            /&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/BaseModal&gt;
    )
  }
}
</code></pre>

<p>I have a component that renders MyModal:</p>

<pre><code>// my_view.js
import MyModal from './my_modal'

export default class MyView extends Component {
  constructor(props) {
    super(props)
    this.state = {
      showModal: false
    }
    this.showModal = this.showModal.bind(this);
    this.hideModal = this.hideModal.bind(this);
  }

  showModal() {
    this.setState({
      showModal: true
    });
  }

  hideModal() {
    this.setState({
      showModal: false
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Button onClick={this.showModal} /&gt;
        &lt;MyModal 
          showModal={false}
          onClose={this.hideModal}
        /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>The problem is that in MyModal, this.dateInput is not defined when the component mounts. Whenever I render MyView, it renders MyModal, but MyModal renders BaseModal which only renders it's children when it has the prop ""isOpen"" set to true. </p>

<p>When I render MyView, I see the console logs ""BaseModal mounted"", ""MyModal mounted"", and then ""undefined"" for the console.log in the doSomeSetup method (i.e., the ref callback hasn't been executed). When I then click on the button in MyView to open the modal, I see the console.log ""In the input ref"". So the setup that I want to happen with the input in MyModal is not happening, because the actual form input's ref is only being executed when the React Modal has the prop isOpen set to true. </p>

<p>Another setup is with making the following changes:</p>

<pre><code>// my_modal.js

componentDidMount() {
  console.log(""MyModal mounted"");
}

doSomeSetup(input) {
  console.log(input);
}


(...) ref={ input =&gt; { console.log(""In the input ref""); this.doSomeSetup(input); }}
</code></pre>

<p>However, now, there is the following behaviour. When I render MyView, I see ""BaseModal mounted"", ""MyModal mounted"". When I click on the Button to open the modal I see ""In the input ref"" and the the actual input element gets console.logged. </p>

<p>Here is the weird thing (although as I'm writing this I'm beginning to see the answer to my own doubts): let's say I add a button to the render method of MyModal, that just changes the state of inputVal, forcing a rerender:</p>

<pre><code>  changeState() {
    this.setState({
      inputVal: this.state.inputVal + 1
    });
  }

  render() {
    return (
       &lt;BaseModal
        showModal={this.props.showModal}
        onRequestClose={this.props.onClose}
       &gt;
        &lt;button onClick={this.changeState}
        &lt;form&gt;
          &lt;div&gt;
            &lt;input
              ref={ input =&gt; { console.log(""In the input ref""); this.doSomeSetup(input); }}
              type='text'
              value={this.state.inputVal}
              onChange={this.handleChange}
            /&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/BaseModal&gt;
    )
  }
</code></pre>

<p>Now what happens when I click on the button is ""In the input ref"", then the console.log from doSomeSetup is executed and produces ""null"", then I get another ""In the input ref"", and then the console.log from doSomeSetup produces an actual input element. So Actually it seems like the children that are passed into BaseModal (my Button and Form) are first unmounted, and then mounted again (I think this because ref callbacks get called with null as argument when the node will unmount). Which is weird. </p>

<p>So Now, I guess my question is: Does the above make sense, and is it normal that the parent component unmounts and mounts its children everytime? Is this even the right way to describe what is happening?</p>

<p>To be more precise the functionality that I want is to add an event handler to the input in the doSomeSetup. But it seems that anytime the input were to change, because it is contained in a child of BaseModal, which is a prop to BaseModal, the latter somehow decides to unmount and mount the children. Why doesn't it just rerender the children? Is there a better way to do this?</p>
","Yes, it's only here, not in the real code."
"41766384","React Modal always unmounts and mounts children so ref callbacks have weird behavior. Why doesn't it just rerender the children?","2","<p>I have a react modal, which renders it's children:</p>

<pre><code>// base_modal.js  
import React, { Component } from 'react';
import Modal from 'react-modal';

export default class BaseModal extends Component {
  componentDidMount() {
    console.log(""BaseModal mounted"");
  }

  render() {
    return (
      &lt;Modal
        isOpen={this.props.showModal}
        className=""base-modal""
        overlayClassName=""base-modal-overlay""
        onRequestClose={this.props.onRequestClose}
        contentLabel=""base-modal""
      &gt;
        {this.props.children}
      &lt;/Modal&gt;
    );
  }
}
</code></pre>

<p>I have another component that renders BaseModal passes in some children:</p>

<pre><code>// my_modal.js
import BaseModal from './base_modal'

export default class MyModal extends Component {
  constructor(props) {
    super(props);
    this.doSomeSetup = this.doSomeSetup.bind(this);
  }

  componentDidMount() {
    console.log(""MyModal mounted"");
    this.doSomeSetup();
  }

  doSomeSetup() {
    console.log(this.dateInput); // undefined
  }

  render() {
    return (
       &lt;BaseModal
        showModal={this.props.showModal}
        onRequestClose={this.props.onClose}
       &gt;
        &lt;form&gt;
          &lt;div&gt;
            &lt;input
              ref={ input =&gt; { console.log(""In the input ref""); this.dateInput = input; }}
              type='text'
              value={this.state.inputVal}
              onChange={this.handleChange}
            /&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/BaseModal&gt;
    )
  }
}
</code></pre>

<p>I have a component that renders MyModal:</p>

<pre><code>// my_view.js
import MyModal from './my_modal'

export default class MyView extends Component {
  constructor(props) {
    super(props)
    this.state = {
      showModal: false
    }
    this.showModal = this.showModal.bind(this);
    this.hideModal = this.hideModal.bind(this);
  }

  showModal() {
    this.setState({
      showModal: true
    });
  }

  hideModal() {
    this.setState({
      showModal: false
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Button onClick={this.showModal} /&gt;
        &lt;MyModal 
          showModal={false}
          onClose={this.hideModal}
        /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>The problem is that in MyModal, this.dateInput is not defined when the component mounts. Whenever I render MyView, it renders MyModal, but MyModal renders BaseModal which only renders it's children when it has the prop ""isOpen"" set to true. </p>

<p>When I render MyView, I see the console logs ""BaseModal mounted"", ""MyModal mounted"", and then ""undefined"" for the console.log in the doSomeSetup method (i.e., the ref callback hasn't been executed). When I then click on the button in MyView to open the modal, I see the console.log ""In the input ref"". So the setup that I want to happen with the input in MyModal is not happening, because the actual form input's ref is only being executed when the React Modal has the prop isOpen set to true. </p>

<p>Another setup is with making the following changes:</p>

<pre><code>// my_modal.js

componentDidMount() {
  console.log(""MyModal mounted"");
}

doSomeSetup(input) {
  console.log(input);
}


(...) ref={ input =&gt; { console.log(""In the input ref""); this.doSomeSetup(input); }}
</code></pre>

<p>However, now, there is the following behaviour. When I render MyView, I see ""BaseModal mounted"", ""MyModal mounted"". When I click on the Button to open the modal I see ""In the input ref"" and the the actual input element gets console.logged. </p>

<p>Here is the weird thing (although as I'm writing this I'm beginning to see the answer to my own doubts): let's say I add a button to the render method of MyModal, that just changes the state of inputVal, forcing a rerender:</p>

<pre><code>  changeState() {
    this.setState({
      inputVal: this.state.inputVal + 1
    });
  }

  render() {
    return (
       &lt;BaseModal
        showModal={this.props.showModal}
        onRequestClose={this.props.onClose}
       &gt;
        &lt;button onClick={this.changeState}
        &lt;form&gt;
          &lt;div&gt;
            &lt;input
              ref={ input =&gt; { console.log(""In the input ref""); this.doSomeSetup(input); }}
              type='text'
              value={this.state.inputVal}
              onChange={this.handleChange}
            /&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/BaseModal&gt;
    )
  }
</code></pre>

<p>Now what happens when I click on the button is ""In the input ref"", then the console.log from doSomeSetup is executed and produces ""null"", then I get another ""In the input ref"", and then the console.log from doSomeSetup produces an actual input element. So Actually it seems like the children that are passed into BaseModal (my Button and Form) are first unmounted, and then mounted again (I think this because ref callbacks get called with null as argument when the node will unmount). Which is weird. </p>

<p>So Now, I guess my question is: Does the above make sense, and is it normal that the parent component unmounts and mounts its children everytime? Is this even the right way to describe what is happening?</p>

<p>To be more precise the functionality that I want is to add an event handler to the input in the doSomeSetup. But it seems that anytime the input were to change, because it is contained in a child of BaseModal, which is a prop to BaseModal, the latter somehow decides to unmount and mount the children. Why doesn't it just rerender the children? Is there a better way to do this?</p>
","you have a typo: this.showModal = this.showModal.bin(this); ==> (bin => bind) I hope its only here, and not in your real code?"
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","The `<Miss>` component will be removed in the soon to be released beta. I wouldn't worry too much about `<Miss>` issues right now."
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","Why don't you use components, `extends React.Component` to work with the Router?"
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","Yes. A ""miss"" can be the last `<Route>` in a `<Switch>`."
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","@prosti Because I favour functional style over object orientation."
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","@PaulS Thanks for the headsup. Do you know of any issues or other documentation for the reasoning of removing Miss?"
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","@PaulS Ah it seems Miss will be be possible with the Switch and Route(Replaces Match i guess) components combined, right?"
"41912429","react-router 4 unmounts matching component","7","<p>I have an issue where the new react-router 4 unmounts something that I think that it shouldn't.</p>

<p>See the following simple example. Clicking the ""Home"" link unmounts the Match/Miss in the Root component. Why is that?</p>

<pre><code>function Root() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;h1&gt;Example&lt;/h1&gt;
        &lt;Match exactly pattern=""/"" render={() =&gt; &lt;Redirect to=""/home"" /&gt;} /&gt;
        &lt;Miss component={App} /&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  )
}

function App() {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;Link to=""/home""&gt;Home&lt;/Link&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;Match pattern=""/home"" component={Home} /&gt;
    &lt;/div&gt;
  )
}

function Home() { return (&lt;h1&gt;Home&lt;/h1&gt;); }

ReactDOM.render(
  &lt;Root/&gt;,
  document.getElementById('container')
)
</code></pre>

<p>Run the example on jsfiddle: <a href=""https://jsfiddle.net/blacksails/s1fv62vc/"" rel=""nofollow noreferrer"">https://jsfiddle.net/blacksails/s1fv62vc/</a></p>
","Just to clarify, it needs not to be the last - it's simply the first matched Route gets rendered by Switch. In the case of a Route without a path, it would always match, but it should follow all Routes with a path"
"42093066","Webpack react HMR without router","0","<p>I need to start react js project without <code>react-router</code>, but I cannot setup hot module replacement without that one, please can you help me.<br>
My server </p>

<pre><code>const app = express()

// Apply gzip compression
app.use(compress())

if (project.env === 'development') {
  const compiler = webpack(webpackConfig)

   debug('Enabling webpack dev and HMR middleware')
   app.use(require('webpack-dev-middleware')(compiler, {
   publicPath  : webpackConfig.output.publicPath,
   contentBase : project.paths.client(),
   hot         : true,
   quiet       : project.compiler_quiet,
   noInfo      : project.compiler_quiet,
   lazy        : false,
   stats       : project.compiler_stats
 }))
 app.use(require('webpack-hot-middleware')(compiler, {
   path: '/__webpack_hmr'
 }))
} else {
    ....
}
</code></pre>

<p>My application entry point. </p>

<pre><code>const MOUNT_NODE = document.getElementById('root')

let render = () =&gt; {
   ReactDOM.render(
    &lt;App store={store} /&gt;,
    MOUNT_NODE)
 }

 if (__DEV__) {
    if (module.hot) {
      // Development render functions
      const renderApp = render
      const renderError = (error) =&gt; {
      const RedBox = require('redbox-react').default

      ReactDOM.render(&lt;RedBox error={error} /&gt;, MOUNT_NODE)
    }

    // Wrap render in try/catch
   render = () =&gt; {
      try {
         renderApp()
      } catch (error) {
         console.error(error)
         renderError(error)
      }
   }

  // Setup hot module replacement
   module.hot.accept('./App', () =&gt;
     setImmediate(() =&gt; {
        ReactDOM.unmountComponentAtNode(MOUNT_NODE)
        render()
     })
   )
 }
</code></pre>

<p>}</p>

<p>Where <code>./App</code> is simple component wrapping my application inside provider. </p>

<pre><code>shouldComponentUpdate = () =&gt; false;

 render () {
    return (
    &lt;Provider store={this.props.store}&gt;
       &lt;RootComponent /&gt;
    &lt;/Provider&gt;  )
 }
</code></pre>

<p>And the main problem is - that when I save this, or child file, HMR rebuilding and nothing changed, but even, I use router, and pass as entry point of application, instead of simple component - its working fine.</p>

<pre><code>export const createRoutes = (store) =&gt; ({
  path        : '/',
  component   : CoreLayout,
  indexRoute  : { onEnter: (nextState, replace) =&gt; replace('/songs') },
  childRoutes : [
    ...
 ]
 })
</code></pre>

<p>What I am doing wrong?</p>
",""
"42540397","react-router: Calling componentWillUnmount across different non-nested routes","0","<p>I am using react-router with a route structure like so:</p>

<pre><code>const routes = (
  &lt;Router history={browserHistory}&gt;
    &lt;Route path=""/main"" component={MainPage}&gt;&lt;/Route&gt;
    &lt;Route path=""/charts/:chartID"" component={App}&gt;&lt;/Route&gt;
  &lt;/Router&gt;
)
</code></pre>

<p>I am trying to do a call to a meteor method when a user switches away from ""/charts/:chartID"" to ""/main"". I only want the method to be called once if possible</p>

<p>In App.js, I used the life cycle methods:</p>

<pre><code>  componentDidUpdate(){
    Meteor.call('test',""update"");   
  } // prints ""update""

  componentWillUnmount(){
    Meteor.call('test',""unmount"");
  } // nothing happens when url changes
</code></pre>

<p>Main.js (server):</p>

<pre><code>Meteor.methods({
    'test'(obj){
        console.log(obj)
    }
})
</code></pre>

<p>I read from this <a href=""https://github.com/ReactTraining/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow noreferrer"">source</a> that components should unmount when the url changes in my situation, but seems like I may have missed out something. How should I be resolving this?</p>

<p>Any help is greatly appreciated!</p>
",""
"42910092","react-router-redux push, state change reset","0","<p>I have an application that creates a new record and redirect the history to the new record page using <a href=""https://github.com/reactjs/react-router-redux#pushlocation-replacelocation-gonumber-goback-goforward"" rel=""nofollow noreferrer"">react-redux-router push</a>. This redirection is made by a ""smart component"" inside another smart component.</p>

<p>The state of these components is stored on a redux store.</p>

<p>After redirection if I go back to the previous page it's state is dirty.
Is there a way to reset the state ? Or should I manually clean it up before the redirection.</p>

<p>Currently I'm listening on the reducer for <a href=""https://github.com/reactjs/react-router-redux#location_change"" rel=""nofollow noreferrer"">LOCATION_CHANGE</a> and resetting it but this seems manual and hacky.
Shouldn't the component unmount when it's route is not rendered anymore?</p>
",""
"42980457","React warnings using react-hot-loader:","0","<p>I am getting errors like below</p>

<blockquote>
  <p>React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: object.</p>
</blockquote>

<p>And </p>

<blockquote>
  <p>Uncaught TypeError: Cannot read property 'unmountComponent' of null</p>
</blockquote>

<p>Trying to use <code>react-hot-loader</code> with my basic setup. </p>

<p><strong><code>webpack.config.js</code></strong></p>

<pre><code>const path = require(""path"")
const HtmlWebpackPlugin = require(""html-webpack-plugin"")
const ExtractTextPlugin = require(""extract-text-webpack-plugin"")

const context = path.resolve(__dirname, ""src"")

module.exports = {
  context,
  entry: [
    ""react-hot-loader/patch"",
    ""./js/index.js""
  ],
  output: {
    path: path.resolve(__dirname, ""build/js""),
    filename: ""index.js""
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        loader: ""babel-loader"",
        options: {
          plugins: [
            [
              ""react-css-modules"",
              {
                context
              }
            ]
          ]
        }
      },
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: ""style-loader"",
          use: [
            {
              loader: ""css-loader"",
              options: {
                modules: true,
                importLoaders: 1,
                localIdentName: ""[path]___[name]__[local]___[hash:base64:5]"",
                sourceMap: true
              }
            },
            'postcss-loader'
          ]
        })
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: ""./index.html"",
      filename: ""index.html"",
      inject: ""body""
    }),
    new ExtractTextPlugin(""css/app.css"")
  ],
  devServer: {
    contentBase: path.resolve(__dirname, ""src""),
    historyApiFallback: true
  },
  devtool: ""eval""
}
</code></pre>

<p><strong><code>index.js</code></strong></p>

<pre><code>import ReactDOM from ""react-dom""
import React from ""react""
import {AppContainer} from ""react-hot-loader""
import App from ""./App.jsx""
import ""../css/global.css""

const render = Component =&gt; {
  ReactDOM.render(
    &lt;AppContainer&gt;
      &lt;Component /&gt;
    &lt;/AppContainer&gt;,
    document.getElementById(""app"")
  )
}

render(&lt;App /&gt;)

if (module.hot) {
  module.hot.accept(""./App.jsx"", () =&gt; render(&lt;App /&gt;))
}
</code></pre>

<p><strong><code>App.jsx</code></strong></p>

<p>Even when I just do </p>

<pre><code>export default () =&gt; &lt;h1&gt;Hello&lt;/h1&gt;
</code></pre>

<p>I get error</p>

<p>I am doing a more complete class tho </p>

<pre><code>import React from 'react'
import {createStore, applyMiddleware} from ""redux""
import {Provider} from ""react-redux""
import createHistory from ""history/createBrowserHistory""
import {Route, Switch} from ""react-router""
import {NavLink} from ""react-router-dom""
import {ConnectedRouter, routerMiddleware} from ""react-router-redux""
import {
  Layout,
  Panel,
  AppBar,
} from ""react-toolbox""
import Navigation from ""react-toolbox/lib/navigation""

import financeApp from ""./reducers""
import SbpInvestmentsIndex from ""./sbpInvestments/SbpInvestmentsIndex.jsx""
import Http404 from ""./Http404.jsx""
import ""./app.css""

const history = createHistory()
const historyMiddleware = routerMiddleware(history)
const store = createStore(
  financeApp,
  applyMiddleware(historyMiddleware)
)

export default class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      drawerActive: false
    }

    this.toggleDrawerActive = this.toggleDrawerActive.bind(this)
  }

  toggleDrawerActive() {
    this.setState({
      drawerActive: !this.state.drawerActive
    })
  }

  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;ConnectedRouter history={history}&gt;
          &lt;Layout&gt;
            &lt;Panel&gt;
              &lt;AppBar title=""Personal Finance""&gt;
                &lt;Navigation type=""horizontal""&gt;
                  &lt;NavLink to=""/"" styleName=""app-link""&gt;
                    SBP Investments
                  &lt;/NavLink&gt;
                &lt;/Navigation&gt;
              &lt;/AppBar&gt;

              &lt;Switch&gt;
                &lt;Route exact path=""/"" component={SbpInvestmentsIndex} /&gt;
                &lt;Route component={Http404} /&gt;
              &lt;/Switch&gt;
            &lt;/Panel&gt;
          &lt;/Layout&gt;
        &lt;/ConnectedRouter&gt;
      &lt;/Provider&gt;
    )
  }
}
</code></pre>

<p>Whats wrong here? Code on <strong><a href=""https://github.com/jiewmeng/finances-frontend/tree/80264f4d24ffc19faa01ee04aedbe2a8cebefcc8"" rel=""nofollow noreferrer"">Github</a></strong></p>
",""
"43062755","react-native componentDidMount to fetch from server","0","<pre><code>constructor(props) {
    super(props);
    console.log(""props"");
    this.state = {
        userId : ""12345"",
    };
}
componentDidMount() {
    console.log(""componentDidMount"");
    Actions.getProductDetails({userId:""123456""});
    Actions.getProductDetails.completed.listen(this.gotProductDetails.bind(this));
    Actions.cancelOrder.completed.listen(this.cancelOrderCompleted.bind(this));       
}
gotProductDetails(data) {
    console.log(""gotProductDetails"");  
}
goBack(data) {
    console.log(""justgoback"");
    this.props.back();
}
cancelProduct() {
    console.log(""SDsadsadsad"");
    Actions.cancelOrder({
        orderId:this.state.order.id,
        canelMsg:this.state.selectedReason,
        userId:this.state.userId
    });
}
cancelOrderCompleted(data) {
    console.log(""cancelOrderCompleted"");
    this.goBack();
}
</code></pre>

<blockquote>
  <p>My issue is some functions are mounting twice whenever I change the
  route and revisit this route again I would show you console.log here</p>
</blockquote>

<p><strong>This is for first time I come to this route:</strong></p>

<pre><code>props
cancelOrder.js:190 componentDidMount
cancelOrder.js:197 gotProductDetails
</code></pre>

<p>Now I will do cancelProduct call and log will be </p>

<pre><code>SDsadsadsad
cancelOrder.js:221 cancelOrderCompleted
cancelOrder.js:210 justgoback
</code></pre>

<p><strong>This is for second time i.e, I will go back from this route and revisit:</strong></p>

<pre><code>props
cancelOrder.js:190 componentDidMount
cancelOrder.js:197 gotProductDetails
Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the cancelOrder component.
cancelOrder.js:197 gotProductDetails
</code></pre>

<p>Now I will do cancelProduct call and log will be </p>

<pre><code>SDsadsadsad
cancelOrder.js:221 cancelOrderCompleted
cancelOrder.js:210 justgoback
cancelOrder.js:221 cancelOrderCompleted
cancelOrder.js:210 justgoback
</code></pre>

<p>In the above log you can see that for the second time <code>line number 197 221 210 executed twice with the error</code> I was not able to solve </p>

<p>I'm using react <code>navigator</code> for <a href=""https://facebook.github.io/react-native/docs/navigator.html#navigator"" rel=""nofollow noreferrer"">route</a></p>

<p>I checked in release version also, but it is having same error it was told in one Github issue, but was not able to find now.</p>
",""
"43097815","Properly unmount React component","0","<p><em>Question:</em> Why is this warning being thrown after the component is no longer being rendered by its parent? Am I missing something that needs to be done for unmounting of this component rather than just filtering the store state being passed down the hierarchy of components as props?</p>

<p>I've seen this scenario thrown around a lot, but the solution is usually something that involves unsubscribing the redux store from the component; however, this component is not connected to the store, just top-level container.</p>

<ul>
<li>The <code>remove</code> action simply filters the store state to remove the array element responsible for the current component.</li>
<li>The <code>refresh</code> action is currently just a simulation for UI animation events in a child component.</li>
<li>Warning is only thrown when I remove a <code>Feed</code> component after calling the <code>refresh</code> action</li>
</ul>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Feed component.</p>
</blockquote>

<pre><code>// @flow
// Feed.js

import React, { Component } from 'react'
import type { FeedType, FeedState } from '../../utils/types'
import { remove, refresh } from '../../actions/redux-actions'
import RssEventList from '../containers/RssEventList'

const cardColors: Array&lt;string&gt; = ['red', 'orange', 'olive', 'green', 'blue', 'yellow']

export default class Feed extends Component {
  props: FeedType
  state: FeedState

  constructor(props: *) {
    super(props)

    this.state = {
      reloading: false
    }
  }

  refresh() {
    this.setState({ reloading: true })
    setInterval(() =&gt; this.setState({ reloading: false }), 4000)
    this.props.dispatch(refresh(this.props.link))
  }

  remove() {
    this.props.dispatch(remove(this.props.link))
  }

  render() {
    const color: string = cardColors[Math.floor(Math.random() * cardColors.length)]

    return (
      &lt;div className={`ui ${color} card`}&gt;
        &lt;div className=""content""&gt;
          &lt;div className=""ui header""&gt;
            {this.props.title}
            &lt;a className=""source link"" href={this.props.link} target=""_blank""&gt;
              &lt;i className=""linkify right floated icon""&gt;&lt;/i&gt;
            &lt;/a&gt;
          &lt;/div&gt;
          &lt;div className=""meta""&gt;
            {this.props.description}
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className=""content""&gt;
          &lt;RssEventList reloading={this.state.reloading} events={this.props.feed} /&gt;
        &lt;/div&gt;
        &lt;div className=""extra content""&gt;
          &lt;span className=""left floated"" onClick={() =&gt; this.refresh()}&gt;
            &lt;i className=""refresh icon""&gt;&lt;/i&gt;
            Refresh
          &lt;/span&gt;
          &lt;span className=""right floated"" onClick={() =&gt; this.remove()}&gt;
            &lt;i className=""cancel icon""&gt;&lt;/i&gt;
            Remove
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>If it helps, here is a diagram of the component hierarchy:</p>

<pre><code>App (connected to store)
|- Header
|- FilterBar
|- FeedList
   |- Feed
      |- RssEventList
         |- RssEvent
   |- AddCard
</code></pre>
",""
"43178980","Component not unmounting when navigating between scenes","6","<p><strong>EDIT</strong>: I now suspect the issue is caused by the problem described <a href=""https://stackoverflow.com/questions/39538891/react-native-navigator-renderscene-called-multiple-times"">here</a>. I think that navigating away from a scene will render it again, thus keeping my component alive.</p>

<p>========================= </p>

<p>I am building a React Native component that listens for <code>NetInfo</code> changes and displays a modal dialog based on <a href=""https://www.npmjs.com/package/react-native-modal"" rel=""nofollow noreferrer"">react-native-modal</a>.</p>

<p>This is the code:</p>

<pre><code>import React, {Component} from 'react';
import {NetInfo, View, Text, Button, TouchableOpacity} from 'react-native';
import Modal from 'react-native-modal';

export default class WifiCheckModal extends Component {
    constructor() {
        super();
    }

    componentWillMount() {
        console.log('WifiModal mounting');
    }

    componentDidMount() {
        setTimeout(this.refreshConnectionStatus.bind(this), 500);
        NetInfo.addEventListener('change', this._handleConnectivityChange);
    }

    componentWillUnmount() {
        console.log('WifiModal unmounting');
        NetInfo.removeEventListener('change', this._handleConnectivityChange);
        this.isAlive = false;
    }

    _handleConnectivityChange = (connectionStatus) =&gt; {
        console.log('IsConnected = ' + connectionStatus);
        // Need to handle 'WIFI' on Android and 'wifi' on iOS, so convert to lowercase.
        let isOnWifi = (connectionStatus.toLowerCase() === 'wifi');
        let shouldShowModal = !isOnWifi;

        if (this.state.showModal != shouldShowModal) {
            console.log('Changing modal state to ' + shouldShowModal + ' because connection is ' + connectionStatus);
            this.setState({showModal: !isOnWifi});
        }
    }

    render() {
        return (
            &lt;Modal isVisible={this.state.showModal}&gt;
                &lt;View style={styles.modalContent}&gt;
                    &lt;Text&gt;You must be connected to wifi to use this app.&lt;/Text&gt;
                    &lt;TouchableOpacity onPress={this.refreshConnectionStatus.bind(this)}&gt;
                        &lt;View style={styles.button}&gt;
                            &lt;Text&gt;Check again&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            &lt;/Modal&gt;
        );
    }

    refreshConnectionStatus() {
        NetInfo.fetch().then(connectionStatus =&gt; this._handleConnectivityChange(connectionStatus));
    }
}
</code></pre>

<p>I then use this component in the <code>render</code> method of other components that serve as scenes:</p>

<pre><code>class SomeComponentScene extends Component {

    // ...

    render() {
        return (
            &lt;View&gt;&lt;WifiCheckModal /&gt; ... &lt;/View&gt;
        );
    }
}
</code></pre>

<p>The navigation code is found in my <code>index.js</code> (imported from <code>index.android.js</code>) and looks as follows:</p>

<pre><code>export default class App extends Component {
    constructor() {
        super();
    }

    render() {
        if (Platform.OS === 'android') {
            BackAndroid.addEventListener('hardwareBackPress', () =&gt; {
                console.log(""Android back pressed"");

                if (_navigator.getCurrentRoutes().length === 1  ) {
                    return false;
                }

                _navigator.pop();
                return true;
            });
        }

        return (&lt;Navigator
            initialRoute={{ index: 0, name: 'Splash'}}
            renderScene={ this.navigateToScene }/&gt;);
    }

    navigateToScene(route, navigator) {
        console.log(""navigateToScene "" + JSON.stringify(route));

        _navigator = navigator;

        if (route.name == 'Splash') {
            return &lt;SplashScene
                navigator={navigator}
                onRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'Login'}, 0);
                }}
                onNotRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'Login') {
            return &lt;LoginScene
                navigator={navigator}
                onAuthenticationCompleted={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'List') {
            return &lt;ListScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Add') {
            return &lt;AddScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Chat') {
            return &lt;ChatScene
                navigator={navigator}
                data={route.data}/&gt;
        } else if (route.name == 'Map') {
            return &lt;MapScene
                navigator={navigator}
                data={route.data}/&gt;
        }
    }
}
</code></pre>

<p>I noticed that the modal's <code>componentDidUnmount</code> is not always getting called when I move between scenes, leaving multiple listeners listening for <code>NetInfo</code> changes.</p>

<p>Are components not being unmounted when moving between scenes? Or perhaps there is something I'm doing that's keeping my component alive? Is there another way I should detect that my component is no longer in view and should thus unregister itself from <code>NetInfo</code>?</p>

<p>Or perhaps I'm worried for nothing and it's fine to have multiple listeners and they'll all be cleaned up eventually?</p>
","no you should clean up listeners. you should remove the components when not viewing. It sounds like there is a flag that is showing the elements or something instead of just unmounting them."
"43178980","Component not unmounting when navigating between scenes","6","<p><strong>EDIT</strong>: I now suspect the issue is caused by the problem described <a href=""https://stackoverflow.com/questions/39538891/react-native-navigator-renderscene-called-multiple-times"">here</a>. I think that navigating away from a scene will render it again, thus keeping my component alive.</p>

<p>========================= </p>

<p>I am building a React Native component that listens for <code>NetInfo</code> changes and displays a modal dialog based on <a href=""https://www.npmjs.com/package/react-native-modal"" rel=""nofollow noreferrer"">react-native-modal</a>.</p>

<p>This is the code:</p>

<pre><code>import React, {Component} from 'react';
import {NetInfo, View, Text, Button, TouchableOpacity} from 'react-native';
import Modal from 'react-native-modal';

export default class WifiCheckModal extends Component {
    constructor() {
        super();
    }

    componentWillMount() {
        console.log('WifiModal mounting');
    }

    componentDidMount() {
        setTimeout(this.refreshConnectionStatus.bind(this), 500);
        NetInfo.addEventListener('change', this._handleConnectivityChange);
    }

    componentWillUnmount() {
        console.log('WifiModal unmounting');
        NetInfo.removeEventListener('change', this._handleConnectivityChange);
        this.isAlive = false;
    }

    _handleConnectivityChange = (connectionStatus) =&gt; {
        console.log('IsConnected = ' + connectionStatus);
        // Need to handle 'WIFI' on Android and 'wifi' on iOS, so convert to lowercase.
        let isOnWifi = (connectionStatus.toLowerCase() === 'wifi');
        let shouldShowModal = !isOnWifi;

        if (this.state.showModal != shouldShowModal) {
            console.log('Changing modal state to ' + shouldShowModal + ' because connection is ' + connectionStatus);
            this.setState({showModal: !isOnWifi});
        }
    }

    render() {
        return (
            &lt;Modal isVisible={this.state.showModal}&gt;
                &lt;View style={styles.modalContent}&gt;
                    &lt;Text&gt;You must be connected to wifi to use this app.&lt;/Text&gt;
                    &lt;TouchableOpacity onPress={this.refreshConnectionStatus.bind(this)}&gt;
                        &lt;View style={styles.button}&gt;
                            &lt;Text&gt;Check again&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            &lt;/Modal&gt;
        );
    }

    refreshConnectionStatus() {
        NetInfo.fetch().then(connectionStatus =&gt; this._handleConnectivityChange(connectionStatus));
    }
}
</code></pre>

<p>I then use this component in the <code>render</code> method of other components that serve as scenes:</p>

<pre><code>class SomeComponentScene extends Component {

    // ...

    render() {
        return (
            &lt;View&gt;&lt;WifiCheckModal /&gt; ... &lt;/View&gt;
        );
    }
}
</code></pre>

<p>The navigation code is found in my <code>index.js</code> (imported from <code>index.android.js</code>) and looks as follows:</p>

<pre><code>export default class App extends Component {
    constructor() {
        super();
    }

    render() {
        if (Platform.OS === 'android') {
            BackAndroid.addEventListener('hardwareBackPress', () =&gt; {
                console.log(""Android back pressed"");

                if (_navigator.getCurrentRoutes().length === 1  ) {
                    return false;
                }

                _navigator.pop();
                return true;
            });
        }

        return (&lt;Navigator
            initialRoute={{ index: 0, name: 'Splash'}}
            renderScene={ this.navigateToScene }/&gt;);
    }

    navigateToScene(route, navigator) {
        console.log(""navigateToScene "" + JSON.stringify(route));

        _navigator = navigator;

        if (route.name == 'Splash') {
            return &lt;SplashScene
                navigator={navigator}
                onRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'Login'}, 0);
                }}
                onNotRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'Login') {
            return &lt;LoginScene
                navigator={navigator}
                onAuthenticationCompleted={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'List') {
            return &lt;ListScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Add') {
            return &lt;AddScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Chat') {
            return &lt;ChatScene
                navigator={navigator}
                data={route.data}/&gt;
        } else if (route.name == 'Map') {
            return &lt;MapScene
                navigator={navigator}
                data={route.data}/&gt;
        }
    }
}
</code></pre>

<p>I noticed that the modal's <code>componentDidUnmount</code> is not always getting called when I move between scenes, leaving multiple listeners listening for <code>NetInfo</code> changes.</p>

<p>Are components not being unmounted when moving between scenes? Or perhaps there is something I'm doing that's keeping my component alive? Is there another way I should detect that my component is no longer in view and should thus unregister itself from <code>NetInfo</code>?</p>

<p>Or perhaps I'm worried for nothing and it's fine to have multiple listeners and they'll all be cleaned up eventually?</p>
","what is `_navigator`? also are you doing a `navigator.replace` anywhere? also you can clean up your code DRASTICALLY. [see my answer here for a better way to render multiple pages.](http://stackoverflow.com/a/41113141/2733506)"
"43178980","Component not unmounting when navigating between scenes","6","<p><strong>EDIT</strong>: I now suspect the issue is caused by the problem described <a href=""https://stackoverflow.com/questions/39538891/react-native-navigator-renderscene-called-multiple-times"">here</a>. I think that navigating away from a scene will render it again, thus keeping my component alive.</p>

<p>========================= </p>

<p>I am building a React Native component that listens for <code>NetInfo</code> changes and displays a modal dialog based on <a href=""https://www.npmjs.com/package/react-native-modal"" rel=""nofollow noreferrer"">react-native-modal</a>.</p>

<p>This is the code:</p>

<pre><code>import React, {Component} from 'react';
import {NetInfo, View, Text, Button, TouchableOpacity} from 'react-native';
import Modal from 'react-native-modal';

export default class WifiCheckModal extends Component {
    constructor() {
        super();
    }

    componentWillMount() {
        console.log('WifiModal mounting');
    }

    componentDidMount() {
        setTimeout(this.refreshConnectionStatus.bind(this), 500);
        NetInfo.addEventListener('change', this._handleConnectivityChange);
    }

    componentWillUnmount() {
        console.log('WifiModal unmounting');
        NetInfo.removeEventListener('change', this._handleConnectivityChange);
        this.isAlive = false;
    }

    _handleConnectivityChange = (connectionStatus) =&gt; {
        console.log('IsConnected = ' + connectionStatus);
        // Need to handle 'WIFI' on Android and 'wifi' on iOS, so convert to lowercase.
        let isOnWifi = (connectionStatus.toLowerCase() === 'wifi');
        let shouldShowModal = !isOnWifi;

        if (this.state.showModal != shouldShowModal) {
            console.log('Changing modal state to ' + shouldShowModal + ' because connection is ' + connectionStatus);
            this.setState({showModal: !isOnWifi});
        }
    }

    render() {
        return (
            &lt;Modal isVisible={this.state.showModal}&gt;
                &lt;View style={styles.modalContent}&gt;
                    &lt;Text&gt;You must be connected to wifi to use this app.&lt;/Text&gt;
                    &lt;TouchableOpacity onPress={this.refreshConnectionStatus.bind(this)}&gt;
                        &lt;View style={styles.button}&gt;
                            &lt;Text&gt;Check again&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            &lt;/Modal&gt;
        );
    }

    refreshConnectionStatus() {
        NetInfo.fetch().then(connectionStatus =&gt; this._handleConnectivityChange(connectionStatus));
    }
}
</code></pre>

<p>I then use this component in the <code>render</code> method of other components that serve as scenes:</p>

<pre><code>class SomeComponentScene extends Component {

    // ...

    render() {
        return (
            &lt;View&gt;&lt;WifiCheckModal /&gt; ... &lt;/View&gt;
        );
    }
}
</code></pre>

<p>The navigation code is found in my <code>index.js</code> (imported from <code>index.android.js</code>) and looks as follows:</p>

<pre><code>export default class App extends Component {
    constructor() {
        super();
    }

    render() {
        if (Platform.OS === 'android') {
            BackAndroid.addEventListener('hardwareBackPress', () =&gt; {
                console.log(""Android back pressed"");

                if (_navigator.getCurrentRoutes().length === 1  ) {
                    return false;
                }

                _navigator.pop();
                return true;
            });
        }

        return (&lt;Navigator
            initialRoute={{ index: 0, name: 'Splash'}}
            renderScene={ this.navigateToScene }/&gt;);
    }

    navigateToScene(route, navigator) {
        console.log(""navigateToScene "" + JSON.stringify(route));

        _navigator = navigator;

        if (route.name == 'Splash') {
            return &lt;SplashScene
                navigator={navigator}
                onRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'Login'}, 0);
                }}
                onNotRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'Login') {
            return &lt;LoginScene
                navigator={navigator}
                onAuthenticationCompleted={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'List') {
            return &lt;ListScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Add') {
            return &lt;AddScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Chat') {
            return &lt;ChatScene
                navigator={navigator}
                data={route.data}/&gt;
        } else if (route.name == 'Map') {
            return &lt;MapScene
                navigator={navigator}
                data={route.data}/&gt;
        }
    }
}
</code></pre>

<p>I noticed that the modal's <code>componentDidUnmount</code> is not always getting called when I move between scenes, leaving multiple listeners listening for <code>NetInfo</code> changes.</p>

<p>Are components not being unmounted when moving between scenes? Or perhaps there is something I'm doing that's keeping my component alive? Is there another way I should detect that my component is no longer in view and should thus unregister itself from <code>NetInfo</code>?</p>

<p>Or perhaps I'm worried for nothing and it's fine to have multiple listeners and they'll all be cleaned up eventually?</p>
","@JohnRuddell What flag should I be looking for? Shouldn't react be unmounting the (invisible) components during navigation?"
"43178980","Component not unmounting when navigating between scenes","6","<p><strong>EDIT</strong>: I now suspect the issue is caused by the problem described <a href=""https://stackoverflow.com/questions/39538891/react-native-navigator-renderscene-called-multiple-times"">here</a>. I think that navigating away from a scene will render it again, thus keeping my component alive.</p>

<p>========================= </p>

<p>I am building a React Native component that listens for <code>NetInfo</code> changes and displays a modal dialog based on <a href=""https://www.npmjs.com/package/react-native-modal"" rel=""nofollow noreferrer"">react-native-modal</a>.</p>

<p>This is the code:</p>

<pre><code>import React, {Component} from 'react';
import {NetInfo, View, Text, Button, TouchableOpacity} from 'react-native';
import Modal from 'react-native-modal';

export default class WifiCheckModal extends Component {
    constructor() {
        super();
    }

    componentWillMount() {
        console.log('WifiModal mounting');
    }

    componentDidMount() {
        setTimeout(this.refreshConnectionStatus.bind(this), 500);
        NetInfo.addEventListener('change', this._handleConnectivityChange);
    }

    componentWillUnmount() {
        console.log('WifiModal unmounting');
        NetInfo.removeEventListener('change', this._handleConnectivityChange);
        this.isAlive = false;
    }

    _handleConnectivityChange = (connectionStatus) =&gt; {
        console.log('IsConnected = ' + connectionStatus);
        // Need to handle 'WIFI' on Android and 'wifi' on iOS, so convert to lowercase.
        let isOnWifi = (connectionStatus.toLowerCase() === 'wifi');
        let shouldShowModal = !isOnWifi;

        if (this.state.showModal != shouldShowModal) {
            console.log('Changing modal state to ' + shouldShowModal + ' because connection is ' + connectionStatus);
            this.setState({showModal: !isOnWifi});
        }
    }

    render() {
        return (
            &lt;Modal isVisible={this.state.showModal}&gt;
                &lt;View style={styles.modalContent}&gt;
                    &lt;Text&gt;You must be connected to wifi to use this app.&lt;/Text&gt;
                    &lt;TouchableOpacity onPress={this.refreshConnectionStatus.bind(this)}&gt;
                        &lt;View style={styles.button}&gt;
                            &lt;Text&gt;Check again&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            &lt;/Modal&gt;
        );
    }

    refreshConnectionStatus() {
        NetInfo.fetch().then(connectionStatus =&gt; this._handleConnectivityChange(connectionStatus));
    }
}
</code></pre>

<p>I then use this component in the <code>render</code> method of other components that serve as scenes:</p>

<pre><code>class SomeComponentScene extends Component {

    // ...

    render() {
        return (
            &lt;View&gt;&lt;WifiCheckModal /&gt; ... &lt;/View&gt;
        );
    }
}
</code></pre>

<p>The navigation code is found in my <code>index.js</code> (imported from <code>index.android.js</code>) and looks as follows:</p>

<pre><code>export default class App extends Component {
    constructor() {
        super();
    }

    render() {
        if (Platform.OS === 'android') {
            BackAndroid.addEventListener('hardwareBackPress', () =&gt; {
                console.log(""Android back pressed"");

                if (_navigator.getCurrentRoutes().length === 1  ) {
                    return false;
                }

                _navigator.pop();
                return true;
            });
        }

        return (&lt;Navigator
            initialRoute={{ index: 0, name: 'Splash'}}
            renderScene={ this.navigateToScene }/&gt;);
    }

    navigateToScene(route, navigator) {
        console.log(""navigateToScene "" + JSON.stringify(route));

        _navigator = navigator;

        if (route.name == 'Splash') {
            return &lt;SplashScene
                navigator={navigator}
                onRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'Login'}, 0);
                }}
                onNotRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'Login') {
            return &lt;LoginScene
                navigator={navigator}
                onAuthenticationCompleted={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'List') {
            return &lt;ListScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Add') {
            return &lt;AddScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Chat') {
            return &lt;ChatScene
                navigator={navigator}
                data={route.data}/&gt;
        } else if (route.name == 'Map') {
            return &lt;MapScene
                navigator={navigator}
                data={route.data}/&gt;
        }
    }
}
</code></pre>

<p>I noticed that the modal's <code>componentDidUnmount</code> is not always getting called when I move between scenes, leaving multiple listeners listening for <code>NetInfo</code> changes.</p>

<p>Are components not being unmounted when moving between scenes? Or perhaps there is something I'm doing that's keeping my component alive? Is there another way I should detect that my component is no longer in view and should thus unregister itself from <code>NetInfo</code>?</p>

<p>Or perhaps I'm worried for nothing and it's fine to have multiple listeners and they'll all be cleaned up eventually?</p>
","@JohnRuddell I use the modal component in multiple scenes. In a scene transition, my expectation was that it would unmount the modal of the old scene and mount the modal of the new scene. What I'm seeing instead is that it would sometime have two modals loaded at the same time. I can add my navigation code if you think the problem could lie there."
"43178980","Component not unmounting when navigating between scenes","6","<p><strong>EDIT</strong>: I now suspect the issue is caused by the problem described <a href=""https://stackoverflow.com/questions/39538891/react-native-navigator-renderscene-called-multiple-times"">here</a>. I think that navigating away from a scene will render it again, thus keeping my component alive.</p>

<p>========================= </p>

<p>I am building a React Native component that listens for <code>NetInfo</code> changes and displays a modal dialog based on <a href=""https://www.npmjs.com/package/react-native-modal"" rel=""nofollow noreferrer"">react-native-modal</a>.</p>

<p>This is the code:</p>

<pre><code>import React, {Component} from 'react';
import {NetInfo, View, Text, Button, TouchableOpacity} from 'react-native';
import Modal from 'react-native-modal';

export default class WifiCheckModal extends Component {
    constructor() {
        super();
    }

    componentWillMount() {
        console.log('WifiModal mounting');
    }

    componentDidMount() {
        setTimeout(this.refreshConnectionStatus.bind(this), 500);
        NetInfo.addEventListener('change', this._handleConnectivityChange);
    }

    componentWillUnmount() {
        console.log('WifiModal unmounting');
        NetInfo.removeEventListener('change', this._handleConnectivityChange);
        this.isAlive = false;
    }

    _handleConnectivityChange = (connectionStatus) =&gt; {
        console.log('IsConnected = ' + connectionStatus);
        // Need to handle 'WIFI' on Android and 'wifi' on iOS, so convert to lowercase.
        let isOnWifi = (connectionStatus.toLowerCase() === 'wifi');
        let shouldShowModal = !isOnWifi;

        if (this.state.showModal != shouldShowModal) {
            console.log('Changing modal state to ' + shouldShowModal + ' because connection is ' + connectionStatus);
            this.setState({showModal: !isOnWifi});
        }
    }

    render() {
        return (
            &lt;Modal isVisible={this.state.showModal}&gt;
                &lt;View style={styles.modalContent}&gt;
                    &lt;Text&gt;You must be connected to wifi to use this app.&lt;/Text&gt;
                    &lt;TouchableOpacity onPress={this.refreshConnectionStatus.bind(this)}&gt;
                        &lt;View style={styles.button}&gt;
                            &lt;Text&gt;Check again&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            &lt;/Modal&gt;
        );
    }

    refreshConnectionStatus() {
        NetInfo.fetch().then(connectionStatus =&gt; this._handleConnectivityChange(connectionStatus));
    }
}
</code></pre>

<p>I then use this component in the <code>render</code> method of other components that serve as scenes:</p>

<pre><code>class SomeComponentScene extends Component {

    // ...

    render() {
        return (
            &lt;View&gt;&lt;WifiCheckModal /&gt; ... &lt;/View&gt;
        );
    }
}
</code></pre>

<p>The navigation code is found in my <code>index.js</code> (imported from <code>index.android.js</code>) and looks as follows:</p>

<pre><code>export default class App extends Component {
    constructor() {
        super();
    }

    render() {
        if (Platform.OS === 'android') {
            BackAndroid.addEventListener('hardwareBackPress', () =&gt; {
                console.log(""Android back pressed"");

                if (_navigator.getCurrentRoutes().length === 1  ) {
                    return false;
                }

                _navigator.pop();
                return true;
            });
        }

        return (&lt;Navigator
            initialRoute={{ index: 0, name: 'Splash'}}
            renderScene={ this.navigateToScene }/&gt;);
    }

    navigateToScene(route, navigator) {
        console.log(""navigateToScene "" + JSON.stringify(route));

        _navigator = navigator;

        if (route.name == 'Splash') {
            return &lt;SplashScene
                navigator={navigator}
                onRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'Login'}, 0);
                }}
                onNotRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'Login') {
            return &lt;LoginScene
                navigator={navigator}
                onAuthenticationCompleted={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'List') {
            return &lt;ListScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Add') {
            return &lt;AddScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Chat') {
            return &lt;ChatScene
                navigator={navigator}
                data={route.data}/&gt;
        } else if (route.name == 'Map') {
            return &lt;MapScene
                navigator={navigator}
                data={route.data}/&gt;
        }
    }
}
</code></pre>

<p>I noticed that the modal's <code>componentDidUnmount</code> is not always getting called when I move between scenes, leaving multiple listeners listening for <code>NetInfo</code> changes.</p>

<p>Are components not being unmounted when moving between scenes? Or perhaps there is something I'm doing that's keeping my component alive? Is there another way I should detect that my component is no longer in view and should thus unregister itself from <code>NetInfo</code>?</p>

<p>Or perhaps I'm worried for nothing and it's fine to have multiple listeners and they'll all be cleaned up eventually?</p>
","it should. I dont know what is going on in your application since I dont see the navigation part. You need to make sure that you are rendering only the components that need to be rendered. the Unmount happens when you dont render a component that was rendered previously. So on a new render scene you need to only return the component you want to see. the others need to be omitted and that will kick off their unmount cycle"
"43178980","Component not unmounting when navigating between scenes","6","<p><strong>EDIT</strong>: I now suspect the issue is caused by the problem described <a href=""https://stackoverflow.com/questions/39538891/react-native-navigator-renderscene-called-multiple-times"">here</a>. I think that navigating away from a scene will render it again, thus keeping my component alive.</p>

<p>========================= </p>

<p>I am building a React Native component that listens for <code>NetInfo</code> changes and displays a modal dialog based on <a href=""https://www.npmjs.com/package/react-native-modal"" rel=""nofollow noreferrer"">react-native-modal</a>.</p>

<p>This is the code:</p>

<pre><code>import React, {Component} from 'react';
import {NetInfo, View, Text, Button, TouchableOpacity} from 'react-native';
import Modal from 'react-native-modal';

export default class WifiCheckModal extends Component {
    constructor() {
        super();
    }

    componentWillMount() {
        console.log('WifiModal mounting');
    }

    componentDidMount() {
        setTimeout(this.refreshConnectionStatus.bind(this), 500);
        NetInfo.addEventListener('change', this._handleConnectivityChange);
    }

    componentWillUnmount() {
        console.log('WifiModal unmounting');
        NetInfo.removeEventListener('change', this._handleConnectivityChange);
        this.isAlive = false;
    }

    _handleConnectivityChange = (connectionStatus) =&gt; {
        console.log('IsConnected = ' + connectionStatus);
        // Need to handle 'WIFI' on Android and 'wifi' on iOS, so convert to lowercase.
        let isOnWifi = (connectionStatus.toLowerCase() === 'wifi');
        let shouldShowModal = !isOnWifi;

        if (this.state.showModal != shouldShowModal) {
            console.log('Changing modal state to ' + shouldShowModal + ' because connection is ' + connectionStatus);
            this.setState({showModal: !isOnWifi});
        }
    }

    render() {
        return (
            &lt;Modal isVisible={this.state.showModal}&gt;
                &lt;View style={styles.modalContent}&gt;
                    &lt;Text&gt;You must be connected to wifi to use this app.&lt;/Text&gt;
                    &lt;TouchableOpacity onPress={this.refreshConnectionStatus.bind(this)}&gt;
                        &lt;View style={styles.button}&gt;
                            &lt;Text&gt;Check again&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            &lt;/Modal&gt;
        );
    }

    refreshConnectionStatus() {
        NetInfo.fetch().then(connectionStatus =&gt; this._handleConnectivityChange(connectionStatus));
    }
}
</code></pre>

<p>I then use this component in the <code>render</code> method of other components that serve as scenes:</p>

<pre><code>class SomeComponentScene extends Component {

    // ...

    render() {
        return (
            &lt;View&gt;&lt;WifiCheckModal /&gt; ... &lt;/View&gt;
        );
    }
}
</code></pre>

<p>The navigation code is found in my <code>index.js</code> (imported from <code>index.android.js</code>) and looks as follows:</p>

<pre><code>export default class App extends Component {
    constructor() {
        super();
    }

    render() {
        if (Platform.OS === 'android') {
            BackAndroid.addEventListener('hardwareBackPress', () =&gt; {
                console.log(""Android back pressed"");

                if (_navigator.getCurrentRoutes().length === 1  ) {
                    return false;
                }

                _navigator.pop();
                return true;
            });
        }

        return (&lt;Navigator
            initialRoute={{ index: 0, name: 'Splash'}}
            renderScene={ this.navigateToScene }/&gt;);
    }

    navigateToScene(route, navigator) {
        console.log(""navigateToScene "" + JSON.stringify(route));

        _navigator = navigator;

        if (route.name == 'Splash') {
            return &lt;SplashScene
                navigator={navigator}
                onRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'Login'}, 0);
                }}
                onNotRequireAuthentication={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'Login') {
            return &lt;LoginScene
                navigator={navigator}
                onAuthenticationCompleted={() =&gt; {
                    navigator.replaceAtIndex({name: 'List'}, 0);
                }}/&gt;
        } else if (route.name == 'List') {
            return &lt;ListScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Add') {
            return &lt;AddScene
                navigator={navigator}/&gt;
        } else if (route.name == 'Chat') {
            return &lt;ChatScene
                navigator={navigator}
                data={route.data}/&gt;
        } else if (route.name == 'Map') {
            return &lt;MapScene
                navigator={navigator}
                data={route.data}/&gt;
        }
    }
}
</code></pre>

<p>I noticed that the modal's <code>componentDidUnmount</code> is not always getting called when I move between scenes, leaving multiple listeners listening for <code>NetInfo</code> changes.</p>

<p>Are components not being unmounted when moving between scenes? Or perhaps there is something I'm doing that's keeping my component alive? Is there another way I should detect that my component is no longer in view and should thus unregister itself from <code>NetInfo</code>?</p>

<p>Or perhaps I'm worried for nothing and it's fine to have multiple listeners and they'll all be cleaned up eventually?</p>
","@JohnRuddell `_navigator` is a global navigator object. I use `navigator.replaceAtIndex` in some locations. Could this be the problem? Also see the edit I placed at the top of my question - there's a React bug that causes `renderScene` to be called twice when navigating between scenes. Could this explain the problem? Your simplification is indeed simplifying :) I'll use it."
"44857280","Keep component from unmounting on React Router v4 transition","2","<p>I transition (route) from a parent component to a child component. When I go Back to the parent, it re-mounts entirely, reloading data, and re-rendering.</p>

<p>How can I keep a specific component from unmounting [on a certain child route]?</p>
","This might be useful: https://www.reddit.com/r/reactjs/comments/44lgke/unmount_a_component_and_remount_it_later/"
"45162985","How function exist after component has been unmounted","2","<p>My Doubt is related to using timer in react component, as per my understanding <strong>once component unmount</strong> its all properties/methods will not exist after that.</p>

<p>As per <a href=""https://facebook.github.io/react/docs/react-component.html#componentwillunmount"" rel=""nofollow noreferrer"">DOC</a>:</p>

<blockquote>
  <p>componentWillUnmount() is invoked immediately before a component is
  unmounted and destroyed. <strong>Perform any necessary cleanup in this method,
  such as invalidating timers,</strong> canceling network requests, or cleaning
  up any DOM elements that were created in componentDidMount.</p>
</blockquote>

<p>Check this snippet:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""false"" data-babel=""true"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 1};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      3000
    );
  }

  componentWillUnmount() {
    //clearInterval(this.timerID);
  }

  tick() {
     console.log('called', this.props.no);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Clock {this.props.no}&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

class App extends React.Component {
  
  constructor(){
     super();
     this.state = {unMount: false}
  }
  
  click(){
     console.log('unmounted successfully');
     this.setState({unMount: !this.state.unMount})
  }
  
  render(){
    return (
       &lt;div&gt;
          &lt;button onClick={() =&gt; this.click()}&gt;Unmount first&lt;/button&gt;
           {!this.state.unMount &amp;&amp; &lt;Clock no={1}/&gt;}
           &lt;Clock no={2}/&gt;
       &lt;/div&gt;
    );
  }
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;

&lt;div id='root'/&gt;</code></pre>
</div>
</div>
</p>

<p>Here i am rendering two clock component and unmounting the first one onclick of button that is happening successfully and it's updating the DOM also, even after unmounting the first component timer is printing the props values properly by <code>console.log()</code>.</p>

<p><strong>I am not clearing the Timer</strong> in <code>componentWillUmount</code>:</p>

<pre><code>componentWillUnmount() {
    //clearInterval(this.timerID);
}
</code></pre>

<p><strong>My Doubt is:</strong></p>

<pre><code>this.timerID = setInterval(
   () =&gt; this.tick(),
   3000
);

tick() {
   console.log('called', this.props.no);
}
</code></pre>

<p>I am passing a <strong>class method as callback</strong> in timer so once component has been unmounted how tick function exist, How this timer is resolving <code>this</code> keyword and the <code>tick</code> function after the component unmounted? How <code>this.props.no</code> is having the correct value? why it's not throwing the error:</p>

<blockquote>
  <p>can't read tick of undefined or tick is not defined</p>
</blockquote>

<p>How it is maintaining the references to these functions?</p>

<p>Help me what i am missing here, please provide any reference or example.</p>
","@hindmost thanks, but if that code will still exist then it should create the memory issue since component get render and unmount very frequently when we visit different pages correct? another thing is, till what moment that code will be available because i waited for 10 mins but still that is printing the values properly, it should throw error after some time."
"45162985","How function exist after component has been unmounted","2","<p>My Doubt is related to using timer in react component, as per my understanding <strong>once component unmount</strong> its all properties/methods will not exist after that.</p>

<p>As per <a href=""https://facebook.github.io/react/docs/react-component.html#componentwillunmount"" rel=""nofollow noreferrer"">DOC</a>:</p>

<blockquote>
  <p>componentWillUnmount() is invoked immediately before a component is
  unmounted and destroyed. <strong>Perform any necessary cleanup in this method,
  such as invalidating timers,</strong> canceling network requests, or cleaning
  up any DOM elements that were created in componentDidMount.</p>
</blockquote>

<p>Check this snippet:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""false"" data-babel=""true"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {count: 1};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      3000
    );
  }

  componentWillUnmount() {
    //clearInterval(this.timerID);
  }

  tick() {
     console.log('called', this.props.no);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Clock {this.props.no}&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}

class App extends React.Component {
  
  constructor(){
     super();
     this.state = {unMount: false}
  }
  
  click(){
     console.log('unmounted successfully');
     this.setState({unMount: !this.state.unMount})
  }
  
  render(){
    return (
       &lt;div&gt;
          &lt;button onClick={() =&gt; this.click()}&gt;Unmount first&lt;/button&gt;
           {!this.state.unMount &amp;&amp; &lt;Clock no={1}/&gt;}
           &lt;Clock no={2}/&gt;
       &lt;/div&gt;
    );
  }
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;

&lt;div id='root'/&gt;</code></pre>
</div>
</div>
</p>

<p>Here i am rendering two clock component and unmounting the first one onclick of button that is happening successfully and it's updating the DOM also, even after unmounting the first component timer is printing the props values properly by <code>console.log()</code>.</p>

<p><strong>I am not clearing the Timer</strong> in <code>componentWillUmount</code>:</p>

<pre><code>componentWillUnmount() {
    //clearInterval(this.timerID);
}
</code></pre>

<p><strong>My Doubt is:</strong></p>

<pre><code>this.timerID = setInterval(
   () =&gt; this.tick(),
   3000
);

tick() {
   console.log('called', this.props.no);
}
</code></pre>

<p>I am passing a <strong>class method as callback</strong> in timer so once component has been unmounted how tick function exist, How this timer is resolving <code>this</code> keyword and the <code>tick</code> function after the component unmounted? How <code>this.props.no</code> is having the correct value? why it's not throwing the error:</p>

<blockquote>
  <p>can't read tick of undefined or tick is not defined</p>
</blockquote>

<p>How it is maintaining the references to these functions?</p>

<p>Help me what i am missing here, please provide any reference or example.</p>
","_..as per my understanding once component unmount its all properties/methods will not exist after that._ That's not quite correct. Technically React component is a JS class (function) and _mounting_ make connection between this class and respective DOM stuff. When component is unmounted only this connection is destroyed but the respective JS class and its props/methods are _**still exist**_."
"45306081","preact compat causing component to mount infinitely","6","<p>I have working reactjs app with redux and react router. 
I want to switch to preact. 
When I updated webpack config to alias react and react dom. 
Component started mounting infinitely. It mount then unmount .. goes on doing so. 
Webpack config. </p>

<pre><code>alias: {
        ""react"": path.resolve(__dirname, 'react.js'),
        ""react-dom"": path.resolve(__dirname, 'react.js')
        },
</code></pre>

<p>react.js </p>

<pre><code>var preact = require('preact-compat');
var react = {};
Object.keys(preact).forEach(function(key) {
  react[key] = preact[key];
});

module.exports = react;
</code></pre>

<p>This file is because I am using react hot loader. 
React app is working fine .. but adding preact has bug. pls guide me. </p>
","Why aren't you using [the documented method](https://github.com/developit/preact-compat#usage-with-webpack) of replacing React and ReactDOM?"
"45306081","preact compat causing component to mount infinitely","6","<p>I have working reactjs app with redux and react router. 
I want to switch to preact. 
When I updated webpack config to alias react and react dom. 
Component started mounting infinitely. It mount then unmount .. goes on doing so. 
Webpack config. </p>

<pre><code>alias: {
        ""react"": path.resolve(__dirname, 'react.js'),
        ""react-dom"": path.resolve(__dirname, 'react.js')
        },
</code></pre>

<p>react.js </p>

<pre><code>var preact = require('preact-compat');
var react = {};
Object.keys(preact).forEach(function(key) {
  react[key] = preact[key];
});

module.exports = react;
</code></pre>

<p>This file is because I am using react hot loader. 
React app is working fine .. but adding preact has bug. pls guide me. </p>
","I have done that.. but it caused another error. which I have fixed with above code."
"45306081","preact compat causing component to mount infinitely","6","<p>I have working reactjs app with redux and react router. 
I want to switch to preact. 
When I updated webpack config to alias react and react dom. 
Component started mounting infinitely. It mount then unmount .. goes on doing so. 
Webpack config. </p>

<pre><code>alias: {
        ""react"": path.resolve(__dirname, 'react.js'),
        ""react-dom"": path.resolve(__dirname, 'react.js')
        },
</code></pre>

<p>react.js </p>

<pre><code>var preact = require('preact-compat');
var react = {};
Object.keys(preact).forEach(function(key) {
  react[key] = preact[key];
});

module.exports = react;
</code></pre>

<p>This file is because I am using react hot loader. 
React app is working fine .. but adding preact has bug. pls guide me. </p>
","So you fixed one issue by introducing another. What was the other error?"
"45306081","preact compat causing component to mount infinitely","6","<p>I have working reactjs app with redux and react router. 
I want to switch to preact. 
When I updated webpack config to alias react and react dom. 
Component started mounting infinitely. It mount then unmount .. goes on doing so. 
Webpack config. </p>

<pre><code>alias: {
        ""react"": path.resolve(__dirname, 'react.js'),
        ""react-dom"": path.resolve(__dirname, 'react.js')
        },
</code></pre>

<p>react.js </p>

<pre><code>var preact = require('preact-compat');
var react = {};
Object.keys(preact).forEach(function(key) {
  react[key] = preact[key];
});

module.exports = react;
</code></pre>

<p>This file is because I am using react hot loader. 
React app is working fine .. but adding preact has bug. pls guide me. </p>
","after removing hot loader .. it is working fine .. thanks"
"45306081","preact compat causing component to mount infinitely","6","<p>I have working reactjs app with redux and react router. 
I want to switch to preact. 
When I updated webpack config to alias react and react dom. 
Component started mounting infinitely. It mount then unmount .. goes on doing so. 
Webpack config. </p>

<pre><code>alias: {
        ""react"": path.resolve(__dirname, 'react.js'),
        ""react-dom"": path.resolve(__dirname, 'react.js')
        },
</code></pre>

<p>react.js </p>

<pre><code>var preact = require('preact-compat');
var react = {};
Object.keys(preact).forEach(function(key) {
  react[key] = preact[key];
});

module.exports = react;
</code></pre>

<p>This file is because I am using react hot loader. 
React app is working fine .. but adding preact has bug. pls guide me. </p>
","Uncaught TypeError: Cannot set property createElement of #<Object> which has only a getter"
"45306081","preact compat causing component to mount infinitely","6","<p>I have working reactjs app with redux and react router. 
I want to switch to preact. 
When I updated webpack config to alias react and react dom. 
Component started mounting infinitely. It mount then unmount .. goes on doing so. 
Webpack config. </p>

<pre><code>alias: {
        ""react"": path.resolve(__dirname, 'react.js'),
        ""react-dom"": path.resolve(__dirname, 'react.js')
        },
</code></pre>

<p>react.js </p>

<pre><code>var preact = require('preact-compat');
var react = {};
Object.keys(preact).forEach(function(key) {
  react[key] = preact[key];
});

module.exports = react;
</code></pre>

<p>This file is because I am using react hot loader. 
React app is working fine .. but adding preact has bug. pls guide me. </p>
","Ohh yeah, I remember that error from my own project. I resolved it by not using `preact-compact` in combination with `react-hot-loader`, because (AFAIK) those two just don't work together."
"45412054","Accessing videojs player in react component from other component","2","<p>I've used the guide in the videojs docs to create a component that is working correctly (see below).  Once, loaded I can also control the player from the console with API functions like <code>window.player.play()</code>. </p>

<p>I would now like to create a play/pause button component.  If I just use <code>onClick = {window.player.play}</code>, player doesn't exist when the page loads and causes an error.  </p>

<p>I would like the Play/Pause components to be siblings of VideoPlayer:</p>

<pre><code>&lt;div&gt;
  &lt;VideoPlayer props /&gt;
  &lt;PlayButton /&gt;
  &lt;PauseButton /&gt;
&lt;/div&gt;
</code></pre>

<p>What is the best way of accessing my player from other components?</p>

<pre><code>import React from 'react';

export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js

    this.player = window.videojs(this.videoNode, this.props, function onPlayerReady() {
      console.log('onPlayerReady', this)
    });
    window.player = this.player;
    }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  // wrap the player in a div with a `data-vjs-player` attribute
  // so videojs won't create additional wrapper in the DOM
  // see https://github.com/videojs/video.js/pull/3856
  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
      &lt;/div&gt;

    )
  }
}
</code></pre>
","I assume that your play and pause buttons will be child components of VideoPlayer component. It is correct?"
"45412054","Accessing videojs player in react component from other component","2","<p>I've used the guide in the videojs docs to create a component that is working correctly (see below).  Once, loaded I can also control the player from the console with API functions like <code>window.player.play()</code>. </p>

<p>I would now like to create a play/pause button component.  If I just use <code>onClick = {window.player.play}</code>, player doesn't exist when the page loads and causes an error.  </p>

<p>I would like the Play/Pause components to be siblings of VideoPlayer:</p>

<pre><code>&lt;div&gt;
  &lt;VideoPlayer props /&gt;
  &lt;PlayButton /&gt;
  &lt;PauseButton /&gt;
&lt;/div&gt;
</code></pre>

<p>What is the best way of accessing my player from other components?</p>

<pre><code>import React from 'react';

export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js

    this.player = window.videojs(this.videoNode, this.props, function onPlayerReady() {
      console.log('onPlayerReady', this)
    });
    window.player = this.player;
    }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  // wrap the player in a div with a `data-vjs-player` attribute
  // so videojs won't create additional wrapper in the DOM
  // see https://github.com/videojs/video.js/pull/3856
  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
      &lt;/div&gt;

    )
  }
}
</code></pre>
","Ah no - they're going to be top level components"
"45424967","how to get data from react-meteor-data container only when it's ready?","0","<p>I am having trouble getting data from my container since isReady stays false. When looking in MeteorToys the collection does get loaded so I do not understand why.</p>

<p>On the server I define the StaticContents collection which gets loaded with ""api"" data. (which I typed in myself for now)</p>

<pre><code>export const StaticContents = new Mongo.Collection(""staticContents"");

if (Meteor.isServer) {
  Meteor.publish(""polled-publication"", function() {
    const publishedKeys = {};
    const poll = () =&gt; {
      // Let's assume the data comes back as an array of JSON documents, with an _id field, for simplicity
      const data = [{ _id: 1, name: ""jef"" }, { _id: 2, name: ""jan"" }];
      const COLLECTION_NAME = ""staticContents"";
      data.forEach(doc =&gt; {
        if (publishedKeys[doc._id]) {
          this.changed(COLLECTION_NAME, doc._id, doc);
        } else {
          publishedKeys[doc._id] = true;
          this.added(COLLECTION_NAME, doc._id, doc);
        }
      });
    };
    poll();
    this.ready();
  });
}
</code></pre>

<p>On the client I import this StaticContents collection and react-meteor-data and put this in a container which passes these variables to my react component.</p>

<pre><code>import { Meteor } from ""meteor/meteor"";
import { Mongo } from ""meteor/mongo"";
import { StaticContents } from ""../api/gap.js"";
import { createContainer } from ""meteor/react-meteor-data"";
import React, { Component } from ""react"";

class Dashboard extends Component {
  componentWillMount() {
    console.log(""log the props"");
    console.log(this.props);
  }
  render() {
    //const gapData = Session.get(""gapData"");
    return (
      &lt;div className=""container""&gt;
        &lt;div className=""starter-template""&gt;
          &lt;h1&gt;This is the dashboard page.&lt;/h1&gt;
          &lt;p className=""lead""&gt;
            Use this document as a way to quickly start any new project.&lt;br /&gt;{"" ""}
            All you get is this text and a mostly barebones HTML document.
          &lt;/p&gt;
          &lt;p&gt;
            {this.props.testprop}
            &lt;br /&gt;
            {this.props.isReady &amp;&amp; this.props.content.name}
            &lt;br /&gt;
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default createContainer(props =&gt; {
  // Do all your reactive data access in this method.
  // Note that this subscription will get cleaned up when your component is unmounted
  const handle = Meteor.subscribe(""polled-publication"");

  return {
    isReady: handle.ready(),
    content: StaticContents.find({}).fetch(),
    testprop: ""this is a testprop""
  };
}, Dashboard);
</code></pre>

<p>When logging the props isReady is false and content is an empty array.
How should I solve this and why is it taking so long to load?</p>

<p>I am using the official meteor guide ""loading from rest"" as a guide.
<a href=""https://guide.meteor.com/data-loading.html#loading-from-rest"" rel=""nofollow noreferrer"">https://guide.meteor.com/data-loading.html#loading-from-rest</a></p>
",""
"45477449","use videojs plugins in react Video JS","3","<p>As doc mentioned I ve initialized video js in react by doing something like this ...</p>

<pre><code>    import React from 'react';
    import videojs from 'video.js'

    export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js
        this.player = videojs(this.videoNode, this.props, function onPlayerReady() {
          console.log('onPlayerReady', this)
        });
      }

      // destroy player on unmount
      componentWillUnmount() {
        if (this.player) {
          this.player.dispose()
        }
      }

      // wrap the player in a div with a `data-vjs-player` attribute
      // so videojs won't create additional wrapper in the DOM
      // see https://github.com/videojs/video.js/pull/3856
      render() {
        return (
          &lt;div data-vjs-player&gt;
            &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
          &lt;/div&gt;
        )
      }
    }
</code></pre>

<p>I want to integrate VideoJs Overlay plugin in this... 
so i ve done something like this...</p>

<pre><code>import React from 'react';
import videojs from 'video.js'

export default class VideoPlayer extends React.Component {
  componentDidMount() {
    // instantiate video.js
    this.player = videojs(this.videoNode, this.props, function onPlayerReady() {

player.overlay({
            content: 'Default overlay content',
            debug: true,
            overlays: [{
              content: 'The video is playing!',
              start: 'play',
              end: 'pause'
            }, {
              start: 0,
              end: 15,
              align: 'bottom-left'
            }, {
              start: 15,
              end: 30,
              align: 'bottom'
            }, {
              start: 30,
              end: 45,
              align: 'bottom-right'
            }, {
              start: 20,
              end: 'pause'
            }]
          });
            });
      }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js"" id=""videojs-overlay-player""&gt;&lt;/video&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>While doing this it give me error like player.overlay is not function...</p>

<p>and if i do     <code>videojs.registerPlugin('overlay', overlay);</code></p>

<p>and call overlay function it gives me error like <code>component Overlay is undefined</code></p>

<p>How to workout videojs plugins in react way????</p>
","did you find a solution/"
"45477449","use videojs plugins in react Video JS","3","<p>As doc mentioned I ve initialized video js in react by doing something like this ...</p>

<pre><code>    import React from 'react';
    import videojs from 'video.js'

    export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js
        this.player = videojs(this.videoNode, this.props, function onPlayerReady() {
          console.log('onPlayerReady', this)
        });
      }

      // destroy player on unmount
      componentWillUnmount() {
        if (this.player) {
          this.player.dispose()
        }
      }

      // wrap the player in a div with a `data-vjs-player` attribute
      // so videojs won't create additional wrapper in the DOM
      // see https://github.com/videojs/video.js/pull/3856
      render() {
        return (
          &lt;div data-vjs-player&gt;
            &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
          &lt;/div&gt;
        )
      }
    }
</code></pre>

<p>I want to integrate VideoJs Overlay plugin in this... 
so i ve done something like this...</p>

<pre><code>import React from 'react';
import videojs from 'video.js'

export default class VideoPlayer extends React.Component {
  componentDidMount() {
    // instantiate video.js
    this.player = videojs(this.videoNode, this.props, function onPlayerReady() {

player.overlay({
            content: 'Default overlay content',
            debug: true,
            overlays: [{
              content: 'The video is playing!',
              start: 'play',
              end: 'pause'
            }, {
              start: 0,
              end: 15,
              align: 'bottom-left'
            }, {
              start: 15,
              end: 30,
              align: 'bottom'
            }, {
              start: 30,
              end: 45,
              align: 'bottom-right'
            }, {
              start: 20,
              end: 'pause'
            }]
          });
            });
      }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js"" id=""videojs-overlay-player""&gt;&lt;/video&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>While doing this it give me error like player.overlay is not function...</p>

<p>and if i do     <code>videojs.registerPlugin('overlay', overlay);</code></p>

<p>and call overlay function it gives me error like <code>component Overlay is undefined</code></p>

<p>How to workout videojs plugins in react way????</p>
","@MarksCode yeah you can just save overlay plugin in your project and import it.  **import overlay from './plugins/videojs-overlay'** and other code runs well."
"45477449","use videojs plugins in react Video JS","3","<p>As doc mentioned I ve initialized video js in react by doing something like this ...</p>

<pre><code>    import React from 'react';
    import videojs from 'video.js'

    export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js
        this.player = videojs(this.videoNode, this.props, function onPlayerReady() {
          console.log('onPlayerReady', this)
        });
      }

      // destroy player on unmount
      componentWillUnmount() {
        if (this.player) {
          this.player.dispose()
        }
      }

      // wrap the player in a div with a `data-vjs-player` attribute
      // so videojs won't create additional wrapper in the DOM
      // see https://github.com/videojs/video.js/pull/3856
      render() {
        return (
          &lt;div data-vjs-player&gt;
            &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
          &lt;/div&gt;
        )
      }
    }
</code></pre>

<p>I want to integrate VideoJs Overlay plugin in this... 
so i ve done something like this...</p>

<pre><code>import React from 'react';
import videojs from 'video.js'

export default class VideoPlayer extends React.Component {
  componentDidMount() {
    // instantiate video.js
    this.player = videojs(this.videoNode, this.props, function onPlayerReady() {

player.overlay({
            content: 'Default overlay content',
            debug: true,
            overlays: [{
              content: 'The video is playing!',
              start: 'play',
              end: 'pause'
            }, {
              start: 0,
              end: 15,
              align: 'bottom-left'
            }, {
              start: 15,
              end: 30,
              align: 'bottom'
            }, {
              start: 30,
              end: 45,
              align: 'bottom-right'
            }, {
              start: 20,
              end: 'pause'
            }]
          });
            });
      }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js"" id=""videojs-overlay-player""&gt;&lt;/video&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>While doing this it give me error like player.overlay is not function...</p>

<p>and if i do     <code>videojs.registerPlugin('overlay', overlay);</code></p>

<p>and call overlay function it gives me error like <code>component Overlay is undefined</code></p>

<p>How to workout videojs plugins in react way????</p>
","I m also looking for something similar to it. Did you find out the solution?"
"45652778","Reactjs Attempted to update component that has already been unmounted","2","<p>I'm trying to build a dashboard showing info in different views. These views can be toggled, i.e. the user should be able to pick the view/representation in a list and the page will show the relevant component for that view.</p>

<p>The code for this looks something like this:</p>

<pre><code>class Dashboard extends Component {
constructor(props) {
    super(props);

    this.state = {
        chartView: true,
        problemsByStatus: {
            chartValues: [],
            tableValues: []
        }
    };
}

componentDidMount() {
    this.loadDashboardInfo();
};

toggleView() {
    this.setState({
        chartView: !this.state.chartView
    })
}

loadDashboardInfo() {
    $.getJSON(""/api/problems"").then((data) =&gt; {
        this.setState({
            problemsByStatus: data;
        })
    });
}

render() {
    return (
        &lt;div className=""animated fadeIn""&gt;
            &lt;div className=""row""&gt;
                 &lt;Toggle
                   className=""pull-right""
                   onClick={() =&gt; this.toggleView()}
                   on={&lt;span&gt;&lt;i className='fa fa-pie-chart'&gt;&lt;/i&gt; Pie chart&lt;/span&gt;}          off={&lt;span&gt;&lt;i className='fa fa-table'&gt;&lt;/i&gt; Table&lt;/span&gt;}          size=""sm""
                   active={this.state.chartView}
            /&gt;
            { this.state.chartView ?
                &lt;div className=""col-md-6 col-md-pull-3 col-sm-12 ""&gt;
                    &lt;DoughnutChart data={this.state.problemsByStatus.chartValues} colorCodes={this.colorCodes} /&gt;
                &lt;/div&gt;
                :
                &lt;div className=""col-md-12 col-sm-12""&gt;
                    &lt;BootstrapTable data={this.state.problemsByStatus.tableValues}&gt;

                    &lt;/BootstrapTable&gt;
                &lt;/div&gt;
            }
            &lt;/div&gt;
        &lt;/div&gt;
        );
}
</code></pre>

<p>}</p>

<p>With DoughnutChart just being a wrapper around the react-chartjs-2 module:</p>

<pre><code>import React from 'react';
import { Chart, Doughnut } from 'react-chartjs-2';

export default class DoughnutChart extends React.Component {
    constructor(props) {
        super(props);

        this.colorCodes = props.colorCodes;

        this.state = {
            data: this.getDoughnutData(props.data)
        };

        var doughnutDraw = Chart.controllers.doughnut.prototype.draw;
        Chart.helpers.extend(Chart.controllers.doughnut.prototype, {
            draw: function() {
                doughnutDraw.apply(this, arguments);

                var chart = this.chart;
                var width = chart.chart.width,
                    height = chart.chart.height,
                    ctx = chart.chart.ctx;

                var fontSize = (height / 114).toFixed(2);
                ctx.font = fontSize + ""em Verdana"";
                ctx.fillStyle = ""#292b2c"";
                ctx.textBaseline = ""middle"";

                var sum = 0;
                for (var i = 0; i &lt; chart.config.data.datasets[0].data.length; i++) {
                    sum += chart.config.data.datasets[0].data[i];
                }

                var text = sum;
                var textX = Math.round((width - ctx.measureText(text).width) / 2);
                var textY = (height + 20) / 2;

                ctx.fillText(text, textX, textY);
            }
        });
    };

    componentWillReceiveProps(nextProps) {
        this.setState({
            data: this.getDoughnutData(nextProps.data)
        });
    }

    getDoughnutData(items) {
        var data = [];
        var labels = [];
        var backgroundColors = [];

        $.each(items, (_, item) =&gt; {
            data.push(item.count);
            labels.push(item.type);
            backgroundColors.push(this.colorCodes[item.type]);
        });

        return {
            datasets: [
                {
                    data: data,
                    backgroundColor: backgroundColors
                }
            ],
            labels: labels
        };
    }

    render() {
        return (
            &lt;Doughnut data={this.state.data}/&gt;
        )
    }
}
</code></pre>

<p>Now, each time i'm switching the view (by changing the chartview state to false) and then switching it back, i get the exception:</p>

<pre><code>Attempted to update component `DoughnutChart` that has already been unmounted (or failed to mount).
</code></pre>

<p>A similar thing happens for the tableview i'm using. I suspect this has to do with the chartValues state that is being updated and still has a reference to the DougnutChart component, so it tries to rerender the component but it was already unmounted (since the tableview was activated). Is this correct? And if so, how would i handle this situation? I always read it was best to switch views in the render method itself, such that the components get unmounted and are not just hidden and needlessly updated. But for me, this causes the issue described above.</p>
","would be helpful to see the code of `DoughnutChart` component"
"45652778","Reactjs Attempted to update component that has already been unmounted","2","<p>I'm trying to build a dashboard showing info in different views. These views can be toggled, i.e. the user should be able to pick the view/representation in a list and the page will show the relevant component for that view.</p>

<p>The code for this looks something like this:</p>

<pre><code>class Dashboard extends Component {
constructor(props) {
    super(props);

    this.state = {
        chartView: true,
        problemsByStatus: {
            chartValues: [],
            tableValues: []
        }
    };
}

componentDidMount() {
    this.loadDashboardInfo();
};

toggleView() {
    this.setState({
        chartView: !this.state.chartView
    })
}

loadDashboardInfo() {
    $.getJSON(""/api/problems"").then((data) =&gt; {
        this.setState({
            problemsByStatus: data;
        })
    });
}

render() {
    return (
        &lt;div className=""animated fadeIn""&gt;
            &lt;div className=""row""&gt;
                 &lt;Toggle
                   className=""pull-right""
                   onClick={() =&gt; this.toggleView()}
                   on={&lt;span&gt;&lt;i className='fa fa-pie-chart'&gt;&lt;/i&gt; Pie chart&lt;/span&gt;}          off={&lt;span&gt;&lt;i className='fa fa-table'&gt;&lt;/i&gt; Table&lt;/span&gt;}          size=""sm""
                   active={this.state.chartView}
            /&gt;
            { this.state.chartView ?
                &lt;div className=""col-md-6 col-md-pull-3 col-sm-12 ""&gt;
                    &lt;DoughnutChart data={this.state.problemsByStatus.chartValues} colorCodes={this.colorCodes} /&gt;
                &lt;/div&gt;
                :
                &lt;div className=""col-md-12 col-sm-12""&gt;
                    &lt;BootstrapTable data={this.state.problemsByStatus.tableValues}&gt;

                    &lt;/BootstrapTable&gt;
                &lt;/div&gt;
            }
            &lt;/div&gt;
        &lt;/div&gt;
        );
}
</code></pre>

<p>}</p>

<p>With DoughnutChart just being a wrapper around the react-chartjs-2 module:</p>

<pre><code>import React from 'react';
import { Chart, Doughnut } from 'react-chartjs-2';

export default class DoughnutChart extends React.Component {
    constructor(props) {
        super(props);

        this.colorCodes = props.colorCodes;

        this.state = {
            data: this.getDoughnutData(props.data)
        };

        var doughnutDraw = Chart.controllers.doughnut.prototype.draw;
        Chart.helpers.extend(Chart.controllers.doughnut.prototype, {
            draw: function() {
                doughnutDraw.apply(this, arguments);

                var chart = this.chart;
                var width = chart.chart.width,
                    height = chart.chart.height,
                    ctx = chart.chart.ctx;

                var fontSize = (height / 114).toFixed(2);
                ctx.font = fontSize + ""em Verdana"";
                ctx.fillStyle = ""#292b2c"";
                ctx.textBaseline = ""middle"";

                var sum = 0;
                for (var i = 0; i &lt; chart.config.data.datasets[0].data.length; i++) {
                    sum += chart.config.data.datasets[0].data[i];
                }

                var text = sum;
                var textX = Math.round((width - ctx.measureText(text).width) / 2);
                var textY = (height + 20) / 2;

                ctx.fillText(text, textX, textY);
            }
        });
    };

    componentWillReceiveProps(nextProps) {
        this.setState({
            data: this.getDoughnutData(nextProps.data)
        });
    }

    getDoughnutData(items) {
        var data = [];
        var labels = [];
        var backgroundColors = [];

        $.each(items, (_, item) =&gt; {
            data.push(item.count);
            labels.push(item.type);
            backgroundColors.push(this.colorCodes[item.type]);
        });

        return {
            datasets: [
                {
                    data: data,
                    backgroundColor: backgroundColors
                }
            ],
            labels: labels
        };
    }

    render() {
        return (
            &lt;Doughnut data={this.state.data}/&gt;
        )
    }
}
</code></pre>

<p>Now, each time i'm switching the view (by changing the chartview state to false) and then switching it back, i get the exception:</p>

<pre><code>Attempted to update component `DoughnutChart` that has already been unmounted (or failed to mount).
</code></pre>

<p>A similar thing happens for the tableview i'm using. I suspect this has to do with the chartValues state that is being updated and still has a reference to the DougnutChart component, so it tries to rerender the component but it was already unmounted (since the tableview was activated). Is this correct? And if so, how would i handle this situation? I always read it was best to switch views in the render method itself, such that the components get unmounted and are not just hidden and needlessly updated. But for me, this causes the issue described above.</p>
","DoughnutChart component has been added to the post. It's just a wrapper around the react-chartjs-2 module."
"45800517","React, setState warning for mounted/unmounted component","4","<p>I have a react component I am using to load my images progressively for my app which has been working great for me. When I use it on a page to load images, though, I am seeing an error:</p>

<blockquote>
  <p>warning.js:35 Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>Multiple times - looks like once for each image called. It does not seem to be effecting anything seriously as the image components still work. I am wondering how to get rid of this error though, I cannot figure out how.</p>

<p>So here is my component:</p>

<pre><code>import React, { PropTypes } from 'react';

require('./progressive-image.scss');

export default class ProgressiveImage extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      loaded: false,
      image: props.smallImg
    };

    this.loadImage = this.loadImage.bind(this);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.image = undefined;
  }

  componentDidMount() {
    const { largeImg } = this.props;
    this.loadImage(largeImg);
  }

  onError(err) {
    console.warn('Error loading progressive image :', err);
  }

  onLoad() {
    this.setState({
      loaded: true,
      image: this.image.src
    });
  }

  componentDidUpdate(nextProps) {
    const { largeImg, smallImg } = nextProps;

    if (largeImg !== this.props.largeImg) {
      this.setState({ loaded: false, image: smallImg }, () =&gt; {
        this.loadImage(largeImg);
      });
    }
  }


  loadImage(src) {
    if (this.image) {
      this.image.onload = null;
      this.image.onerror = null;
    }

    const image = new Image();
    this.image = image;
    image.onload = this.onLoad;
    image.onerror = this.onError;
    image.src = src;
  }

  render() {
    const imgStyle = { 'paddingBottom': this.props.heightRatio };
    const { imgAlt, imgTitle } = this.props;

    return (
      &lt;div className={`progressive-placeholder ${this.state.loaded ? 'loaded' : ''}`}&gt;
        {this.state.loaded &amp;&amp;
          &lt;img
            alt={imgAlt}
            className={`loaded`}
            src={this.state.image}
            title={imgTitle}
             /&gt;
        }
        &lt;img className={`img-small ${!this.state.loaded ? 'loaded' : ''}`} src={this.state.image} alt=""placeholder image for loading""/&gt;
        &lt;div style={imgStyle} &gt;&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ProgressiveImage.displayName = 'ProgressiveImage';

ProgressiveImage.propTypes = {
  bgColor: PropTypes.string,
  heightRatio: PropTypes.string.isRequired,
  largeImg: PropTypes.string.isRequired,
  smallImg: PropTypes.string.isRequired,
  imgAlt: PropTypes.string,
  imgTitle: PropTypes.string,
};
</code></pre>

<p>So the only time setState is called is when <code>onLoad</code>or <code>componentDidUpdate</code> is called. My thinking is that because its only called did mount and did update it should not be getting this error. Looking for any insight on how to clean up this error, as it has me puzzled. If any additional info is needed, I am happy to provide.</p>
","Just a note, `Prop-Types` have been moved to their own package and will be removed from the `React` package in future releases."
"45800517","React, setState warning for mounted/unmounted component","4","<p>I have a react component I am using to load my images progressively for my app which has been working great for me. When I use it on a page to load images, though, I am seeing an error:</p>

<blockquote>
  <p>warning.js:35 Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>Multiple times - looks like once for each image called. It does not seem to be effecting anything seriously as the image components still work. I am wondering how to get rid of this error though, I cannot figure out how.</p>

<p>So here is my component:</p>

<pre><code>import React, { PropTypes } from 'react';

require('./progressive-image.scss');

export default class ProgressiveImage extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      loaded: false,
      image: props.smallImg
    };

    this.loadImage = this.loadImage.bind(this);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.image = undefined;
  }

  componentDidMount() {
    const { largeImg } = this.props;
    this.loadImage(largeImg);
  }

  onError(err) {
    console.warn('Error loading progressive image :', err);
  }

  onLoad() {
    this.setState({
      loaded: true,
      image: this.image.src
    });
  }

  componentDidUpdate(nextProps) {
    const { largeImg, smallImg } = nextProps;

    if (largeImg !== this.props.largeImg) {
      this.setState({ loaded: false, image: smallImg }, () =&gt; {
        this.loadImage(largeImg);
      });
    }
  }


  loadImage(src) {
    if (this.image) {
      this.image.onload = null;
      this.image.onerror = null;
    }

    const image = new Image();
    this.image = image;
    image.onload = this.onLoad;
    image.onerror = this.onError;
    image.src = src;
  }

  render() {
    const imgStyle = { 'paddingBottom': this.props.heightRatio };
    const { imgAlt, imgTitle } = this.props;

    return (
      &lt;div className={`progressive-placeholder ${this.state.loaded ? 'loaded' : ''}`}&gt;
        {this.state.loaded &amp;&amp;
          &lt;img
            alt={imgAlt}
            className={`loaded`}
            src={this.state.image}
            title={imgTitle}
             /&gt;
        }
        &lt;img className={`img-small ${!this.state.loaded ? 'loaded' : ''}`} src={this.state.image} alt=""placeholder image for loading""/&gt;
        &lt;div style={imgStyle} &gt;&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ProgressiveImage.displayName = 'ProgressiveImage';

ProgressiveImage.propTypes = {
  bgColor: PropTypes.string,
  heightRatio: PropTypes.string.isRequired,
  largeImg: PropTypes.string.isRequired,
  smallImg: PropTypes.string.isRequired,
  imgAlt: PropTypes.string,
  imgTitle: PropTypes.string,
};
</code></pre>

<p>So the only time setState is called is when <code>onLoad</code>or <code>componentDidUpdate</code> is called. My thinking is that because its only called did mount and did update it should not be getting this error. Looking for any insight on how to clean up this error, as it has me puzzled. If any additional info is needed, I am happy to provide.</p>
","@DimitarChristoff is that what's causing the issue then? I tried swapping it to componentWillUpdate, and still am seeing the error."
"45800517","React, setState warning for mounted/unmounted component","4","<p>I have a react component I am using to load my images progressively for my app which has been working great for me. When I use it on a page to load images, though, I am seeing an error:</p>

<blockquote>
  <p>warning.js:35 Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>Multiple times - looks like once for each image called. It does not seem to be effecting anything seriously as the image components still work. I am wondering how to get rid of this error though, I cannot figure out how.</p>

<p>So here is my component:</p>

<pre><code>import React, { PropTypes } from 'react';

require('./progressive-image.scss');

export default class ProgressiveImage extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      loaded: false,
      image: props.smallImg
    };

    this.loadImage = this.loadImage.bind(this);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.image = undefined;
  }

  componentDidMount() {
    const { largeImg } = this.props;
    this.loadImage(largeImg);
  }

  onError(err) {
    console.warn('Error loading progressive image :', err);
  }

  onLoad() {
    this.setState({
      loaded: true,
      image: this.image.src
    });
  }

  componentDidUpdate(nextProps) {
    const { largeImg, smallImg } = nextProps;

    if (largeImg !== this.props.largeImg) {
      this.setState({ loaded: false, image: smallImg }, () =&gt; {
        this.loadImage(largeImg);
      });
    }
  }


  loadImage(src) {
    if (this.image) {
      this.image.onload = null;
      this.image.onerror = null;
    }

    const image = new Image();
    this.image = image;
    image.onload = this.onLoad;
    image.onerror = this.onError;
    image.src = src;
  }

  render() {
    const imgStyle = { 'paddingBottom': this.props.heightRatio };
    const { imgAlt, imgTitle } = this.props;

    return (
      &lt;div className={`progressive-placeholder ${this.state.loaded ? 'loaded' : ''}`}&gt;
        {this.state.loaded &amp;&amp;
          &lt;img
            alt={imgAlt}
            className={`loaded`}
            src={this.state.image}
            title={imgTitle}
             /&gt;
        }
        &lt;img className={`img-small ${!this.state.loaded ? 'loaded' : ''}`} src={this.state.image} alt=""placeholder image for loading""/&gt;
        &lt;div style={imgStyle} &gt;&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ProgressiveImage.displayName = 'ProgressiveImage';

ProgressiveImage.propTypes = {
  bgColor: PropTypes.string,
  heightRatio: PropTypes.string.isRequired,
  largeImg: PropTypes.string.isRequired,
  smallImg: PropTypes.string.isRequired,
  imgAlt: PropTypes.string,
  imgTitle: PropTypes.string,
};
</code></pre>

<p>So the only time setState is called is when <code>onLoad</code>or <code>componentDidUpdate</code> is called. My thinking is that because its only called did mount and did update it should not be getting this error. Looking for any insight on how to clean up this error, as it has me puzzled. If any additional info is needed, I am happy to provide.</p>
","can't mutate state on didUpdate, or it will go into an endless loop."
"45800517","React, setState warning for mounted/unmounted component","4","<p>I have a react component I am using to load my images progressively for my app which has been working great for me. When I use it on a page to load images, though, I am seeing an error:</p>

<blockquote>
  <p>warning.js:35 Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.</p>
</blockquote>

<p>Multiple times - looks like once for each image called. It does not seem to be effecting anything seriously as the image components still work. I am wondering how to get rid of this error though, I cannot figure out how.</p>

<p>So here is my component:</p>

<pre><code>import React, { PropTypes } from 'react';

require('./progressive-image.scss');

export default class ProgressiveImage extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      loaded: false,
      image: props.smallImg
    };

    this.loadImage = this.loadImage.bind(this);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.image = undefined;
  }

  componentDidMount() {
    const { largeImg } = this.props;
    this.loadImage(largeImg);
  }

  onError(err) {
    console.warn('Error loading progressive image :', err);
  }

  onLoad() {
    this.setState({
      loaded: true,
      image: this.image.src
    });
  }

  componentDidUpdate(nextProps) {
    const { largeImg, smallImg } = nextProps;

    if (largeImg !== this.props.largeImg) {
      this.setState({ loaded: false, image: smallImg }, () =&gt; {
        this.loadImage(largeImg);
      });
    }
  }


  loadImage(src) {
    if (this.image) {
      this.image.onload = null;
      this.image.onerror = null;
    }

    const image = new Image();
    this.image = image;
    image.onload = this.onLoad;
    image.onerror = this.onError;
    image.src = src;
  }

  render() {
    const imgStyle = { 'paddingBottom': this.props.heightRatio };
    const { imgAlt, imgTitle } = this.props;

    return (
      &lt;div className={`progressive-placeholder ${this.state.loaded ? 'loaded' : ''}`}&gt;
        {this.state.loaded &amp;&amp;
          &lt;img
            alt={imgAlt}
            className={`loaded`}
            src={this.state.image}
            title={imgTitle}
             /&gt;
        }
        &lt;img className={`img-small ${!this.state.loaded ? 'loaded' : ''}`} src={this.state.image} alt=""placeholder image for loading""/&gt;
        &lt;div style={imgStyle} &gt;&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ProgressiveImage.displayName = 'ProgressiveImage';

ProgressiveImage.propTypes = {
  bgColor: PropTypes.string,
  heightRatio: PropTypes.string.isRequired,
  largeImg: PropTypes.string.isRequired,
  smallImg: PropTypes.string.isRequired,
  imgAlt: PropTypes.string,
  imgTitle: PropTypes.string,
};
</code></pre>

<p>So the only time setState is called is when <code>onLoad</code>or <code>componentDidUpdate</code> is called. My thinking is that because its only called did mount and did update it should not be getting this error. Looking for any insight on how to clean up this error, as it has me puzzled. If any additional info is needed, I am happy to provide.</p>
","How did this `componentDidlUpdate` typo get in there?"
"46062894","React.js -- How to add an animation when unmounting a component and mounting another?","2","<p>I have this code for unmounting and remounting elements:</p>

<pre><code>import React, { Component } from 'react';
import './App.css';
import Header from './Header';
import Bottom1 from './Bottom1';
import Bottom2 from './Bottom2';
class App extends Component {
  constructor(){
    super();
    this.state={
      playWindow: true
     }
     this.update = this.update.bind(this);
  }

  update(){
    const newState = this.state.playWindow? false : true;
    this.setState({playWindow: newState});
  }

  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;Header update={this.update}/&gt;
        {this.state.playWindow?  &lt;Bottom1/&gt;  : &lt;Bottom2/&gt; }
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>

<p>When I do the action, the components are exchanged. The problem is that there is no transition, the toggle fells rough. How do I add an animation, like one fading out, and then the other fading in?</p>
","https://github.com/reactjs/react-transition-group/tree/v1-stable"
"46110082","Cancel async request on unmount with axios","0","<p>I have multiple component with <a href=""https://github.com/mzabriskie/axios"" rel=""nofollow noreferrer"">axios</a> plugin for some get requests. i need some help to cancel all xhr request with axios on component unmount event in react js. but the axios cancel code is not working. its return me cancel() is not a function error.</p>

<p><strong>Code example</strong>:-</p>

<pre><code>import axios from 'axios';


var CancelToken = axios.CancelToken;
var cancel;

axios.get('abc/xyz', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});

// cancel the request
cancel();
</code></pre>

<p>Please help me to implement cancel request in axios.</p>

<p>Thanks.</p>
",""
"46265467","How to load async react components without Webpack imports with SSR and RR4","0","<p>I have been looking for a good solution to load async react components on demand at matched route without Webpack import, System.import, require.ensure, ...</p>

<p>I want to <strong>avoid Webpack footprints in client-side code</strong>.</p>

<p>On Server I fetch all routes and render matched locations as static HTML/JS. Like classic SSR.</p>

<h1>My solution is:</h1>

<ul>
<li>Pack async Components with Webpack to static bundles (<em>c1.js</em>, c2.js, ...)</li>
<li>Store Map for Routes => async Components as json (""/path"" => <em>c1.js</em>)</li>
<li>Request React-Rroute(RR4) matched path with param <code>wrap=true</code> over ajax</li>
<li>If route exists, and param <code>wrap=true</code> render <em>c1.js</em> on server to fetch data (universal ajax) from DB</li>
<li>Wrap data and raw <em>c1.js</em> as script response</li>
<li>Append response as script child at body or parent React Component Dom</li>
<li>Script unwraps data and code, stores them (e.g. Redux) and append/render async component (<em>c1.js</em>) to React Dom</li>
</ul>

<p><strong>This way i have a small entry file and could:</strong></p>

<ol>
<li>request route <code>https://host</code> and load component (/path) on demand</li>
<li>request route <code>https://host/path</code> on entry and render compleate components (no async)</li>
<li>request route <code>https://host/path</code> with RR4 and fetch and render async component(s)</li>
<li>reload page like 2.</li>
<li><p>use browser history (back-forward) without requests for data or components (both exist in Redux store and script tag)  </p></li>
<li><p>Be able to use component with pagination (load more data and reuse fetched component)</p></li>
</ol>

<p><strong>My thoughts on this:</strong><br>
 Render async components direct to Dom instead cache them in script tag will lose component code on unmount parent Component (because async component not exist in main.bundle.js)</p>

<h1>Questions:</h1>

<ul>
<li>Is there a proven approach to handle async component loading (<strong>React code only</strong> and without <strong>Webpack hacky imports</strong>) and be able to render universal?</li>
<li><p>Is it bad practice to split react code over independent bundles?</p>

<pre><code>`&lt;script src=bundle.js /&gt;&lt;script&gt;*c1.js* code&lt;/script&gt;`
</code></pre></li>
<li>Is it bad practice to appand script tag to react component dom (like <code>&lt;App/&gt;</code> or <code>&lt;Home/&gt;</code>)  

<ul>
<li>Whats about HMR (Maybe side effects)?</li>
</ul></li>
</ul>
",""
"46612722","React Child component will mount then unmount after calling parent function to set parent state","4","<p>I have two components, parent and child. The parent keeps track of the audio player component (the child is the player) and what segment the player is playing, e.g. segment 1 might be the first 34 seconds followed by the second segment until 215 seconds, etc.</p>

<p>My parent component renders the Player component and passes a bound function to the Player so the Player can update the parent with the current time of the player so the parent can figure out which segment should be highlighted.</p>

<p><em>The problems</em> are that (1) (major problem) once play button is clicked and it plays, or the user skips, beyond the first segment break then the state of the parent updates but the Player is unmounted, causing the MediaElement to be removed; (2) (minor problem) when initially loading the page, the Player unmounts, followed by the parent mounting, followed by the Player unmounting and mounting again. I believe they're related.</p>

<p>parent:</p>

<pre><code>import React from 'react'
import shortid from 'shortid'

import Frame from '../../layout/Frame'
import Box from '../../layout/Box'
import Flex from '../../layout/Flex'
import G1 from '../../layout/G1'

import Player from '../../parts/Player'

import BriefingTitle from './BriefingTitle'

import {assoc, lensPath, set, view} from 'ramda'
import {createMarkup} from '../../../lib/tools'

class Briefing extends React.Component {
  constructor({briefing}) {
    super()

    const segments = briefing.segments.map(assoc('playing', false))
    console.log('segments:', segments)
    this.state = {
      briefing,
      segments
    }
    this.parentMonitor = this.updateSegments.bind(this)
  }

  updateSegments(time) {
    console.log('time:', time)
    const firstPlayingLens = lensPath([0, 'playing'])
    if (time &gt; 36 &amp;&amp; !view(firstPlayingLens, this.state.segments)) {
      this.setState(set(firstPlayingLens, true, this.state.segments))
    }
  }

  componentDidMount() {
    console.log('Briefing mounted')
  }

  componentWillUnmount() {
    console.log('Briefing will unmount')
  }

  render() {
    const {briefing, segments} = this.state
    return (
      &lt;Frame pb={['0px', 3]}&gt;
        &lt;G1&gt;
          &lt;Flex pt={[2, 3]} direction={['column', 'row']}&gt;
            &lt;Box mt={[2, 'm']} mr={2} shrink={0} grow={2} order={[2, 1]}&gt;
              &lt;BriefingTitle&gt;&lt;span dangerouslySetInnerHTML={createMarkup(briefing.title)} /&gt;&lt;/BriefingTitle&gt;

              &lt;Box mt={0} pt={0} bt&gt;
                &lt;Player key={'briefing_'+briefing.id} url={briefing.audioFile} type=""audio/mp3"" duration={briefing.duration} parentMonitor={this.parentMonitor}&gt;Play Full Episode&lt;/Player&gt;
              &lt;/Box&gt;
              &lt;Box mt={0} pt={0} bt&gt;
                {briefing.segments.map(s =&gt; s.playing ? &lt;p&gt;&lt;strong&gt;{s.title}&lt;/strong&gt;&lt;/p&gt; : &lt;p&gt;{s.title}&lt;/p&gt;)}
              &lt;/Box&gt;
            &lt;/Box&gt;
          &lt;/Flex&gt;
        &lt;/G1&gt;
      &lt;/Frame&gt;
    )
  }
}

export default Briefing
</code></pre>

<p>Player:</p>

<pre><code>import React from 'react'
import styled from 'styled-components'

import Flex from '../../layout/Flex'
import Box from '../../layout/Box'

import 'mediaelement'
import 'mediaelement/build/mediaelementplayer.min.css'
import 'mediaelement/build/mediaelement-flash-video.swf'
import 'mediaelement-plugins/dist/skip-back/skip-back.min.js'
import 'mediaelement-plugins/dist/skip-back/skip-back.css'

import {rem} from '../../../lib/tools'
import {type} from '../../../designSystem'

const StyledSpan = styled.span`
  font-family: ${type.family.default};
  font-size: ${rem(type.size.s0)};
  font-weight: ${type.weight.bold};
  line-height: ${type.lineHeight.meta};
`

class Player extends React.Component {
  constructor(props, {
    inverse = props.inverse ? true : false
  }) {
    super()
    this.state = {
      inverse,
      children: props.children,
      player: null
    }
  }

  monitor(media) {
    this.props.parentMonitor(media.getCurrentTime())
    setTimeout(this.playing.bind(this), 200)
  }

  playing() {
    this.monitor(this.state.player)
  }

  success(media, node, instance) {
    // successfully loaded!
    const playEvent = e =&gt; this.playing()
    media.addEventListener('playing', playEvent)
    media.removeEventListener('pause', playEvent)
    media.removeEventListener('ended', playEvent)
  }

  error(media) {
    // failed to load
  }

  componentDidMount() {
    console.log('Player mounted')
    const {MediaElementPlayer} = global
    if (MediaElementPlayer) {
      const options = {
        features: ['skipback'],
        useDefaultControls: true,
        pluginPath: './build/static/media/',
        skipBackInterval: 31,
        skipBackText: 'Rewind 30 seconds',
        success: (media, node, instance) =&gt; this.success(media, node, instance),
        error: (media, node) =&gt; this.error(media, node)
      }
      this.setState({player: new MediaElementPlayer('player_'+this.props.key, options)})
    }
  }

  componentWillUnmount() {
    console.log('Player will unmount')
    if (this.state.player) {
      this.state.player.remove()
      this.setState({player: null})
    }
  }

  shouldComponentUpdate() {
    return false
  }

  render() {
    return (
      &lt;Flex justify={this.state.children ? 'space-between' : ''} align=""center""&gt;
        &lt;Flex align=""center""&gt;
          &lt;audio id={'player_'+this.props.key} width={this.props.width || 400}&gt;
            &lt;source src={this.props.url} type={this.props.type} /&gt;
          &lt;/audio&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    )
  }
}

export default Player
</code></pre>

<p>I'm using <a href=""https://www.npmjs.com/package/mediaelement"" rel=""nofollow noreferrer"">MediaElement</a> and React 15.5.4. </p>
","For the Briefing component try setting a key for the Player to something like this: `<Player key=""MyPlayer"" ... />`"
"46612722","React Child component will mount then unmount after calling parent function to set parent state","4","<p>I have two components, parent and child. The parent keeps track of the audio player component (the child is the player) and what segment the player is playing, e.g. segment 1 might be the first 34 seconds followed by the second segment until 215 seconds, etc.</p>

<p>My parent component renders the Player component and passes a bound function to the Player so the Player can update the parent with the current time of the player so the parent can figure out which segment should be highlighted.</p>

<p><em>The problems</em> are that (1) (major problem) once play button is clicked and it plays, or the user skips, beyond the first segment break then the state of the parent updates but the Player is unmounted, causing the MediaElement to be removed; (2) (minor problem) when initially loading the page, the Player unmounts, followed by the parent mounting, followed by the Player unmounting and mounting again. I believe they're related.</p>

<p>parent:</p>

<pre><code>import React from 'react'
import shortid from 'shortid'

import Frame from '../../layout/Frame'
import Box from '../../layout/Box'
import Flex from '../../layout/Flex'
import G1 from '../../layout/G1'

import Player from '../../parts/Player'

import BriefingTitle from './BriefingTitle'

import {assoc, lensPath, set, view} from 'ramda'
import {createMarkup} from '../../../lib/tools'

class Briefing extends React.Component {
  constructor({briefing}) {
    super()

    const segments = briefing.segments.map(assoc('playing', false))
    console.log('segments:', segments)
    this.state = {
      briefing,
      segments
    }
    this.parentMonitor = this.updateSegments.bind(this)
  }

  updateSegments(time) {
    console.log('time:', time)
    const firstPlayingLens = lensPath([0, 'playing'])
    if (time &gt; 36 &amp;&amp; !view(firstPlayingLens, this.state.segments)) {
      this.setState(set(firstPlayingLens, true, this.state.segments))
    }
  }

  componentDidMount() {
    console.log('Briefing mounted')
  }

  componentWillUnmount() {
    console.log('Briefing will unmount')
  }

  render() {
    const {briefing, segments} = this.state
    return (
      &lt;Frame pb={['0px', 3]}&gt;
        &lt;G1&gt;
          &lt;Flex pt={[2, 3]} direction={['column', 'row']}&gt;
            &lt;Box mt={[2, 'm']} mr={2} shrink={0} grow={2} order={[2, 1]}&gt;
              &lt;BriefingTitle&gt;&lt;span dangerouslySetInnerHTML={createMarkup(briefing.title)} /&gt;&lt;/BriefingTitle&gt;

              &lt;Box mt={0} pt={0} bt&gt;
                &lt;Player key={'briefing_'+briefing.id} url={briefing.audioFile} type=""audio/mp3"" duration={briefing.duration} parentMonitor={this.parentMonitor}&gt;Play Full Episode&lt;/Player&gt;
              &lt;/Box&gt;
              &lt;Box mt={0} pt={0} bt&gt;
                {briefing.segments.map(s =&gt; s.playing ? &lt;p&gt;&lt;strong&gt;{s.title}&lt;/strong&gt;&lt;/p&gt; : &lt;p&gt;{s.title}&lt;/p&gt;)}
              &lt;/Box&gt;
            &lt;/Box&gt;
          &lt;/Flex&gt;
        &lt;/G1&gt;
      &lt;/Frame&gt;
    )
  }
}

export default Briefing
</code></pre>

<p>Player:</p>

<pre><code>import React from 'react'
import styled from 'styled-components'

import Flex from '../../layout/Flex'
import Box from '../../layout/Box'

import 'mediaelement'
import 'mediaelement/build/mediaelementplayer.min.css'
import 'mediaelement/build/mediaelement-flash-video.swf'
import 'mediaelement-plugins/dist/skip-back/skip-back.min.js'
import 'mediaelement-plugins/dist/skip-back/skip-back.css'

import {rem} from '../../../lib/tools'
import {type} from '../../../designSystem'

const StyledSpan = styled.span`
  font-family: ${type.family.default};
  font-size: ${rem(type.size.s0)};
  font-weight: ${type.weight.bold};
  line-height: ${type.lineHeight.meta};
`

class Player extends React.Component {
  constructor(props, {
    inverse = props.inverse ? true : false
  }) {
    super()
    this.state = {
      inverse,
      children: props.children,
      player: null
    }
  }

  monitor(media) {
    this.props.parentMonitor(media.getCurrentTime())
    setTimeout(this.playing.bind(this), 200)
  }

  playing() {
    this.monitor(this.state.player)
  }

  success(media, node, instance) {
    // successfully loaded!
    const playEvent = e =&gt; this.playing()
    media.addEventListener('playing', playEvent)
    media.removeEventListener('pause', playEvent)
    media.removeEventListener('ended', playEvent)
  }

  error(media) {
    // failed to load
  }

  componentDidMount() {
    console.log('Player mounted')
    const {MediaElementPlayer} = global
    if (MediaElementPlayer) {
      const options = {
        features: ['skipback'],
        useDefaultControls: true,
        pluginPath: './build/static/media/',
        skipBackInterval: 31,
        skipBackText: 'Rewind 30 seconds',
        success: (media, node, instance) =&gt; this.success(media, node, instance),
        error: (media, node) =&gt; this.error(media, node)
      }
      this.setState({player: new MediaElementPlayer('player_'+this.props.key, options)})
    }
  }

  componentWillUnmount() {
    console.log('Player will unmount')
    if (this.state.player) {
      this.state.player.remove()
      this.setState({player: null})
    }
  }

  shouldComponentUpdate() {
    return false
  }

  render() {
    return (
      &lt;Flex justify={this.state.children ? 'space-between' : ''} align=""center""&gt;
        &lt;Flex align=""center""&gt;
          &lt;audio id={'player_'+this.props.key} width={this.props.width || 400}&gt;
            &lt;source src={this.props.url} type={this.props.type} /&gt;
          &lt;/audio&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    )
  }
}

export default Player
</code></pre>

<p>I'm using <a href=""https://www.npmjs.com/package/mediaelement"" rel=""nofollow noreferrer"">MediaElement</a> and React 15.5.4. </p>
","Thanks @Hoyen. I added it and it may have resolved the minor problem but the major one, the player being unmounted, remains. I'll update the question with your suggestion."
"46612722","React Child component will mount then unmount after calling parent function to set parent state","4","<p>I have two components, parent and child. The parent keeps track of the audio player component (the child is the player) and what segment the player is playing, e.g. segment 1 might be the first 34 seconds followed by the second segment until 215 seconds, etc.</p>

<p>My parent component renders the Player component and passes a bound function to the Player so the Player can update the parent with the current time of the player so the parent can figure out which segment should be highlighted.</p>

<p><em>The problems</em> are that (1) (major problem) once play button is clicked and it plays, or the user skips, beyond the first segment break then the state of the parent updates but the Player is unmounted, causing the MediaElement to be removed; (2) (minor problem) when initially loading the page, the Player unmounts, followed by the parent mounting, followed by the Player unmounting and mounting again. I believe they're related.</p>

<p>parent:</p>

<pre><code>import React from 'react'
import shortid from 'shortid'

import Frame from '../../layout/Frame'
import Box from '../../layout/Box'
import Flex from '../../layout/Flex'
import G1 from '../../layout/G1'

import Player from '../../parts/Player'

import BriefingTitle from './BriefingTitle'

import {assoc, lensPath, set, view} from 'ramda'
import {createMarkup} from '../../../lib/tools'

class Briefing extends React.Component {
  constructor({briefing}) {
    super()

    const segments = briefing.segments.map(assoc('playing', false))
    console.log('segments:', segments)
    this.state = {
      briefing,
      segments
    }
    this.parentMonitor = this.updateSegments.bind(this)
  }

  updateSegments(time) {
    console.log('time:', time)
    const firstPlayingLens = lensPath([0, 'playing'])
    if (time &gt; 36 &amp;&amp; !view(firstPlayingLens, this.state.segments)) {
      this.setState(set(firstPlayingLens, true, this.state.segments))
    }
  }

  componentDidMount() {
    console.log('Briefing mounted')
  }

  componentWillUnmount() {
    console.log('Briefing will unmount')
  }

  render() {
    const {briefing, segments} = this.state
    return (
      &lt;Frame pb={['0px', 3]}&gt;
        &lt;G1&gt;
          &lt;Flex pt={[2, 3]} direction={['column', 'row']}&gt;
            &lt;Box mt={[2, 'm']} mr={2} shrink={0} grow={2} order={[2, 1]}&gt;
              &lt;BriefingTitle&gt;&lt;span dangerouslySetInnerHTML={createMarkup(briefing.title)} /&gt;&lt;/BriefingTitle&gt;

              &lt;Box mt={0} pt={0} bt&gt;
                &lt;Player key={'briefing_'+briefing.id} url={briefing.audioFile} type=""audio/mp3"" duration={briefing.duration} parentMonitor={this.parentMonitor}&gt;Play Full Episode&lt;/Player&gt;
              &lt;/Box&gt;
              &lt;Box mt={0} pt={0} bt&gt;
                {briefing.segments.map(s =&gt; s.playing ? &lt;p&gt;&lt;strong&gt;{s.title}&lt;/strong&gt;&lt;/p&gt; : &lt;p&gt;{s.title}&lt;/p&gt;)}
              &lt;/Box&gt;
            &lt;/Box&gt;
          &lt;/Flex&gt;
        &lt;/G1&gt;
      &lt;/Frame&gt;
    )
  }
}

export default Briefing
</code></pre>

<p>Player:</p>

<pre><code>import React from 'react'
import styled from 'styled-components'

import Flex from '../../layout/Flex'
import Box from '../../layout/Box'

import 'mediaelement'
import 'mediaelement/build/mediaelementplayer.min.css'
import 'mediaelement/build/mediaelement-flash-video.swf'
import 'mediaelement-plugins/dist/skip-back/skip-back.min.js'
import 'mediaelement-plugins/dist/skip-back/skip-back.css'

import {rem} from '../../../lib/tools'
import {type} from '../../../designSystem'

const StyledSpan = styled.span`
  font-family: ${type.family.default};
  font-size: ${rem(type.size.s0)};
  font-weight: ${type.weight.bold};
  line-height: ${type.lineHeight.meta};
`

class Player extends React.Component {
  constructor(props, {
    inverse = props.inverse ? true : false
  }) {
    super()
    this.state = {
      inverse,
      children: props.children,
      player: null
    }
  }

  monitor(media) {
    this.props.parentMonitor(media.getCurrentTime())
    setTimeout(this.playing.bind(this), 200)
  }

  playing() {
    this.monitor(this.state.player)
  }

  success(media, node, instance) {
    // successfully loaded!
    const playEvent = e =&gt; this.playing()
    media.addEventListener('playing', playEvent)
    media.removeEventListener('pause', playEvent)
    media.removeEventListener('ended', playEvent)
  }

  error(media) {
    // failed to load
  }

  componentDidMount() {
    console.log('Player mounted')
    const {MediaElementPlayer} = global
    if (MediaElementPlayer) {
      const options = {
        features: ['skipback'],
        useDefaultControls: true,
        pluginPath: './build/static/media/',
        skipBackInterval: 31,
        skipBackText: 'Rewind 30 seconds',
        success: (media, node, instance) =&gt; this.success(media, node, instance),
        error: (media, node) =&gt; this.error(media, node)
      }
      this.setState({player: new MediaElementPlayer('player_'+this.props.key, options)})
    }
  }

  componentWillUnmount() {
    console.log('Player will unmount')
    if (this.state.player) {
      this.state.player.remove()
      this.setState({player: null})
    }
  }

  shouldComponentUpdate() {
    return false
  }

  render() {
    return (
      &lt;Flex justify={this.state.children ? 'space-between' : ''} align=""center""&gt;
        &lt;Flex align=""center""&gt;
          &lt;audio id={'player_'+this.props.key} width={this.props.width || 400}&gt;
            &lt;source src={this.props.url} type={this.props.type} /&gt;
          &lt;/audio&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    )
  }
}

export default Player
</code></pre>

<p>I'm using <a href=""https://www.npmjs.com/package/mediaelement"" rel=""nofollow noreferrer"">MediaElement</a> and React 15.5.4. </p>
","When you `setState()`, it causes the entire component to re-render. That's propably why it is unmounting. Do you need `segments` when you render the component? If not, implement a `shouldComponentUpdate()` function and have it return false if you don't want it to re-render."
"46612722","React Child component will mount then unmount after calling parent function to set parent state","4","<p>I have two components, parent and child. The parent keeps track of the audio player component (the child is the player) and what segment the player is playing, e.g. segment 1 might be the first 34 seconds followed by the second segment until 215 seconds, etc.</p>

<p>My parent component renders the Player component and passes a bound function to the Player so the Player can update the parent with the current time of the player so the parent can figure out which segment should be highlighted.</p>

<p><em>The problems</em> are that (1) (major problem) once play button is clicked and it plays, or the user skips, beyond the first segment break then the state of the parent updates but the Player is unmounted, causing the MediaElement to be removed; (2) (minor problem) when initially loading the page, the Player unmounts, followed by the parent mounting, followed by the Player unmounting and mounting again. I believe they're related.</p>

<p>parent:</p>

<pre><code>import React from 'react'
import shortid from 'shortid'

import Frame from '../../layout/Frame'
import Box from '../../layout/Box'
import Flex from '../../layout/Flex'
import G1 from '../../layout/G1'

import Player from '../../parts/Player'

import BriefingTitle from './BriefingTitle'

import {assoc, lensPath, set, view} from 'ramda'
import {createMarkup} from '../../../lib/tools'

class Briefing extends React.Component {
  constructor({briefing}) {
    super()

    const segments = briefing.segments.map(assoc('playing', false))
    console.log('segments:', segments)
    this.state = {
      briefing,
      segments
    }
    this.parentMonitor = this.updateSegments.bind(this)
  }

  updateSegments(time) {
    console.log('time:', time)
    const firstPlayingLens = lensPath([0, 'playing'])
    if (time &gt; 36 &amp;&amp; !view(firstPlayingLens, this.state.segments)) {
      this.setState(set(firstPlayingLens, true, this.state.segments))
    }
  }

  componentDidMount() {
    console.log('Briefing mounted')
  }

  componentWillUnmount() {
    console.log('Briefing will unmount')
  }

  render() {
    const {briefing, segments} = this.state
    return (
      &lt;Frame pb={['0px', 3]}&gt;
        &lt;G1&gt;
          &lt;Flex pt={[2, 3]} direction={['column', 'row']}&gt;
            &lt;Box mt={[2, 'm']} mr={2} shrink={0} grow={2} order={[2, 1]}&gt;
              &lt;BriefingTitle&gt;&lt;span dangerouslySetInnerHTML={createMarkup(briefing.title)} /&gt;&lt;/BriefingTitle&gt;

              &lt;Box mt={0} pt={0} bt&gt;
                &lt;Player key={'briefing_'+briefing.id} url={briefing.audioFile} type=""audio/mp3"" duration={briefing.duration} parentMonitor={this.parentMonitor}&gt;Play Full Episode&lt;/Player&gt;
              &lt;/Box&gt;
              &lt;Box mt={0} pt={0} bt&gt;
                {briefing.segments.map(s =&gt; s.playing ? &lt;p&gt;&lt;strong&gt;{s.title}&lt;/strong&gt;&lt;/p&gt; : &lt;p&gt;{s.title}&lt;/p&gt;)}
              &lt;/Box&gt;
            &lt;/Box&gt;
          &lt;/Flex&gt;
        &lt;/G1&gt;
      &lt;/Frame&gt;
    )
  }
}

export default Briefing
</code></pre>

<p>Player:</p>

<pre><code>import React from 'react'
import styled from 'styled-components'

import Flex from '../../layout/Flex'
import Box from '../../layout/Box'

import 'mediaelement'
import 'mediaelement/build/mediaelementplayer.min.css'
import 'mediaelement/build/mediaelement-flash-video.swf'
import 'mediaelement-plugins/dist/skip-back/skip-back.min.js'
import 'mediaelement-plugins/dist/skip-back/skip-back.css'

import {rem} from '../../../lib/tools'
import {type} from '../../../designSystem'

const StyledSpan = styled.span`
  font-family: ${type.family.default};
  font-size: ${rem(type.size.s0)};
  font-weight: ${type.weight.bold};
  line-height: ${type.lineHeight.meta};
`

class Player extends React.Component {
  constructor(props, {
    inverse = props.inverse ? true : false
  }) {
    super()
    this.state = {
      inverse,
      children: props.children,
      player: null
    }
  }

  monitor(media) {
    this.props.parentMonitor(media.getCurrentTime())
    setTimeout(this.playing.bind(this), 200)
  }

  playing() {
    this.monitor(this.state.player)
  }

  success(media, node, instance) {
    // successfully loaded!
    const playEvent = e =&gt; this.playing()
    media.addEventListener('playing', playEvent)
    media.removeEventListener('pause', playEvent)
    media.removeEventListener('ended', playEvent)
  }

  error(media) {
    // failed to load
  }

  componentDidMount() {
    console.log('Player mounted')
    const {MediaElementPlayer} = global
    if (MediaElementPlayer) {
      const options = {
        features: ['skipback'],
        useDefaultControls: true,
        pluginPath: './build/static/media/',
        skipBackInterval: 31,
        skipBackText: 'Rewind 30 seconds',
        success: (media, node, instance) =&gt; this.success(media, node, instance),
        error: (media, node) =&gt; this.error(media, node)
      }
      this.setState({player: new MediaElementPlayer('player_'+this.props.key, options)})
    }
  }

  componentWillUnmount() {
    console.log('Player will unmount')
    if (this.state.player) {
      this.state.player.remove()
      this.setState({player: null})
    }
  }

  shouldComponentUpdate() {
    return false
  }

  render() {
    return (
      &lt;Flex justify={this.state.children ? 'space-between' : ''} align=""center""&gt;
        &lt;Flex align=""center""&gt;
          &lt;audio id={'player_'+this.props.key} width={this.props.width || 400}&gt;
            &lt;source src={this.props.url} type={this.props.type} /&gt;
          &lt;/audio&gt;
        &lt;/Flex&gt;
      &lt;/Flex&gt;
    )
  }
}

export default Player
</code></pre>

<p>I'm using <a href=""https://www.npmjs.com/package/mediaelement"" rel=""nofollow noreferrer"">MediaElement</a> and React 15.5.4. </p>
","I do need to update the display so it shows which segment is playing. I tried adding `shouldComponentUpdate` to the Player but it still unmounted. I'll update my question to reflect the segment change on the parent display."
"46635649","React warning on setState when unmounting component","1","<p>When I execute the following code (see snippet below), I get the warning: </p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Blinker component.</p>
</blockquote>

<p>Is there something I am doing wrong in my componentWillUnmount() method under my Mounter class? Thanks!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Blinker extends React.Component {
   constructor(props) {
    super();
    this.state = {
      appear: true
    }
    this.blinker = this.blinker.bind(this);
  }

  blinker()  {
    this.setState({appear: !this.state.appear });
  }

  componentDidMount() {
    setInterval(this.blinker, 300)
  }

  render() {
    return (
      &lt;div&gt;
        { (this.state.appear) &amp;&amp; ""xxx"" }
      &lt;/div&gt;
    );
  }
}

class Mounter extends React.Component {
  constructor(props) {
    super();
    this.state = {
      render: true
    };
    this.interval = null;
  }

  componentDidMount() {
    this.interval = setTimeout( () =&gt;
      this.rendering(), 1500
    );
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  rendering() {
    this.setState({ render: !this.state.render });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          { this.state.render &amp;&amp; &lt;Blinker /&gt; }
        &lt;/h1&gt;
      &lt;/div&gt;
    );
  }   
}



ReactDOM.render(&lt;Mounter /&gt;, app);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;

&lt;div id=""app""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","Your snippet doesn't throw a warning. i'm not sure this is related but you call `clearInterval` on a `setTimeout` function. did you mean to call `clearTimeout` instead?"
"46720506","Properly unmounting a react component","4","<p>Sorry I couldn't come up with a more specific title for this question. When I execute the below snippet I get the following warning:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Typewriter component.</p>
</blockquote>

<p>However, if the render() in MyComponent is changed to the following, I get no such warning:</p>

<pre><code>render() {
  return (
    &lt;div&gt;
      &lt;h1&gt;
        &lt;Typewriter /&gt;
        { this.state.render == 1 &amp;&amp; ""Render 1"" }
        { this.state.render == 2 &amp;&amp; ""Render 2"" }
        { this.state.render == 3 &amp;&amp; ""Render 3"" }
      &lt;/h1&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>How do I properly unmount this rendered Typewriter component that itself is performing some mounting and unmounting actions? Thanks!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Typewriter extends React.Component {
  constructor(props) {
    super();
    this.state = {
      finalText: ''
    }
    this.typeWriter = this.typeWriter.bind(this);
  }

  typeWriter(text, n) {
    if (n &lt; (text.length)) {
      if (n + 1 == (text.length)) {
        let j = text.substring(0, n+1);
        this.setState({ finalText: j });
        n++;
      }
      else {
        let k = text.substring(0, n+1) + '|';
        this.setState({ finalText: k });
        n++;
      }
      setTimeout( () =&gt; { this.typeWriter(text, n) }, 100 );
    }
  }

  componentDidMount() {
    this.typeWriter('testing_typewriter', 0);
  }

  render() {
    return (
      &lt;div&gt;
        { this.state.finalText }
      &lt;/div&gt;
    );
  }
}

class MyComponent extends React.Component {
  constructor(props) {
    super();
    this.state = {
      render: 1,
      update: false
    };
    this.interval = null;
  }

  componentDidMount() {
    this.interval = setTimeout( () =&gt;
      this.rendering(), 1700
    );
  }

  componentWillUpdate(nextProps, nextState) {
    if (this.state.render &lt; 3) {
      this.interval = setTimeout( () =&gt;
        this.rendering(), 1200
      );
    }
  }

  componentWillUnmount() {
      clearInterval(this.interval);
      this.interval = null;
  }

  rendering() {
    if (this.state.render &lt; 3) {
      if (this.interval) {
        this.setState({ render: this.state.render + 1 });
      }
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          { this.state.render == 1 &amp;&amp; ""Render 1"" }
          { this.state.render == 2 &amp;&amp; &lt;Typewriter /&gt; }
          { this.state.render == 3 &amp;&amp; ""Render 3"" }
        &lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}



ReactDOM.render(&lt;MyComponent /&gt;, app);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;

&lt;div id=""app""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","I think your problem is that your parent component is attempting to replace the Typewriter component before the latter has completed its typewriter routine. I would suggest a ""handshake"" approach instead of using timers. You could for example define a `typingDone` function in the parent, then pass it as a prop to the Typewriter component, and have the later call that method when the typing is complete. The `typingDone` function could then trigger a change of child component by updating the state, for example."
"46720506","Properly unmounting a react component","4","<p>Sorry I couldn't come up with a more specific title for this question. When I execute the below snippet I get the following warning:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Typewriter component.</p>
</blockquote>

<p>However, if the render() in MyComponent is changed to the following, I get no such warning:</p>

<pre><code>render() {
  return (
    &lt;div&gt;
      &lt;h1&gt;
        &lt;Typewriter /&gt;
        { this.state.render == 1 &amp;&amp; ""Render 1"" }
        { this.state.render == 2 &amp;&amp; ""Render 2"" }
        { this.state.render == 3 &amp;&amp; ""Render 3"" }
      &lt;/h1&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>How do I properly unmount this rendered Typewriter component that itself is performing some mounting and unmounting actions? Thanks!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Typewriter extends React.Component {
  constructor(props) {
    super();
    this.state = {
      finalText: ''
    }
    this.typeWriter = this.typeWriter.bind(this);
  }

  typeWriter(text, n) {
    if (n &lt; (text.length)) {
      if (n + 1 == (text.length)) {
        let j = text.substring(0, n+1);
        this.setState({ finalText: j });
        n++;
      }
      else {
        let k = text.substring(0, n+1) + '|';
        this.setState({ finalText: k });
        n++;
      }
      setTimeout( () =&gt; { this.typeWriter(text, n) }, 100 );
    }
  }

  componentDidMount() {
    this.typeWriter('testing_typewriter', 0);
  }

  render() {
    return (
      &lt;div&gt;
        { this.state.finalText }
      &lt;/div&gt;
    );
  }
}

class MyComponent extends React.Component {
  constructor(props) {
    super();
    this.state = {
      render: 1,
      update: false
    };
    this.interval = null;
  }

  componentDidMount() {
    this.interval = setTimeout( () =&gt;
      this.rendering(), 1700
    );
  }

  componentWillUpdate(nextProps, nextState) {
    if (this.state.render &lt; 3) {
      this.interval = setTimeout( () =&gt;
        this.rendering(), 1200
      );
    }
  }

  componentWillUnmount() {
      clearInterval(this.interval);
      this.interval = null;
  }

  rendering() {
    if (this.state.render &lt; 3) {
      if (this.interval) {
        this.setState({ render: this.state.render + 1 });
      }
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          { this.state.render == 1 &amp;&amp; ""Render 1"" }
          { this.state.render == 2 &amp;&amp; &lt;Typewriter /&gt; }
          { this.state.render == 3 &amp;&amp; ""Render 3"" }
        &lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}



ReactDOM.render(&lt;MyComponent /&gt;, app);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;

&lt;div id=""app""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","Why do you want to call `this.setState` from `componentWillUpdate()`. You should not ideally do it. What is the reason though?"
"46720506","Properly unmounting a react component","4","<p>Sorry I couldn't come up with a more specific title for this question. When I execute the below snippet I get the following warning:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Typewriter component.</p>
</blockquote>

<p>However, if the render() in MyComponent is changed to the following, I get no such warning:</p>

<pre><code>render() {
  return (
    &lt;div&gt;
      &lt;h1&gt;
        &lt;Typewriter /&gt;
        { this.state.render == 1 &amp;&amp; ""Render 1"" }
        { this.state.render == 2 &amp;&amp; ""Render 2"" }
        { this.state.render == 3 &amp;&amp; ""Render 3"" }
      &lt;/h1&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>How do I properly unmount this rendered Typewriter component that itself is performing some mounting and unmounting actions? Thanks!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Typewriter extends React.Component {
  constructor(props) {
    super();
    this.state = {
      finalText: ''
    }
    this.typeWriter = this.typeWriter.bind(this);
  }

  typeWriter(text, n) {
    if (n &lt; (text.length)) {
      if (n + 1 == (text.length)) {
        let j = text.substring(0, n+1);
        this.setState({ finalText: j });
        n++;
      }
      else {
        let k = text.substring(0, n+1) + '|';
        this.setState({ finalText: k });
        n++;
      }
      setTimeout( () =&gt; { this.typeWriter(text, n) }, 100 );
    }
  }

  componentDidMount() {
    this.typeWriter('testing_typewriter', 0);
  }

  render() {
    return (
      &lt;div&gt;
        { this.state.finalText }
      &lt;/div&gt;
    );
  }
}

class MyComponent extends React.Component {
  constructor(props) {
    super();
    this.state = {
      render: 1,
      update: false
    };
    this.interval = null;
  }

  componentDidMount() {
    this.interval = setTimeout( () =&gt;
      this.rendering(), 1700
    );
  }

  componentWillUpdate(nextProps, nextState) {
    if (this.state.render &lt; 3) {
      this.interval = setTimeout( () =&gt;
        this.rendering(), 1200
      );
    }
  }

  componentWillUnmount() {
      clearInterval(this.interval);
      this.interval = null;
  }

  rendering() {
    if (this.state.render &lt; 3) {
      if (this.interval) {
        this.setState({ render: this.state.render + 1 });
      }
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          { this.state.render == 1 &amp;&amp; ""Render 1"" }
          { this.state.render == 2 &amp;&amp; &lt;Typewriter /&gt; }
          { this.state.render == 3 &amp;&amp; ""Render 3"" }
        &lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}



ReactDOM.render(&lt;MyComponent /&gt;, app);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;

&lt;div id=""app""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","Also, in the Typewriter component you are not setting a reference to the `setTimeout` and clearing it in `componentWillUnmount`."
"46720506","Properly unmounting a react component","4","<p>Sorry I couldn't come up with a more specific title for this question. When I execute the below snippet I get the following warning:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Typewriter component.</p>
</blockquote>

<p>However, if the render() in MyComponent is changed to the following, I get no such warning:</p>

<pre><code>render() {
  return (
    &lt;div&gt;
      &lt;h1&gt;
        &lt;Typewriter /&gt;
        { this.state.render == 1 &amp;&amp; ""Render 1"" }
        { this.state.render == 2 &amp;&amp; ""Render 2"" }
        { this.state.render == 3 &amp;&amp; ""Render 3"" }
      &lt;/h1&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>How do I properly unmount this rendered Typewriter component that itself is performing some mounting and unmounting actions? Thanks!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Typewriter extends React.Component {
  constructor(props) {
    super();
    this.state = {
      finalText: ''
    }
    this.typeWriter = this.typeWriter.bind(this);
  }

  typeWriter(text, n) {
    if (n &lt; (text.length)) {
      if (n + 1 == (text.length)) {
        let j = text.substring(0, n+1);
        this.setState({ finalText: j });
        n++;
      }
      else {
        let k = text.substring(0, n+1) + '|';
        this.setState({ finalText: k });
        n++;
      }
      setTimeout( () =&gt; { this.typeWriter(text, n) }, 100 );
    }
  }

  componentDidMount() {
    this.typeWriter('testing_typewriter', 0);
  }

  render() {
    return (
      &lt;div&gt;
        { this.state.finalText }
      &lt;/div&gt;
    );
  }
}

class MyComponent extends React.Component {
  constructor(props) {
    super();
    this.state = {
      render: 1,
      update: false
    };
    this.interval = null;
  }

  componentDidMount() {
    this.interval = setTimeout( () =&gt;
      this.rendering(), 1700
    );
  }

  componentWillUpdate(nextProps, nextState) {
    if (this.state.render &lt; 3) {
      this.interval = setTimeout( () =&gt;
        this.rendering(), 1200
      );
    }
  }

  componentWillUnmount() {
      clearInterval(this.interval);
      this.interval = null;
  }

  rendering() {
    if (this.state.render &lt; 3) {
      if (this.interval) {
        this.setState({ render: this.state.render + 1 });
      }
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          { this.state.render == 1 &amp;&amp; ""Render 1"" }
          { this.state.render == 2 &amp;&amp; &lt;Typewriter /&gt; }
          { this.state.render == 3 &amp;&amp; ""Render 3"" }
        &lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}



ReactDOM.render(&lt;MyComponent /&gt;, app);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;

&lt;div id=""app""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","You're using `clearInterval`. What you want is `clearTimeout`."
"46746781","Warning: setState(...): Can only update a mounted or mounting component, How to unmount?","2","<p>I know that this question title has been asked multiple times, but my question is different. I am not sure how to solve that using <code>componentWillUnmount</code>. </p>

<p>I am using <code>firebase</code>'s new <code>FireStore</code> to add data. I also watch for changes as  </p>

<pre><code>componentDidMount() {
        fdb.collection(collectionName)
            .onSnapshot({includeDocumentMetadataChanges: true}, function (querySnapshot) {
            let items = [];
            querySnapshot.forEach(function (doc) {
                let source = doc.metadata.hasPendingWrites ? ""[OF]"" : ""[ON]"";
                items.push(source + "" -&gt; "" + doc.data().title);
                console.log(source, "" data: "", doc &amp;&amp; doc.data());
            });
            this.setState({""items"": items});
        }.bind(this));
    }  
</code></pre>

<p>So that means, every time a new change is loaded, the entire component is refreshed, which means the current one is going to trash, is that a correct understanding?  </p>

<p>If yes, that means, I should stop listening to this snapshot since this one is going to go away. Is that understanding correct?  </p>

<p>If yes, I am not sure how to stop listening to this ongoing watch.<br>
My entire code looks like  </p>

<pre><code>import React from ""react"";
import {fdb} from ""../mainPage/constants"";

const collectionName = ""todos"";
export default class ToDos extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            items: [],
            textBox: """",
            loading: true
        }
    }

    componentDidMount() {
        fdb.collection(collectionName)
            .onSnapshot({includeDocumentMetadataChanges: true}, function (querySnapshot) {
            let items = [];
            querySnapshot.forEach(function (doc) {
                let source = doc.metadata.hasPendingWrites ? ""[OF]"" : ""[ON]"";
                items.push(source + "" -&gt; "" + doc.data().title);
                console.log(source, "" data: "", doc &amp;&amp; doc.data());
            });
            this.setState({""items"": items});
        }.bind(this));
    }


    handleTextBoxChange = (event) =&gt; {
        this.setState({textBox: event.target.value});
    };

    handleAddItem = () =&gt; {
        fdb.collection(collectionName).add({
            ""title"": this.state.textBox
        }).then(function (docRef) {
            console.log(""added "" + docRef.id , docRef.get());
        }.bind(this));
    };

    handleRemoveItem = (index) =&gt; {
        let remainingItems = this.state.items;
        remainingItems.splice(index, 1);
        this.setState({items: remainingItems});
    };

    render() {
        return (
            &lt;div&gt;
                &lt;div&gt;
                    &lt;input type=""text"" value={this.state.textBox} onChange={this.handleTextBoxChange}/&gt;
                    &lt;input type=""submit"" value=""Add Item"" onClick={this.handleAddItem}/&gt;
                &lt;/div&gt;
                &lt;div&gt;{this.state.items.map((item, index) =&gt; &lt;Item key={index}
                                                                  index={index}
                                                                  item={item}
                                                                  onDeleteClick={this.handleRemoveItem}/&gt;)}&lt;/div&gt;

            &lt;/div&gt;
        )
    }
}

const Item = ({index, item, onDeleteClick}) =&gt; {
    return &lt;div&gt;
        &lt;input type=""button"" value=""delete"" onClick={() =&gt; onDeleteClick(index)}/&gt;
        &lt;span&gt;{item}&lt;/span&gt;

    &lt;/div&gt;
};
</code></pre>

<p>And what I see on Developer Console is  </p>

<pre><code>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the ToDos component.  
</code></pre>

<p>Can someone please help me with this?</p>
","The documentation clearly states how to unsubscribe. https://cloud.google.com/nodejs/docs/reference/firestore/0.8.x/CollectionReference#onSnapshot"
"46826558","Will react automatically remove eventlisteners when a component unmounts?","6","<p>Will react automatically remove eventlisteners when a component unmounts, or do I have to remove them in <code>componentWillUnmount()</code> ?</p>

<p>I specifically mean event listeners registered to rendered contents of the actual component.</p>

<p>Is it bad practice not to remove them manually?</p>

<p>Example:</p>

<pre><code>import React, { Component } from 'react';
import { render } from 'react-dom';

class App extends Component {
  constructor() {
    super();
  }

  componentDidMount() {
    this.content.addEventListener('click', () =&gt; alert('Hello'));
  }

  setRef = ref =&gt; {
    this.content = ref;
  }

  render() {
    return (
      &lt;div ref={this.setRef}&gt;
        &lt;p&gt;Hello World&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
","you can check like this: https://jsfiddle.net/buxLoovu/"
"47300506","How to solve Cannot read property 'listeners' of null in reactjs","2","<p>I am using the following packages for my React project.</p>

<pre><code>    ""react-redux"": ""^4.4.5"",
    ""react-router"": ""3.0.0"",
    ""react-cookie"": ""1.0.4"",
    ""react-dom"": ""^15.4.1"",
    ""react"":""^15.4.1""
</code></pre>

<p>Inside componentWillMount function i'm checking my cookie value, if it's not match, i just forward to my home page.</p>

<p>For forward page, i'm using</p>

<pre><code>hashHistory.push('/');
</code></pre>

<p>Here i'm getting error like</p>

<pre><code>error TypeError: Cannot read property 'listeners' of null
at ReactDOMComponent.unmountComponent (ReactDOMComponent.js:966)
at Object.unmountComponent (ReactReconciler.js:78)
at Object.unmountChildren (ReactChildReconciler.js:146)
at ReactDOMComponent.unmountChildren (ReactMultiChild.js:371)
at ReactDOMComponent.unmountComponent (ReactDOMComponent.js:990)
at Object.unmountComponent (ReactReconciler.js:78)
at Object.unmountChildren (ReactChildReconciler.js:146)
at ReactDOMComponent.unmountChildren (ReactMultiChild.js:371)
at ReactDOMComponent.unmountComponent (ReactDOMComponent.js:990)
at Object.unmountComponent (ReactReconciler.js:78)
</code></pre>

<p>How can i solve this error.Please give my solution.</p>

<p>Thanks in advance.</p>
","why do you use `hashHistory` ? why not the more preferred `browserHistory` ?"
"47300506","How to solve Cannot read property 'listeners' of null in reactjs","2","<p>I am using the following packages for my React project.</p>

<pre><code>    ""react-redux"": ""^4.4.5"",
    ""react-router"": ""3.0.0"",
    ""react-cookie"": ""1.0.4"",
    ""react-dom"": ""^15.4.1"",
    ""react"":""^15.4.1""
</code></pre>

<p>Inside componentWillMount function i'm checking my cookie value, if it's not match, i just forward to my home page.</p>

<p>For forward page, i'm using</p>

<pre><code>hashHistory.push('/');
</code></pre>

<p>Here i'm getting error like</p>

<pre><code>error TypeError: Cannot read property 'listeners' of null
at ReactDOMComponent.unmountComponent (ReactDOMComponent.js:966)
at Object.unmountComponent (ReactReconciler.js:78)
at Object.unmountChildren (ReactChildReconciler.js:146)
at ReactDOMComponent.unmountChildren (ReactMultiChild.js:371)
at ReactDOMComponent.unmountComponent (ReactDOMComponent.js:990)
at Object.unmountComponent (ReactReconciler.js:78)
at Object.unmountChildren (ReactChildReconciler.js:146)
at ReactDOMComponent.unmountChildren (ReactMultiChild.js:371)
at ReactDOMComponent.unmountComponent (ReactDOMComponent.js:990)
at Object.unmountComponent (ReactReconciler.js:78)
</code></pre>

<p>How can i solve this error.Please give my solution.</p>

<p>Thanks in advance.</p>
","This is already developed by someone they done with hashHistory, so i'm just maintaining that."
"47361511","How to reset state of redux store while using react-navigation when react-navigation reset does not immediately unmount screens from stack?","0","<p>I'm trying to do auth sign-out with react-native and am experiencing an issue where I want to reset the state of the redux store but, because I am using react-navigation, I have a bunch of redux-connected screens that are still mounted that re-render when the state tree is reset to it's initialState causing a bunch of exception errors. I tried to unmount them on sign-out with a react-navigation reset which redirects the user to the signup/login screen but I have no way of knowing when these screens are actually unmounted in order to call the <code>RESET_STATE</code> action. Initially I was dispatching the action via saga. </p>

<p><strong>sagas/logout.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { LOGOUT, RESET_STATE } from 'Actions/user';

// clear localstorage once user logs out.
const clearData = function* clearData(action) {
  AsyncStorage.removeItem('user');
  
  yield put(
    NavigationActions.reset({
      index: 0, 
      actions: [ 
        NavigationActions.navigate({ routeName: 'SignedOut' })
      ],
    })
  );
  // causes re-renders, screens still mounted
  yield put({type: RESET_STATE});
}

export default function* logoutSaga () {
  yield all([
    yield takeEvery(LOGOUT, clearData),
  ]);
}</code></pre>
</div>
</div>
</p>

<p>I also tried to reset once user reaches the SignedOut screen in it's componentDidMount cycle but unfortunately the screens unmount at some point well after componentDidMount is triggered:</p>

<p><strong>screens/SignedOut.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { resetState } from 'Actions/user';
import ActionButton from 'Components/FormElements/ActionButton';

class SignedOut extends Component {
  // screens are still mounted, causing screens from
  // previous screens to throw exception errors
  componentDidMount() {
    this.props.dispatch(resetState());
  }

  componentWillUnmount() {
    // never called
  }

  handleSignup = () =&gt; {
    this.props.navigation.navigate('Signup');
  }

  handleLogin = () =&gt; {
    this.props.navigation.navigate('Login');
  }

  render() {
    return(
      &lt;Container&gt;
        &lt;ActionButton
          text=""Sign Up""
          handleButtonPress={this.handleSignup}
        /&gt;
        &lt;ActionButton
          text=""Log In""
          handleButtonPress={this.handleLogin}
        /&gt;
      &lt;/Container&gt;
    );
  }
}

export default connect()(SignedOut);</code></pre>
</div>
</div>
</p>

<p>My question is, can anyone think of a way to reset state of redux store after all of my screens have finally unmounted by the react-navigation reset action?</p>
",""
"47423997","Error while fitBounds in google-maps-react","0","<p>I'm trying to do fitBounds of my markers in Google-maps-react. But the map won't unmount by itself after I go other page. Below is my code:</p>

<pre><code>const PGoogleMap = compose(
withProps({
googleMapURL: `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAP_API_KEY}&amp;v=3.exp&amp;libraries=geometry,drawing,places`,
loadingElement: &lt;div style={{ height: `100%` }} /&gt;,
containerElement: &lt;div style={{ height: `400px` }} /&gt;,
mapElement: &lt;div style={{ height: `100%` }} /&gt;
}),
withHandlers(() =&gt; {
const refs = {
  map: undefined,
}
return {
  onSetFit: () =&gt; ref =&gt; {
    refs.map = ref
    var mBounds = new google.maps.LatLngBounds();
    mCoords.forEach((p) =&gt; {
      var latLng = new google.maps.LatLng(p.lat, p.lng);
      mBounds.extend(latLng);
    })
    ref.map.fitBounds(mBounds)
  }
}
}),
withScriptjs,
withGoogleMap
 )((props) =&gt;
&lt;GoogleMap
ref={props.onSetFit}
defaultZoom={18}
defaultCenter={props.centerFocus}
&gt;
{props.patrol.map((marker, i) =&gt; (
    &lt;Marker
      key={marker.id}
      position={{ lat: marker.lat, lng: marker.lng }}
    &gt;
    &lt;/Marker&gt;
  ))}
&lt;Polyline path={props.coordinates}
/&gt;
&lt;/GoogleMap&gt;
)
</code></pre>

<p>The code is fine in the map page. 
But whenever I go other page which does not have the map, the map will still there mounted on the bottom. There will be error msg in console : <code>ref.map is null. Warning: Exception thrown by hook while handling onSetChildren: Invariant Violation: Expected hook events to fire for the child before its parent includes it in onSetChildren().</code>. Anyone knows how to fix it?</p>
",""
"47430157","""react-native-fade-in-view"" causes ""Cannot read property 'func' of undefined"" error","3","<p>I am new in react native and I need to use ""react-native-fade-in-view"" in my project. However, as I used <code>import FadeInView from 'react-native-fade-in-view';</code> in my project, the following error is shown:</p>

<blockquote>
  <p>Cannot read property 'func' of undefined</p>
</blockquote>

<p>As I deleted my module folder and applied the yarn command on the project to refresh the folder, the following warning shown: </p>

<blockquote>
  <p>yarn install v1.3.2 warning ../../../package.json: No license field</p>
  
  <p>[1/4] Resolving packages... [2/4] Fetching packages... info</p>
  
  <p>fsevents@1.1.2: The platform ""linux"" is incompatible with this module.</p>
  
  <p>info ""fsevents@1.1.2"" is an optional dependency and failed</p>
  
  <p>compatibility check. Excluding it from installation. [3/4] Linking</p>
  
  <p>dependencies... warning "" > react-native-fade-in-view@1.0.4"" has
  incorrect peer dependency ""react@^15.4.2"". warning "" >
  react-native-fade-in-view@1.0.4"" has incorrect peer dependency
  ""react-native@^0.40.0"". warning "" > babel-jest@21.2.0"" has unmet peer
  dependency 
  ""babel-core@^6.0.0 || ^7.0.0-alpha || ^7.0.0-beta ||
  ^7.0.0"". [4/4] Building fresh packages... Done in 6.51s.</p>
</blockquote>

<p>I also updated my yarn using the following steps:
<a href=""https://github.com/yarnpkg/yarn/issues/3042"" rel=""nofollow noreferrer"">https://github.com/yarnpkg/yarn/issues/3042</a>
Do you have any idea what happen on my project? </p>

<p>Here is my total code:</p>

<pre><code>import React, { Component } from ""react"";
import { StyleSheet, AsyncStorage, Dimensions, Image, ImageBackground, Platform, ScrollView, StatusBar, TouchableHighlight, TouchableOpacity, View, Text,  TextInput } from ""react-native"";
import { Body, Switch, Button, Container, Content, Header, Input, InputGroup, Left, Right, StyleProvider, Title } from ""native-base"";
import I18n from '../../libs/i18n';
import {Config} from '../../config';
// import PropTypes from 'prop-types';
import FadeInView from 'react-native-fade-in-view';

export default class Home extends React.Component {
  static navigationOptions = {
    title: I18n.t('Login'),
  };

  constructor() {
    super();
    this.state = {

    };

  }

  render() {

    if(this.timer &gt; 0) return;
        this.timer = setTimeout(() =&gt; {
          //turn off the pop up
           this.props.navigation.navigate('Home_Tool');
          this.timer = null;  //not necessary if you are unmounting the component
        }, 3000);

    return (

            &lt;Image source={require('../../assets/images/Home/tt.jpg')} style={styles.Container} &gt;
              &lt;View style={styles.logoContiainer}&gt;

                  &lt;Image source={require('../../assets/images/Home/ttt.png')} style={styles.Container} /&gt;

              &lt;/View&gt;
            &lt;/Image&gt;

            );


  }
};

const styles = StyleSheet.create({

  Container: {
    flex: 1,
       // remove width and height to override fixed static size
    width: null,
    height: null,
    justifyContent: 'center',
    alignItems: 'center',
  },

  logoContiainer: {
    flex: 0.25,
    flexDirection: 'column',
    justifyContent: 'center',
    width: (Dimensions.get('window').width)/2,

  },


});
</code></pre>
","@IshitaSinha: I should mentioned that, when I delete the ""import FadeInView from 'react-native-fade-in-view';"" code, everything work fine."
"47430157","""react-native-fade-in-view"" causes ""Cannot read property 'func' of undefined"" error","3","<p>I am new in react native and I need to use ""react-native-fade-in-view"" in my project. However, as I used <code>import FadeInView from 'react-native-fade-in-view';</code> in my project, the following error is shown:</p>

<blockquote>
  <p>Cannot read property 'func' of undefined</p>
</blockquote>

<p>As I deleted my module folder and applied the yarn command on the project to refresh the folder, the following warning shown: </p>

<blockquote>
  <p>yarn install v1.3.2 warning ../../../package.json: No license field</p>
  
  <p>[1/4] Resolving packages... [2/4] Fetching packages... info</p>
  
  <p>fsevents@1.1.2: The platform ""linux"" is incompatible with this module.</p>
  
  <p>info ""fsevents@1.1.2"" is an optional dependency and failed</p>
  
  <p>compatibility check. Excluding it from installation. [3/4] Linking</p>
  
  <p>dependencies... warning "" > react-native-fade-in-view@1.0.4"" has
  incorrect peer dependency ""react@^15.4.2"". warning "" >
  react-native-fade-in-view@1.0.4"" has incorrect peer dependency
  ""react-native@^0.40.0"". warning "" > babel-jest@21.2.0"" has unmet peer
  dependency 
  ""babel-core@^6.0.0 || ^7.0.0-alpha || ^7.0.0-beta ||
  ^7.0.0"". [4/4] Building fresh packages... Done in 6.51s.</p>
</blockquote>

<p>I also updated my yarn using the following steps:
<a href=""https://github.com/yarnpkg/yarn/issues/3042"" rel=""nofollow noreferrer"">https://github.com/yarnpkg/yarn/issues/3042</a>
Do you have any idea what happen on my project? </p>

<p>Here is my total code:</p>

<pre><code>import React, { Component } from ""react"";
import { StyleSheet, AsyncStorage, Dimensions, Image, ImageBackground, Platform, ScrollView, StatusBar, TouchableHighlight, TouchableOpacity, View, Text,  TextInput } from ""react-native"";
import { Body, Switch, Button, Container, Content, Header, Input, InputGroup, Left, Right, StyleProvider, Title } from ""native-base"";
import I18n from '../../libs/i18n';
import {Config} from '../../config';
// import PropTypes from 'prop-types';
import FadeInView from 'react-native-fade-in-view';

export default class Home extends React.Component {
  static navigationOptions = {
    title: I18n.t('Login'),
  };

  constructor() {
    super();
    this.state = {

    };

  }

  render() {

    if(this.timer &gt; 0) return;
        this.timer = setTimeout(() =&gt; {
          //turn off the pop up
           this.props.navigation.navigate('Home_Tool');
          this.timer = null;  //not necessary if you are unmounting the component
        }, 3000);

    return (

            &lt;Image source={require('../../assets/images/Home/tt.jpg')} style={styles.Container} &gt;
              &lt;View style={styles.logoContiainer}&gt;

                  &lt;Image source={require('../../assets/images/Home/ttt.png')} style={styles.Container} /&gt;

              &lt;/View&gt;
            &lt;/Image&gt;

            );


  }
};

const styles = StyleSheet.create({

  Container: {
    flex: 1,
       // remove width and height to override fixed static size
    width: null,
    height: null,
    justifyContent: 'center',
    alignItems: 'center',
  },

  logoContiainer: {
    flex: 0.25,
    flexDirection: 'column',
    justifyContent: 'center',
    width: (Dimensions.get('window').width)/2,

  },


});
</code></pre>
","@IshitaSinha: Thanks for your reply, I have posted it"
"47430157","""react-native-fade-in-view"" causes ""Cannot read property 'func' of undefined"" error","3","<p>I am new in react native and I need to use ""react-native-fade-in-view"" in my project. However, as I used <code>import FadeInView from 'react-native-fade-in-view';</code> in my project, the following error is shown:</p>

<blockquote>
  <p>Cannot read property 'func' of undefined</p>
</blockquote>

<p>As I deleted my module folder and applied the yarn command on the project to refresh the folder, the following warning shown: </p>

<blockquote>
  <p>yarn install v1.3.2 warning ../../../package.json: No license field</p>
  
  <p>[1/4] Resolving packages... [2/4] Fetching packages... info</p>
  
  <p>fsevents@1.1.2: The platform ""linux"" is incompatible with this module.</p>
  
  <p>info ""fsevents@1.1.2"" is an optional dependency and failed</p>
  
  <p>compatibility check. Excluding it from installation. [3/4] Linking</p>
  
  <p>dependencies... warning "" > react-native-fade-in-view@1.0.4"" has
  incorrect peer dependency ""react@^15.4.2"". warning "" >
  react-native-fade-in-view@1.0.4"" has incorrect peer dependency
  ""react-native@^0.40.0"". warning "" > babel-jest@21.2.0"" has unmet peer
  dependency 
  ""babel-core@^6.0.0 || ^7.0.0-alpha || ^7.0.0-beta ||
  ^7.0.0"". [4/4] Building fresh packages... Done in 6.51s.</p>
</blockquote>

<p>I also updated my yarn using the following steps:
<a href=""https://github.com/yarnpkg/yarn/issues/3042"" rel=""nofollow noreferrer"">https://github.com/yarnpkg/yarn/issues/3042</a>
Do you have any idea what happen on my project? </p>

<p>Here is my total code:</p>

<pre><code>import React, { Component } from ""react"";
import { StyleSheet, AsyncStorage, Dimensions, Image, ImageBackground, Platform, ScrollView, StatusBar, TouchableHighlight, TouchableOpacity, View, Text,  TextInput } from ""react-native"";
import { Body, Switch, Button, Container, Content, Header, Input, InputGroup, Left, Right, StyleProvider, Title } from ""native-base"";
import I18n from '../../libs/i18n';
import {Config} from '../../config';
// import PropTypes from 'prop-types';
import FadeInView from 'react-native-fade-in-view';

export default class Home extends React.Component {
  static navigationOptions = {
    title: I18n.t('Login'),
  };

  constructor() {
    super();
    this.state = {

    };

  }

  render() {

    if(this.timer &gt; 0) return;
        this.timer = setTimeout(() =&gt; {
          //turn off the pop up
           this.props.navigation.navigate('Home_Tool');
          this.timer = null;  //not necessary if you are unmounting the component
        }, 3000);

    return (

            &lt;Image source={require('../../assets/images/Home/tt.jpg')} style={styles.Container} &gt;
              &lt;View style={styles.logoContiainer}&gt;

                  &lt;Image source={require('../../assets/images/Home/ttt.png')} style={styles.Container} /&gt;

              &lt;/View&gt;
            &lt;/Image&gt;

            );


  }
};

const styles = StyleSheet.create({

  Container: {
    flex: 1,
       // remove width and height to override fixed static size
    width: null,
    height: null,
    justifyContent: 'center',
    alignItems: 'center',
  },

  logoContiainer: {
    flex: 0.25,
    flexDirection: 'column',
    justifyContent: 'center',
    width: (Dimensions.get('window').width)/2,

  },


});
</code></pre>
","can you post the code with the line where you get `Cannot read property 'func' of undefined`?"
"47784831","Cannot read property 'findDOMNode' of undefined when using stopPropagation - reactJs","0","<p>I need to do event bubbling through the deep nested components ,  I tried to do some thing like below</p>

<pre><code>   import {ReactDOM,render, unmountComponentAtNode} from 'react-dom';

  .........
  .........

  componentDidMount() {
    ReactDOM.findDOMNode(this).addEventListener('click', (event) =&gt; {
    event.stopPropagation();
  }, false)
}
</code></pre>

<p>I got the following error</p>

<pre><code>bundle.js:45 Uncaught TypeError: Cannot read property 'findDOMNode' of undefined
</code></pre>
",""
"47799097","React-form-with-constraints unable to findDomNode on an unmounted component","2","<p>My form extends FormWithConstraints of 'react-form-with-constraints' version  ""^0.2.2"", but it is using react and react-dom's higher version '16.2.0' in its downloaded package but my project supports '15.6.1'. I'm not sure if this is the issue. 
And the form throws error like</p>

<pre><code>Uncaught Error: Unable to find node on an unmounted component.
    at invariant (commons.chunk.js.f2d6763b.js:214)
    at Object.findDOMNode (bundle.f2d6763b.js:96653)
    at CreateCompanyForm.FormWithConstraints.showFormErrors
</code></pre>

<p>The package's built in FormWithConstaints file looks like</p>

<pre><code>handleSubmit(e: React.FormEvent&lt;HTMLFormElement&gt;) {
    this.showFormErrors();
  }

  private showFormErrors() {
    const form = ReactDOM.findDOMNode(this);
    const inputs = form.querySelectorAll('[name]');
    inputs.forEach((input: any) =&gt; this.showFieldError(input));
  }
</code></pre>

<p>I can't switch to higher version as the higher version breaks most of my code. Could someone help me.</p>

<p>My package.json looks like</p>

<pre><code>    ""react"": ""^15.6.1"",
    ""react-dom"": ""^15.6.1"",
    ""react-form-with-constraints"": ""^0.2.2""
</code></pre>

<p>My CompanyForm file looks like:</p>

<pre><code>import React from 'react';
import TextInput from '../../../../components/common/input/TextInput';
import Button from '../../../../components/common/button/PrimaryButton';
import { FormWithConstraints } from 'react-form-with-constraints';
import PropTypes from 'prop-types';

class CreateCompanyForm extends FormWithConstraints {
    constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.getInitialState = this.getInitialState.bind(this);
        this.state = this.getInitialState();
    }

    getInitialState(){
        return({
            name: '',
            address:'',
        });
    }

    handleChange(event) {
        console.log(""handle change"");
        const target = event.currentTarget;

        this.setState({
            [target.name]: target.value
        });

        super.handleChange(event);
    }

    handleSubmit(event) {
        event.preventDefault();

        super.handleSubmit(event);

        if (!this.isValid()) {
            //dont proceed
        } else {
            this.props.onSubmit();
        }
    }

    render() {
        return (
            &lt;div&gt;
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;div&gt;Create New Company&lt;/div&gt;
                    &lt;div style={{marginTop: 10}} className=""row""&gt;
                        &lt;div className=""col-md-6""&gt;
                            &lt;TextInput
                                readOnly={false}
                                required={true}
                                label=""Name of Company""
                                value={this.state.name}
                                onChange={this.handleChange}
                                name=""name""/&gt;
                        &lt;/div&gt;
                        &lt;div className=""col-md-6""&gt;
                            &lt;TextInput
                                readOnly={false}
                                required={true}
                                label=""Registered Address""
                                value={this.state.address}
                                onChange={this.handleChange}
                                name=""address""/&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;div&gt;
                        &lt;Button
                            label={""Create Company""}
                            onClick={this.handleSubmit}
                        /&gt;
                    &lt;/div&gt;

                &lt;/form&gt;

            &lt;/div&gt;
        );
    }
}


CreateCompanyForm.propTypes ={
    onSubmit: PropTypes.func.isRequired

};

export default CreateCompanyForm;
</code></pre>

<p>The parent component looks like:</p>

<pre><code>class CreateCompanyHome extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            reload: true,
            loading:false,
            error:{},
            success:{},
            isSuperUser: false,

        };
        this.onSubmit = this.onSubmit.bind(this);
    }

    componentDidMount(){
        this.setState({isSuperUser:Auth.isSuperUser}); //check if the user is SU
    }

    onSubmit(createCompanyParams={}){
        //call api
    }

    render() {
            return (
                &lt;div&gt;
                    {this.state.loading?&lt;Loader /&gt;:null}
                    {this.state.reload?
                        &lt;CreateCompanyForm
                            opacity={this.state.loading}
                            onSubmit={this.onSubmit}/&gt;:null}
                &lt;/div&gt;);
        }
}

function mapStateToProps(state) {
    return {
        userRoleSetMap: state.authentication.userRoleSet,
        cwEntityMap: state.authentication.cwEntityMap,
    };
}

export default connect(mapStateToProps)(CreateCompanyHome);
</code></pre>
","Please check, i have added both form file and parent component which calls that form component"
"47799097","React-form-with-constraints unable to findDomNode on an unmounted component","2","<p>My form extends FormWithConstraints of 'react-form-with-constraints' version  ""^0.2.2"", but it is using react and react-dom's higher version '16.2.0' in its downloaded package but my project supports '15.6.1'. I'm not sure if this is the issue. 
And the form throws error like</p>

<pre><code>Uncaught Error: Unable to find node on an unmounted component.
    at invariant (commons.chunk.js.f2d6763b.js:214)
    at Object.findDOMNode (bundle.f2d6763b.js:96653)
    at CreateCompanyForm.FormWithConstraints.showFormErrors
</code></pre>

<p>The package's built in FormWithConstaints file looks like</p>

<pre><code>handleSubmit(e: React.FormEvent&lt;HTMLFormElement&gt;) {
    this.showFormErrors();
  }

  private showFormErrors() {
    const form = ReactDOM.findDOMNode(this);
    const inputs = form.querySelectorAll('[name]');
    inputs.forEach((input: any) =&gt; this.showFieldError(input));
  }
</code></pre>

<p>I can't switch to higher version as the higher version breaks most of my code. Could someone help me.</p>

<p>My package.json looks like</p>

<pre><code>    ""react"": ""^15.6.1"",
    ""react-dom"": ""^15.6.1"",
    ""react-form-with-constraints"": ""^0.2.2""
</code></pre>

<p>My CompanyForm file looks like:</p>

<pre><code>import React from 'react';
import TextInput from '../../../../components/common/input/TextInput';
import Button from '../../../../components/common/button/PrimaryButton';
import { FormWithConstraints } from 'react-form-with-constraints';
import PropTypes from 'prop-types';

class CreateCompanyForm extends FormWithConstraints {
    constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.getInitialState = this.getInitialState.bind(this);
        this.state = this.getInitialState();
    }

    getInitialState(){
        return({
            name: '',
            address:'',
        });
    }

    handleChange(event) {
        console.log(""handle change"");
        const target = event.currentTarget;

        this.setState({
            [target.name]: target.value
        });

        super.handleChange(event);
    }

    handleSubmit(event) {
        event.preventDefault();

        super.handleSubmit(event);

        if (!this.isValid()) {
            //dont proceed
        } else {
            this.props.onSubmit();
        }
    }

    render() {
        return (
            &lt;div&gt;
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;div&gt;Create New Company&lt;/div&gt;
                    &lt;div style={{marginTop: 10}} className=""row""&gt;
                        &lt;div className=""col-md-6""&gt;
                            &lt;TextInput
                                readOnly={false}
                                required={true}
                                label=""Name of Company""
                                value={this.state.name}
                                onChange={this.handleChange}
                                name=""name""/&gt;
                        &lt;/div&gt;
                        &lt;div className=""col-md-6""&gt;
                            &lt;TextInput
                                readOnly={false}
                                required={true}
                                label=""Registered Address""
                                value={this.state.address}
                                onChange={this.handleChange}
                                name=""address""/&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    &lt;div&gt;
                        &lt;Button
                            label={""Create Company""}
                            onClick={this.handleSubmit}
                        /&gt;
                    &lt;/div&gt;

                &lt;/form&gt;

            &lt;/div&gt;
        );
    }
}


CreateCompanyForm.propTypes ={
    onSubmit: PropTypes.func.isRequired

};

export default CreateCompanyForm;
</code></pre>

<p>The parent component looks like:</p>

<pre><code>class CreateCompanyHome extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            reload: true,
            loading:false,
            error:{},
            success:{},
            isSuperUser: false,

        };
        this.onSubmit = this.onSubmit.bind(this);
    }

    componentDidMount(){
        this.setState({isSuperUser:Auth.isSuperUser}); //check if the user is SU
    }

    onSubmit(createCompanyParams={}){
        //call api
    }

    render() {
            return (
                &lt;div&gt;
                    {this.state.loading?&lt;Loader /&gt;:null}
                    {this.state.reload?
                        &lt;CreateCompanyForm
                            opacity={this.state.loading}
                            onSubmit={this.onSubmit}/&gt;:null}
                &lt;/div&gt;);
        }
}

function mapStateToProps(state) {
    return {
        userRoleSetMap: state.authentication.userRoleSet,
        cwEntityMap: state.authentication.cwEntityMap,
    };
}

export default connect(mapStateToProps)(CreateCompanyHome);
</code></pre>
","Could you please post the relevant code?"
"47921783","react error on componentDidMount -> Can only update a mounted or mounting component?","4","<p>I am new to React, so this is probably just a beginner's mistake.</p>

<p>In summary, it's throwing the error/warning mentioned and it is running fetch twice. It ends up with the correct final result though. </p>

<p>The set up is a page to show basic user profile information, with functionality to change profile to be added later.</p>

<p>Details:</p>

<ul>
<li><p>componentDidMount seems to be called once, as per the console.log output below</p></li>
<li><p>fetch is called twice, for whatever reason. Both times it gets the correct info from remote</p></li>
<li><p>this.setState({account.data.data[0]}) fails the first time around and throws the error. This is particularly strange as <strong>it suggests the component is not mounted while it is called within componentDidMount</strong>.
The second time fetch and setState run it updates state correctly.</p></li>
</ul>

<p>The exact error message:</p>

<blockquote>
  <p>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.</p>
</blockquote>

<p>This is the main component:</p>

<pre><code>class AccountTable extends React.Component{

constructor(props){
    super(props)
    this.state={
        account:{},
    }
}

componentDidMount(){
    console.log('componentDidMount');//outputs once
    fetch('/mon-compte-api', {
        method: 'get',
        credentials: 'same-origin'
    })
    .then((response) =&gt; {
        console.log('fetch'); // outputs twice 
        response.json().then((data) =&gt; {
            console.log('data', data);// correct output both times
            this.setState({account: data.data[0]}) // this throws the error
            console.log('state_account', this.state.account); 
// no output for this.state.account first time around. Correct output 2nd time 
        })       
    })
    .catch((err) =&gt; {
        console.log(err)
    });      
}

render(){
    return (
        &lt;table&gt;
                &lt;TableRow 
                   account={this.state.account} /&gt;
        &lt;/table&gt;
    );      
}
}

ReactDOM.render(&lt;AccountTable /&gt;,document.querySelector(""#react_account""));
</code></pre>

<p>This is the child component:</p>

<pre><code>const TableRow = (props) =&gt; {
if(Object.keys(props.account).length === 0){ //show something while awaiting fetch
    return (
        &lt;tbody&gt;
            &lt;tr&gt;&lt;td&gt;Loading.....&lt;/td&gt;&lt;/tr&gt; // shows momentarily
        &lt;/tbody&gt;
        );
}else{
        return ( // outputs correct info eventually
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;td&gt;{props.account.name}&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Email&lt;/th&gt;&lt;td&gt;{props.account.email}&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
        );  
}   
}
</code></pre>

<p>response info requested:</p>

<pre><code>Status code: 200 OK
Date: Thu, 21 Dec 2017 11:53:50 GMT
Server: Apache/2.2.32 (Unix) mod_wsgi/3.5 Python/2.7.13 PHP/7.1.8     mod_ssl/2.2.32 OpenSSL/1.0.2j DAV/2 mod_fastcgi/2.4.6 mod_perl/2.0.9  Perl/v5.24.0
X-Powered-By: PHP/7.1.8
Cache-Control: no-cache, private
Content-Length: 600
Keep-Alive: timeout=5, max=99
Connection: Keep-Alive
Content-Type: application/json
</code></pre>
","Log full `response` status code and headers, it may have something to do with the way you authenticate. Maybe you receive a 401 at first call asking authentication, and then fetch makes a second call with your credentials. Couldn't find documentation for fetch, but it is well explained in request module : https://github.com/request/request#http-authentication"
"47921783","react error on componentDidMount -> Can only update a mounted or mounting component?","4","<p>I am new to React, so this is probably just a beginner's mistake.</p>

<p>In summary, it's throwing the error/warning mentioned and it is running fetch twice. It ends up with the correct final result though. </p>

<p>The set up is a page to show basic user profile information, with functionality to change profile to be added later.</p>

<p>Details:</p>

<ul>
<li><p>componentDidMount seems to be called once, as per the console.log output below</p></li>
<li><p>fetch is called twice, for whatever reason. Both times it gets the correct info from remote</p></li>
<li><p>this.setState({account.data.data[0]}) fails the first time around and throws the error. This is particularly strange as <strong>it suggests the component is not mounted while it is called within componentDidMount</strong>.
The second time fetch and setState run it updates state correctly.</p></li>
</ul>

<p>The exact error message:</p>

<blockquote>
  <p>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.</p>
</blockquote>

<p>This is the main component:</p>

<pre><code>class AccountTable extends React.Component{

constructor(props){
    super(props)
    this.state={
        account:{},
    }
}

componentDidMount(){
    console.log('componentDidMount');//outputs once
    fetch('/mon-compte-api', {
        method: 'get',
        credentials: 'same-origin'
    })
    .then((response) =&gt; {
        console.log('fetch'); // outputs twice 
        response.json().then((data) =&gt; {
            console.log('data', data);// correct output both times
            this.setState({account: data.data[0]}) // this throws the error
            console.log('state_account', this.state.account); 
// no output for this.state.account first time around. Correct output 2nd time 
        })       
    })
    .catch((err) =&gt; {
        console.log(err)
    });      
}

render(){
    return (
        &lt;table&gt;
                &lt;TableRow 
                   account={this.state.account} /&gt;
        &lt;/table&gt;
    );      
}
}

ReactDOM.render(&lt;AccountTable /&gt;,document.querySelector(""#react_account""));
</code></pre>

<p>This is the child component:</p>

<pre><code>const TableRow = (props) =&gt; {
if(Object.keys(props.account).length === 0){ //show something while awaiting fetch
    return (
        &lt;tbody&gt;
            &lt;tr&gt;&lt;td&gt;Loading.....&lt;/td&gt;&lt;/tr&gt; // shows momentarily
        &lt;/tbody&gt;
        );
}else{
        return ( // outputs correct info eventually
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;td&gt;{props.account.name}&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Email&lt;/th&gt;&lt;td&gt;{props.account.email}&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
        );  
}   
}
</code></pre>

<p>response info requested:</p>

<pre><code>Status code: 200 OK
Date: Thu, 21 Dec 2017 11:53:50 GMT
Server: Apache/2.2.32 (Unix) mod_wsgi/3.5 Python/2.7.13 PHP/7.1.8     mod_ssl/2.2.32 OpenSSL/1.0.2j DAV/2 mod_fastcgi/2.4.6 mod_perl/2.0.9  Perl/v5.24.0
X-Powered-By: PHP/7.1.8
Cache-Control: no-cache, private
Content-Length: 600
Keep-Alive: timeout=5, max=99
Connection: Keep-Alive
Content-Type: application/json
</code></pre>
","I think the problem lies within the parent of AccountTable, can you post the code here?"
"47921783","react error on componentDidMount -> Can only update a mounted or mounting component?","4","<p>I am new to React, so this is probably just a beginner's mistake.</p>

<p>In summary, it's throwing the error/warning mentioned and it is running fetch twice. It ends up with the correct final result though. </p>

<p>The set up is a page to show basic user profile information, with functionality to change profile to be added later.</p>

<p>Details:</p>

<ul>
<li><p>componentDidMount seems to be called once, as per the console.log output below</p></li>
<li><p>fetch is called twice, for whatever reason. Both times it gets the correct info from remote</p></li>
<li><p>this.setState({account.data.data[0]}) fails the first time around and throws the error. This is particularly strange as <strong>it suggests the component is not mounted while it is called within componentDidMount</strong>.
The second time fetch and setState run it updates state correctly.</p></li>
</ul>

<p>The exact error message:</p>

<blockquote>
  <p>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.</p>
</blockquote>

<p>This is the main component:</p>

<pre><code>class AccountTable extends React.Component{

constructor(props){
    super(props)
    this.state={
        account:{},
    }
}

componentDidMount(){
    console.log('componentDidMount');//outputs once
    fetch('/mon-compte-api', {
        method: 'get',
        credentials: 'same-origin'
    })
    .then((response) =&gt; {
        console.log('fetch'); // outputs twice 
        response.json().then((data) =&gt; {
            console.log('data', data);// correct output both times
            this.setState({account: data.data[0]}) // this throws the error
            console.log('state_account', this.state.account); 
// no output for this.state.account first time around. Correct output 2nd time 
        })       
    })
    .catch((err) =&gt; {
        console.log(err)
    });      
}

render(){
    return (
        &lt;table&gt;
                &lt;TableRow 
                   account={this.state.account} /&gt;
        &lt;/table&gt;
    );      
}
}

ReactDOM.render(&lt;AccountTable /&gt;,document.querySelector(""#react_account""));
</code></pre>

<p>This is the child component:</p>

<pre><code>const TableRow = (props) =&gt; {
if(Object.keys(props.account).length === 0){ //show something while awaiting fetch
    return (
        &lt;tbody&gt;
            &lt;tr&gt;&lt;td&gt;Loading.....&lt;/td&gt;&lt;/tr&gt; // shows momentarily
        &lt;/tbody&gt;
        );
}else{
        return ( // outputs correct info eventually
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;td&gt;{props.account.name}&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Email&lt;/th&gt;&lt;td&gt;{props.account.email}&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
        );  
}   
}
</code></pre>

<p>response info requested:</p>

<pre><code>Status code: 200 OK
Date: Thu, 21 Dec 2017 11:53:50 GMT
Server: Apache/2.2.32 (Unix) mod_wsgi/3.5 Python/2.7.13 PHP/7.1.8     mod_ssl/2.2.32 OpenSSL/1.0.2j DAV/2 mod_fastcgi/2.4.6 mod_perl/2.0.9  Perl/v5.24.0
X-Powered-By: PHP/7.1.8
Cache-Control: no-cache, private
Content-Length: 600
Keep-Alive: timeout=5, max=99
Connection: Keep-Alive
Content-Type: application/json
</code></pre>
","@GabrielBleu, thanks. I added response info above. It's 200 OK."
"47921783","react error on componentDidMount -> Can only update a mounted or mounting component?","4","<p>I am new to React, so this is probably just a beginner's mistake.</p>

<p>In summary, it's throwing the error/warning mentioned and it is running fetch twice. It ends up with the correct final result though. </p>

<p>The set up is a page to show basic user profile information, with functionality to change profile to be added later.</p>

<p>Details:</p>

<ul>
<li><p>componentDidMount seems to be called once, as per the console.log output below</p></li>
<li><p>fetch is called twice, for whatever reason. Both times it gets the correct info from remote</p></li>
<li><p>this.setState({account.data.data[0]}) fails the first time around and throws the error. This is particularly strange as <strong>it suggests the component is not mounted while it is called within componentDidMount</strong>.
The second time fetch and setState run it updates state correctly.</p></li>
</ul>

<p>The exact error message:</p>

<blockquote>
  <p>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.</p>
</blockquote>

<p>This is the main component:</p>

<pre><code>class AccountTable extends React.Component{

constructor(props){
    super(props)
    this.state={
        account:{},
    }
}

componentDidMount(){
    console.log('componentDidMount');//outputs once
    fetch('/mon-compte-api', {
        method: 'get',
        credentials: 'same-origin'
    })
    .then((response) =&gt; {
        console.log('fetch'); // outputs twice 
        response.json().then((data) =&gt; {
            console.log('data', data);// correct output both times
            this.setState({account: data.data[0]}) // this throws the error
            console.log('state_account', this.state.account); 
// no output for this.state.account first time around. Correct output 2nd time 
        })       
    })
    .catch((err) =&gt; {
        console.log(err)
    });      
}

render(){
    return (
        &lt;table&gt;
                &lt;TableRow 
                   account={this.state.account} /&gt;
        &lt;/table&gt;
    );      
}
}

ReactDOM.render(&lt;AccountTable /&gt;,document.querySelector(""#react_account""));
</code></pre>

<p>This is the child component:</p>

<pre><code>const TableRow = (props) =&gt; {
if(Object.keys(props.account).length === 0){ //show something while awaiting fetch
    return (
        &lt;tbody&gt;
            &lt;tr&gt;&lt;td&gt;Loading.....&lt;/td&gt;&lt;/tr&gt; // shows momentarily
        &lt;/tbody&gt;
        );
}else{
        return ( // outputs correct info eventually
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;td&gt;{props.account.name}&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Email&lt;/th&gt;&lt;td&gt;{props.account.email}&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
        );  
}   
}
</code></pre>

<p>response info requested:</p>

<pre><code>Status code: 200 OK
Date: Thu, 21 Dec 2017 11:53:50 GMT
Server: Apache/2.2.32 (Unix) mod_wsgi/3.5 Python/2.7.13 PHP/7.1.8     mod_ssl/2.2.32 OpenSSL/1.0.2j DAV/2 mod_fastcgi/2.4.6 mod_perl/2.0.9  Perl/v5.24.0
X-Powered-By: PHP/7.1.8
Cache-Control: no-cache, private
Content-Length: 600
Keep-Alive: timeout=5, max=99
Connection: Keep-Alive
Content-Type: application/json
</code></pre>
","@LirenYeo thanks, but there is no parent. This is it."
"47952405","dynamic component shows warning in console when making http requests react-router v4","2","<p>For a dashboard component i've been working has been having some issues recently. I'm using react-router to handle url routes client-side, and recently I started loading in components asynchronously for each route.</p>

<p>Whenever I make a http requests from route components I keep getting a warning message in the console. The warning says that setState cannot the state of a unmounted component. So far I have been able to deduce that a mounting loop could be causing setState to unsuccessfully set the state of the component. Other than that I am not sure what is causing this issue top occur. </p>

<p>Has anyone else have this issue before? Any advice on this issue is appreciated.</p>

<p><strong>console screenshot</strong>:
<a href=""https://i.stack.imgur.com/wxcnD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wxcnD.png"" alt=""enter image description here""></a></p>

<p><strong>asyncLoader.js</strong>:</p>

<pre><code> import React from 'react';

 export default (getComponent, extraProps=null) =&gt; {
     return class asyncComponent extends React.Component {
         static Component = null;

         constructor(props){
             super(props);

             this.state = {Component: asyncComponent.Component};
         }
         componentWillMount(){
             const {Component} = this.state;

             if (Component === null) getComponent().then((component) =&gt; {
                asyncComponent.Component = component;

                if (this.mounted) this.setState({Component: component});

             });
         }
         componentDidMount(){
             this.mounted = true;
         }
         componentWillUnmount(){
             this.mounted = false;
         }
         render(){
             const {Component} = this.state;

             return Component !== null ? &lt;Component {...this.props} {...extraProps} /&gt; : null;

         }
     };
};
</code></pre>

<p><strong>route-container.js</strong>:</p>

<pre><code>import React from 'react';
import {Switch, Route, Redirect} from 'react-router-dom';
import asyncComponent from './asyncLoader';

export default class Container extends React.Component{
    constructor(props){
        super(props);

        this.state = {loadingScreen: true};

        this.handleStateChange = this.handleStateChange.bind(this);
    }
    handleStateChange(){
        this.setState((prevState) =&gt; ({loadingScreen: !prevState.loadingScreen}));
    }
    render(){
        const {user, getUserCallback} = this.props,
              {loadingScreen} = this.state,
              UserSettings = asyncComponent(() =&gt; import('./user').then((module) =&gt; module.UserSettings), {user: {...user}, getUserCallback: getUserCallback, loadingScreenCallback: this.handleStateChange}),
              TransactionHistory = asyncComponent(() =&gt; import('./transactions').then((module) =&gt; module.TransactionHistory), {user: {...user}, loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              PaymentMethods = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.PaymentMethods), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              UserBillCreator = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.UserBillCreator), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              UserBillPaymentSender = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.UserBillPaymentSender), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance, getUserCallback: getUserCallback, accountBalance: !user.admin ? user.account_balance : 0});

        return(
            &lt;div className=""d-flex flex-column col dashboard-app-container""&gt;
                &lt;div ref=""loadingScreen"" className={loadingScreen ? ""row justify-content-center react-loading-screen"" : ""row justify-content-center react-loading-screen hide""}&gt;
                    &lt;div className=""d-flex flex-column justify-content-center react-loading-container""&gt;
                        &lt;i className=""fa fa-spin fa-circle-o-notch"" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;Switch&gt;
                   &lt;Route path=""/settings"" component={UserSettings} /&gt;
                   &lt;Route path=""/transactions/history"" component={TransactionHistory} /&gt;
                   &lt;Route path=""/transactions/paymentMethods"" component={PaymentMethods} /&gt;
                   &lt;Route path=""/transactions/billing/create"" component={UserBillCreator} /&gt;
                   &lt;Route path=""/transactions/billing/pay"" component={UserBillPaymentSender} /&gt;
                   &lt;Redirect from=""/"" to=""/transactions/history"" /&gt;
                &lt;/Switch&gt;
            &lt;/div&gt;
        );
    }

}
</code></pre>

<p>Component example for route <strong>""/transactions/history""</strong></p>

<p><strong>transactions.js</strong>:</p>

<pre><code>import React from 'react';
import _ from 'lodash';
import moment from 'moment';
import {Link} from 'react-router-dom';
import {AgGridReact} from 'ag-grid-react';
import DayPickerInput from 'react-day-picker/DayPickerInput';
import 'react-day-picker/lib/style.css';


export class TransactionHistory extends React.Component{
    constructor(props){
        super(props);

        this.state = {
            activity_day_period: '30 days',
            date_filter: {
                start: '',
                end: ''
            },
            dateAccordianOpen: false,
            data_grid: {
                columns: [
                    {headerName: 'Bill ID', field: 'id'},
                    {headerName: 'Created On', field: 'created_on'},
                    {headerName: 'Paid on', field: 'transaction_created_on'},
                    {headerName: 'Amount', field: 'billed_amount'},
                    {headerName: 'Item', field: 'item_name'},
                    {headerName: 'Description', field: 'description'}

                ],
                rows: [],
                filtered_rows: [],
                raw_data: []
            }
        };

        this.handleDateChangeStart = this.handleDateChangeStart.bind(this);
        this.handleDateChangeEnd = this.handleDateChangeEnd.bind(this);
        this.onGridReady = this.onGridReady.bind(this);
        this.handGridResize = this.handleGridResize.bind(this);
        this.getTransactionData = this.getTransactionData.bind(this);

    }
    componentDidMount(){
        this.getTransactionData();
        setTimeout(this.props.loadingScreenCallback, 600);
    }
    componentWillUnmount(){
        this.props.loadingScreenCallback();
    }
    handleDateChangeStart(date){
        this.setState((prevState) =&gt; ({date_filter: {...prevState.date_filter, start: moment.utc(date).format('YYYY-MM-DD')}}));

    }
    handleDateChangeEnd(date){
        this.setState((prevState) =&gt; ({date_filter: {...prevState.date_filter, end: moment.utc(date).format('YYYY-MM-DD')}}));
    }
    onGridReady(params){
        this.api = params.api;
        this.columnApi = params.columnApi;

        this.api.sizeColumnsToFit();

    }
    handleGridResize(){
        this.api.sizeColumnsToFit();

    }
    getTransactionData(){
        const {activity_day_period} = this.state;
        let api_url = window.location.origin;

        switch (activity_day_period) {
            case '30 days':
                api_url = `${api_url}/api/user/billing?days=30`;
                break;

            case '3 months':
                api_url = `${api_url}/api/user/billing?months=3`;
                break;

            case '6 months':
                api_url = `${api_url}/api/user/billing?months=6`;
                break;

            case '1 year':
                api_url = `${api_url}/api/user/billing?years=1`;
                break;

            case 'All':
                api_url = `${api_url}/api/user/billing`;
                break;

        }

        this.props.axiosInstance.get(api_url).then((response) =&gt; {
            if (response.data.code == 200) {
                // The warning seems to pop up when setState in this method is called...
                this.setState((prevState) =&gt; ({
                    data_grid: {
                        ...prevState.data_grid,
                        rows: response.data.bills.map((data) =&gt; {
                            if (data.bill_paid) {
                                return {
                                    id: data.id,
                                    created_on: moment.utc(data.created_on).format('YYYY-MM-DD'),
                                    transaction_created_on: moment.utc(data.transaction.date).format('YYYY-MM-DD'),
                                    billed_amount: `$${data.billed_amount.toFixed(2)}`,
                                    item_name: data.item_name,
                                    description: data.description
                                };
                            }
                        }), 
                        raw_data: response.data.bills
                    }
                }));

            }
        }).catch((error) =&gt; {
            if (error.response) {
                if (error.response.data.code == 401) {
                 //Here another http request is made to my api in order to get new auth tokens before retrying the original request. 
                }

        });
    }
    render(){
        const {user} = this.props,
              {activity_day_period, date_filter, dateAccordianOpen, data_grid} = this.state,
              start_date_obj = new Date(),
              end_date_obj = new Date();
              start_date_obj.setDate(start_date_obj.getDate() - 1);

        return(
            &lt;div className=""container pl-0 pr-0""&gt;
                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-6""&gt;
                        &lt;h2&gt;Transaction History&lt;/h2&gt;
                        &lt;p&gt;You can check past and pending tranactions here.&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-7 ml-5 mt-3""&gt;
                        &lt;h4&gt;Account Balance&lt;/h4&gt;
                        &lt;h1 className=""display-3 text-muted text-center""&gt;${user.account_balance &gt; 0 ? user.account_balance.toFixed(2) : '0.00'}&lt;/h1&gt;
                        {user.account_balance &gt; 0 ? (&lt;div className=""row""&gt;&lt;Link className=""ml-auto"" to=""/transactions/billing/pay""&gt;Pay Now &lt;i className=""fa fa-chevron-right"" /&gt;&lt;/Link&gt;&lt;/div&gt;) : (&lt;p className=""text-right text-muted""&gt;&lt;em&gt;No balances to pay right now. HOORAY!&lt;/em&gt;&lt;/p&gt;)}
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row mt-4""&gt;
                    &lt;div className=""col-md-3 form-group""&gt;
                        &lt;label htmlFor=""activity""&gt;Activity&lt;/label&gt;
                        &lt;select id=""activity"" name=""activity_day_period"" className=""form-control"" value={activity_day_period} onChange={(e) =&gt; this.setState({activity_day_period: e.target.value}, this.getTransactionData)}&gt;
                            &lt;option key=""1""&gt;30 days&lt;/option&gt;
                            &lt;option key=""2""&gt;3 months&lt;/option&gt;
                            &lt;option key=""3""&gt;6 months&lt;/option&gt;
                            &lt;option key=""4""&gt;1 year&lt;/option&gt;
                            &lt;option key=""5""&gt;All&lt;/option&gt;
                        &lt;/select&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row pb-3""&gt;
                    &lt;div className=""ag-blue dashboard-transaction-grid""&gt;
                        &lt;AgGridReact columnDefs={data_grid.columns} 
                                     rowData={data_grid.rows} 
                                     groupHeaders=""true"" 
                                     onGridReady={this.onGridReady}
                                     onGridSizeChanged={this.handleGridResize}/&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
","this is happening because you are calling setState in componentWillMount.  The docs say to do async calls in componentDidMount https://reactjs.org/docs/react-component.html#componentwillmount"
"47952405","dynamic component shows warning in console when making http requests react-router v4","2","<p>For a dashboard component i've been working has been having some issues recently. I'm using react-router to handle url routes client-side, and recently I started loading in components asynchronously for each route.</p>

<p>Whenever I make a http requests from route components I keep getting a warning message in the console. The warning says that setState cannot the state of a unmounted component. So far I have been able to deduce that a mounting loop could be causing setState to unsuccessfully set the state of the component. Other than that I am not sure what is causing this issue top occur. </p>

<p>Has anyone else have this issue before? Any advice on this issue is appreciated.</p>

<p><strong>console screenshot</strong>:
<a href=""https://i.stack.imgur.com/wxcnD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wxcnD.png"" alt=""enter image description here""></a></p>

<p><strong>asyncLoader.js</strong>:</p>

<pre><code> import React from 'react';

 export default (getComponent, extraProps=null) =&gt; {
     return class asyncComponent extends React.Component {
         static Component = null;

         constructor(props){
             super(props);

             this.state = {Component: asyncComponent.Component};
         }
         componentWillMount(){
             const {Component} = this.state;

             if (Component === null) getComponent().then((component) =&gt; {
                asyncComponent.Component = component;

                if (this.mounted) this.setState({Component: component});

             });
         }
         componentDidMount(){
             this.mounted = true;
         }
         componentWillUnmount(){
             this.mounted = false;
         }
         render(){
             const {Component} = this.state;

             return Component !== null ? &lt;Component {...this.props} {...extraProps} /&gt; : null;

         }
     };
};
</code></pre>

<p><strong>route-container.js</strong>:</p>

<pre><code>import React from 'react';
import {Switch, Route, Redirect} from 'react-router-dom';
import asyncComponent from './asyncLoader';

export default class Container extends React.Component{
    constructor(props){
        super(props);

        this.state = {loadingScreen: true};

        this.handleStateChange = this.handleStateChange.bind(this);
    }
    handleStateChange(){
        this.setState((prevState) =&gt; ({loadingScreen: !prevState.loadingScreen}));
    }
    render(){
        const {user, getUserCallback} = this.props,
              {loadingScreen} = this.state,
              UserSettings = asyncComponent(() =&gt; import('./user').then((module) =&gt; module.UserSettings), {user: {...user}, getUserCallback: getUserCallback, loadingScreenCallback: this.handleStateChange}),
              TransactionHistory = asyncComponent(() =&gt; import('./transactions').then((module) =&gt; module.TransactionHistory), {user: {...user}, loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              PaymentMethods = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.PaymentMethods), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              UserBillCreator = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.UserBillCreator), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              UserBillPaymentSender = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.UserBillPaymentSender), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance, getUserCallback: getUserCallback, accountBalance: !user.admin ? user.account_balance : 0});

        return(
            &lt;div className=""d-flex flex-column col dashboard-app-container""&gt;
                &lt;div ref=""loadingScreen"" className={loadingScreen ? ""row justify-content-center react-loading-screen"" : ""row justify-content-center react-loading-screen hide""}&gt;
                    &lt;div className=""d-flex flex-column justify-content-center react-loading-container""&gt;
                        &lt;i className=""fa fa-spin fa-circle-o-notch"" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;Switch&gt;
                   &lt;Route path=""/settings"" component={UserSettings} /&gt;
                   &lt;Route path=""/transactions/history"" component={TransactionHistory} /&gt;
                   &lt;Route path=""/transactions/paymentMethods"" component={PaymentMethods} /&gt;
                   &lt;Route path=""/transactions/billing/create"" component={UserBillCreator} /&gt;
                   &lt;Route path=""/transactions/billing/pay"" component={UserBillPaymentSender} /&gt;
                   &lt;Redirect from=""/"" to=""/transactions/history"" /&gt;
                &lt;/Switch&gt;
            &lt;/div&gt;
        );
    }

}
</code></pre>

<p>Component example for route <strong>""/transactions/history""</strong></p>

<p><strong>transactions.js</strong>:</p>

<pre><code>import React from 'react';
import _ from 'lodash';
import moment from 'moment';
import {Link} from 'react-router-dom';
import {AgGridReact} from 'ag-grid-react';
import DayPickerInput from 'react-day-picker/DayPickerInput';
import 'react-day-picker/lib/style.css';


export class TransactionHistory extends React.Component{
    constructor(props){
        super(props);

        this.state = {
            activity_day_period: '30 days',
            date_filter: {
                start: '',
                end: ''
            },
            dateAccordianOpen: false,
            data_grid: {
                columns: [
                    {headerName: 'Bill ID', field: 'id'},
                    {headerName: 'Created On', field: 'created_on'},
                    {headerName: 'Paid on', field: 'transaction_created_on'},
                    {headerName: 'Amount', field: 'billed_amount'},
                    {headerName: 'Item', field: 'item_name'},
                    {headerName: 'Description', field: 'description'}

                ],
                rows: [],
                filtered_rows: [],
                raw_data: []
            }
        };

        this.handleDateChangeStart = this.handleDateChangeStart.bind(this);
        this.handleDateChangeEnd = this.handleDateChangeEnd.bind(this);
        this.onGridReady = this.onGridReady.bind(this);
        this.handGridResize = this.handleGridResize.bind(this);
        this.getTransactionData = this.getTransactionData.bind(this);

    }
    componentDidMount(){
        this.getTransactionData();
        setTimeout(this.props.loadingScreenCallback, 600);
    }
    componentWillUnmount(){
        this.props.loadingScreenCallback();
    }
    handleDateChangeStart(date){
        this.setState((prevState) =&gt; ({date_filter: {...prevState.date_filter, start: moment.utc(date).format('YYYY-MM-DD')}}));

    }
    handleDateChangeEnd(date){
        this.setState((prevState) =&gt; ({date_filter: {...prevState.date_filter, end: moment.utc(date).format('YYYY-MM-DD')}}));
    }
    onGridReady(params){
        this.api = params.api;
        this.columnApi = params.columnApi;

        this.api.sizeColumnsToFit();

    }
    handleGridResize(){
        this.api.sizeColumnsToFit();

    }
    getTransactionData(){
        const {activity_day_period} = this.state;
        let api_url = window.location.origin;

        switch (activity_day_period) {
            case '30 days':
                api_url = `${api_url}/api/user/billing?days=30`;
                break;

            case '3 months':
                api_url = `${api_url}/api/user/billing?months=3`;
                break;

            case '6 months':
                api_url = `${api_url}/api/user/billing?months=6`;
                break;

            case '1 year':
                api_url = `${api_url}/api/user/billing?years=1`;
                break;

            case 'All':
                api_url = `${api_url}/api/user/billing`;
                break;

        }

        this.props.axiosInstance.get(api_url).then((response) =&gt; {
            if (response.data.code == 200) {
                // The warning seems to pop up when setState in this method is called...
                this.setState((prevState) =&gt; ({
                    data_grid: {
                        ...prevState.data_grid,
                        rows: response.data.bills.map((data) =&gt; {
                            if (data.bill_paid) {
                                return {
                                    id: data.id,
                                    created_on: moment.utc(data.created_on).format('YYYY-MM-DD'),
                                    transaction_created_on: moment.utc(data.transaction.date).format('YYYY-MM-DD'),
                                    billed_amount: `$${data.billed_amount.toFixed(2)}`,
                                    item_name: data.item_name,
                                    description: data.description
                                };
                            }
                        }), 
                        raw_data: response.data.bills
                    }
                }));

            }
        }).catch((error) =&gt; {
            if (error.response) {
                if (error.response.data.code == 401) {
                 //Here another http request is made to my api in order to get new auth tokens before retrying the original request. 
                }

        });
    }
    render(){
        const {user} = this.props,
              {activity_day_period, date_filter, dateAccordianOpen, data_grid} = this.state,
              start_date_obj = new Date(),
              end_date_obj = new Date();
              start_date_obj.setDate(start_date_obj.getDate() - 1);

        return(
            &lt;div className=""container pl-0 pr-0""&gt;
                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-6""&gt;
                        &lt;h2&gt;Transaction History&lt;/h2&gt;
                        &lt;p&gt;You can check past and pending tranactions here.&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-7 ml-5 mt-3""&gt;
                        &lt;h4&gt;Account Balance&lt;/h4&gt;
                        &lt;h1 className=""display-3 text-muted text-center""&gt;${user.account_balance &gt; 0 ? user.account_balance.toFixed(2) : '0.00'}&lt;/h1&gt;
                        {user.account_balance &gt; 0 ? (&lt;div className=""row""&gt;&lt;Link className=""ml-auto"" to=""/transactions/billing/pay""&gt;Pay Now &lt;i className=""fa fa-chevron-right"" /&gt;&lt;/Link&gt;&lt;/div&gt;) : (&lt;p className=""text-right text-muted""&gt;&lt;em&gt;No balances to pay right now. HOORAY!&lt;/em&gt;&lt;/p&gt;)}
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row mt-4""&gt;
                    &lt;div className=""col-md-3 form-group""&gt;
                        &lt;label htmlFor=""activity""&gt;Activity&lt;/label&gt;
                        &lt;select id=""activity"" name=""activity_day_period"" className=""form-control"" value={activity_day_period} onChange={(e) =&gt; this.setState({activity_day_period: e.target.value}, this.getTransactionData)}&gt;
                            &lt;option key=""1""&gt;30 days&lt;/option&gt;
                            &lt;option key=""2""&gt;3 months&lt;/option&gt;
                            &lt;option key=""3""&gt;6 months&lt;/option&gt;
                            &lt;option key=""4""&gt;1 year&lt;/option&gt;
                            &lt;option key=""5""&gt;All&lt;/option&gt;
                        &lt;/select&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row pb-3""&gt;
                    &lt;div className=""ag-blue dashboard-transaction-grid""&gt;
                        &lt;AgGridReact columnDefs={data_grid.columns} 
                                     rowData={data_grid.rows} 
                                     groupHeaders=""true"" 
                                     onGridReady={this.onGridReady}
                                     onGridSizeChanged={this.handleGridResize}/&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
","That's vague since many of my components use componentwillmount. Which one?"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","are you using `setState` inside `Header` and `HomeContent` component, if yes can you show those components?"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","i am only using it in sidebar.js and is being set in index.js as pasted above"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","i am retrieveing data from here to build up my menu list"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","Is your API endpoint `/api/user/get/user/method/menu/format/json` or you need to send headers"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","After reviewing your code, it seems the issue could be that you are passing DOM elements to your Sidebar. Can you please add your Sidebar code to your question for inspection?"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","added `sidebar,js`"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","please try to debug the code by using `debugger;` in your code. This will assist you to debug quite nicely in google chrome console."
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","Were you able to find the solution ?"
"48062682","react warning cannot set state when using promises","9","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","@stack76 no i was not i still have problem"
"48093185","semantic-ui-react <Responsive> not working for <Table.Cell>","0","<p>I am using semantic-ui react to render a table of data. My requirement is that when the page is on mobile view, I hide certain columns. I tried using <code>className=""mobile hidden""</code> on the <code>Table.Cell</code> element but this doesn't seem to work at all. </p>

<p>Then I tried using the <code>Responsive</code> component like below but I am getting an error. Am I missing something here? Unable to find anyone else having this issue ...</p>

<pre><code>  &lt;Responsive as={Table.Cell} minWidth={Responsive.onlyMobile.minWidth}&gt;
     {record.datapoint}
  &lt;/Responsive&gt;
</code></pre>

<p>I get this error in the console when resizing the window...</p>

<pre><code>index.js:2177 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the Responsive component.
</code></pre>
",""
"48199823","React native component unmounting twice when navigating","0","<p>When I try to navigate back to the home screen the addCar component is unmounting twice causing this error:</p>

<blockquote>
  <p>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.</p>
</blockquote>

<p>in both Home and AddCar js files.</p>

<p><strong><em>Here's my AddCar.js(some debuging code is still in place)</em></strong></p>

<pre><code>    import React from 'react';
import { View, ScrollView, Text, TextInput, TouchableOpacity, KeyboardAvoidingView, StyleSheet, AsyncStorage, Picker, ActivityIndicator } from 'react-native';
import { StackNavigator, NavigationActions } from 'react-navigation';

import { Foot } from '../../../components/Foot';
import carList from '../../../resources/carList.json';

export default class AddCar extends React.Component {
    static navigationOptions = ({ navigation }) =&gt; ({
        title: typeof (navigation.state.params) === 'undefined' || typeof (navigation.state.params.title) === 'undefined' ? '' : navigation.state.params.title,
        headerRight: &lt;View&gt;&lt;/View&gt;
    });
    constructor(props) {
        super(props);
        this.state = {
            hasLoaded: false,
            submitted: false,

            name: '',
            email: '',

            cars: [],

            Year: 'None',
            Make: 'None',
            Model: 'None',
            Engine: 'None',
        }
    }

    componentDidMount() {
        this._loadInitialState().done();
    }

    componentWillUnmount() {
        console.log('Unmounting addcar');
        console.log(this.state.Year);
    }

    _loadInitialState = async () =&gt; {

        var user = await AsyncStorage.getItem('user');
        if (user !== null) {
            var info = JSON.parse(user);

            this.setState({ email: info['email'] });
            this.setState({ age: info['age'] });
            this.setState({ name: info['name'] });

            this.props.navigation.setParams({ title: this.state.name });
        }

        this._getCarList().done();

    }

    _getCarList = async () =&gt; {
        this.setState({
            cars: carList[""years""].reduce((current, next) =&gt; {
                return Object.assign(current, next);
            })
        });
        this.setState({ hasLoaded: true });
        //console.log(this.state.years);
    }

    updateYear(year) {
        if (!this.state.submitted) {
            this.setState({ Year: year });
            this.setState({ Make: ""None"" });
            this.setState({ Model: ""None"" });
            this.setState({ Engine: ""None"" });
        }
    }

    updateMake(make) {
        if (!this.state.submitted) {
            this.setState({ Make: make });
            this.setState({ Model: ""None"" });
            this.setState({ Engine: ""None"" });
        }
    }

    updateModel(model) {
        if (!this.state.submitted) {
            this.setState({ Model: model });
            this.setState({ Engine: ""None"" });
        }
    }
    updateEngine(engine) {
        if (!this.state.submitted) {
            this.setState({ Engine: engine });
        }
    }

    render() {
        return (
            &lt;KeyboardAvoidingView behavior='padding' style={styles.container}&gt;

                &lt;ScrollView&gt;

                    &lt;View style={styles.content}&gt;

                        {this.state.hasLoaded &amp;&amp;
                            &lt;View&gt;
                                &lt;View style={styles.selector}&gt;
                                    &lt;Text style={styles.label}&gt;Year:&lt;/Text&gt;
                                    &lt;View style={styles.dropContainer}&gt;
                                        &lt;Picker
                                            style={styles.dropdown}
                                            selectedValue={this.state.Year}
                                            onValueChange={(itemValue) =&gt; this.updateYear(itemValue)} &gt;
                                            {this.years()}
                                        &lt;/Picker&gt;
                                    &lt;/View&gt;
                                &lt;/View&gt;

                                &lt;View style={styles.selector}&gt;
                                    &lt;Text style={styles.label}&gt;Make:&lt;/Text&gt;
                                    &lt;View style={styles.dropContainer}&gt;
                                        &lt;Picker style={styles.dropdown}
                                            selectedValue={this.state.Make}
                                            onValueChange={(itemValue) =&gt; this.updateMake(itemValue)} &gt;
                                            {this.makes()}
                                        &lt;/Picker&gt;
                                    &lt;/View&gt;
                                &lt;/View&gt;

                                &lt;View style={styles.selector}&gt;
                                    &lt;Text style={styles.label}&gt;Model:&lt;/Text&gt;
                                    &lt;View style={styles.dropContainer}&gt;
                                        &lt;Picker style={styles.dropdown}
                                            selectedValue={this.state.Model}
                                            onValueChange={(itemValue) =&gt; this.updateModel(itemValue)} &gt;
                                            {this.models()}
                                        &lt;/Picker&gt;
                                    &lt;/View&gt;
                                &lt;/View&gt;

                                &lt;View style={styles.selector}&gt;
                                    &lt;Text style={styles.label}&gt;Engine:&lt;/Text&gt;
                                    &lt;View style={styles.dropContainer}&gt;
                                        &lt;Picker style={styles.dropdown}
                                            selectedValue={this.state.Engine}
                                            onValueChange={(itemValue) =&gt; this.updateEngine(itemValue)} &gt;
                                            {this.engines()}
                                        &lt;/Picker&gt;
                                    &lt;/View&gt;
                                &lt;/View&gt;

                            &lt;/View&gt;
                        }
                    &lt;/View&gt;
                    &lt;TouchableOpacity style={styles.button} onPress={() =&gt; this.checkSubmitCar()}&gt;
                        &lt;Text style={styles.buttonText}&gt;Add Car&lt;/Text&gt;
                    &lt;/TouchableOpacity&gt;
                    &lt;TouchableOpacity onPress={() =&gt; this.createCar()}&gt;
                        &lt;Text style={styles.noCar}&gt;Can't find your car? Click here&lt;/Text&gt;
                    &lt;/TouchableOpacity&gt;

                &lt;/ScrollView&gt;

                {!this.state.hasLoaded &amp;&amp; &lt;View style={styles.load} collapsable={false} &gt;
                    &lt;ActivityIndicator size=""large"" color=""orange"" /&gt;
                &lt;/View&gt;}

                &lt;Foot /&gt;
            &lt;/KeyboardAvoidingView&gt;
        );
    }
    years() {
        if (this.state.hasLoaded) {
            return Object.keys(this.state.cars).slice(0).reverse().map((item, test, value) =&gt; {
                return (&lt;Picker.Item label={item} value={item} key={item} /&gt;)
            });
        } else {
            return (
                &lt;Picker.Item label={""None""} value={""None""} key={""None""} /&gt;
            )
        }
    }
    makes() {
        if (this.state.hasLoaded) {
            return Object.keys(this.state.cars[this.state.Year]).map((item, value) =&gt; {
                return (&lt;Picker.Item label={item} value={item} key={item} /&gt;)
            });
        } else {
            return (
                &lt;Picker.Item label={""None""} value={""None""} key={""None""} /&gt;
            )
        }
    }
    models() {
        if (this.state.hasLoaded &amp;&amp; this.state.Make !== ""None"") {
            return Object.keys(this.state.cars[this.state.Year][this.state.Make]).map((item, value) =&gt; {
                return (&lt;Picker.Item label={item} value={item} key={item} /&gt;)
            });
        } else {
            return (
                &lt;Picker.Item label={""None""} value={""None""} key={""None""} /&gt;
            )
        }
    }
    engines() {
        if (this.state.hasLoaded &amp;&amp; this.state.Make !== ""None"" &amp;&amp; this.state.Model !== ""None"") {
            return Object.keys(this.state.cars[this.state.Year][this.state.Make][this.state.Model]).map((item, value) =&gt; {
                return (&lt;Picker.Item label={this.state.cars[this.state.Year][this.state.Make][this.state.Model][value]}
                    value={this.state.cars[this.state.Year][this.state.Make][this.state.Model][value]}
                    key={this.state.cars[this.state.Year][this.state.Make][this.state.Model][value]} /&gt;)
            });
        } else {
            return (
                &lt;Picker.Item label={""None""} value={""None""} key={""None""} /&gt;
            )
        }
    }

    checkSubmitCar() {
        if (this.state.Year === 'None') {
            alert(""Year is empty. Please select the year of your car!"");
        } else if (this.state.Make === 'None') {
            alert(""Make is empty. Please select the make of your car!"");
        } else if (this.state.Model === 'None') {
            alert(""Model is empty. Please select the model of your car!"");
        } else if (this.state.Engine === 'None') {
            alert(""Engine is empty. Please select the engine of your car!"");
        } else {
            console.log('car submitted');
            this.setState({ submitted: true });
            this.submitCar();
        }
    }

    submitCar() {
        this.setState({ hasLoaded: false });

        var payload = {
            email: this.state.email,
            year: this.state.Year,
            make: this.state.Make,
            model: this.state.Model,
            engine: this.state.Engine,
        };

        fetch('https://x/user_car_registration.php', {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)

        }).then((response) =&gt; response.json())
            .then((responseJson) =&gt; {

                if (responseJson === ""Car Registered Successfully"") {
                    alert(responseJson);
                    //this.setState({ hasLoaded: true });
                    console.log(""car registered"");
                    console.log(this.state.Year);
                    this.resetNavigation('CHome');
                } else {
                    alert(responseJson);
                    this.setState({ hasLoaded: true });
                }


            }).catch((error) =&gt; {
                console.error(error);
            });
    }

    resetNavigation(targetRoute) {
        const resetAction = NavigationActions.reset({
            index: 0,
            actions: [
                NavigationActions.navigate({ routeName: targetRoute }),
            ],
            key: null,
        });
        console.log('Moving to home page');
        this.props.navigation.dispatch(resetAction);
    }

    createCar() {

    }
}
</code></pre>

<p>I believe it has to do with the Picker's but not sure.</p>

<p><strong><em>This is the out put from the console.log() calls</em></strong></p>

<blockquote>
  <p>car submitted</p>
  
  <p>car registered</p>
  
  <p>2018</p>
  
  <p>Moving to home page</p>
  
  <p>Unmounting addcar</p>
  
  <p>2018</p>
  
  <p>Unmounting addcar</p>
  
  <p>None</p>
</blockquote>

<p>Sorry for the long post.</p>
",""
"48217565","Three js not rendering objects in scene after OOP implementation in react","1","<p>After making a stand alone three js app I wanted to make this three js app a component in my React application.</p>

<p>I needed multiple scenes overlayed so I made a threeApp function that instantiates a scene, camera, renderer and adds it to the DOM. So I tried to make a lot of stuff reusable. </p>

<p>After following <a href=""https://stackoverflow.com/questions/41248287/how-to-connect-threejs-to-react"">this answer</a> I managed to get some a three js scene with a spinning cube in my react app. Success! Since I already made a functioning OOP (?) implementation without react so I dove right in. </p>

<p>Right now I have a rendered canvas in my app but the objects in it are not getting rendered. However I can see the scene in three js inspector extension. If I console log at the animate/update functions they all fire.</p>

<p>This is the react component copied from this <a href=""https://stackoverflow.com/questions/41248287/how-to-connect-threejs-to-react"">SO answer</a> which originally worked.</p>

<pre><code>import React, { Component } from 'react'
import * as THREE from 'three'

import testCube from ""./viz/testCube""
import VizHandler from './VizHandler'


class Visualizer extends Component {
  constructor(props) {
    super(props)

    this.start = this.start.bind(this)
    this.stop = this.stop.bind(this)
    this.animate = this.animate.bind(this)
  }

  componentDidMount() {
    const vizHandler = this.vizHandler = new VizHandler();
    vizHandler.init(this.mount);
    this.start()
  }

  componentWillUnmount() {
    this.stop()
    // this.mount.removeChild(threeApps['vizholder'].getRenderer().domElement)
    // vizHandler.unmount(this.mount);
  }

  start() {
    if (!this.frameId) {
      this.frameId = requestAnimationFrame(this.animate)
    }
  }

  stop() {
    cancelAnimationFrame(this.frameId)
  }

  animate() {
    this.vizHandler.update(); // update / animate stuff in here

    this.vizHandler.render()
    this.frameId = window.requestAnimationFrame(this.animate)
  }

  render() {
    return (
      &lt;div
        // style={{ width: '400px', height: '400px' }}
        ref={(mount) =&gt; { this.mount = mount }}
      /&gt;
    )
  }
}

export default Visualizer
</code></pre>

<p>I handle multiple threejs scenes/canvases here in the VizHandler function/class</p>

<pre><code>import * as THREE from ""three"";
import threeApp from ""./threeApp"";
import WhiteRing from ""./viz/WhiteRing"";
import testCube from ""./viz/testCube"";
import Bars from ""./viz/Bars"";


const VizHandler = function () {

  var threeApps = [];
  var rings = new WhiteRing();
  var bars = new Bars();
  var cube = new testCube();

  function init(mount) {


      threeApps['vizholder'] = new threeApp();
      // threeApps['overlay'] = new threeApp();
      threeApps['vizholder'].init(mount, 'VizHolder') ;
      // threeApps['overlay'].init(mount, 'Overlay');

      window.scene = threeApps['vizholder'].getScene();
      window.THREE = THREE;

      const vizHolder = threeApps['vizholder'].getVizHolder();
      rings.init( vizHolder );
      bars.init( vizHolder );
      cube.init( vizHolder );

  }

  function update() {
    rings.update();
    bars.update();
    cube.update();
  }

  function render() {
    threeApps[""vizholder""].render();
  }


  return {
      init: init,
      update: update,
      render: render,
      getVizHolder: function( name ) {
          if ( name ) return threeApps[name].getVizHolder();
          else return threeApps['vizholder'].getVizHolder();
      },
      getRenderer: function( name ) {
          if ( name ) return threeApps[name].getRenderer();
          else return threeApps['vizholder'].getRenderer();
      },
      getThreeApps: function() {
          return threeApps
      },
  };

};
</code></pre>

<p>And this is the most basic cube to that I'm trying to render.</p>

<pre><code>import * as THREE from 'three';

const testCube = function () {

  let cube;

  function init (vizHolder) {

      const groupHolder = new THREE.Object3D();
      groupHolder.name = ""TemplateViz"";
      vizHolder.add(groupHolder);

      const geometry = new THREE.BoxGeometry(1, 1, 1)
      const material = new THREE.MeshBasicMaterial({ color: '#ffffff' })
      cube = new THREE.Mesh(geometry, material)
      cube.name = ""TESTCUBE"";
      groupHolder.add(cube);
      vizHolder.add(groupHolder);

  }

  function update() {
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
  }

  return {
    init: init,
    update: update,
  }

};

export default testCube;
</code></pre>

<p>And the result of all this is a renderer element in the dom that does not render my elements to the scene. I can change the renderer color and update the objects in the scene but I cannot make them appear.</p>

<p>EDIT: After solving the problem in my more simplified answer <a href=""https://stackoverflow.com/questions/48241380/react-three-js-scene-wont-render-until-manipulated-in-chrome-inspector-extension"">here</a>, I forgot to post 1 important file where the error eventually occurred. The threeApp class where I make scenes, renderers and camera's. The code below was the non working code.</p>

<pre><code>import * as THREE from ""three"";

function threeApp() {

  let camera, scene, renderer;
  let groundLight, skyLight, hemiLight;
  let vizHolder;
  let objName;
  let renderColor = '#909009';

  function init(mount, name) {

      objName = name;
      this.holderName = name;

      renderer = new THREE.WebGLRenderer({
          // antialias: true,
          // alpha: true
      });
      renderer.setSize(800, 600);

      renderer.domElement.className = ""renderer"";
      mount.appendChild(renderer.domElement);

      //3D SCENE
      camera = new THREE.PerspectiveCamera(70, 800 / 600, 1, 3000);
      camera.position.z = 1000;
      camera.name = ""camera"";


      scene = new THREE.Scene();
      // window.THREE = THREE;
      scene.name = name + "" scene"";
      console.log( 'name', name );
      if ( name == ""VizHolder"") {
          window.scene = scene;
      }
      camera.lookAt(scene);
      scene.fog = new THREE.Fog(0xffd8e5, 1000, 3000);
      scene.add(camera);

      //INIT VIZ
      vizHolder = new THREE.Object3D();
      vizHolder.name = name;

      scene.add(vizHolder);
  }


  function update () {
        render();
  }

  function render() {
    renderer.render(scene, camera);
  }

  function onResize () {

      var renderW = window.innerWidth;
      var renderH = window.innerHeight;
      camera.aspect = renderW / renderH;
      camera.updateProjectionMatrix();
      renderer.setSize(renderW, renderH);
  }

  return {
    init: init,
    render: render,
    onResize: onResize,
    getVizHolder: function() {
        return vizHolder;
    },
    getCamera: function() {
        return camera;
    },
    getScene: function() {
        return scene;
    },
    getRenderer: function() {
        return renderer;
    },
    setRenderColor: setRenderColor
}

};

export default threeApp
</code></pre>
","Ok so as I said I could see the objects in the scene via the chrome three js extension. As soon as I tweak the camera settings, the scene starts getting rendered with the animations.

This only happens with the camera, no other object starts the rendering. Maybe something with asynchronicity going on here?"
"48291943","react-native function in map","0","<p>I'm new to react-native and I'm trying to build an application connected to a ruby on rails backend.</p>

<p>I have an index view in which I retrieve a list of lunches, I would like that when I click on one of them, I go to that presentation. so I created a specific view in which I redo an api call to retrieve the lunch data and then I display this one. 
The problem is that it tries to read the data first and then it makes the api call after that while the method is in a <code>componentWillMount()</code> and the api call is done after that because I see it in the logs.</p>

<p>INDEX.js</p>

<pre><code>import React from 'react';
import { View, Text, Image, StyleSheet, ScrollView, TouchableHighlight } from 'react-native'
import { Card, ListItem, Button } from 'react-native-elements'
import { Actions } from 'react-native-router-flux';

export default class IndexLunches extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      lunches: []
    };
    this.show = this.show.bind(this)
  }
  fetchLunches() {
    fetch('http://192.168.1.24:3000/api/v1/lunches', {
      method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        }
    })
    .then((response) =&gt; {
      if (response.ok) {
        console.log('RESPONSE OK : GET LUNCHES')
        var lunches = JSON.parse(response._bodyText);
        var headers = response.headers
        console.log(lunches)
        console.log(headers)
        this.setState({lunches: lunches})

      } else {
        alert(""Erreur pendant la réceptions des lunchs voir les logs"")
        console.log(response)
      }

    })
    .catch(function(error) {
      console.log('There has been a problem with your fetch operation: ' + error.message);
      // ADD THIS THROW error
        throw error;
      })
    .done();

  }

  show(id) {
    Actions.show_lunch({lunch_id: id})
  }

  lunchCard() {
    lunches = this.state.lunches
    return lunches.map((lunch, i) =&gt; {
      return(
        &lt;TouchableHighlight key={i} onPress={() =&gt; this.show(lunch.id)}&gt;
          &lt;View 
            // key={i}
            // Error here because react auto execute onPress on load
            &gt;
            &lt;Image
              style={{flex: 1, height: 150}}
              source={{ uri: lunch.photos[0].url }}
            /&gt;
            &lt;Text&gt;Titre du lunch : {lunch.title}&lt;/Text&gt;
            &lt;View&gt;
              &lt;Text&gt;id : {lunch.id}&lt;/Text&gt;
            &lt;/View&gt;
        &lt;/View&gt;
        &lt;/TouchableHighlight&gt;
      );
    });
  }
  // Its called before render component
  componentWillMount() {
    this.fetchLunches();
  }
  render () {
    return (
      &lt;ScrollView&gt;
        &lt;Text style={styles.title} &gt; Liste des lunchs &lt;/Text&gt;
        &lt;View&gt;
          { this.lunchCard() }
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    )
  }
}

const styles = StyleSheet.create({
  title: {
    color: ""#0000FF"",
    fontSize: 16,
    marginBottom: 20,
  },
  text: {

  }
})
</code></pre>

<p>Show.js</p>

<pre><code>import React from 'react';
import { View, Text, Image, StyleSheet, ScrollView } from 'react-native'
import { Card, ListItem, Button } from 'react-native-elements'

export default class ShowLunch extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      lunch: {},
      lunch_id: this.props.navigation.state.params.lunch_id
    };
  }
  fetchLunch() {
    let id = this.state.lunch_id
    fetch(`http://192.168.1.24:3000/api/v1/lunches/${id}`, {
      method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        }
    })
    .then((response) =&gt; {
      if (response.ok) {
        console.log(`RESPONSE OK : GET LUNCH, ID: ${id}` )
        var lunch = JSON.parse(response._bodyText);
        var headers = response.headers
        console.log(lunch.lunch)
        console.log(headers)
        this.setState({lunch: lunch.lunch})

      } else {
        alert(""Erreur pendant la réceptions du lunch voir les logs"")
        console.log(response)
      }

    })
    .catch(function(error) {
      console.log('There has been a problem with your fetch operation: ' + error.message);
      // ADD THIS THROW error
        throw error;
      })
    .done();

  }

  lunchView() {
    lunch = this.state.lunch
    console.log(""ENTER IN LUNCH VIEW"")
    console.log(lunch)
    return(
        &lt;View key=""lunch""&gt;
          &lt;Image
            style={{flex: 1, height: 150}}
            source={{ uri: lunch.photos[0].url }}
          /&gt;
          &lt;Text&gt;Titre du lunch : {lunch.title}&lt;/Text&gt;
          &lt;View&gt;
            &lt;Text&gt;id : {lunch.id}&lt;/Text&gt;
          &lt;/View&gt;
      &lt;/View&gt;
    );
  }
  // Called before render component
  componentWillMount() {
    this.fetchLunch();
  }
  render () {
    return (
      &lt;ScrollView&gt;
        &lt;Text style={styles.title} &gt;Lunch : &lt;/Text&gt;
        &lt;View&gt;
          { this.lunchView() }
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    )
  }
}

const styles = StyleSheet.create({
  title: {
    color: ""#0000FF"",
    fontSize: 16,
    marginBottom: 20,
  },
  text: {

  }
})
</code></pre>

<p>Console.log</p>

<pre><code>LOGIN SUCCESSFULL
Login.js:62 VALIDATE TOKEN SUCCESSFULL
Login.js:63 Response {type: ""default"", status: 200, ok: true, statusText: undefined, headers: Headers, …}
Login.js:65 {…}
IndexLunches.js:24 RESPONSE OK : GET LUNCHES
IndexLunches.js:27 (6) [{…}, {…}, {…}, {…}, {…}, {…}]
IndexLunches.js:28 Headers {map: {…}}
ShowLunch.js:48 ENTER IN LUNCH VIEW
ShowLunch.js:49 {}
ExceptionsManager.js:65 TypeError: Cannot read property '0' of undefined

This error is located at:
    in ShowLunch (at navigationStore.js:319)
    in Wrapped (at SceneView.js:31)
    in SceneView (at CardStack.js:412)
    in RCTView (at View.js:113)
    in View (at CardStack.js:411)
    in RCTView (at View.js:113)
    in View (at CardStack.js:410)
    in RCTView (at View.js:113)
    in View (at createAnimatedComponent.js:134)
    in AnimatedComponent (at Card.js:26)
    in Card (at PointerEventsContainer.js:55)
    in Container (at CardStack.js:454)
    in RCTView (at View.js:113)
    in View (at CardStack.js:383)
    in RCTView (at View.js:113)
    in View (at CardStack.js:382)
    in CardStack (at CardStackTransitioner.js:97)
    in RCTView (at View.js:113)
    in View (at Transitioner.js:192)
    in Transitioner (at CardStackTransitioner.js:49)
    in CardStackTransitioner (at StackNavigator.js:60)
    in Unknown (at createNavigator.js:52)
    in Navigator (at createNavigationContainer.js:210)
    in NavigationContainer (at Router.js:70)
    in App (at Router.js:91)
    in Router (at LunchRouter.js:31)
    in LunchRouter (at App.js:16)
    in RCTView (at View.js:113)
    in View (at App.js:14)
    in App (created by AwakeInDevApp)
    in RCTView (at View.js:113)
    in View (created by AwakeInDevApp)
    in AwakeInDevApp (at registerRootComponent.js:34)
    in RootErrorBoundary (at registerRootComponent.js:33)
    in ExpoRootComponent (at renderApplication.js:35)
    in RCTView (at View.js:113)
    in View (at AppContainer.js:102)
    in RCTView (at View.js:113)
    in View (at AppContainer.js:122)
    in AppContainer (at renderApplication.js:34)
handleException @ ExceptionsManager.js:65
ReactNativeFiberErrorDialog @ ReactNativeFiber-dev.js:231
logCapturedError @ ReactNativeFiber-dev.js:19
captureError @ ReactNativeFiber-dev.js:2649
performWork @ ReactNativeFiber-dev.js:2601
batchedUpdates @ ReactNativeFiber-dev.js:2756
batchedUpdates @ ReactNativeFiber-dev.js:202
batchedUpdatesWithControlledComponents @ ReactNativeFiber-dev.js:209
_receiveRootNodeIDEvent @ ReactNativeFiber-dev.js:3559
receiveTouches @ ReactNativeFiber-dev.js:3572
__callFunction @ MessageQueue.js:302
(anonymous) @ MessageQueue.js:116
__guard @ MessageQueue.js:265
callFunctionReturnFlushedQueue @ MessageQueue.js:115
(anonymous) @ debuggerWorker.js:72
ExceptionsManager.js:73 TypeError: TypeError: Cannot read property '0' of undefined

This error is located at:
    in ShowLunch (at navigationStore.js:319)
    in Wrapped (at SceneView.js:31)
    in SceneView (at CardStack.js:412)
    in RCTView (at View.js:113)
    in View (at CardStack.js:411)
    in RCTView (at View.js:113)
    in View (at CardStack.js:410)
    in RCTView (at View.js:113)
    in View (at createAnimatedComponent.js:134)
    in AnimatedComponent (at Card.js:26)
    in Card (at PointerEventsContainer.js:55)
    in Container (at CardStack.js:454)
    in RCTView (at View.js:113)
    in View (at CardStack.js:383)
    in RCTView (at View.js:113)
    in View (at CardStack.js:382)
    in CardStack (at CardStackTransitioner.js:97)
    in RCTView (at View.js:113)
    in View (at Transitioner.js:192)
    in Transitioner (at CardStackTransitioner.js:49)
    in CardStackTransitioner (at StackNavigator.js:60)
    in Unknown (at createNavigator.js:52)
    in Navigator (at createNavigationContainer.js:210)
    in NavigationContainer (at Router.js:70)
    in App (at Router.js:91)
    in Router (at LunchRouter.js:31)
    in LunchRouter (at App.js:16)
    in RCTView (at View.js:113)
    in View (at App.js:14)
    in App (created by AwakeInDevApp)
    in RCTView (at View.js:113)
    in View (created by AwakeInDevApp)
    in AwakeInDevApp (at registerRootComponent.js:34)
    in RootErrorBoundary (at registerRootComponent.js:33)
    in ExpoRootComponent (at renderApplication.js:35)
    in RCTView (at View.js:113)
    in View (at AppContainer.js:102)
    in RCTView (at View.js:113)
    in View (at AppContainer.js:122)
    in AppContainer (at renderApplication.js:34)
    at ShowLunch.lunchView (ShowLunch.js:54)
    at ShowLunch.proxiedMethod (createPrototypeProxy.js:44)
    at ShowLunch.render (ShowLunch.js:72)
    at ShowLunch.proxiedMethod (createPrototypeProxy.js:44)
    at finishClassComponent (ReactNativeFiber-dev.js:1667)
    at updateClassComponent (ReactNativeFiber-dev.js:1659)
    at beginWork (ReactNativeFiber-dev.js:1786)
    at performUnitOfWork (ReactNativeFiber-dev.js:2528)
    at workLoop (ReactNativeFiber-dev.js:2554)
    at Object._invokeGuardedCallback (ReactNativeFiber-dev.js:73)
reactConsoleErrorHandler @ ExceptionsManager.js:73
console.error @ YellowBox.js:71
componentDidCatch @ RootErrorBoundary.js:71
proxiedMethod @ createPrototypeProxy.js:44
commitErrorHandling @ ReactNativeFiber-dev.js:2675
commitAllLifeCycles @ ReactNativeFiber-dev.js:2462
_invokeGuardedCallback @ ReactNativeFiber-dev.js:73
invokeGuardedCallback @ ReactNativeFiber-dev.js:47
commitAllWork @ ReactNativeFiber-dev.js:2485
workLoop @ ReactNativeFiber-dev.js:2555
performWorkCatchBlock @ ReactNativeFiber-dev.js:2587
_invokeGuardedCallback @ ReactNativeFiber-dev.js:73
invokeGuardedCallback @ ReactNativeFiber-dev.js:47
performWork @ ReactNativeFiber-dev.js:2604
batchedUpdates @ ReactNativeFiber-dev.js:2756
batchedUpdates @ ReactNativeFiber-dev.js:202
batchedUpdatesWithControlledComponents @ ReactNativeFiber-dev.js:209
_receiveRootNodeIDEvent @ ReactNativeFiber-dev.js:3559
receiveTouches @ ReactNativeFiber-dev.js:3572
__callFunction @ MessageQueue.js:302
(anonymous) @ MessageQueue.js:116
__guard @ MessageQueue.js:265
callFunctionReturnFlushedQueue @ MessageQueue.js:115
(anonymous) @ debuggerWorker.js:72
ShowLunch.js:24 RESPONSE OK : GET LUNCH, ID: 5
ShowLunch.js:27 {id: 5, title: ""Coconut, Beef and Winter melon "", description: ""[""Propre subline nom origines sans vers."", ""Italiq…rent mille qui."", ""Pour nostalgique fin chemin.""]"", portion: 4, supply: ""Aucun"", …}
ShowLunch.js:28 Headers {map: {…}}
ExceptionsManager.js:73 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the ShowLunch component.
</code></pre>

<p>I tried several things with the bind (this) or the arrows functions but I don't understand.</p>
",""
"48428500","Data not updating in a reactJs page component","6","<p>Consider the following code:</p>

<p>App.jsx:</p>

<pre><code>import TripDay from ""./pages/TripDay"";

export default () =&gt;
&lt;Provider store={store}&gt;
    &lt;ConnectedRouter history={history}&gt;
        &lt;Switch&gt;
            &lt;Route exact path=""/me/trips/:tripUrlSlug/days/:tripDayNum"" component={TripDay}/&gt;
        &lt;/Switch&gt;
    &lt;/ConnectedRouter&gt;
&lt;/Provider&gt;
</code></pre>

<p>TripDay.jsx</p>

<pre><code>import {getTripDay} from ""../modules/TripDay/trip-day.action"";

@connect((store) =&gt; store.tripDayReducer)
export default class TripDay extends Component {
   // constructor code suppressed for this question

   componentWillMount() {
     const { tripUrlSlug, tripDayNum } = this.props.match.params;
     const {dispatch} = this.props;
     dispatch(getTripDay({tripUrlSlug, tripDayNum}));
   }

   render() {
     const {tripDay, loading, dispatch} = this.props;

     const tripDayNum = parseInt(this.props.match.params.tripDayNum);
     const tripUrlSlug = this.props.match.params.trip;

     const trip = tripDay.trip;
     const nextDayLink = (tripDayNum !== trip.days.length
                          ? `/me/trips/${tripUrlSlug}/days/${tripDayNum + 1}`
                          : null);
     const prevDayLink = (tripDayNum !== 1
                          ? `/me/trips/${tripUrlSlug}/days/${tripDayNum - 1}`
                          : null);

     return &lt;Layout&gt;
              {prevDayLink &amp;&amp;
              &lt;Link className=""btn btn-outline-secondary btn-sm pull-left"" to={prevDayLink}&gt;
                  &lt;i className=""fa fa-chevron-left mr-2"" /&gt;
                  Day: {tripDayNum - 1}
              &lt;/Link&gt;
              }

              {nextDayLink &amp;&amp;
              &lt;Link className=""btn btn-outline-secondary btn-sm pull-right"" to={nextDayLink}&gt;
                  Day: {tripDayNum + 1}
                  &lt;i className=""fa fa-chevron-right ml-2"" /&gt;
              &lt;/Link&gt;
              }

              &lt;h1 className=""h4""&gt;Day-{tripDayNum}: {tripDay.title}&lt;/h1&gt;
        &lt;/Layout&gt;;
   }
</code></pre>

<p>As you can see, it's a simple page with 2 buttons to move between days of a trip itinerary. The route is all handled fine but the ""h1"" {tripDay.title} does not get updated. What am I doing wrong?</p>

<p><strong>Update</strong>
Following the handy link pointed by Ben, I tried handling these lifecycle events:</p>

<pre><code>componentDidMount() {
    const tripUrlSlug = this.props.match.params.trip;
  const tripDayNum = this.props.match.params.tripDayNum;
  const {dispatch} = this.props;
  dispatch(getTripDay({tripUrlSlug, tripDayNum}));
}

componentDidUpdate (prevProps) {
    let prevTripDayNum = prevProps.match.params.tripDayNum;
    let newTripDayNum = this.props.match.params.tripDayNum;

    console.log(prevTripDayNum, newTripDayNum);

    if (newTripDayNum !== prevTripDayNum) {
        const {dispatch} = this.props;
        dispatch(getTripDay({tripUrlSlug, tripDayNum}));
    }
}
</code></pre>

<p>I'm seeing that the <code>componentDidUpdate</code> is not being hit at all when moving to a different day in the itinerary i.e., with different parameters between the same route.</p>
","That's because the component isn't unmounting and remounting - you're rendering the same component with different parameters and react-router's pretty clever with this kind of thing. You need to use `componentWillReceiveProps` and update it there - here's a good link to [react-router's Component Lifecycle methods](https://github.com/ReactTraining/react-router/blob/c865bc6b331eabd853641dcc7e0224a7dce76f3b/docs/guides/ComponentLifecycle.md)"
"48477051","How to handle serial mutations with react apollo","2","<p>I have a small question about how to properly handle mutations in Apollo for React. </p>

<p><strong>Situation</strong></p>

<p>I want to set a state of the component after a successful mutation — but before setting the state I want to perform other mutation (using <code>@client</code>). Mutations return promises so my first attempt was to <strong>chain promises</strong>, but then I realize that the remote mutation could take a long time and a user could go to another page and when the promise resolves my component will be <strong>unmounted</strong> already.</p>

<p>At the moment I consider 2 approaches to solve the issue:</p>

<ol>
<li><p>To use <strong>EventEmitter</strong> and emit an event on mutation finish. Subscribe at <code>componentDidMount</code> and unsubscribe on <code>componentWillUnmount</code>.</p></li>
<li><p>To use <strong>cancelable promises</strong> - this recommended ( <a href=""https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html"" rel=""nofollow noreferrer"">https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html</a> ) in React docs, but it is not a standard and looks a bit ""hackish"", especially on promise chains.</p></li>
</ol>

<p>But I feel that there should be a <strong>better way</strong>, thanks in advance and have a nice day.</p>
","It's a little unclear what you're trying to do. If the user navigates away and the component unmounts, even using the 2 solutions above will not affect the component's state when it's mounted again -- it's state will be reset to whatever the initial state is set up to be. It sounds like you should be lifting the state up to a component that won't be affected by user navigation, or using something like redux to manage app state."
"48477051","How to handle serial mutations with react apollo","2","<p>I have a small question about how to properly handle mutations in Apollo for React. </p>

<p><strong>Situation</strong></p>

<p>I want to set a state of the component after a successful mutation — but before setting the state I want to perform other mutation (using <code>@client</code>). Mutations return promises so my first attempt was to <strong>chain promises</strong>, but then I realize that the remote mutation could take a long time and a user could go to another page and when the promise resolves my component will be <strong>unmounted</strong> already.</p>

<p>At the moment I consider 2 approaches to solve the issue:</p>

<ol>
<li><p>To use <strong>EventEmitter</strong> and emit an event on mutation finish. Subscribe at <code>componentDidMount</code> and unsubscribe on <code>componentWillUnmount</code>.</p></li>
<li><p>To use <strong>cancelable promises</strong> - this recommended ( <a href=""https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html"" rel=""nofollow noreferrer"">https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html</a> ) in React docs, but it is not a standard and looks a bit ""hackish"", especially on promise chains.</p></li>
</ol>

<p>But I feel that there should be a <strong>better way</strong>, thanks in advance and have a nice day.</p>
","The idea is to handle the case when a component is already unmounted when the mutation is resolved."
"48513892","React components unmount and remount when dispatching redux action in lifecycle methods","2","<p>This occurs with React + Redux Saga application my team is working on</p>

<p>We buy the React Isomorphic theme from Themeforest which bundles the Redux, Saga, and React Router V.4. We are now working on top of it.</p>

<p>I have been using React for a while but new to Redux and never experienced with such behavior. The problem is that whenever I dispatch an action, the component unmounts and remounts as the state changes</p>

<p>Okay, what I am doing is to fetch some user data from the API but. So this is how I come up with the following action &amp; reducer</p>

<pre><code>// Actions.js

const UserActions = {
    FETCH_USER_REQUEST: 'FETCH_USER_REQUEST',
    FETCH_USER_SUCCESS: 'FETCH_USER_SUCCESS',
    fetch_users: () =&gt; {
        return {
            type: UserActions.FETCH_USER_REQUEST
        }
    }
}

export default UserActions;
</code></pre>

<p>And the reducer</p>

<pre><code>// Reducer.js
export default function UserReducer(state = initialState, action) {
    switch (action.type) {
        case 'REQUEST_USER_SUCCESS':
            return state.set('user_list', action.user_list);
        default:
            return state;
    }
}
</code></pre>

<p>With Redux Saga, the middleware is created to handle async actions. This is how it looks</p>

<pre><code>// Saga.js
import { all, takeEvery, call, put, fork } from 'redux-saga/effects';
import {get, post} from 'axios';

export function fetchUser() {
    return get('https://mockapi.testapp.dev/users')
    .then(response =&gt; {
         return response.data;
    }).catch(error =&gt; {
         return error.data
    });
}

export function* fetchUserRequest() {
    yield takeEvery('FETCH_USER_REQUEST', function*() {
        const resp = yield call(fetchUser);
        yield put({
            action: 'FETCH_USER_SUCCESS',
            user_list: resp
        });
    });
}

export default function* rootSaga() {
   yield all([
      fork(fetchUserRequest)
   ]);
}
</code></pre>

<p>Now I implement the code in my component like this</p>

<pre><code>// App.js
import React, {Component} from 'react';
import {connect} from 'react-redux';
import UserActions from './actions/UserAction';

const mapStateToProps = (state, ownProps) =&gt; {
    return {
        userList: state.User.get('user_list')
    }
}

const mapDispatchToProps = dispatch =&gt; {
    return {
        fetchUser: () =&gt; dispatch(UserActions.fetch_users())
    }
}

class App extends Component {
    componentDidMount() {
        this.props.fetchUser();
    }

    render() {
        // ... The rest of the rendering processes
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(App);
</code></pre>

<p>Now that you can see, with the behavior mentioned prior to this. Dispatching an action via this.props.fetchUser() cause the state to change but what I don't expect is that the component shouldn't unmount and remount because once it does so, an infinite loop occurs because the componentDidMount runs over and over and state also changes accordingly.</p>

<p>What I expect is to fetch the data from the API once the component mounts without remounting itself once the state changes for any reason because the theme we purchased is equipped with other base components which make use of Redux-saga to handle state and async actions. For example, the collapsable sidebar triggers a dispatch which changes the state that controls its bahavior once the users click on the it. Currently, once it does that my current component immediately unmounts unexpectedly.</p>

<p>Is there any possible way to solve such a problem or this is the default behavior of Redux?</p>
","I meet this problem with in my React Native project"
"48513892","React components unmount and remount when dispatching redux action in lifecycle methods","2","<p>This occurs with React + Redux Saga application my team is working on</p>

<p>We buy the React Isomorphic theme from Themeforest which bundles the Redux, Saga, and React Router V.4. We are now working on top of it.</p>

<p>I have been using React for a while but new to Redux and never experienced with such behavior. The problem is that whenever I dispatch an action, the component unmounts and remounts as the state changes</p>

<p>Okay, what I am doing is to fetch some user data from the API but. So this is how I come up with the following action &amp; reducer</p>

<pre><code>// Actions.js

const UserActions = {
    FETCH_USER_REQUEST: 'FETCH_USER_REQUEST',
    FETCH_USER_SUCCESS: 'FETCH_USER_SUCCESS',
    fetch_users: () =&gt; {
        return {
            type: UserActions.FETCH_USER_REQUEST
        }
    }
}

export default UserActions;
</code></pre>

<p>And the reducer</p>

<pre><code>// Reducer.js
export default function UserReducer(state = initialState, action) {
    switch (action.type) {
        case 'REQUEST_USER_SUCCESS':
            return state.set('user_list', action.user_list);
        default:
            return state;
    }
}
</code></pre>

<p>With Redux Saga, the middleware is created to handle async actions. This is how it looks</p>

<pre><code>// Saga.js
import { all, takeEvery, call, put, fork } from 'redux-saga/effects';
import {get, post} from 'axios';

export function fetchUser() {
    return get('https://mockapi.testapp.dev/users')
    .then(response =&gt; {
         return response.data;
    }).catch(error =&gt; {
         return error.data
    });
}

export function* fetchUserRequest() {
    yield takeEvery('FETCH_USER_REQUEST', function*() {
        const resp = yield call(fetchUser);
        yield put({
            action: 'FETCH_USER_SUCCESS',
            user_list: resp
        });
    });
}

export default function* rootSaga() {
   yield all([
      fork(fetchUserRequest)
   ]);
}
</code></pre>

<p>Now I implement the code in my component like this</p>

<pre><code>// App.js
import React, {Component} from 'react';
import {connect} from 'react-redux';
import UserActions from './actions/UserAction';

const mapStateToProps = (state, ownProps) =&gt; {
    return {
        userList: state.User.get('user_list')
    }
}

const mapDispatchToProps = dispatch =&gt; {
    return {
        fetchUser: () =&gt; dispatch(UserActions.fetch_users())
    }
}

class App extends Component {
    componentDidMount() {
        this.props.fetchUser();
    }

    render() {
        // ... The rest of the rendering processes
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(App);
</code></pre>

<p>Now that you can see, with the behavior mentioned prior to this. Dispatching an action via this.props.fetchUser() cause the state to change but what I don't expect is that the component shouldn't unmount and remount because once it does so, an infinite loop occurs because the componentDidMount runs over and over and state also changes accordingly.</p>

<p>What I expect is to fetch the data from the API once the component mounts without remounting itself once the state changes for any reason because the theme we purchased is equipped with other base components which make use of Redux-saga to handle state and async actions. For example, the collapsable sidebar triggers a dispatch which changes the state that controls its bahavior once the users click on the it. Currently, once it does that my current component immediately unmounts unexpectedly.</p>

<p>Is there any possible way to solve such a problem or this is the default behavior of Redux?</p>
","Have you tried using `componentWillMount` instead of `componentDidMount`. Also the component would remount if when rendering the `<App>` component you added a key that is dynamic such as `<App key={newestUser}`. Remounting could also occur if the parent component of `App` only sometimes renders App. If the parent occasionally doesn't render anything then you could try giving giving App a static key like `<App key=""main-app"" />`

Changing routes remounts components, if you could share your route file maybe there's something there I could find."
"48519744","Why ""this.setState()"" thows a warning for unmounted component?","1","<p>I get the Warning ""Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op"" at <a href=""https://github.com/matthiaw/react-native-redux-example/blob/e4aa60997022463c881625240ce4656f6a75403f/src/Components/roles2.js"" rel=""nofollow noreferrer"">following code</a>. At <a href=""https://github.com/matthiaw/react-native-redux-example/tree/e4aa60997022463c881625240ce4656f6a75403f"" rel=""nofollow noreferrer"">GitHub</a> you can find the full working react-navigation example with firebase and Redux. I think the problem could be seen if a more skilled person than me looks at the code.</p>

<p>I not know how to compensate this warning, when i jump beck from ""roles2"" to the ""home"" navigation. Could you find the bug?</p>

<pre><code>import React, { Component } from ""react"";
import { Text, View, TouchableHighlight, TouchableOpacity, ListView, StatusBar, ScrollView, StyleSheet } from ""react-native"";
import Styles from ""./../../App.scss"";
import Firebase from ""./../Util/database"";
import Item from ""./item"";
const Uuid = require('uuid/v1');
import FontAwesome from 'react-native-vector-icons/FontAwesome';
import { NavigationActions, SafeAreaView } from ""react-navigation"";
import { connect } from ""react-redux"";

var db = Firebase.firestore();

const list = ['Loading...']

export default class Empty extends Component {

constructor(props) {
  super(props);
  this.ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2})

  this.state = {
    dataSource: this.ds.cloneWithRows(list),
  };

  this.roles = db.collection(""roles"").get();
  this.renderItem = this.renderItem.bind(this)
  this.setItemsFromFirestore = this.setItemsFromFirestore.bind(this);
}

setItemsFromFirestore(roles) {
  roles.then((querySnapshot) =&gt; {
  // get children as an array
  var items = [];
  querySnapshot.forEach((child) =&gt; {
    items.push({
      label: `${child.data().label}`,
      description: `${child.data().description}`,
      id: `${child.id}`
    });
  });

  this.setState({
    dataSource: this.ds.cloneWithRows(items),
  });
});
}

componentWillUpdate(nextProps, nextState) {
  this.roles = db.collection(""roles"").get();
  this.setItemsFromFirestore(this.roles);
}

componentDidMount() {
  this.setItemsFromFirestore(this.roles);
}

renderItem(item, navigation) {
  return (
   &lt;Item key={Uuid()} label={item.label} description={item.description} onPress={ () =&gt; {
    const param = item.param;
    const route = item.route;
    const navigateAction = NavigationActions.navigate({
      routeName: 'role',
      params: {
        label: `${item.label}`,
        description: `${item.description}`,
        id: `${item.id}`
      }
    });
    navigation.dispatch(navigateAction);
  }} /&gt;
 )
}

static navigationOptions = props =&gt; {
  const { navigation } = props;
  const { state, setParams } = navigation;
  const { params } = state;
  return {
  title: ""Rollen (Cloud)"",
  headerTintColor: Styles.ci_Header.color,
  headerStyle: {
    height: Styles.ci_Header.height,
    backgroundColor: Styles.ci_Header.backgroundColor
  },
  headerRight: (
    &lt;FontAwesome
      name= {'plus'}
      size={18}
      style={{ color: Styles.ci_Header.color, paddingHorizontal: 5}}
      onPress={() =&gt; {
        const id = `${Uuid()}`;
        var data = {
          id: {id},
          label: `Neue Rolle (${id.substring(0,6)}...)`,
          description: ''
        };
        var setDoc = db.collection('roles').doc(id).set(data);
      }}
    /&gt;
  )
 };
};

render() {
 return (
  &lt;View style={{ flex: 1 }}&gt;
    &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={item =&gt; this.renderItem(item, this.props.navigation)} /&gt;
    &lt;StatusBar barStyle=""light-content"" /&gt;
  &lt;/View&gt;
  );
 }
}
</code></pre>

<p>I am new to react-native with navigation and did not get what i did wrong.</p>

<p>Could you find the bug?</p>
","You might find this useful https://stackoverflow.com/questions/39767482/is-there-a-way-to-check-if-the-react-component-is-unmounted/39767963#39767963"
"48623313","ReactDOM.unmountComponentAtNode() in Test causes Warning","0","<p>I built my application wir create-react-app. In the recent version of it, it adds one line in the bootstrapped test setup in Jest to unmount the component (see <code>ReactDOM.unmountComponentAtNode(div)</code>).</p>

<pre><code>import ReactDOM from 'react-dom';
import App from './App';

it('renders without crashing', () =&gt; {
  const div = document.createElement('div');
  ReactDOM.render(&lt;App /&gt;, div);
  ReactDOM.unmountComponentAtNode(div);
});
</code></pre>

<p>It causes a warning when I run the test for my App component.</p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.</strong></p>

<p>My guess: It happens because I have an asynchronous request in <code>componentDidMount()</code>:</p>

<pre><code>fetchFoo(bar) {
  fetch(SOME_URL)
    .then(response =&gt; response.json())
    .then(result =&gt; this.setState({ result }))
    .catch(error =&gt; this.setState({ error }));
}
</code></pre>

<p>If this is the case, how do I wait in the test for the asynchronous request to finally unmount the component again? I know that I could remove the one liner in the Jest test which causes this, but rather I would like to fix it. </p>

<ul>
<li><a href=""https://github.com/the-road-to-learn-react/the-road-to-learn-react/issues/101"" rel=""noreferrer"">Here you can find the issue</a>.</li>
</ul>
",""
"48755214","How to handle sporadic component unmount error with ReactJS/Preact?","1","<p>I'm building a ReactJS SPA with Preact for learning purposes. Every once in a while, a component from a library I use (<a href=""https://github.com/ryanseddon/react-frame-component"" rel=""nofollow noreferrer""><code>react-frame-component</code></a>) will throw an exception when being unmounted, which breaks other parts of the application. This is a fairly sporadic error, and as such I've not been able to create a test-case that reproduces it.</p>

<p>I do know about <a href=""https://reactjs.org/docs/error-boundaries.html"" rel=""nofollow noreferrer"">error boundaries</a>, and did try wrapping the problematic <code>&lt;Frame&gt;</code> component in one, but it hasn't made a difference. Specifically, the error message I get is</p>

<pre><code>Uncaught (in promise) TypeError: Cannot read property 'body' of null
    at Frame.getMountTarget (Frame.js:112)
    at Frame.componentWillUnmount (Frame.js:95)
    at unmountComponent (preact.js:355)
    at unmountComponent (preact.js:358)
    at recollectNodeTree (preact.js:198)
    at removeChildren (preact.js:208)
    at recollectNodeTree (preact.js:201)
    at removeChildren (preact.js:208)
    at recollectNodeTree (preact.js:201)
    at removeChildren (preact.js:208)
</code></pre>

<p>I'm unsure how to go about capturing this error myself, or even just debugging it correctly. Any help would be appreciated. </p>
","provide code examples with all files"
"48851613","How to call a component on a click event in react?","2","<p>I have a simple react application. I want to call a component on a click event. Now what happens is when I click that function, it gets called but that component doesn't change. I tried the checking the path and all everything seems fine as when I put the same component in render it gets executed. Here's my code:</p>

<p>Please let me know what am I doing wrong.</p>

<p>Please ignore some of the wrong if else condition, I have put them trying to bug to no avail.</p>

<p>header.jsx</p>

<pre><code>   class Head extends React.Component {
  handleClick = (e) =&gt; {
    console.log(e.key);
    &lt;Cont key1 = e.key /&gt;
  }


  render(){
      return( 
      &lt;Header&gt;
        &lt;div className=""logo"" /&gt;
        &lt;Menu
        onClick={ this.handleClick }&gt;
        &lt;Menu.Item key=""1""&gt;Hungry Rides&lt;/Menu.Item&gt;
        &lt;Menu.Item key=""2""&gt;Hiker's Diary&lt;/Menu.Item&gt;
        &lt;Menu.Item key=""3""&gt;Hiking @ Hometown &lt;/Menu.Item&gt;
      &lt;/Menu&gt;
    &lt;/Header&gt;
    )
  }
}
</code></pre>

<p>content.jsx</p>

<pre><code>    class Cont extends React.Component {

  constructor(props) {
    super(props);
    thisDefault = this.props.key1
    console.log('inside constructor')
    // alert(this.props.key1)
    if ( thisDefault != 100){
        alert('miracle')
    thisDefault = 1
  }


componentWillMount() {
    console.log('component mounted')
}

componentWillUnmount() {
    console.log('unmounted')
}

componentWillReceiveProps() {
    console.log('ghfdshg')
}



  render(){
    console.log('called from key')
    let data = null
     if(thisDefault == null) {
     data = (
      &lt;div id = ""journal"" style={{ background: '#fff', padding: 24 , textAlign : 'center'}}&gt;
       &lt;Intro /&gt;
      &lt;/div&gt;
      )
  }
  else{
  data = (  &lt;div id = ""journal"" style={{ background: '#fff', padding: 24 , textAlign : 'center'}}&gt;
       &lt;h1&gt; Hello &lt;/h1&gt;
      &lt;/div&gt;
      )
  }
    return( 
        &lt;Content style={{ padding: '0 50px' }}&gt;
        &lt;Bread /&gt;
        &lt;Slider /&gt;
    {data}
    &lt;/Content&gt;

    )}}

    export default Cont
</code></pre>
","where u want to render `Cont `?"
"48851613","How to call a component on a click event in react?","2","<p>I have a simple react application. I want to call a component on a click event. Now what happens is when I click that function, it gets called but that component doesn't change. I tried the checking the path and all everything seems fine as when I put the same component in render it gets executed. Here's my code:</p>

<p>Please let me know what am I doing wrong.</p>

<p>Please ignore some of the wrong if else condition, I have put them trying to bug to no avail.</p>

<p>header.jsx</p>

<pre><code>   class Head extends React.Component {
  handleClick = (e) =&gt; {
    console.log(e.key);
    &lt;Cont key1 = e.key /&gt;
  }


  render(){
      return( 
      &lt;Header&gt;
        &lt;div className=""logo"" /&gt;
        &lt;Menu
        onClick={ this.handleClick }&gt;
        &lt;Menu.Item key=""1""&gt;Hungry Rides&lt;/Menu.Item&gt;
        &lt;Menu.Item key=""2""&gt;Hiker's Diary&lt;/Menu.Item&gt;
        &lt;Menu.Item key=""3""&gt;Hiking @ Hometown &lt;/Menu.Item&gt;
      &lt;/Menu&gt;
    &lt;/Header&gt;
    )
  }
}
</code></pre>

<p>content.jsx</p>

<pre><code>    class Cont extends React.Component {

  constructor(props) {
    super(props);
    thisDefault = this.props.key1
    console.log('inside constructor')
    // alert(this.props.key1)
    if ( thisDefault != 100){
        alert('miracle')
    thisDefault = 1
  }


componentWillMount() {
    console.log('component mounted')
}

componentWillUnmount() {
    console.log('unmounted')
}

componentWillReceiveProps() {
    console.log('ghfdshg')
}



  render(){
    console.log('called from key')
    let data = null
     if(thisDefault == null) {
     data = (
      &lt;div id = ""journal"" style={{ background: '#fff', padding: 24 , textAlign : 'center'}}&gt;
       &lt;Intro /&gt;
      &lt;/div&gt;
      )
  }
  else{
  data = (  &lt;div id = ""journal"" style={{ background: '#fff', padding: 24 , textAlign : 'center'}}&gt;
       &lt;h1&gt; Hello &lt;/h1&gt;
      &lt;/div&gt;
      )
  }
    return( 
        &lt;Content style={{ padding: '0 50px' }}&gt;
        &lt;Bread /&gt;
        &lt;Slider /&gt;
    {data}
    &lt;/Content&gt;

    )}}

    export default Cont
</code></pre>
","You can call a component on a click event using [tag:react-redux] also. Else  [Talgat Saribayev](https://stackoverflow.com/users/5817056/talgat-saribayev) answer is correct. If you need any further assistance on [tag:react-redux] let me know."
"48906259","How to forcefully unmount a component in react native?","4","<p>I'm using <a href=""https://reactnavigation.org/"" rel=""nofollow noreferrer""><strong><code>reactnavigation</code></strong></a> stackNavigtor as the root structure.</p>

<p>When my app loads, it initially mounts a component based on intialRouteName - which is good so far. However, when I open my slideMenu and navigate to another screen, the component that I was just in, is not unmounted and still renders at the back, even though I have successfully navigated.</p>

<p>Ofcourse I can use the <code>this.state({})</code> in my initial component to stop the render, but the issue is, I can't setup it in such a way that when I navigate to another screen, I'd prevent the render of the previous screen.</p>

<h1>AppNavigation.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/*
 * LaunchScreen loads first
 * I then navigate to Profile via (this.props.navigate('OpenDrawer')).
 *  - This opens CustomComponent and inside that, I select Profile
 * When I navigate to Profile, The LaunchScreen is not unmounted
*/
export const SignedIn = StackNavigator({
  LaunchScreen: {
    screen: $LaunchScreen
  },
  Profile: {
    screen: $Profile
  },
  EditProfile: {
    screen: EditProfile
  },
  MyDoctors: {
    screen: $Doctors
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: 'LaunchScreen' // this is the component that loads
});

export const HomeNav = StackNavigator({
  Home: {
    screen: SignedIn,
    navigationOptions: {
      gesturesEnabled: false
    }
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Home"", // we enter this route when the app loads.
});

const PrimaryNav = StackNavigator({
  SignedIn: {
    screen: HomeNav,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  SignedOut: {
    screen: SignedOut,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  Loading: {
    screen: Loading
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Loading"",
});

export default PrimaryNav;</code></pre>
</div>
</div>
</p>

<h1>LaunchScreen.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// ... Imports {}


export default class LaunchScreen extends PureComponent&lt;*, State&gt; {
  constructor(props) {
    super(props);
    this.state = {
      index: 0,
    };
  }

  componentDidMount() {
  };

_renderScene = ({ route }) =&gt; {
    return (
      &lt;SimplePage
        state           = {this.state}
        style           = {{ backgroundColor: 'white' }}
        type            = {this.state.type}
        updateIndex     = {this.updateIndex.bind(this)}

      /&gt;
    );
  };
  
  _renderHeader = props =&gt; {
  /*
   * ""this.props.navigation.navigate('DrawerOpen')"" opens the drawer from left side
   *
  */
    return (
      &lt;View&gt;
        &lt;View style={styles.headerContainer}&gt;
          &lt;TouchableHighlight onPress={() =&gt; this.props.navigation.navigate('DrawerOpen')} activeOpacity={1.0} underlayColor=""rgba(253,138,94,0)""&gt;
          &lt;/TouchableHighlight&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  };


  render() {
    return (
        &lt;TabViewAnimated
        style={[styles.container, this.props.style]}
        navigationState={this.state}
        renderScene={this._renderScene}
        renderHeader={this._renderHeader}
      /&gt;
    );
  }
}</code></pre>
</div>
</div>
</p>

<h1>What is the main question?</h1>

<p>I would like to know how I can unmount a component when I navigate to another screen.</p>
","In a stack navigation we keep pushing pages/views to the stack and those won't unmount until we move to another stack. So you can't unmount this way."
"48906259","How to forcefully unmount a component in react native?","4","<p>I'm using <a href=""https://reactnavigation.org/"" rel=""nofollow noreferrer""><strong><code>reactnavigation</code></strong></a> stackNavigtor as the root structure.</p>

<p>When my app loads, it initially mounts a component based on intialRouteName - which is good so far. However, when I open my slideMenu and navigate to another screen, the component that I was just in, is not unmounted and still renders at the back, even though I have successfully navigated.</p>

<p>Ofcourse I can use the <code>this.state({})</code> in my initial component to stop the render, but the issue is, I can't setup it in such a way that when I navigate to another screen, I'd prevent the render of the previous screen.</p>

<h1>AppNavigation.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/*
 * LaunchScreen loads first
 * I then navigate to Profile via (this.props.navigate('OpenDrawer')).
 *  - This opens CustomComponent and inside that, I select Profile
 * When I navigate to Profile, The LaunchScreen is not unmounted
*/
export const SignedIn = StackNavigator({
  LaunchScreen: {
    screen: $LaunchScreen
  },
  Profile: {
    screen: $Profile
  },
  EditProfile: {
    screen: EditProfile
  },
  MyDoctors: {
    screen: $Doctors
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: 'LaunchScreen' // this is the component that loads
});

export const HomeNav = StackNavigator({
  Home: {
    screen: SignedIn,
    navigationOptions: {
      gesturesEnabled: false
    }
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Home"", // we enter this route when the app loads.
});

const PrimaryNav = StackNavigator({
  SignedIn: {
    screen: HomeNav,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  SignedOut: {
    screen: SignedOut,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  Loading: {
    screen: Loading
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Loading"",
});

export default PrimaryNav;</code></pre>
</div>
</div>
</p>

<h1>LaunchScreen.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// ... Imports {}


export default class LaunchScreen extends PureComponent&lt;*, State&gt; {
  constructor(props) {
    super(props);
    this.state = {
      index: 0,
    };
  }

  componentDidMount() {
  };

_renderScene = ({ route }) =&gt; {
    return (
      &lt;SimplePage
        state           = {this.state}
        style           = {{ backgroundColor: 'white' }}
        type            = {this.state.type}
        updateIndex     = {this.updateIndex.bind(this)}

      /&gt;
    );
  };
  
  _renderHeader = props =&gt; {
  /*
   * ""this.props.navigation.navigate('DrawerOpen')"" opens the drawer from left side
   *
  */
    return (
      &lt;View&gt;
        &lt;View style={styles.headerContainer}&gt;
          &lt;TouchableHighlight onPress={() =&gt; this.props.navigation.navigate('DrawerOpen')} activeOpacity={1.0} underlayColor=""rgba(253,138,94,0)""&gt;
          &lt;/TouchableHighlight&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  };


  render() {
    return (
        &lt;TabViewAnimated
        style={[styles.container, this.props.style]}
        navigationState={this.state}
        renderScene={this._renderScene}
        renderHeader={this._renderHeader}
      /&gt;
    );
  }
}</code></pre>
</div>
</div>
</p>

<h1>What is the main question?</h1>

<p>I would like to know how I can unmount a component when I navigate to another screen.</p>
","Ah, I see, in that case, how can we create two different stacks? and link them? @Pavan"
"48906259","How to forcefully unmount a component in react native?","4","<p>I'm using <a href=""https://reactnavigation.org/"" rel=""nofollow noreferrer""><strong><code>reactnavigation</code></strong></a> stackNavigtor as the root structure.</p>

<p>When my app loads, it initially mounts a component based on intialRouteName - which is good so far. However, when I open my slideMenu and navigate to another screen, the component that I was just in, is not unmounted and still renders at the back, even though I have successfully navigated.</p>

<p>Ofcourse I can use the <code>this.state({})</code> in my initial component to stop the render, but the issue is, I can't setup it in such a way that when I navigate to another screen, I'd prevent the render of the previous screen.</p>

<h1>AppNavigation.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/*
 * LaunchScreen loads first
 * I then navigate to Profile via (this.props.navigate('OpenDrawer')).
 *  - This opens CustomComponent and inside that, I select Profile
 * When I navigate to Profile, The LaunchScreen is not unmounted
*/
export const SignedIn = StackNavigator({
  LaunchScreen: {
    screen: $LaunchScreen
  },
  Profile: {
    screen: $Profile
  },
  EditProfile: {
    screen: EditProfile
  },
  MyDoctors: {
    screen: $Doctors
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: 'LaunchScreen' // this is the component that loads
});

export const HomeNav = StackNavigator({
  Home: {
    screen: SignedIn,
    navigationOptions: {
      gesturesEnabled: false
    }
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Home"", // we enter this route when the app loads.
});

const PrimaryNav = StackNavigator({
  SignedIn: {
    screen: HomeNav,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  SignedOut: {
    screen: SignedOut,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  Loading: {
    screen: Loading
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Loading"",
});

export default PrimaryNav;</code></pre>
</div>
</div>
</p>

<h1>LaunchScreen.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// ... Imports {}


export default class LaunchScreen extends PureComponent&lt;*, State&gt; {
  constructor(props) {
    super(props);
    this.state = {
      index: 0,
    };
  }

  componentDidMount() {
  };

_renderScene = ({ route }) =&gt; {
    return (
      &lt;SimplePage
        state           = {this.state}
        style           = {{ backgroundColor: 'white' }}
        type            = {this.state.type}
        updateIndex     = {this.updateIndex.bind(this)}

      /&gt;
    );
  };
  
  _renderHeader = props =&gt; {
  /*
   * ""this.props.navigation.navigate('DrawerOpen')"" opens the drawer from left side
   *
  */
    return (
      &lt;View&gt;
        &lt;View style={styles.headerContainer}&gt;
          &lt;TouchableHighlight onPress={() =&gt; this.props.navigation.navigate('DrawerOpen')} activeOpacity={1.0} underlayColor=""rgba(253,138,94,0)""&gt;
          &lt;/TouchableHighlight&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  };


  render() {
    return (
        &lt;TabViewAnimated
        style={[styles.container, this.props.style]}
        navigationState={this.state}
        renderScene={this._renderScene}
        renderHeader={this._renderHeader}
      /&gt;
    );
  }
}</code></pre>
</div>
</div>
</p>

<h1>What is the main question?</h1>

<p>I would like to know how I can unmount a component when I navigate to another screen.</p>
","Your stack would contain the previous screen and it won't be unmounted. But why do you wanna unmount though?"
"48906259","How to forcefully unmount a component in react native?","4","<p>I'm using <a href=""https://reactnavigation.org/"" rel=""nofollow noreferrer""><strong><code>reactnavigation</code></strong></a> stackNavigtor as the root structure.</p>

<p>When my app loads, it initially mounts a component based on intialRouteName - which is good so far. However, when I open my slideMenu and navigate to another screen, the component that I was just in, is not unmounted and still renders at the back, even though I have successfully navigated.</p>

<p>Ofcourse I can use the <code>this.state({})</code> in my initial component to stop the render, but the issue is, I can't setup it in such a way that when I navigate to another screen, I'd prevent the render of the previous screen.</p>

<h1>AppNavigation.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/*
 * LaunchScreen loads first
 * I then navigate to Profile via (this.props.navigate('OpenDrawer')).
 *  - This opens CustomComponent and inside that, I select Profile
 * When I navigate to Profile, The LaunchScreen is not unmounted
*/
export const SignedIn = StackNavigator({
  LaunchScreen: {
    screen: $LaunchScreen
  },
  Profile: {
    screen: $Profile
  },
  EditProfile: {
    screen: EditProfile
  },
  MyDoctors: {
    screen: $Doctors
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: 'LaunchScreen' // this is the component that loads
});

export const HomeNav = StackNavigator({
  Home: {
    screen: SignedIn,
    navigationOptions: {
      gesturesEnabled: false
    }
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Home"", // we enter this route when the app loads.
});

const PrimaryNav = StackNavigator({
  SignedIn: {
    screen: HomeNav,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  SignedOut: {
    screen: SignedOut,
    navigationOptions: {
      gesturesEnabled: false
    }
  },
  Loading: {
    screen: Loading
  }
}, {
  headerMode: ""none"",
  mode: ""modal"",
  initialRouteName: ""Loading"",
});

export default PrimaryNav;</code></pre>
</div>
</div>
</p>

<h1>LaunchScreen.js</h1>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// ... Imports {}


export default class LaunchScreen extends PureComponent&lt;*, State&gt; {
  constructor(props) {
    super(props);
    this.state = {
      index: 0,
    };
  }

  componentDidMount() {
  };

_renderScene = ({ route }) =&gt; {
    return (
      &lt;SimplePage
        state           = {this.state}
        style           = {{ backgroundColor: 'white' }}
        type            = {this.state.type}
        updateIndex     = {this.updateIndex.bind(this)}

      /&gt;
    );
  };
  
  _renderHeader = props =&gt; {
  /*
   * ""this.props.navigation.navigate('DrawerOpen')"" opens the drawer from left side
   *
  */
    return (
      &lt;View&gt;
        &lt;View style={styles.headerContainer}&gt;
          &lt;TouchableHighlight onPress={() =&gt; this.props.navigation.navigate('DrawerOpen')} activeOpacity={1.0} underlayColor=""rgba(253,138,94,0)""&gt;
          &lt;/TouchableHighlight&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  };


  render() {
    return (
        &lt;TabViewAnimated
        style={[styles.container, this.props.style]}
        navigationState={this.state}
        renderScene={this._renderScene}
        renderHeader={this._renderHeader}
      /&gt;
    );
  }
}</code></pre>
</div>
</div>
</p>

<h1>What is the main question?</h1>

<p>I would like to know how I can unmount a component when I navigate to another screen.</p>
","Because the initial component is rendering heavy content, and when I navigate to different screen, the rendered content from previous screen still exists and affects the performance heavily @Pavan"
"48925340","How to prevent refreshing the filtered items on one tab while switching to another tab in react application?","2","<p>I have five different tabs, each with a filter where I am filtering data on the basis of parameters. Now</p>

<ol>
<li>Let's say I am on tab 1 and I filtered the content on the basis of parameters.</li>
<li>Now when I change to tab 2, the filtered data on tab 1 should not be changed and remain same (for comparison purposes). So basically the filtered state should remain same while switching tabs.</li>
</ol>

<p>I have used no filter module or library for this. How do I implement this in my react application?</p>
","If you keep the data in each Tab component, each time you change the Tab it will get unmounted and a new one is mounted and hence filtering is not persisted. You need to lift the state up to their parent. Check this answer https://stackoverflow.com/questions/46594900/reactjs-lifting-state-up-vs-keeping-a-local-state/47349693#47349693 and https://stackoverflow.com/questions/38394015/how-to-pass-data-from-child-component-to-its-parent-in-reactjs/38397755#38397755"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","Tried that, same error..."
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","Could you try to just replace `componentDidMount` with `componentWillMount` ? I did this just this morning because i had the same erros and it fix the error"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","Erf ... Could you try to do put your state in a constructor ? like that `constructor(props){
        super(props);
        this.state = {
            introLoaded: false,
        }
    }``"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","try this this.setState((state) => { introLoaded: true }); . with componentDidMount"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","@ShahzadMirza , added the Slider component"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","As the error suggesting *The Onboarding component is inside the Slider* please also add Slider component in your question."
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","@javed , tried that as well"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","please explain what are you trying to achieve from Slider component? as it is a stateless component and also why are you using async await for updating the state of HomeScreen?"
"49009217","React Native: setState + unmounted or mounting component","9","<p>I am trying to conditionally display either a Home or Slider component in the screen below, but when the onDone function runs, i am getting the error: </p>

<p><strong>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.
Please check the code for the Onboarding component.</strong></p>

<p>The Onboarding component is inside the Slider (react-native-onboarding-swiper - used for app intro)...</p>

<pre><code>export default class HomeScreen extends Component {
  static navigationOptions = {
    headerStyle: {
      backgroundColor: 'skyblue',
      elevation: 0,
      borderBottomWidth: 0,
    },
    headerLeft: null,
  };

  state = {
    introLoaded: false,
  };

  async componentDidMount() {
    const value = await AsyncStorage.getItem('@SKIP_INTRO');
    if (value !== null) {
      this.onDone();
    }
  };

  onDone = async () =&gt; {
    await this.setState({ introLoaded: true });
  };

  render() {
    return this.state.introLoaded ? (
      &lt;Home navigation={this.props.navigation} /&gt;
    ) : (
      &lt;Slider onDone={this.onDone} /&gt;
    );
  }
}
</code></pre>

<p>Any help appreciated...</p>

<p>Slider.js</p>

<pre><code>import React from 'react';
import { Image, Text } from 'react-native';
import PropTypes from 'prop-types';
import Onboarding from 'react-native-onboarding-swiper';
import styles from './styles';

const Slider = ({ onDone }) =&gt; (
  &lt;Onboarding
    pages={[
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic1.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 1&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 1&lt;/Text&gt;,
      },
      {
        backgroundColor: 'skyblue',
        image: (
          &lt;Image source={require('../../assets/images/intro/pic2.png')} style={styles.image} /&gt;
        ),
        title: &lt;Text style={styles.title}&gt;Title 2&lt;/Text&gt;,
        subtitle: &lt;Text style={styles.subtitle}&gt;Subtitle 2&lt;/Text&gt;,
      },
    ]}
    onDone={onDone}
  /&gt;
);

Slider.propTypes = {
  onDone: PropTypes.func.isRequired,
};

export default Slider;
</code></pre>
","@ShahzadMirza , the Slider component is an app intro screen with different slides inside it, if the user clicks the Done button at the last slide they should then see the Home screen (where they will be able to login / signup). So the Slider should appear once only on first loading of the app. On the async/await part in setState - i though setState was asynchronous, so I wrote it that way."
"49019431","Checking if user signed in before react native","0","<p>In my react native app I save the user information securely on the key chain, so that after they have logged in once, I save the information and then the next time the user comes, the information is already there and so the user won't need to log in.</p>

<p>The issue is that I do the check in componentDidMount, and then if the user has never logged in before or logged out in their last visit I redirect them to the loginScreen like so:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>componentDidMount() {
    //Need to check if they've signed in before by checking the USER_INFO.
    SecureStore.getItemAsync(""USER_INFO"").then(response =&gt; {
        //Have they signed in before?
        if (response !== undefined) {
          //yes.
          //continue with app stuff.
        }
        else {
          //Not logged in before need to go to login.
          const resetAction = NavigationActions.reset({
            index: 0,
            actions: [
              NavigationActions.navigate({ routeName: 'Login', params: this.props.navigation.state.params }),
            ]
          });
          this.props.navigation.dispatch(resetAction);

        }
    });

}</code></pre>
</div>
</div>
</p>

<p>The problem is that I get a warning that 'Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.'. Which makes sense because I am redirecting before the screen has rendered, but then the question is, where should I perform these checks?</p>

<p>Thanks</p>
",""
"49049729","Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component","2","<p>Homepage.js</p>

<pre><code>import React, { Component } from 'react';
import { Route, Redirect, withRouter } from 'react-router-dom';

import $ from 'jquery';
import { css } from 'glamor';
import { ToastContainer } from 'react-toastify';
import toast from '../toast';
import { BarLoader } from 'react-spinners';

//  ----------------   Custom components
import Header from '../Header/Header';
import Footer from '../Footer/Footer';
import RelayAnimation from '../RelayAnimation/RelayAnimation';
import UserLoginForm from '../UserLoginForm/UserLoginForm';
import UserSignUpForm from '../UserSignUpForm/UserSignUpForm';
import PassResetReqForm from '../PassResetReqForm/PassResetReqForm';
import PassResetForm from '../PassResetForm/PassResetForm';

import './HomePage.css';

// ---------   Message for Network Error
const Msg = () =&gt; (
  &lt;div&gt;
    Error please, try again later &lt;br /&gt; or reload the Page.
  &lt;/div&gt;
);

class HomePage extends Component {

  constructor(props) {
    super(props);
    this.state = {
      loading: false
    };

    this.toggleLoader = this.toggleLoader.bind(this);
    this.notifySuccess = this.notifySuccess.bind(this);
    this.notifyError = this.notifyError.bind(this);
  }

  notifySuccess(msg) {
    toast.success(msg);
  }

  notifyError(msg) {
    toast.error(msg);
  }

  // ---------   Toast Notifications ---------------
  // notify = (status) =&gt; {
  //   // ---------   Server Issue Toaster
  //   if (status === 'Bad Gateway') {
  //     toast.error(&lt;Msg /&gt;, {
  //       className: {
  //         color: '#fff',
  //         minHeight: '60px',
  //         borderRadius: '8px',
  //         boxShadow: '2px 2px 20px 2px rgba(0,0,0,0.3)'
  //       }

  //     });
  //   }
  // }

  toggleLoader() {
    this.setState({
      loading: !this.state.loading
    });
  }

  isAuthenticated() {
    const token = localStorage.getItem('authToken');
    if (token) {
      return true;
    }
  }

  componentDidMount() {
    const currentLocationPath = this.props.location.pathname;
    const urlForEmailVerification =         currentLocationPath.includes('/api/v1/verifyEmailUser/');
if (urlForEmailVerification) {
  const { token } = this.props.match.params; // token value from url params passed by &lt;Route/&gt;

  if (token) {
    const url = `/api/v1/verifyEmailUser/${token}`;

    // api call to make the user's account verified in db based on token in url
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'GET',
      success: function (res) {
        console.log(res);
        this.notifySuccess('emailVerified');
        this.props.history.push('/');
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  }
 }
}

  render() {
const currentLocationPath = this.props.location.pathname;
const isAuthenticated = this.isAuthenticated();
const resetPasswordPathname = currentLocationPath.includes('/api/v1/resetPassword/');

if (!isAuthenticated) {
  return (
    &lt;div className=""App d-flex flex-column""&gt;
      {/* Navbar with brand logo and language change dropdown and signup/login button */}
      &lt; Header /&gt;

      {/* Main Section with RelayStream Animation graphic and forms */}
      &lt;div className=""container py-4 py-md-0 pt-lg-4 d-flex flex-grow"" &gt;
        &lt;div className={'LoginScreen d-flex align-items-center align-items-lg-start ' +
          ((currentLocationPath === '/login' ||
            currentLocationPath === '/signup' ||
            currentLocationPath === '/forgot-password' ||
            resetPasswordPathname) ? 'justify-content-around' : 'justify-content-center')}&gt;

          {/* RelayStream Animation graphic */}
          &lt;RelayAnimation /&gt;

          {/* forms to switch between based on path change by &lt;Router/&gt; */}
          &lt;Route path=""/login"" component={(props) =&gt; &lt;UserLoginForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;
          &lt;Route path=""/signup"" component={(props) =&gt; &lt;UserSignUpForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;
          &lt;Route path=""/forgot-password"" component={(props) =&gt; &lt;PassResetReqForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;
          &lt;Route path=""/api/v1/resetPassword/:token"" component={(props) =&gt; &lt;PassResetForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;

        &lt;/div&gt;
      &lt;/div &gt;

      {/* Footer with copyright message */}
      &lt;Footer /&gt;

      &lt;div className={this.state.loading ? 'loader flex-column' : 'd-none'}&gt;
        &lt;span className=""loader__title""&gt;Loading...&lt;/span&gt;
        &lt;BarLoader color={'#36D7B7'} loading={this.state.loading} /&gt;
      &lt;/div&gt;

      {/* React toastify for toast notification */}
      &lt;ToastContainer className={{ textAlign: 'center' }} progressClassName={css({ background: '#007aff' })} /&gt;
    &lt;/div &gt;
  );
} else {
  return &lt;Redirect to={'/dashboard'} /&gt;;
 }
}
}

export default withRouter(HomePage);
</code></pre>

<p>UserLoginForm.js</p>

<pre><code>import React, { Component } from 'react';
import { Link, Redirect } from 'react-router-dom';

import $ from 'jquery';
import { Animated } from 'react-animated-css';
import SocialButton from '../SocialButton/SocialButton';
//  ----------------   Form components
import Form from 'react-validation/build/form';
import Button from 'react-validation/build/button';

//  ----------------   Custom Form components &amp; validations
import { Email, Password, required, noSpace, minChar8, email } from '../formValidation';

import FontAwesomeIcon from '@fortawesome/react-fontawesome';
import facebook from '@fortawesome/fontawesome-free-brands/faFacebookF';
import google from '@fortawesome/fontawesome-free-brands/faGooglePlusG';
import './UserLoginForm.css';

class UserLoginForm extends Component {
  constructor(props) {
    super(props);
    this.state = {
      fireRedirect: false
    };

    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSocialLogin = (user) =&gt; {
    const provider = user._provider;
    const name = user._profile.name;
    const email = user._profile.email;
    const profilePic = user._profile.profilePicURL;

    const token = user._token.accessToken;
    const data = { provider, name, email, profilePic, token };

    console.log(data);
    const url = '/api/v1/loginWithFacekbook'; // social login's api url

    // api call for social logins
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: data,
      success: function (res) {
        console.log('success response after api call ===&gt;&gt;', res);

        const generatingAuthToken = res.object.generatingAuthToken;
        const apikey = generatingAuthToken.apiKey;
        const authToken = generatingAuthToken.authToken;

        localStorage.setItem('apiKey', apikey);
        localStorage.setItem('authToken', authToken);

        // if social login was successful then redirect user to dashboard
        this.setState({ fireRedirect: true });
      }.bind(this),
      error: function (xhr, status, err) {
        console.log(status);
        // if there was network issue notify user to try again later or refresh page
        this.props.notifyError(err.toString());
        console.error(url, status, err.toString());
      }.bind(this)
    });

  }

  handleSocialLoginFailure = (err) =&gt; {
    console.error(err)
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.value;
    const name = target.name;

    // input field animation code - adds class to current focused input field's parent
    if (value) {
      target.parentElement.classList.add('input--filled');
    } else {
      target.parentElement.classList.remove('input--filled');
    }

    this.setState({
      [name]: value
    });
  }

  handleSubmit(event) {
    event.preventDefault();

    // show loading spinner
    this.props.toggleLoader();

    // get data from all field in form
    const data = this.form.getValues();

    const url = '/api/v1/loginUser'; // user login api url

    // api call to generate token and apikey and login user to dashboard
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: data,
      success: function (res) {
        console.log('success response after api call ===&gt;&gt;', res);

        const obj = res.object;
        const loginStatus = res.status;
        const msg = res.message;

        // check if authToken and apiKey was received
        if (obj) {
          // if data is found in database check if credentials provided were correct
          if (loginStatus) {
            JSON.stringify(obj);
            // save apiKey and token in loacalStorage
            for (let key in obj) {
              if (obj.hasOwnProperty(key)) {
                let val = obj[key];
                localStorage.setItem(key, val);
              }
            }

            // turn off loader spinner
            this.props.toggleLoader();

            this.setState({ fireRedirect: true });

            // if credentials were correct accept login then redirect user to dashboard
          } else { // if credentials were wrong 
            // turn off loader spinner
            // this.props.toggleLoader();
            // then notify about wrong credentials
            this.props.notifyError(msg);
          }
        } else { // if data was not found in database notify user to signup first
          this.props.notifyError(msg);
          // turn off loader spinner
          // this.props.toggleLoader();
        }
      }.bind(this),
      error: function (xhr, status, err) {
        console.log(status);
        // if there was network issue notify user to try again later or refresh page
        this.props.notify(err.toString());
        console.error(url, status, err.toString());
      }.bind(this)
    });
  }

  render() {
    const { fireRedirect } = this.state;

    return (
      &lt;Animated className=""form-animation"" animationIn=""fadeInRight"" animationOut=""fadeOutLeft"" isVisible={true}&gt;
        &lt;Form className=""userLoginForm"" ref={c =&gt; { this.form = c }} onSubmit={this.handleSubmit} noValidate&gt;
          &lt;h2 className=""formTitle text-center""&gt;LOG IN&lt;/h2&gt;

          &lt;Email
            required
            pattern=""[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,3}$""
            id=""email""
            name=""email""
            type=""email""
            className=""input__field input__field--madoka""
            onChange={this.handleInputChange}
            validations={[required, email]} /&gt;

          {/* must wrap Password Field Component with ""div.form-group"" */}
          &lt;div className=""form-group""&gt;
            &lt;Password
              required
              id=""password""
              name=""password""
              type=""password""
              minLength=""8""
              className=""input__field input__field--madoka""
              onChange={this.handleInputChange}
              validations={[noSpace, required, minChar8]} /&gt;

            {/* Optional Link Component below... 
          Note: If there is no requirement of Link or any Other Element just below &lt;Password/&gt; input field 
          in entire project then the wrapping ""div.form-group"" can also be put inside 
          Password Component's Template Located in formValidation.js file*/}
            &lt;Link to=""/forgot-password"" className=""float-right forgotPassword""&gt;
              &lt;small&gt;Forgot password ?&lt;/small&gt;
            &lt;/Link&gt;
          &lt;/div&gt;

          &lt;div className=""form-group submitGroup text-center""&gt;
            &lt;Button type=""submit"" className=""btn btn--submit btn-rounded btn-outline-primary mx-auto""&gt;LOG IN&lt;/Button&gt;
          &lt;/div&gt;

          {/* login buttons for facebook and google login */}
          &lt;div className=""socialLogin mx-auto""&gt;
            {/* &lt;a href=""#"" className=""socialBtn socialBtn--facebook rounded-circle""&gt;
              &lt;FontAwesomeIcon icon={facebook} /&gt;
            &lt;/a&gt; */}
            &lt;SocialButton
              className=""socialBtn socialBtn--facebook rounded-circle""
              provider='facebook' appId='873380466175223'
              onLoginSuccess={this.handleSocialLogin}
              onLoginFailure={this.handleSocialLoginFailure}
              redirect=""/dashboard""&gt;

              &lt;FontAwesomeIcon icon={facebook} /&gt;
            &lt;/SocialButton&gt;

            &lt;span className=""seperator"" /&gt;

            &lt;SocialButton
              className=""socialBtn socialBtn--googlePlus rounded-circle""
              provider=""google""
              appId=""843586925977-d7j31p5j0me5kqvcp29nr9s37reg5b5u.apps.googleusercontent.com""
              onLoginSuccess={this.handleSocialLogin}
              onLoginFailure={this.handleSocialLoginFailure}&gt;

              &lt;FontAwesomeIcon icon={google} /&gt;
            &lt;/SocialButton&gt;

            {/* &lt;a href=""#"" className=""socialBtn socialBtn--googlePlus rounded-circle""&gt;
              &lt;FontAwesomeIcon icon={google} /&gt;
            &lt;/a&gt; */}
          &lt;/div&gt;

          {/* code to redirect user to dashboard page after successful login */}
          {fireRedirect &amp;&amp; (&lt;Redirect to={'/dashboard'} /&gt;)}
        &lt;/Form&gt;
      &lt;/Animated&gt;
    );
  }
}

export default UserLoginForm;
</code></pre>

<p>UserSignUpForm.js</p>

<pre><code>import React, { Component } from 'react';
import { Redirect } from 'react-router-dom';
import $ from 'jquery';
import { Animated } from 'react-animated-css';

//  ----------------   Form components
import Form from 'react-validation/build/form';
import Button from 'react-validation/build/button';

//  ----------------   Custom Form components &amp; validations
import { UserName, Email, NewPassword, ConfirmPassword, noSpace, required, minChar8, email, confirmPassword } from '../formValidation';

import './UserSignUp.css';

class UserSignUpForm extends Component {
  constructor(props) {
    super(props);
    this.state = {
      userName: '',
      email: '',
      password: '',
      confirmPassword: '',
      fireRedirect: false
    };

    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.value;
    const name = target.name;

    // input field animation code - adds class to current focused input field's parent
    if (value) {
      target.parentElement.classList.add('input--filled');
    } else {
      target.parentElement.classList.remove('input--filled');
    }

    this.setState({
      [name]: value
    });
  }

  handleSubmit(event) {
    event.preventDefault();
    const data = this.form.getValues();

    console.log(data);
    // api call to sign up user
    $.ajax({
      url: '/api/v1/user',
      dataType: 'json',
      type: 'POST',
      data: data,
      success: function (res) {
        console.log('success response after api call ===&gt;&gt;', res);

        const signUpStatus = res.status;
        const msg = res.message;

        if (signUpStatus) {
          // if signup was successful notify user
          this.props.notifySuccess(msg);
          // redirect user to login form
          this.setState({ fireRedirect: true });
        } else {
          this.props.notifyError(msg); // notify user on signup fail
        }
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  }

  render() {
    const { fireRedirect } = this.state;

    return (
      &lt;Animated className=""form-animation"" animationIn=""fadeInRight"" animationOut=""fadeOutLeft"" isVisible={true}&gt;

        &lt;Form className=""userSignUpForm"" ref={c =&gt; { this.form = c }} onSubmit={this.handleSubmit}&gt;
          &lt;h2 className=""formTitle text-center""&gt;SIGN UP&lt;/h2&gt;

          &lt;UserName
            required
            id=""userName""
            name=""userName""
            ref={c =&gt; { this.UserName = c }}
            value={this.state.userName}
            type=""text""
            className=""input__field input__field--madoka""
            validations={[required]}
            onChange={this.handleInputChange} /&gt;

          &lt;Email
            required
            pattern=""[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,3}$""
            id=""email""
            name=""email""
            ref={c =&gt; { this.Email = c }}
            value={this.state.email}
            type=""email""
            className=""input__field input__field--madoka""
            validations={[required, email]}
            onChange={this.handleInputChange} /&gt;

          &lt;div className=""form-group""&gt;
            &lt;NewPassword
              required
              id=""password""
              name=""password""
              ref={c =&gt; { this.NewPassword = c }}
              value={this.state.password}
              type=""password""
              minLength=""8""
              className=""input__field input__field--madoka""
              onChange={this.handleInputChange}
              validations={[noSpace, required, minChar8]} /&gt;
          &lt;/div&gt;

          &lt;div className=""form-group""&gt;
            &lt;ConfirmPassword
              required
              id=""confirmPassword""
              name=""confirmPassword""
              ref={c =&gt; { this.ConfirmPassword = c }}
              value={this.state.confirmPassword}
              type=""password""
              minLength=""8""
              className=""input__field input__field--madoka""
              onChange={this.handleInputChange}
              validations={[noSpace, required, confirmPassword]} /&gt;
          &lt;/div&gt;

          &lt;div className=""form-group submitGroup text-center""&gt;
            &lt;Button type=""submit"" className=""btn btn--submit btn-rounded btn-outline-primary mx-auto""&gt;SIGN UP&lt;/Button&gt;
          &lt;/div&gt;
          {/* code to redirect user to dashboard page after successful login */}
          {fireRedirect &amp;&amp; (&lt;Redirect to={'/login'} /&gt;)}
        &lt;/Form&gt;
      &lt;/Animated&gt;
    );
  }
}

export default UserSignUpForm;
</code></pre>

<p>i am facing many issues. first i have a spinner in homepage.js which shows as overlay on whole page when this.state.loading = true, initially it is set to False in constructor.</p>

<p>Issues 1.) when we submit the login form (if signup was done already ) the loader shows for fraction of second on screen but "" this.setState({ fireRedirect: true }); "" this code is supposed to redirect user to dashboard which it does but gives error in console :</p>

<pre><code>index.js:2178 Warning: Cannot update during an existing state transition (such as within `render` or another component's constructor). Render methods should be a pure function of props and state; constructor side-effects are an anti-pattern, but can be moved to `componentWillMount`.

index.js:2178 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the UserLoginForm component.
</code></pre>

<p>Issue 2.) If i create a new user from UserSignUpForm which redirects us to UserLoginForm. now if i try to login i get only this error:</p>

<pre><code>index.js:2178 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the UserLoginForm component.
</code></pre>

<p>Issue 3.) If i remove or comment ""this.toggleLoader();"" from the ajax's success functions right before "" this.setState({ fireRedirect: true }); "" this line. then the loader shows on screen but doesn't go away even page doesn't redirect and console gives this error:</p>

<pre><code>index.js:2178 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the UserLoginForm component.
</code></pre>
","i tried "" this.props.history.push('/dashboard') "" , it takes me too dashboard but i still get the error : ""Warning: Cannot update during an existing state transition (such as within `render` or another component's constructor). Render methods should be a pure function of props and state; constructor side-effects are an anti-pattern, but can be moved to `componentWillMount`."""
"49049729","Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component","2","<p>Homepage.js</p>

<pre><code>import React, { Component } from 'react';
import { Route, Redirect, withRouter } from 'react-router-dom';

import $ from 'jquery';
import { css } from 'glamor';
import { ToastContainer } from 'react-toastify';
import toast from '../toast';
import { BarLoader } from 'react-spinners';

//  ----------------   Custom components
import Header from '../Header/Header';
import Footer from '../Footer/Footer';
import RelayAnimation from '../RelayAnimation/RelayAnimation';
import UserLoginForm from '../UserLoginForm/UserLoginForm';
import UserSignUpForm from '../UserSignUpForm/UserSignUpForm';
import PassResetReqForm from '../PassResetReqForm/PassResetReqForm';
import PassResetForm from '../PassResetForm/PassResetForm';

import './HomePage.css';

// ---------   Message for Network Error
const Msg = () =&gt; (
  &lt;div&gt;
    Error please, try again later &lt;br /&gt; or reload the Page.
  &lt;/div&gt;
);

class HomePage extends Component {

  constructor(props) {
    super(props);
    this.state = {
      loading: false
    };

    this.toggleLoader = this.toggleLoader.bind(this);
    this.notifySuccess = this.notifySuccess.bind(this);
    this.notifyError = this.notifyError.bind(this);
  }

  notifySuccess(msg) {
    toast.success(msg);
  }

  notifyError(msg) {
    toast.error(msg);
  }

  // ---------   Toast Notifications ---------------
  // notify = (status) =&gt; {
  //   // ---------   Server Issue Toaster
  //   if (status === 'Bad Gateway') {
  //     toast.error(&lt;Msg /&gt;, {
  //       className: {
  //         color: '#fff',
  //         minHeight: '60px',
  //         borderRadius: '8px',
  //         boxShadow: '2px 2px 20px 2px rgba(0,0,0,0.3)'
  //       }

  //     });
  //   }
  // }

  toggleLoader() {
    this.setState({
      loading: !this.state.loading
    });
  }

  isAuthenticated() {
    const token = localStorage.getItem('authToken');
    if (token) {
      return true;
    }
  }

  componentDidMount() {
    const currentLocationPath = this.props.location.pathname;
    const urlForEmailVerification =         currentLocationPath.includes('/api/v1/verifyEmailUser/');
if (urlForEmailVerification) {
  const { token } = this.props.match.params; // token value from url params passed by &lt;Route/&gt;

  if (token) {
    const url = `/api/v1/verifyEmailUser/${token}`;

    // api call to make the user's account verified in db based on token in url
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'GET',
      success: function (res) {
        console.log(res);
        this.notifySuccess('emailVerified');
        this.props.history.push('/');
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(url, status, err.toString());
      }.bind(this)
    });
  }
 }
}

  render() {
const currentLocationPath = this.props.location.pathname;
const isAuthenticated = this.isAuthenticated();
const resetPasswordPathname = currentLocationPath.includes('/api/v1/resetPassword/');

if (!isAuthenticated) {
  return (
    &lt;div className=""App d-flex flex-column""&gt;
      {/* Navbar with brand logo and language change dropdown and signup/login button */}
      &lt; Header /&gt;

      {/* Main Section with RelayStream Animation graphic and forms */}
      &lt;div className=""container py-4 py-md-0 pt-lg-4 d-flex flex-grow"" &gt;
        &lt;div className={'LoginScreen d-flex align-items-center align-items-lg-start ' +
          ((currentLocationPath === '/login' ||
            currentLocationPath === '/signup' ||
            currentLocationPath === '/forgot-password' ||
            resetPasswordPathname) ? 'justify-content-around' : 'justify-content-center')}&gt;

          {/* RelayStream Animation graphic */}
          &lt;RelayAnimation /&gt;

          {/* forms to switch between based on path change by &lt;Router/&gt; */}
          &lt;Route path=""/login"" component={(props) =&gt; &lt;UserLoginForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;
          &lt;Route path=""/signup"" component={(props) =&gt; &lt;UserSignUpForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;
          &lt;Route path=""/forgot-password"" component={(props) =&gt; &lt;PassResetReqForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;
          &lt;Route path=""/api/v1/resetPassword/:token"" component={(props) =&gt; &lt;PassResetForm {...props} notifySuccess={this.notifySuccess} notifyError={this.notifyError} toggleLoader={this.toggleLoader} /&gt;} /&gt;

        &lt;/div&gt;
      &lt;/div &gt;

      {/* Footer with copyright message */}
      &lt;Footer /&gt;

      &lt;div className={this.state.loading ? 'loader flex-column' : 'd-none'}&gt;
        &lt;span className=""loader__title""&gt;Loading...&lt;/span&gt;
        &lt;BarLoader color={'#36D7B7'} loading={this.state.loading} /&gt;
      &lt;/div&gt;

      {/* React toastify for toast notification */}
      &lt;ToastContainer className={{ textAlign: 'center' }} progressClassName={css({ background: '#007aff' })} /&gt;
    &lt;/div &gt;
  );
} else {
  return &lt;Redirect to={'/dashboard'} /&gt;;
 }
}
}

export default withRouter(HomePage);
</code></pre>

<p>UserLoginForm.js</p>

<pre><code>import React, { Component } from 'react';
import { Link, Redirect } from 'react-router-dom';

import $ from 'jquery';
import { Animated } from 'react-animated-css';
import SocialButton from '../SocialButton/SocialButton';
//  ----------------   Form components
import Form from 'react-validation/build/form';
import Button from 'react-validation/build/button';

//  ----------------   Custom Form components &amp; validations
import { Email, Password, required, noSpace, minChar8, email } from '../formValidation';

import FontAwesomeIcon from '@fortawesome/react-fontawesome';
import facebook from '@fortawesome/fontawesome-free-brands/faFacebookF';
import google from '@fortawesome/fontawesome-free-brands/faGooglePlusG';
import './UserLoginForm.css';

class UserLoginForm extends Component {
  constructor(props) {
    super(props);
    this.state = {
      fireRedirect: false
    };

    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSocialLogin = (user) =&gt; {
    const provider = user._provider;
    const name = user._profile.name;
    const email = user._profile.email;
    const profilePic = user._profile.profilePicURL;

    const token = user._token.accessToken;
    const data = { provider, name, email, profilePic, token };

    console.log(data);
    const url = '/api/v1/loginWithFacekbook'; // social login's api url

    // api call for social logins
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: data,
      success: function (res) {
        console.log('success response after api call ===&gt;&gt;', res);

        const generatingAuthToken = res.object.generatingAuthToken;
        const apikey = generatingAuthToken.apiKey;
        const authToken = generatingAuthToken.authToken;

        localStorage.setItem('apiKey', apikey);
        localStorage.setItem('authToken', authToken);

        // if social login was successful then redirect user to dashboard
        this.setState({ fireRedirect: true });
      }.bind(this),
      error: function (xhr, status, err) {
        console.log(status);
        // if there was network issue notify user to try again later or refresh page
        this.props.notifyError(err.toString());
        console.error(url, status, err.toString());
      }.bind(this)
    });

  }

  handleSocialLoginFailure = (err) =&gt; {
    console.error(err)
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.value;
    const name = target.name;

    // input field animation code - adds class to current focused input field's parent
    if (value) {
      target.parentElement.classList.add('input--filled');
    } else {
      target.parentElement.classList.remove('input--filled');
    }

    this.setState({
      [name]: value
    });
  }

  handleSubmit(event) {
    event.preventDefault();

    // show loading spinner
    this.props.toggleLoader();

    // get data from all field in form
    const data = this.form.getValues();

    const url = '/api/v1/loginUser'; // user login api url

    // api call to generate token and apikey and login user to dashboard
    $.ajax({
      url: url,
      dataType: 'json',
      type: 'POST',
      data: data,
      success: function (res) {
        console.log('success response after api call ===&gt;&gt;', res);

        const obj = res.object;
        const loginStatus = res.status;
        const msg = res.message;

        // check if authToken and apiKey was received
        if (obj) {
          // if data is found in database check if credentials provided were correct
          if (loginStatus) {
            JSON.stringify(obj);
            // save apiKey and token in loacalStorage
            for (let key in obj) {
              if (obj.hasOwnProperty(key)) {
                let val = obj[key];
                localStorage.setItem(key, val);
              }
            }

            // turn off loader spinner
            this.props.toggleLoader();

            this.setState({ fireRedirect: true });

            // if credentials were correct accept login then redirect user to dashboard
          } else { // if credentials were wrong 
            // turn off loader spinner
            // this.props.toggleLoader();
            // then notify about wrong credentials
            this.props.notifyError(msg);
          }
        } else { // if data was not found in database notify user to signup first
          this.props.notifyError(msg);
          // turn off loader spinner
          // this.props.toggleLoader();
        }
      }.bind(this),
      error: function (xhr, status, err) {
        console.log(status);
        // if there was network issue notify user to try again later or refresh page
        this.props.notify(err.toString());
        console.error(url, status, err.toString());
      }.bind(this)
    });
  }

  render() {
    const { fireRedirect } = this.state;

    return (
      &lt;Animated className=""form-animation"" animationIn=""fadeInRight"" animationOut=""fadeOutLeft"" isVisible={true}&gt;
        &lt;Form className=""userLoginForm"" ref={c =&gt; { this.form = c }} onSubmit={this.handleSubmit} noValidate&gt;
          &lt;h2 className=""formTitle text-center""&gt;LOG IN&lt;/h2&gt;

          &lt;Email
            required
            pattern=""[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,3}$""
            id=""email""
            name=""email""
            type=""email""
            className=""input__field input__field--madoka""
            onChange={this.handleInputChange}
            validations={[required, email]} /&gt;

          {/* must wrap Password Field Component with ""div.form-group"" */}
          &lt;div className=""form-group""&gt;
            &lt;Password
              required
              id=""password""
              name=""password""
              type=""password""
              minLength=""8""
              className=""input__field input__field--madoka""
              onChange={this.handleInputChange}
              validations={[noSpace, required, minChar8]} /&gt;

            {/* Optional Link Component below... 
          Note: If there is no requirement of Link or any Other Element just below &lt;Password/&gt; input field 
          in entire project then the wrapping ""div.form-group"" can also be put inside 
          Password Component's Template Located in formValidation.js file*/}
            &lt;Link to=""/forgot-password"" className=""float-right forgotPassword""&gt;
              &lt;small&gt;Forgot password ?&lt;/small&gt;
            &lt;/Link&gt;
          &lt;/div&gt;

          &lt;div className=""form-group submitGroup text-center""&gt;
            &lt;Button type=""submit"" className=""btn btn--submit btn-rounded btn-outline-primary mx-auto""&gt;LOG IN&lt;/Button&gt;
          &lt;/div&gt;

          {/* login buttons for facebook and google login */}
          &lt;div className=""socialLogin mx-auto""&gt;
            {/* &lt;a href=""#"" className=""socialBtn socialBtn--facebook rounded-circle""&gt;
              &lt;FontAwesomeIcon icon={facebook} /&gt;
            &lt;/a&gt; */}
            &lt;SocialButton
              className=""socialBtn socialBtn--facebook rounded-circle""
              provider='facebook' appId='873380466175223'
              onLoginSuccess={this.handleSocialLogin}
              onLoginFailure={this.handleSocialLoginFailure}
              redirect=""/dashboard""&gt;

              &lt;FontAwesomeIcon icon={facebook} /&gt;
            &lt;/SocialButton&gt;

            &lt;span className=""seperator"" /&gt;

            &lt;SocialButton
              className=""socialBtn socialBtn--googlePlus rounded-circle""
              provider=""google""
              appId=""843586925977-d7j31p5j0me5kqvcp29nr9s37reg5b5u.apps.googleusercontent.com""
              onLoginSuccess={this.handleSocialLogin}
              onLoginFailure={this.handleSocialLoginFailure}&gt;

              &lt;FontAwesomeIcon icon={google} /&gt;
            &lt;/SocialButton&gt;

            {/* &lt;a href=""#"" className=""socialBtn socialBtn--googlePlus rounded-circle""&gt;
              &lt;FontAwesomeIcon icon={google} /&gt;
            &lt;/a&gt; */}
          &lt;/div&gt;

          {/* code to redirect user to dashboard page after successful login */}
          {fireRedirect &amp;&amp; (&lt;Redirect to={'/dashboard'} /&gt;)}
        &lt;/Form&gt;
      &lt;/Animated&gt;
    );
  }
}

export default UserLoginForm;
</code></pre>

<p>UserSignUpForm.js</p>

<pre><code>import React, { Component } from 'react';
import { Redirect } from 'react-router-dom';
import $ from 'jquery';
import { Animated } from 'react-animated-css';

//  ----------------   Form components
import Form from 'react-validation/build/form';
import Button from 'react-validation/build/button';

//  ----------------   Custom Form components &amp; validations
import { UserName, Email, NewPassword, ConfirmPassword, noSpace, required, minChar8, email, confirmPassword } from '../formValidation';

import './UserSignUp.css';

class UserSignUpForm extends Component {
  constructor(props) {
    super(props);
    this.state = {
      userName: '',
      email: '',
      password: '',
      confirmPassword: '',
      fireRedirect: false
    };

    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.value;
    const name = target.name;

    // input field animation code - adds class to current focused input field's parent
    if (value) {
      target.parentElement.classList.add('input--filled');
    } else {
      target.parentElement.classList.remove('input--filled');
    }

    this.setState({
      [name]: value
    });
  }

  handleSubmit(event) {
    event.preventDefault();
    const data = this.form.getValues();

    console.log(data);
    // api call to sign up user
    $.ajax({
      url: '/api/v1/user',
      dataType: 'json',
      type: 'POST',
      data: data,
      success: function (res) {
        console.log('success response after api call ===&gt;&gt;', res);

        const signUpStatus = res.status;
        const msg = res.message;

        if (signUpStatus) {
          // if signup was successful notify user
          this.props.notifySuccess(msg);
          // redirect user to login form
          this.setState({ fireRedirect: true });
        } else {
          this.props.notifyError(msg); // notify user on signup fail
        }
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  }

  render() {
    const { fireRedirect } = this.state;

    return (
      &lt;Animated className=""form-animation"" animationIn=""fadeInRight"" animationOut=""fadeOutLeft"" isVisible={true}&gt;

        &lt;Form className=""userSignUpForm"" ref={c =&gt; { this.form = c }} onSubmit={this.handleSubmit}&gt;
          &lt;h2 className=""formTitle text-center""&gt;SIGN UP&lt;/h2&gt;

          &lt;UserName
            required
            id=""userName""
            name=""userName""
            ref={c =&gt; { this.UserName = c }}
            value={this.state.userName}
            type=""text""
            className=""input__field input__field--madoka""
            validations={[required]}
            onChange={this.handleInputChange} /&gt;

          &lt;Email
            required
            pattern=""[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,3}$""
            id=""email""
            name=""email""
            ref={c =&gt; { this.Email = c }}
            value={this.state.email}
            type=""email""
            className=""input__field input__field--madoka""
            validations={[required, email]}
            onChange={this.handleInputChange} /&gt;

          &lt;div className=""form-group""&gt;
            &lt;NewPassword
              required
              id=""password""
              name=""password""
              ref={c =&gt; { this.NewPassword = c }}
              value={this.state.password}
              type=""password""
              minLength=""8""
              className=""input__field input__field--madoka""
              onChange={this.handleInputChange}
              validations={[noSpace, required, minChar8]} /&gt;
          &lt;/div&gt;

          &lt;div className=""form-group""&gt;
            &lt;ConfirmPassword
              required
              id=""confirmPassword""
              name=""confirmPassword""
              ref={c =&gt; { this.ConfirmPassword = c }}
              value={this.state.confirmPassword}
              type=""password""
              minLength=""8""
              className=""input__field input__field--madoka""
              onChange={this.handleInputChange}
              validations={[noSpace, required, confirmPassword]} /&gt;
          &lt;/div&gt;

          &lt;div className=""form-group submitGroup text-center""&gt;
            &lt;Button type=""submit"" className=""btn btn--submit btn-rounded btn-outline-primary mx-auto""&gt;SIGN UP&lt;/Button&gt;
          &lt;/div&gt;
          {/* code to redirect user to dashboard page after successful login */}
          {fireRedirect &amp;&amp; (&lt;Redirect to={'/login'} /&gt;)}
        &lt;/Form&gt;
      &lt;/Animated&gt;
    );
  }
}

export default UserSignUpForm;
</code></pre>

<p>i am facing many issues. first i have a spinner in homepage.js which shows as overlay on whole page when this.state.loading = true, initially it is set to False in constructor.</p>

<p>Issues 1.) when we submit the login form (if signup was done already ) the loader shows for fraction of second on screen but "" this.setState({ fireRedirect: true }); "" this code is supposed to redirect user to dashboard which it does but gives error in console :</p>

<pre><code>index.js:2178 Warning: Cannot update during an existing state transition (such as within `render` or another component's constructor). Render methods should be a pure function of props and state; constructor side-effects are an anti-pattern, but can be moved to `componentWillMount`.

index.js:2178 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the UserLoginForm component.
</code></pre>

<p>Issue 2.) If i create a new user from UserSignUpForm which redirects us to UserLoginForm. now if i try to login i get only this error:</p>

<pre><code>index.js:2178 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the UserLoginForm component.
</code></pre>

<p>Issue 3.) If i remove or comment ""this.toggleLoader();"" from the ajax's success functions right before "" this.setState({ fireRedirect: true }); "" this line. then the loader shows on screen but doesn't go away even page doesn't redirect and console gives this error:</p>

<pre><code>index.js:2178 Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

Please check the code for the UserLoginForm component.
</code></pre>
","You should change the way you do the redirection, you can use [react-router history](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md) to push/replace a route in a function instead of changing state to render the redirect component."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Sidney Unfortunately, I have tried with that and it doesn't work."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","sounds like `ConnectedReduxForm` just needs to implement [`shouldComponentUpdate`](https://reactjs.org/docs/react-component.html#shouldcomponentupdate)"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","Prehaps you need to apply the `key` to the DOM element that `ConnectedReduxForm` returns?"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@leuction If returning `false` from `shouldComponentUpdate` doesn't work, the re-render is likely being caused by a class decorator (probably Redux's `connect` decorator). You should post the source for `ConnectedReduxForm`."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Hamms I have tried with set the shouldComponentUpdate function return false, and it doesn't work. Furthermore, the ConntectedReduxForm have been unmounted, I think there is nothing to do with the update."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@SimpleJ I just tried to directly import MyReduxForm instead connect the redux. shouldComponentUpdate doesn't work. it is quite wired."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","Can you post your complete code somewhere? My feeling is that the parent component was unmounted and mounted again, but I can't be sure without trying the code myself."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","`shouldComponentUpdate` should only return false if the component shouldn't update. It seems like you want the component to update only when its schemaName changes, so your `shouldComponentUpdate` method should reflect that"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Hamms I just return false for the test. The problem is I have no way to prevent the schemaForm to re-mount. All of three schemaForm are re-mounted. the multipleForm is not."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@brickingup Hello, I have just uploaded all the code. But I think that the parent component has not been re-mounted."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","One thing I noticed is that in MultipleForm you put 'key' in SchemaForm while you should put it in Element. This may be the issue because each time MultipleForm re-renders Element will be re-mounted. So SchemaForm will also be re-mounted regardless of it's key."
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","Did you remove `this.init()` from your constructor when you tried it from the `componentDidMount` method?"
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","@SterlingArcher yes"
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","@Aaqib, yes I do."
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","Do you load data inside dataVar ?"
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","didnt bind the function"
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","Are you trying to create Global manually with `new Global(...)`? How is it called?"
"49120512","Call a function on application startup in react","7","<p>I'm trying to call a function from application startup.  The function reads data from JSON via dataVar (set elsewhere) and tries to load it into {items} for further consumption:</p>

<pre><code>const dataVar = JSONStuff;    
class Global extends Component {
        constructor(props) {
        super(props);
        this.state = {
            query: '',
            items: []
        }

        this.init();

    } 

    // componentDidMount() {
    // This doesn't work either!
    //  this.init();
    // }

    init() {
        let { items } = dataVar;
        this.setState({items});
    }


    render() {
        return (
            &lt;div className=""Global""&gt;
                    &lt;Gallery items={this.state.items}/&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>Then in Gallery.js:</p>

<pre><code>import React, { Component } from 'react';

class Gallery extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;gallery:&lt;/h3&gt;
                {
                    this.props.items.map((item, index) =&gt; {
                        let {title} = item.name;
                        return (
                            &lt;div key={index}&gt;{title}&lt;/div&gt;
                        )
                    })
                }
            &lt;/div&gt;
        )
    }
}
</code></pre>

<p>export default Gallery;</p>

<p>Not sure why Global can't call a function inside of itself.  I've tried with and without ""this.""  I either get error to where the app won't complile or I get:</p>

<pre><code>""Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op.""
</code></pre>
","Joel I edited the question to answer your question.  @Omar, I tried that too, but would you mind giving me an example of specifically what you mean?"
"49335127","react-native with healthkit api","2","<p>enter image description hereI got the problem with an npm package that is rn-apple-healthkit.
And my problem is as a below
<a href=""https://github.com/terrillo/rn-apple-healthkit/issues/16"" rel=""nofollow noreferrer"">https://github.com/terrillo/rn-apple-healthkit/issues/16</a></p>

<h2>I have imported AppleHealthkit, however Eslint still alert me AppleHealthkit is not defined in ""<strong><em>AppleHealthkit.initStepCountObserver({}, () => {});</em></strong>""</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import {
  ScrollView,
  Navigator,
  View,
  NativeAppEventEmitter,
} from 'react-native';
import axios from 'axios';
import AppleHealthKit from 'rn-apple-healthkit';

import AlbumDetail from './AlbumDetail';

// Healthkit API part
const d = new Date();

const PERMS = AppleHealthKit.Constants.Permissions;

const HKOPTIONS = {
  permissions: {
    read: [
        PERMS.StepCount,
        PERMS.Height,
        PERMS.Weight,
        PERMS.DateOfBirth,
        PERMS.BodyMassIndex,
    ],
    write: [
        PERMS.StepCount,
        PERMS.Weight,
        PERMS.BodyMassIndex,
    ],
  },
  date: d.toISOString()
};

AppleHealthKit.initHealthKit(HKOPTIONS, (err, res) =&gt; {
  if (err) {
    console.log('HealthkitInitError: ', err);
    return;
  }
  console.log('HealthkitInitSucess');

  AppleHealthkit.initStepCountObserver({}, () =&gt; {});

  this.sub = NativeAppEventEmitter.addListener(
    'change:steps',
    (event) =&gt; {
    //'change:steps' event has been received. step
    //count data should be re-fetched from Healthkit.
      this._fetchStepCountData();
      console.log(event);
    }
  );
  this._fetchStepCountData();
  this._fetchOtherRelevantHealthkitData();
});

// StepCounter Example
AppleHealthKit.getStepCount(HKOPTIONS, (error, results) =&gt; {
  if (error) {
    console.log('getStepCountError: ', error);
    return;
  }
  console.log(results);
});

// React-Native part
class albumList extends Component {
  state = { albums: [] };
  
  componentWillMount() {
    axios.get('https://rallycoding.herokuapp.com/api/music_albums')
      .then(response =&gt; this.setState({ albums: response.data }))
      .then(response =&gt; console.log(response));
  }

  componentDidMount() {
    console.log(this.state.albums);
  }

// when the component where the listener was added unmounts, call the 'remove' method of the subscription object.
  componentWillUnmount() {
    this.sub.remove();
  };

  renderAlbums() {
    return this.state.albums.map(album =&gt; 
      &lt;AlbumDetail key={album.title} data={album} /&gt;
    );
  }
  render() {
    return (
      &lt;ScrollView&gt; 
        {this.renderAlbums()}
      &lt;/ScrollView&gt;
    );
  }
}

export default albumList;</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><a href=""https://i.stack.imgur.com/SXZzD.jpg"" rel=""nofollow noreferrer"">enter image description here</a></p>
","`AppleHealthkit.initStepCountObserver({}, () => {});` should be `AppleHealthKit.initStepCountObserver({}, () => {});` with capital `K`"
"49335127","react-native with healthkit api","2","<p>enter image description hereI got the problem with an npm package that is rn-apple-healthkit.
And my problem is as a below
<a href=""https://github.com/terrillo/rn-apple-healthkit/issues/16"" rel=""nofollow noreferrer"">https://github.com/terrillo/rn-apple-healthkit/issues/16</a></p>

<h2>I have imported AppleHealthkit, however Eslint still alert me AppleHealthkit is not defined in ""<strong><em>AppleHealthkit.initStepCountObserver({}, () => {});</em></strong>""</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import {
  ScrollView,
  Navigator,
  View,
  NativeAppEventEmitter,
} from 'react-native';
import axios from 'axios';
import AppleHealthKit from 'rn-apple-healthkit';

import AlbumDetail from './AlbumDetail';

// Healthkit API part
const d = new Date();

const PERMS = AppleHealthKit.Constants.Permissions;

const HKOPTIONS = {
  permissions: {
    read: [
        PERMS.StepCount,
        PERMS.Height,
        PERMS.Weight,
        PERMS.DateOfBirth,
        PERMS.BodyMassIndex,
    ],
    write: [
        PERMS.StepCount,
        PERMS.Weight,
        PERMS.BodyMassIndex,
    ],
  },
  date: d.toISOString()
};

AppleHealthKit.initHealthKit(HKOPTIONS, (err, res) =&gt; {
  if (err) {
    console.log('HealthkitInitError: ', err);
    return;
  }
  console.log('HealthkitInitSucess');

  AppleHealthkit.initStepCountObserver({}, () =&gt; {});

  this.sub = NativeAppEventEmitter.addListener(
    'change:steps',
    (event) =&gt; {
    //'change:steps' event has been received. step
    //count data should be re-fetched from Healthkit.
      this._fetchStepCountData();
      console.log(event);
    }
  );
  this._fetchStepCountData();
  this._fetchOtherRelevantHealthkitData();
});

// StepCounter Example
AppleHealthKit.getStepCount(HKOPTIONS, (error, results) =&gt; {
  if (error) {
    console.log('getStepCountError: ', error);
    return;
  }
  console.log(results);
});

// React-Native part
class albumList extends Component {
  state = { albums: [] };
  
  componentWillMount() {
    axios.get('https://rallycoding.herokuapp.com/api/music_albums')
      .then(response =&gt; this.setState({ albums: response.data }))
      .then(response =&gt; console.log(response));
  }

  componentDidMount() {
    console.log(this.state.albums);
  }

// when the component where the listener was added unmounts, call the 'remove' method of the subscription object.
  componentWillUnmount() {
    this.sub.remove();
  };

  renderAlbums() {
    return this.state.albums.map(album =&gt; 
      &lt;AlbumDetail key={album.title} data={album} /&gt;
    );
  }
  render() {
    return (
      &lt;ScrollView&gt; 
        {this.renderAlbums()}
      &lt;/ScrollView&gt;
    );
  }
}

export default albumList;</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><a href=""https://i.stack.imgur.com/SXZzD.jpg"" rel=""nofollow noreferrer"">enter image description here</a></p>
","Thanks for your reply:)
I got a new problm!! 
Are you have any idea?
The mistake:
_this._fetchStepCountData is not a function"
"49582622","Reactjs: how to write a method to handle component creation and unmount","0","<p>So let's say there is acomponent which displays 2 child components: a <em>document list</em> and <em>the selected document</em>. By default <em>the selected document</em> component is not rendered, only when a document is selected from the list. And i also want this whole thing work when a new document is selected from the list.</p>

<p>There is a <code>state</code> which holds the document content and responsible for <em>the selected document</em> rendering, so i thought i'm going to set it to <strong>null</strong> in the method which handles the list item selection in order to unmount the previously created child component. Like this (excerpts from the parent class):</p>

<pre><code> handleResultListItemClick(docname) {
    if (this.state.sectioncontainer != null) this.setState({sectioncontainer: null},()=&gt;{console.log(""muhoo"");});
    var selected_doc = this.state.resultlist.filter((doc) =&gt; {
      return docname === doc.properties.title;
    });
    this.setState({sectioncontainer: selected_doc[0].content.sections},()=&gt;{console.log(""boohoo"");});
  }

...

render() {
  return (

    ...

    {this.state.sectioncontainer != null &amp;&amp; &lt;SectionContainer listOfSections={this.state.sectioncontainer}/&gt;}
  );
}
</code></pre>

<p>The only problem is that state handling is not fast enough (or something) in react, because putting the <code>state</code> nullification and its new value setting in the same method results in no change in ReactDOM.
With the above code, the component will be created when the parent component first rendered, but after selecting a new doc in the list results in no change.</p>

<p>How should i implement this in way which works and also elegant?</p>

<p>I found this: <a href=""https://reactjs.org/docs/react-dom.html#unmountcomponentatnode"" rel=""nofollow noreferrer"">ReactDOM.unmountComponentAtNode(container)</a> in the official react docs. Is this the only way? If yes, how could i get this <code>container</code> 'name'?</p>

<p><strong>Edit:</strong></p>

<p>Based on the answers and thinking the problem a bit more through, i have to explain more of the context.</p>

<p>As kingdaro explained, i understand why there is no need to unmount a child component on a basic level, but maybe my problem is bit more sophisticated. So why did i want to unmount the child?</p>

<p>The documents consist of several subsections, hence the document object which is passed to the child component is an array of objects. And the document is generated dynamically based on this array the following way (excerpt from the SectionContainer class which is responsible to display the document):</p>

<pre><code>  buildSectionContainer() {
    return this.props.listOfSections.map((section, index) =&gt;
      {
        if (section.type === 'editor') return (
          &lt;QuillEditor
            key={index}
            id={section.id}
            modules={modules}
            defaultValue={section.content}
            placeholder={section.placeholder}
          /&gt;
        );
        else if (section.type === 'text') return (
         &lt;div key={index}&gt;{section.value}&lt;/div&gt;
        );
      }
    );
  }

  render() {
    return (
      &lt;div&gt;
        {this.buildSectionContainer()}
      &lt;/div&gt;
    );
  }
</code></pre>

<p>The SectionContainer gets the array of objects and generate the document from it according to the type of these sections. The problem is that these sections are not updated when a different doc is selected in the parent component. I see change only when a bigger length array is passed to the child component. Like the firstly selected doc had an array of 2 elements, and then the newly selected doc had 3 elements array of sections and this third section is added to the previously existing 2, but the first 2 sections remained as they were.
And that’s why i though it’s better to unmount the child component and create a new one.</p>

<p>Surely it can happen that i miss something fundamental here again. Maybe related to how react handles lists. I just dont know what.</p>

<p><strong>Edit2:</strong></p>

<p>Ok, figured out that there is a problem with how i use the QuillEditor component. I just dont know what. :) The document updates, only the content of QuillEditors doesnt.</p>
",""
"49749945","Transition color of element in react js","2","<p>I have 2 scenes in React. On scene 1, there is a div with a timer which color should be transitioned from green to red for 180 seconds. The problem is that at any time user can switch to scene 2 and switch back to the scene1 after some time. So I need a way to start the animation not from the beginning but from the color it would've transitioned after user switched to scene 2, spent some time there and switched back to scene 1. </p>

<p>For example: </p>

<ol>
<li>user opened scene 1 </li>
<li>user spent 40 seconds there, color transitioned to some orangish one  </li>
<li>user switched to scene 2 and spent 30 seconds there and then switched back to scene 1</li>
</ol>

<p>So I need some js magic that can transition color so that the transition starts from the color that would've been there if user spent 70 seconds on scene 1 and the transition time would be 110 seconds. All I can think up for now is some library that can transition colors and in which I can specify the start time from which the transition starts (in time or percentage, it doesn't matter), but I can't find it for now. If you know any other way, please let me know. Thanks!</p>
","There was no code. It was done in CSS at first, but after the app got cut in 2 scenes which are routed with react-router the css transitions restart because components mount/unmount on switching."
"49763456","react router v4 reseting state on render from api calls","0","<p>I am using react router v4 and I am passing props to the components in the <code>Route</code>. Problem I ham having is when triggerring api call withing the Route compoment which has another component.</p>

<p>Route -> renders componnet -> renders multiple components -> each of these call and api with setstate -> re renders component which Route is assigned to with empty state variables.</p>

<p><strong>app.js containing Switch</strong></p>

<pre><code>render() {
        const Main = () =&gt; (
            &lt;main&gt;
                &lt;Switch&gt;
                    &lt;Route exact path=""/"" component={()=&gt;&lt;Regulator web3={this.state.web3} accounts={this.state.accounts} passDataBack={this.passDataBack} /&gt;} /&gt;
                    &lt;Route exact path=""/tollboothoperator"" component={()=&gt;&lt;TollboothOperator web3={this.state.web3} accounts={this.state.accounts} passDataBack={this.passDataBack} /&gt;} /&gt;
                &lt;/Switch&gt;
            &lt;/main&gt;
        )
        return (
            &lt;div&gt;
                &lt;Menu /&gt;
                &lt;div className=""container-fluid""&gt;
                    &lt;header className=""text-center""&gt;
                        &lt;h1 className=""""&gt;B9Lab Final Exam&lt;/h1&gt;
                    &lt;/header&gt;
                    &lt;Main/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
</code></pre>

<p><strong>Route component (Regulator)</strong></p>

<pre><code>render() {
        const { formRErrors } = this.state;
        const { regulator, owner } = this.state;
        const isEnabled = owner.length &gt; 0;
        console.log(""regulator render"")
        console.log(this);
        let vehicle = '';
        let operator = '';
        if(isEnabled){
            vehicle = &lt;Vehicle regulator={regulator} owner={owner} web3={this.props.web3} accounts={this.props.accounts} passDataBack={this.props.passDataBack} /&gt;;
            operator = &lt;CreateTollboothOperator regulator={regulator} owner={owner} web3={this.props.web3} accounts={this.props.accounts} passDataBack={this.props.passDataBack} /&gt;;
        }
        return (
            &lt;div className=""container-fluid""&gt;
                &lt;div className=""row-fluid""&gt;
                &lt;form className=""form-inline"" onSubmit={this.handleSubmit}&gt;
                {formRErrors.map(error =&gt; (
                    &lt;p key={error}&gt;Error: {error}&lt;/p&gt;
                ))}
                &lt;div className=""form-group""&gt;
                    &lt;label htmlFor=""regulator_address"" className=""control-label""&gt;Regulator Address&lt;/label&gt;
                    &lt;input type=""text"" readOnly={isEnabled} className=""form-control"" id=""regulator_address"" placeholder=""Regulator Address"" value={this.state.regulator_address} onChange={this.handleChange}/&gt;
                &lt;/div&gt;
                &lt;button type=""submit"" disabled={isEnabled} className=""btn btn-primary""&gt;Confirm&lt;/button&gt;
                &lt;/form&gt;
                &lt;/div&gt;
                {vehicle}
                {operator}
            &lt;/div&gt;
        );
    }
</code></pre>

<p><strong>vehicle</strong></p>

<pre><code>render(){
        let options = this.accounts.map((option, index) =&gt; (
            &lt;option key={option} value={option}&gt;
                {option}
            &lt;/option&gt;
        ));
        let vehicleOptions = this.state.vehicleTypes.map((option, index) =&gt; (
            &lt;option key={option.id} value={option.id}&gt;
                {option.type}
            &lt;/option&gt;
        ));

        console.log(this);
        return(
            &lt;div className=""row top-buffer""&gt;
                &lt;h2&gt;Vehicle List&lt;/h2&gt;
                &lt;div className=""col-xs-10 col-sm-3 col-md-4""&gt;
                &lt;div className=""row-fluid""&gt;
                    &lt;form onSubmit={this.handleSubmit} className=""form-horizontal""&gt;
                        &lt;div className=""form-group""&gt;
                            &lt;label className=""control-label col-sm-2""&gt;Available Addresses:&lt;/label&gt;
                            &lt;div className=""col-sm-10""&gt;
                            &lt;select value={this.state.valueAddress} onChange={this.handleChangeAddress} name=""available_addresses"" className=""form-control form-control-inline""&gt;
                            {options}
                            &lt;/select&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div className=""form-group""&gt;
                            &lt;label className=""control-label col-sm-2""&gt;Set as vehicle:&lt;/label&gt;
                            &lt;div className=""col-sm-10""&gt;
                            &lt;select value={this.state.valueVehicle} onChange={this.handleChangeVehicle} name=""vehicles"" className=""form-control form-control-inline""&gt;
                            {vehicleOptions}
                            &lt;/select&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div className=""col-sm-offset-2 col-sm-10 ""&gt;
                            &lt;button type=""submit"" className=""btn btn-isuccess""&gt;Add&lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""col-xs-2 col-sm-6 col-md-8""&gt;
                    &lt;h3&gt;Assigned&lt;/h3&gt;
                    &lt;div&gt;{this.displayAssigned()}&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
</code></pre>

<p>It is failing in the vehicle <code>handleSubmit</code> which is calling api, before it resolved it renders Regulator with empty state variables so i get following error. i use state variables to show hide components. vehicle is sub-component  of regulator, so when regulator gets hidden vehicle component throws below error has there is nothing on the page.</p>

<pre><code>Warning: Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op.

    Please check the code for the e component.
</code></pre>
",""
"49784990","Why does React Router break create-react-app tests? How to fix this?","0","<p>I have seen the very similar post:
<a href=""https://stackoverflow.com/questions/43771517/using-jest-to-test-a-link-from-react-router-v4"">Using Jest to test a Link from react-router v4</a>
but I'm having different errors, and all kinds of them when trying to use CRA and React Router.</p>

<p>If the test script is <code>""test"": ""react-scripts test --env=jsdom""</code>, I get this error preventing the tests from running:</p>

<pre><code>2017-06-28 14:14 node[6612] (FSEvents.framework) FSEventStreamStart: register_with_server: ERROR: f2d_register_rpc() =&gt; (null) (-22)
Error: Error watching file for changes: EMFILE
at exports._errnoException (util.js:1018:11)
at FSEvent.FSWatcher._handle.onchange (fs.js:1420:11)
</code></pre>

<p>One solution I've found but I haven't been able to get it to work is to install/reinstall a library called watchman. (<a href=""https://github.com/facebook/react-native/issues/10028"" rel=""nofollow noreferrer"">https://github.com/facebook/react-native/issues/10028</a>) but trying to install watchman is throwing out errors as well.</p>

<p>Another solution I found (<a href=""https://github.com/jest-community/vscode-jest/issues/125"" rel=""nofollow noreferrer"">https://github.com/jest-community/vscode-jest/issues/125</a>) was to change that test script to <code>""test"": ""jest""</code>, and then I get this error:</p>

<pre><code>src/App.test.js: Unexpected token (7:18)
         5 | it('renders without crashing', () =&gt; {
         6 |   const div = document.createElement('div');
      &gt;  7 |   ReactDOM.render(&lt;App /&gt;, div);
           |                   ^
         8 |   ReactDOM.unmountComponentAtNode(div);
         9 | });
        10 |

Test Suites: 1 failed, 1 total
Tests:       0 total
Snapshots:   0 total
Time:        1.646s
Ran all test suites.
npm ERR! Test failed.  See above for more details.
</code></pre>

<p>After going way back in my commit history to find where the test suite initially had problems, I found a different set of errors.
The first of the errors happens after installing react-router-dom and adding this one liner to App.js</p>

<pre><code>&lt;Link to=""/""&gt;Scratch&lt;/Link&gt;
</code></pre>

<p>I get this error:</p>

<pre><code>  console.error node_modules/fbjs/lib/warning.js:33
    Warning: Failed context type: The context `router` is marked as required in`Link`, but its value is `undefined`.
        in Link (at App.js:13)
        in NavbarBrand (at App.js:12)
        in div (created by NavbarHeader)
        in NavbarHeader (at App.js:11)
        in div (created by Grid)
        in Grid (created by Navbar)
        in nav (created by Navbar)
        in Navbar (created by Uncontrolled(Navbar))
        in Uncontrolled(Navbar) (at App.js:10)
        in div (at App.js:9)
        in App (at App.test.js:7)

  console.error node_modules/react-dom/cjs/react-dom.development.js:9627
    The above error occurred in the &lt;Link&gt; component:
        in Link (at App.js:13)
        in NavbarBrand (at App.js:12)
        in div (created by NavbarHeader)
        in NavbarHeader (at App.js:11)
        in div (created by Grid)
        in Grid (created by Navbar)
        in nav (created by Navbar)
        in Navbar (created by Uncontrolled(Navbar))
        in Uncontrolled(Navbar) (at App.js:10)
        in div (at App.js:9)
        in App (at App.test.js:7)
</code></pre>

<p>Everything that I'm trying seems to be yielding different errors, I don't know the correct way to set this up, and since I'm still new to React I'm not very familiar with any of these messages, and the solutions I'm finding online don't seem to be working.</p>
",""
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","What are you trying to achieve by removing the script? If you just want to remove the tag, that's feasible, but if you're looking for a way to undo whatever effects the script had on the global environment, that'd be a little bit more involved!"
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","That script adds an iframe to DOM when loaded and that needs to be removed too.."
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","What's the use case here for injecting the iFrame via this script rather than managing it via a React component? Also -- similar to what @JoeClay points out, even if you remove the script, if the code has been loaded by the client machine, removing the script tag probably won't have any effect on the iFrame"
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","@Sam I'm loading a form created with `JotForm` (for example https://form.jotform.com/81003857231348), that's why I need to inject the iFrame"
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","Is this a try to do code splitting and [dynamic importing](https://webpack.js.org/guides/code-splitting/#dynamic-imports)? This is supported by webpack. Normally if you do not care for bundle size you do not need to dynamically load javascript. Just create a component that creates an iframe with the desired content and then conditionally render that component. No need to manually remove anything."
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","Is there any way to add the source code of that form directly in React Component?"
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","@trixn I don't care for bundle size and I think that your approach would work. But how can I add the source code of the iframe to the component? https://github.com/alpesh-jikadra/Resources/blob/master/js/81003857231348.js"
"49879277","React remove script when component will unmount","8","<p>How can I remove the previously added script from component when it will unmount?</p>

<p>This is my code:</p>

<pre><code>import React from 'react';

export default class ScriptServices extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidMount() {
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = ""./scriptServices.js"";
    this.instance.appendChild(s);
  }

  componentWillUnmount() {
    // remove script
  }

  render() {
    return &lt;div ref={el =&gt; (this.instance = el)} /&gt;;
  }
}
</code></pre>
","Do you expect that I read 53465454 lines of minified javascript code? :) Usually an iframe is a page in a page. That means you set the source and it will load an individual page inside that. Of course there must be a route for that in your backend."
"49941900","Don't unmount child if parent unmounts","2","<p>I have a component that I want to render in a new browser window and I'm using roughly this technique: <a href=""https://hackernoon.com/using-a-react-16-portal-to-do-something-cool-2a2d627b0202"" rel=""nofollow noreferrer"">https://hackernoon.com/using-a-react-16-portal-to-do-something-cool-2a2d627b0202</a></p>

<p>This is a short extract of it:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>class MyWindowPortal extends React.PureComponent {
  constructor(props) {
    super(props);
    // STEP 1: create a container &lt;div&gt;
    this.containerEl = document.createElement('div');
    this.externalWindow = null;
  }
  
  render() {
    // STEP 2: append props.children to the container &lt;div&gt; that isn't mounted anywhere yet
    return ReactDOM.createPortal(this.props.children, this.containerEl);
  }

  componentDidMount() {
    // STEP 3: open a new browser window and store a reference to it
    this.externalWindow = window.open('', '', 'width=600,height=400,left=200,top=200');

    // STEP 4: append the container &lt;div&gt; (that has props.children appended to it) to the body of the new window
    this.externalWindow.document.body.appendChild(this.containerEl);
  }

  componentWillUnmount() {
    // STEP 5: This will fire when this.state.showWindowPortal in the parent component becomes false
    // So we tidy up by closing the window
    this.externalWindow.close();
  }
}</code></pre>
</div>
</div>
</p>

<p>TL;DR: appending a react portal to the new window.</p>

<p>Complete working codepen for the above example: <a href=""https://codepen.io/davidgilbertson/pen/xPVMqp"" rel=""nofollow noreferrer"">https://codepen.io/davidgilbertson/pen/xPVMqp</a></p>

<p>This works like a charm and even updates the component in the new window. As the portal is a child of the component opening the new window, it also closes when I close the parent component's page (i.e. unmounting in general).</p>

<p>Is there any possibility to keep the new window open and the current content in it? It does not need to change anymore, basically freezing it in place would be fine (no state updates and whatnot). Just keep what was rendered.</p>

<p>Any help is highly appreciated :)</p>
","can you change the `<App />` from the Codepen example?"
"49941900","Don't unmount child if parent unmounts","2","<p>I have a component that I want to render in a new browser window and I'm using roughly this technique: <a href=""https://hackernoon.com/using-a-react-16-portal-to-do-something-cool-2a2d627b0202"" rel=""nofollow noreferrer"">https://hackernoon.com/using-a-react-16-portal-to-do-something-cool-2a2d627b0202</a></p>

<p>This is a short extract of it:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>class MyWindowPortal extends React.PureComponent {
  constructor(props) {
    super(props);
    // STEP 1: create a container &lt;div&gt;
    this.containerEl = document.createElement('div');
    this.externalWindow = null;
  }
  
  render() {
    // STEP 2: append props.children to the container &lt;div&gt; that isn't mounted anywhere yet
    return ReactDOM.createPortal(this.props.children, this.containerEl);
  }

  componentDidMount() {
    // STEP 3: open a new browser window and store a reference to it
    this.externalWindow = window.open('', '', 'width=600,height=400,left=200,top=200');

    // STEP 4: append the container &lt;div&gt; (that has props.children appended to it) to the body of the new window
    this.externalWindow.document.body.appendChild(this.containerEl);
  }

  componentWillUnmount() {
    // STEP 5: This will fire when this.state.showWindowPortal in the parent component becomes false
    // So we tidy up by closing the window
    this.externalWindow.close();
  }
}</code></pre>
</div>
</div>
</p>

<p>TL;DR: appending a react portal to the new window.</p>

<p>Complete working codepen for the above example: <a href=""https://codepen.io/davidgilbertson/pen/xPVMqp"" rel=""nofollow noreferrer"">https://codepen.io/davidgilbertson/pen/xPVMqp</a></p>

<p>This works like a charm and even updates the component in the new window. As the portal is a child of the component opening the new window, it also closes when I close the parent component's page (i.e. unmounting in general).</p>

<p>Is there any possibility to keep the new window open and the current content in it? It does not need to change anymore, basically freezing it in place would be fine (no state updates and whatnot). Just keep what was rendered.</p>

<p>Any help is highly appreciated :)</p>
","I have full control over all components, if that's what you are asking. A solution as close as possible to the two components directly involved would be nice, though, without going all the way up to root."
"50007450","react-google-maps StandaloneSearchBox unmounting","0","<p>I am trying to use the StandaloneSearchBox Component from <a href=""https://www.npmjs.com/package/react-google-maps"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/react-google-maps</a></p>

<p>After looking at the <a href=""https://tomchentw.github.io/react-google-maps/#standalonesearchbox"" rel=""nofollow noreferrer"">docs</a> and some other answers I implemented the component like this:</p>

<pre><code>import React, { Component } from ""react"";
import PropTypes from ""prop-types"";
import { withScriptjs } from ""react-google-maps"";
import StandaloneSearchBox from ""react-google-maps/lib/components/places/StandaloneSearchBox"";
import { Input } from ""semantic-ui-react"";
import API_KEY from ""../config/googleAPIkey"";

class AddressSearchbox extends Component {
  constructor(props) {
    super(props);
    this.searchboxRef = null;
  }

  onSearchBoxMounted = ref =&gt; {
    this.searchboxRef = ref;
  };

  onPlacesChanged = () =&gt; {
    const places = this.searchboxRef.getPlaces();
    this.props.onPlaceSelect(places[0]);
  };

  render() {

    const Searchbox = withScriptjs(props =&gt; (
      &lt;StandaloneSearchBox
        ref={props.onSearchBoxMounted}
        onPlacesChanged={props.onPlacesChanged}
      &gt;
        &lt;Input
          type=""text""
          placeholder=""Type address or google place name""
          icon=""search""
        /&gt;
      &lt;/StandaloneSearchBox&gt;
    ));

    return (
      &lt;Searchbox
        googleMapURL={`https://maps.googleapis.com/maps/api/js?key=${API_KEY}&amp;v=3.exp&amp;libraries=geometry,drawing,places`}
        loadingElement={&lt;div style={{ height: `100%` }} /&gt;}
        onPlacesChanged={this.onPlacesChanged}
        onSearchBoxMounted={this.onSearchBoxMounted}
      /&gt;
    );
  }
}

AddressSearchbox.propTypes = {
  onPlaceSelect: PropTypes.func.isRequired
};

export default AddressSearchbox;
</code></pre>

<p>I use the component in a signup form where all the other input fields update the state on input change causing re-rendering of the whole form.
When the AddressSearchbox component gets re-rendered  it seems that it gets unmounted and then remounts causing flickering. The component itself works fine. </p>

<p>EDIT: When logging the ref parameter passed in onSearchBoxMounted() it prints null and then the SearchBox object after every re-render, so according to <a href=""https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element"" rel=""nofollow noreferrer"">this</a> the SearchBox component gets unmounted</p>
",""
"50015213","Is Redirecting to another path means unmounting?","6","<p>I am new to react and redirecting to another path and restricting some other user to directly enter in <code>/main</code> path. I am checking , <code>if yes ..</code> it will redirect... </p>

<p>So when I am redirecting it will redirecting to <code>/login</code> page and this is redirecting twice.</p>

<p>Now when I reached on login and filled my credentials and got the token, now the field I set i.e. authenticate is <code>yes</code> because <code>componentWillUnmount()</code> did not called.</p>

<p>So this means components did not mounted. And as I put all the credentials right as I said I field (authenticate is 'yes') then flow will not redirected to <code>/main..</code> it will be redirected to same page <code>/login</code> and gave an error.</p>

<pre><code>class Main extends Component { 

    constructor() {
        super();
        this.state = { userInfo: '', onlineUser: '', authenticate: 'no' };
    }

    async getUsers() {
        let user = await apiGateway.getUserInfo();
        alert(' did Mount1');
        alert(user);
        if(user == null) {
            this.setState({ authenticate : 'yes' });
            return;
        }
        else {
            this.setState({ userInfo : user.data });
        }
    }

    async setUpOnlineUsers() {
        let online = await apiGateway.getOnlineUsers();
        alert('did Mount2');
        if (online == null) {
            this.setState({ authenticate: 'yes' });
            return;
        } 
        else {
            this.setState({ onlineUser: online.data });
        }
    }

    async componentDidMount() {
        this.getUsers();
        this.setUpOnlineUsers();
    }

    async componentWillUnmount() {
        alert('unmount');
    }

    render() {
        const { authenticate } = this.state;
        alert(authenticate + ' render');

        if (authenticate === 'yes') {
            console.log('Redirect');
            return &lt;Redirect to='/login' /&gt; ;
        }
        const { userInfo } = this.state;
        const { onlineUser } = this.state;
        console.log(onlineUser);
        return (
            &lt;div className='Main'&gt;
                &lt;div className='Main-header'&gt;
                    &lt;Header userInfo = {userInfo}/&gt;
                &lt;/div&gt;
                &lt;div className='Main-chat'&gt;
                    &lt;Chat onlineUser = {onlineUser}/&gt;
                &lt;/div&gt;
                &lt;div className=""Main-container""&gt;
                    &lt;Image imageArray = {imageArray}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default Main;
</code></pre>

<p>** index.js **</p>

<pre><code> class App extends Component{

    render(){
        return(
            &lt;Router&gt;
                &lt;div&gt;
                    &lt;Route path ='/login' component={Login}/&gt;
                    &lt;Route path = '/register' component={Register}/&gt;
                    &lt;Route path = '/' component={Main}/&gt;
               &lt;/div&gt;
            &lt;/Router&gt;
            );
    }
 }

 export default App;
</code></pre>
","where i am missing } this  ????"
"50015213","Is Redirecting to another path means unmounting?","6","<p>I am new to react and redirecting to another path and restricting some other user to directly enter in <code>/main</code> path. I am checking , <code>if yes ..</code> it will redirect... </p>

<p>So when I am redirecting it will redirecting to <code>/login</code> page and this is redirecting twice.</p>

<p>Now when I reached on login and filled my credentials and got the token, now the field I set i.e. authenticate is <code>yes</code> because <code>componentWillUnmount()</code> did not called.</p>

<p>So this means components did not mounted. And as I put all the credentials right as I said I field (authenticate is 'yes') then flow will not redirected to <code>/main..</code> it will be redirected to same page <code>/login</code> and gave an error.</p>

<pre><code>class Main extends Component { 

    constructor() {
        super();
        this.state = { userInfo: '', onlineUser: '', authenticate: 'no' };
    }

    async getUsers() {
        let user = await apiGateway.getUserInfo();
        alert(' did Mount1');
        alert(user);
        if(user == null) {
            this.setState({ authenticate : 'yes' });
            return;
        }
        else {
            this.setState({ userInfo : user.data });
        }
    }

    async setUpOnlineUsers() {
        let online = await apiGateway.getOnlineUsers();
        alert('did Mount2');
        if (online == null) {
            this.setState({ authenticate: 'yes' });
            return;
        } 
        else {
            this.setState({ onlineUser: online.data });
        }
    }

    async componentDidMount() {
        this.getUsers();
        this.setUpOnlineUsers();
    }

    async componentWillUnmount() {
        alert('unmount');
    }

    render() {
        const { authenticate } = this.state;
        alert(authenticate + ' render');

        if (authenticate === 'yes') {
            console.log('Redirect');
            return &lt;Redirect to='/login' /&gt; ;
        }
        const { userInfo } = this.state;
        const { onlineUser } = this.state;
        console.log(onlineUser);
        return (
            &lt;div className='Main'&gt;
                &lt;div className='Main-header'&gt;
                    &lt;Header userInfo = {userInfo}/&gt;
                &lt;/div&gt;
                &lt;div className='Main-chat'&gt;
                    &lt;Chat onlineUser = {onlineUser}/&gt;
                &lt;/div&gt;
                &lt;div className=""Main-container""&gt;
                    &lt;Image imageArray = {imageArray}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default Main;
</code></pre>

<p>** index.js **</p>

<pre><code> class App extends Component{

    render(){
        return(
            &lt;Router&gt;
                &lt;div&gt;
                    &lt;Route path ='/login' component={Login}/&gt;
                    &lt;Route path = '/register' component={Register}/&gt;
                    &lt;Route path = '/' component={Main}/&gt;
               &lt;/div&gt;
            &lt;/Router&gt;
            );
    }
 }

 export default App;
</code></pre>
","After reindenting of your code, we can see a `}` is missing."
"50015213","Is Redirecting to another path means unmounting?","6","<p>I am new to react and redirecting to another path and restricting some other user to directly enter in <code>/main</code> path. I am checking , <code>if yes ..</code> it will redirect... </p>

<p>So when I am redirecting it will redirecting to <code>/login</code> page and this is redirecting twice.</p>

<p>Now when I reached on login and filled my credentials and got the token, now the field I set i.e. authenticate is <code>yes</code> because <code>componentWillUnmount()</code> did not called.</p>

<p>So this means components did not mounted. And as I put all the credentials right as I said I field (authenticate is 'yes') then flow will not redirected to <code>/main..</code> it will be redirected to same page <code>/login</code> and gave an error.</p>

<pre><code>class Main extends Component { 

    constructor() {
        super();
        this.state = { userInfo: '', onlineUser: '', authenticate: 'no' };
    }

    async getUsers() {
        let user = await apiGateway.getUserInfo();
        alert(' did Mount1');
        alert(user);
        if(user == null) {
            this.setState({ authenticate : 'yes' });
            return;
        }
        else {
            this.setState({ userInfo : user.data });
        }
    }

    async setUpOnlineUsers() {
        let online = await apiGateway.getOnlineUsers();
        alert('did Mount2');
        if (online == null) {
            this.setState({ authenticate: 'yes' });
            return;
        } 
        else {
            this.setState({ onlineUser: online.data });
        }
    }

    async componentDidMount() {
        this.getUsers();
        this.setUpOnlineUsers();
    }

    async componentWillUnmount() {
        alert('unmount');
    }

    render() {
        const { authenticate } = this.state;
        alert(authenticate + ' render');

        if (authenticate === 'yes') {
            console.log('Redirect');
            return &lt;Redirect to='/login' /&gt; ;
        }
        const { userInfo } = this.state;
        const { onlineUser } = this.state;
        console.log(onlineUser);
        return (
            &lt;div className='Main'&gt;
                &lt;div className='Main-header'&gt;
                    &lt;Header userInfo = {userInfo}/&gt;
                &lt;/div&gt;
                &lt;div className='Main-chat'&gt;
                    &lt;Chat onlineUser = {onlineUser}/&gt;
                &lt;/div&gt;
                &lt;div className=""Main-container""&gt;
                    &lt;Image imageArray = {imageArray}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default Main;
</code></pre>

<p>** index.js **</p>

<pre><code> class App extends Component{

    render(){
        return(
            &lt;Router&gt;
                &lt;div&gt;
                    &lt;Route path ='/login' component={Login}/&gt;
                    &lt;Route path = '/register' component={Register}/&gt;
                    &lt;Route path = '/' component={Main}/&gt;
               &lt;/div&gt;
            &lt;/Router&gt;
            );
    }
 }

 export default App;
</code></pre>
","updated with index.js"
"50015213","Is Redirecting to another path means unmounting?","6","<p>I am new to react and redirecting to another path and restricting some other user to directly enter in <code>/main</code> path. I am checking , <code>if yes ..</code> it will redirect... </p>

<p>So when I am redirecting it will redirecting to <code>/login</code> page and this is redirecting twice.</p>

<p>Now when I reached on login and filled my credentials and got the token, now the field I set i.e. authenticate is <code>yes</code> because <code>componentWillUnmount()</code> did not called.</p>

<p>So this means components did not mounted. And as I put all the credentials right as I said I field (authenticate is 'yes') then flow will not redirected to <code>/main..</code> it will be redirected to same page <code>/login</code> and gave an error.</p>

<pre><code>class Main extends Component { 

    constructor() {
        super();
        this.state = { userInfo: '', onlineUser: '', authenticate: 'no' };
    }

    async getUsers() {
        let user = await apiGateway.getUserInfo();
        alert(' did Mount1');
        alert(user);
        if(user == null) {
            this.setState({ authenticate : 'yes' });
            return;
        }
        else {
            this.setState({ userInfo : user.data });
        }
    }

    async setUpOnlineUsers() {
        let online = await apiGateway.getOnlineUsers();
        alert('did Mount2');
        if (online == null) {
            this.setState({ authenticate: 'yes' });
            return;
        } 
        else {
            this.setState({ onlineUser: online.data });
        }
    }

    async componentDidMount() {
        this.getUsers();
        this.setUpOnlineUsers();
    }

    async componentWillUnmount() {
        alert('unmount');
    }

    render() {
        const { authenticate } = this.state;
        alert(authenticate + ' render');

        if (authenticate === 'yes') {
            console.log('Redirect');
            return &lt;Redirect to='/login' /&gt; ;
        }
        const { userInfo } = this.state;
        const { onlineUser } = this.state;
        console.log(onlineUser);
        return (
            &lt;div className='Main'&gt;
                &lt;div className='Main-header'&gt;
                    &lt;Header userInfo = {userInfo}/&gt;
                &lt;/div&gt;
                &lt;div className='Main-chat'&gt;
                    &lt;Chat onlineUser = {onlineUser}/&gt;
                &lt;/div&gt;
                &lt;div className=""Main-container""&gt;
                    &lt;Image imageArray = {imageArray}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default Main;
</code></pre>

<p>** index.js **</p>

<pre><code> class App extends Component{

    render(){
        return(
            &lt;Router&gt;
                &lt;div&gt;
                    &lt;Route path ='/login' component={Login}/&gt;
                    &lt;Route path = '/register' component={Register}/&gt;
                    &lt;Route path = '/' component={Main}/&gt;
               &lt;/div&gt;
            &lt;/Router&gt;
            );
    }
 }

 export default App;
</code></pre>
","no, sorry, my fault. I forgot to reindent the return too."
"50015213","Is Redirecting to another path means unmounting?","6","<p>I am new to react and redirecting to another path and restricting some other user to directly enter in <code>/main</code> path. I am checking , <code>if yes ..</code> it will redirect... </p>

<p>So when I am redirecting it will redirecting to <code>/login</code> page and this is redirecting twice.</p>

<p>Now when I reached on login and filled my credentials and got the token, now the field I set i.e. authenticate is <code>yes</code> because <code>componentWillUnmount()</code> did not called.</p>

<p>So this means components did not mounted. And as I put all the credentials right as I said I field (authenticate is 'yes') then flow will not redirected to <code>/main..</code> it will be redirected to same page <code>/login</code> and gave an error.</p>

<pre><code>class Main extends Component { 

    constructor() {
        super();
        this.state = { userInfo: '', onlineUser: '', authenticate: 'no' };
    }

    async getUsers() {
        let user = await apiGateway.getUserInfo();
        alert(' did Mount1');
        alert(user);
        if(user == null) {
            this.setState({ authenticate : 'yes' });
            return;
        }
        else {
            this.setState({ userInfo : user.data });
        }
    }

    async setUpOnlineUsers() {
        let online = await apiGateway.getOnlineUsers();
        alert('did Mount2');
        if (online == null) {
            this.setState({ authenticate: 'yes' });
            return;
        } 
        else {
            this.setState({ onlineUser: online.data });
        }
    }

    async componentDidMount() {
        this.getUsers();
        this.setUpOnlineUsers();
    }

    async componentWillUnmount() {
        alert('unmount');
    }

    render() {
        const { authenticate } = this.state;
        alert(authenticate + ' render');

        if (authenticate === 'yes') {
            console.log('Redirect');
            return &lt;Redirect to='/login' /&gt; ;
        }
        const { userInfo } = this.state;
        const { onlineUser } = this.state;
        console.log(onlineUser);
        return (
            &lt;div className='Main'&gt;
                &lt;div className='Main-header'&gt;
                    &lt;Header userInfo = {userInfo}/&gt;
                &lt;/div&gt;
                &lt;div className='Main-chat'&gt;
                    &lt;Chat onlineUser = {onlineUser}/&gt;
                &lt;/div&gt;
                &lt;div className=""Main-container""&gt;
                    &lt;Image imageArray = {imageArray}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default Main;
</code></pre>

<p>** index.js **</p>

<pre><code> class App extends Component{

    render(){
        return(
            &lt;Router&gt;
                &lt;div&gt;
                    &lt;Route path ='/login' component={Login}/&gt;
                    &lt;Route path = '/register' component={Register}/&gt;
                    &lt;Route path = '/' component={Main}/&gt;
               &lt;/div&gt;
            &lt;/Router&gt;
            );
    }
 }

 export default App;
</code></pre>
","no..problem..Can you please give me some solution of this problem ??"
"50015213","Is Redirecting to another path means unmounting?","6","<p>I am new to react and redirecting to another path and restricting some other user to directly enter in <code>/main</code> path. I am checking , <code>if yes ..</code> it will redirect... </p>

<p>So when I am redirecting it will redirecting to <code>/login</code> page and this is redirecting twice.</p>

<p>Now when I reached on login and filled my credentials and got the token, now the field I set i.e. authenticate is <code>yes</code> because <code>componentWillUnmount()</code> did not called.</p>

<p>So this means components did not mounted. And as I put all the credentials right as I said I field (authenticate is 'yes') then flow will not redirected to <code>/main..</code> it will be redirected to same page <code>/login</code> and gave an error.</p>

<pre><code>class Main extends Component { 

    constructor() {
        super();
        this.state = { userInfo: '', onlineUser: '', authenticate: 'no' };
    }

    async getUsers() {
        let user = await apiGateway.getUserInfo();
        alert(' did Mount1');
        alert(user);
        if(user == null) {
            this.setState({ authenticate : 'yes' });
            return;
        }
        else {
            this.setState({ userInfo : user.data });
        }
    }

    async setUpOnlineUsers() {
        let online = await apiGateway.getOnlineUsers();
        alert('did Mount2');
        if (online == null) {
            this.setState({ authenticate: 'yes' });
            return;
        } 
        else {
            this.setState({ onlineUser: online.data });
        }
    }

    async componentDidMount() {
        this.getUsers();
        this.setUpOnlineUsers();
    }

    async componentWillUnmount() {
        alert('unmount');
    }

    render() {
        const { authenticate } = this.state;
        alert(authenticate + ' render');

        if (authenticate === 'yes') {
            console.log('Redirect');
            return &lt;Redirect to='/login' /&gt; ;
        }
        const { userInfo } = this.state;
        const { onlineUser } = this.state;
        console.log(onlineUser);
        return (
            &lt;div className='Main'&gt;
                &lt;div className='Main-header'&gt;
                    &lt;Header userInfo = {userInfo}/&gt;
                &lt;/div&gt;
                &lt;div className='Main-chat'&gt;
                    &lt;Chat onlineUser = {onlineUser}/&gt;
                &lt;/div&gt;
                &lt;div className=""Main-container""&gt;
                    &lt;Image imageArray = {imageArray}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default Main;
</code></pre>

<p>** index.js **</p>

<pre><code> class App extends Component{

    render(){
        return(
            &lt;Router&gt;
                &lt;div&gt;
                    &lt;Route path ='/login' component={Login}/&gt;
                    &lt;Route path = '/register' component={Register}/&gt;
                    &lt;Route path = '/' component={Main}/&gt;
               &lt;/div&gt;
            &lt;/Router&gt;
            );
    }
 }

 export default App;
</code></pre>
","share your `index.js` where your routes are set"
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","Ok, in that case you can remove the history.push from there and set a flag to show that its unauthenticated and return <Redirect path=""/""> in render() in unauthenticated cases. The histoty.push will be trying to unmount components which are not mounted hence the error."
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","I did but it throws an error since it needs to know if they are authenticated before the component is rendered."
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","Can you try the same by changing ComponentWillMount to ComponentDidMount?"
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","What do you mean with that? Could you please write a short exemple of your code? I don't find any point of the doc talking about this"
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","Thanks for the help. I ended up using render instead of component, as mentioned in the React Router 4 documentation, and the error went away."
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","Hi @CameronTharp I believe that I am doing the exact same thing as you, and I do receive the same warning. Here is my take on the routes: https://gist.github.com/ahlusar1989/d46edb1f73987838b358e05649624639. I welcome feedback on if this is a similar pattern as your original implementation. I am particularly wondering why you need render over component props in the route? Is this specific to React Router V4?"
"50029468","React warning about setState in unmounted component","7","<p>I'm getting this error: </p>

<blockquote>
  <p>warning.js:33 Warning: Can't call setState (or forceUpdate) on an
  unmounted component. This is a no-op, but it indicates a memory leak
  in your application. To fix, cancel all subscriptions and asynchronous
  tasks in the componentWillUnmount method.</p>
</blockquote>

<p>But I'm not using a componentWillUnMount method. </p>

<p>I'm using a HOC to make sure the user is authenticated before accessing their /account route. </p>

<p>Here's the Route: </p>

<pre><code>&lt;StyleRoute props={this.props} path=""/account"" component= 
{RequireAuth(Account)} /&gt;
</code></pre>

<p>where RequireAuth is the HOC. Here's the HOC: </p>

<pre><code> import { withRouter } from 'react-router';

export default function RequireAuth(Component) {

  return class AuthenticatedComponent extends React.Component {

    componentWillMount() {
      this.checkAuth();
    }

    checkAuth() {
      if ( ! this.props.isAuthenticated) {
        this.props.history.push(`/`);
      }
    }

    render() {
      return this.props.isAuthenticated
        ? &lt;Component { ...this.props } /&gt;
        : null;
    }

  }

  return withRouter(AuthenticatedComponent);
}
</code></pre>

<p>The code works as intended, but I'm getting that error when /account is rendered. As you notice, nowhere in my direct code is there an componentWillUnMount method. I'm really at a loss for why this warning keeps popping up and any info would help.</p>

<hr>

<p>Update 5/23/18:</p>

<p>To get rid of the error and still have props pass down, I did two thing:</p>

<p>1) I opted for a having two higher order functions in parent App component instead of using the HOC. One higher order function is for passing props and the other is to check authentication. I was having trouble passing any props other than the browser history, hence the renderProps function below. </p>

<pre><code>renderProps = (Component, props) =&gt; {
  return (
      &lt;Component {...props} /&gt;
    );
}

checkAuth = (Component, props) =&gt; {
    if (props.isAuthenticated) {
        return &lt;Component {...props} /&gt;
    }
    if (!props.isAuthenticated) {
        return &lt;Redirect to='/' /&gt;
    }
}
</code></pre>

<p>2) To use these, I had to user render in my Route, as opposed to component.</p>

<pre><code>//I could pass props doing this, sending them through the above functions
&lt;Route exact path=""/sitter-dashboard"" render={ () =&gt; this.checkAuth(SitterDashboard, this.props) } /&gt;
&lt;Route exact path={""/account/user""} render={() =&gt; this.renderProps(User, this.props)} /&gt;

//I couldn't pass props doing this
&lt;Route {...this.props} exact path=""/messages"" component={Messages} /&gt;
</code></pre>

<p>Here's the documentation on router vs component as a Route render method: <a href=""https://reacttraining.com/react-router/web/api/Route/route-render-methods"" rel=""noreferrer"">https://reacttraining.com/react-router/web/api/Route/route-render-methods</a></p>

<p>Also, here's a good explanation on <a href=""https://stackoverflow.com/questions/48150567/react-router-difference-between-component-and-render"">Stack Overflow</a></p>

<p>Finally, I used this code from the React Router 4 documentation as a template for what I did above. I'm sure the below is cleaner, but I'm still learning and what I did makes a bit more sense to me.</p>

<pre><code>const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
&lt;Route
  {...rest}
  render={props =&gt;
  fakeAuth.isAuthenticated ? (
       &lt;Component {...props} /&gt;
      ) : (
        &lt;Redirect
          to={{
            pathname: ""/login"",
            state: { from: props.location }
          }}
        /&gt;
      )
    }
  /&gt;
);
</code></pre>
","Pibo, done. I still don't know why I was getting the initial error, but it seems to be cleared up now."
"50087326","When the ref callback argument is NULL in react?","9","<p>In some component when I use ref callback to receive component's ref, the argument of callback is null. When and in what situations the argument will be null?</p>
","> React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts. ref callbacks are invoked before componentDidMount or componentDidUpdate lifecycle hooks. From: https://reactjs.org/docs/refs-and-the-dom.html"
"50401527","React+Redux: bug where component unmounts on render only when code is minified","3","<p>Environment: React 16.3, Redux 3.7.2, Webpack 4.6.0, UglifyJS plugin for Webpack 1.2.5.</p>

<p>I am trying to solve a bug that only occurs when we build with NODE_ENV='production' (which turns on minification using the UglifyJS webpack plugin via <code>mode: 'production'</code>).</p>

<p>The component hierarchy looks roughly (minus a bunch of <code>div</code>s) like:
<code>
Sidebar
   SidebarSection (array)
     SidebarSubSection (array)
       Field (e.g. InputField)
</code></p>

<p>Both SidebarSection and SidebarSubSection components are created with unique <code>key</code> attributes. When an onChange event handler for a field is triggered, it updates the model through a redux reducer, which triggers a re-render of Sidebar and child components. In development, this all works fine but in production (with minification) we are getting bugs that are caused by the SidebarSubSection being unmounted/re-mounted along with all the child fields.</p>

<p>According to <a href=""https://reactjs.org/docs/reconciliation.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/reconciliation.html</a> this shouldn't be happening given that the types in the tree aren't changing and that we are using keys on the arrays of components. </p>

<p>Tweaking things like <code>keep_classnames</code> on the uglify compress options hasn't helped.</p>

<p>My specific configuration for uglifyjs under <code>optimization</code>: 
<code>
minimizer: [
   new UglifyJsPlugin({
      sourceMaps: true,
      uglifyOptions: {
         ecma: 8,
         compress: {
            dead_code: true,
            unused: true,
            inline: false,
            global_defs: {
              'process.env.NODE_ENV': 'production'
            }
         }
      }
   })
]
</code></p>

<p>Any ideas?</p>
","Yes. If I alter the webpack config to `{ optimization: { minimize: false } }` the bug does not appear. Right now it is:"
"50401527","React+Redux: bug where component unmounts on render only when code is minified","3","<p>Environment: React 16.3, Redux 3.7.2, Webpack 4.6.0, UglifyJS plugin for Webpack 1.2.5.</p>

<p>I am trying to solve a bug that only occurs when we build with NODE_ENV='production' (which turns on minification using the UglifyJS webpack plugin via <code>mode: 'production'</code>).</p>

<p>The component hierarchy looks roughly (minus a bunch of <code>div</code>s) like:
<code>
Sidebar
   SidebarSection (array)
     SidebarSubSection (array)
       Field (e.g. InputField)
</code></p>

<p>Both SidebarSection and SidebarSubSection components are created with unique <code>key</code> attributes. When an onChange event handler for a field is triggered, it updates the model through a redux reducer, which triggers a re-render of Sidebar and child components. In development, this all works fine but in production (with minification) we are getting bugs that are caused by the SidebarSubSection being unmounted/re-mounted along with all the child fields.</p>

<p>According to <a href=""https://reactjs.org/docs/reconciliation.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/reconciliation.html</a> this shouldn't be happening given that the types in the tree aren't changing and that we are using keys on the arrays of components. </p>

<p>Tweaking things like <code>keep_classnames</code> on the uglify compress options hasn't helped.</p>

<p>My specific configuration for uglifyjs under <code>optimization</code>: 
<code>
minimizer: [
   new UglifyJsPlugin({
      sourceMaps: true,
      uglifyOptions: {
         ecma: 8,
         compress: {
            dead_code: true,
            unused: true,
            inline: false,
            global_defs: {
              'process.env.NODE_ENV': 'production'
            }
         }
      }
   })
]
</code></p>

<p>Any ideas?</p>
","See my current config above"
"50401527","React+Redux: bug where component unmounts on render only when code is minified","3","<p>Environment: React 16.3, Redux 3.7.2, Webpack 4.6.0, UglifyJS plugin for Webpack 1.2.5.</p>

<p>I am trying to solve a bug that only occurs when we build with NODE_ENV='production' (which turns on minification using the UglifyJS webpack plugin via <code>mode: 'production'</code>).</p>

<p>The component hierarchy looks roughly (minus a bunch of <code>div</code>s) like:
<code>
Sidebar
   SidebarSection (array)
     SidebarSubSection (array)
       Field (e.g. InputField)
</code></p>

<p>Both SidebarSection and SidebarSubSection components are created with unique <code>key</code> attributes. When an onChange event handler for a field is triggered, it updates the model through a redux reducer, which triggers a re-render of Sidebar and child components. In development, this all works fine but in production (with minification) we are getting bugs that are caused by the SidebarSubSection being unmounted/re-mounted along with all the child fields.</p>

<p>According to <a href=""https://reactjs.org/docs/reconciliation.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/reconciliation.html</a> this shouldn't be happening given that the types in the tree aren't changing and that we are using keys on the arrays of components. </p>

<p>Tweaking things like <code>keep_classnames</code> on the uglify compress options hasn't helped.</p>

<p>My specific configuration for uglifyjs under <code>optimization</code>: 
<code>
minimizer: [
   new UglifyJsPlugin({
      sourceMaps: true,
      uglifyOptions: {
         ecma: 8,
         compress: {
            dead_code: true,
            unused: true,
            inline: false,
            global_defs: {
              'process.env.NODE_ENV': 'production'
            }
         }
      }
   })
]
</code></p>

<p>Any ideas?</p>
","Just to be clear, if you build it for production, but just leave out the uglify process, do you still observe the bug? Basically, are you 100% certain it's the minification part of the production build that is causing it?"
"50530634","semantic-ui-react Menu returns TypeError: instance.render is not a function","0","<p>I am somewhat new to React. I've been working on a React project for some time but never messed with packages and dependencies. And I think this is what my issue is related to.</p>

<p>I have a project where I use Semantic-UI-React Menu + Router for navigation. Up until last night it worked fine. Then I ran <code>npm install</code> and everything started failing. I was digging into the specifics to find the root cause and identified that <code>&lt;Menu /&gt;</code> was causing the issue. So I created a new fresh app using the <strong>create-new-app</strong> package and confirmed that the newly created app worked. Then I added the <strong>semantic-ui-react</strong> package to it and confirmed that it worked properly. After that I tried to render <code>&lt;Menu /&gt;</code> again and saw the same issue that I was seeing in my project. I'm suspicious that something is up with the versions of the packages but I cannot figure out what it is.</p>

<p>The Node.js version is 10.0.0.</p>

<p>The npm version is 5.6.0.</p>

<p>Here is my package.json:</p>

<pre><code>{
    ""name"": ""my-app"",
    ""version"": ""0.1.0"",
    ""private"": true,
    ""dependencies"": {
        ""react"": ""^16.4.0"",
        ""react-dom"": ""^16.4.0"",
        ""react-scripts"": ""1.1.4"",
        ""semantic-ui-react"": ""^0.80.1""
    },
    ""scripts"": {
        ""start"": ""react-scripts start"",
        ""build"": ""react-scripts build"",
        ""test"": ""react-scripts test --env=jsdom"",
        ""eject"": ""react-scripts eject""
    }
}
</code></pre>

<p>Here is my App.js (the menu example is copied from semantic-ui-react reference as is):</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import { Menu } from 'semantic-ui-react';
import './App.css';

const items = [
    { key: 'editorials', active: true, name: 'Editorials' },
    { key: 'review', name: 'Reviews' },
    { key: 'events', name: 'Upcoming Events' },
]

const MenuExampleProps = () =&gt; (
    &lt;Menu items={items} /&gt;
)

export default MenuExampleProps
</code></pre>

<p>When I run <code>yarn start</code>, I see this:</p>

<pre><code>1 of 2 errors on the page
TypeError: instance.render is not a function
finishClassComponent
node_modules/react-dom/cjs/react-dom.development.js:13085

  13082 | } else {
  13083 |   {
  13084 |     ReactDebugCurrentFiber.setCurrentPhase('render');
&gt; 13085 |     nextChildren = instance.render();
  13086 |     if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode &amp;&amp; workInProgress.mode &amp; StrictMode) {
  13087 |       instance.render();
  13088 |     }

updateClassComponent
node_modules/react-dom/cjs/react-dom.development.js:13047

  13044 |   } else {
  13045 |     shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
  13046 |   }
&gt; 13047 |   return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);
  13048 | }
  13049 | 
  13050 | function finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime) {

beginWork
node_modules/react-dom/cjs/react-dom.development.js:13715

  13712 | case FunctionalComponent:
  13713 |   return updateFunctionalComponent(current, workInProgress);
  13714 | case ClassComponent:
&gt; 13715 |   return updateClassComponent(current, workInProgress, renderExpirationTime);
  13716 | case HostRoot:
  13717 |   return updateHostRoot(current, workInProgress, renderExpirationTime);
  13718 | case HostComponent:

performUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js:15741

  15738 |   startBaseRenderTimer();
  15739 | }
  15740 | 
&gt; 15741 | next = beginWork(current, workInProgress, nextRenderExpirationTime);
  15742 | 
  15743 | if (workInProgress.mode &amp; ProfileMode) {
  15744 |   // Update ""base"" time if the render wasn't bailed out on.

workLoop
node_modules/react-dom/cjs/react-dom.development.js:15780

  15777 | if (!isAsync) {
  15778 |   // Flush all expired work.
  15779 |   while (nextUnitOfWork !== null) {
&gt; 15780 |     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  15781 |   }
  15782 | } else {
  15783 |   // Flush asynchronous work until the deadline runs out of time.

callCallback
node_modules/react-dom/cjs/react-dom.development.js:100

   97 |   // nested call would trigger the fake event handlers of any call higher
   98 |   // in the stack.
   99 |   fakeNode.removeEventListener(evtType, callCallback, false);
&gt; 100 |   func.apply(context, funcArgs);
  101 |   didError = false;
  102 | }
  103 | 

invokeGuardedCallbackDev
node_modules/react-dom/cjs/react-dom.development.js:138

  135 | // Synchronously dispatch our fake event. If the user-provided function
  136 | // errors, it will trigger our global error handler.
  137 | evt.initEvent(evtType, false, false);
&gt; 138 | fakeNode.dispatchEvent(evt);
  139 | 
  140 | if (didError) {
  141 |   if (!didSetError) {

invokeGuardedCallback
node_modules/react-dom/cjs/react-dom.development.js:187

  184 |  * @param {...*} args Arguments for function
  185 |  */
  186 | invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
&gt; 187 |   invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);
  188 | },
  189 | 
  190 | /**

replayUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js:15194

  15191 | // Replay the begin phase.
  15192 | isReplayingFailedUnitOfWork = true;
  15193 | originalReplayError = thrownValue;
&gt; 15194 | invokeGuardedCallback$2(null, workLoop, null, isAsync);
  15195 | isReplayingFailedUnitOfWork = false;
  15196 | originalReplayError = null;
  15197 | if (hasCaughtError()) {

renderRoot
node_modules/react-dom/cjs/react-dom.development.js:15840

  15837 | 
  15838 | var failedUnitOfWork = nextUnitOfWork;
  15839 | if (true &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) {
&gt; 15840 |   replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);
  15841 | }
  15842 | 
  15843 | // TODO: we already know this isn't true in some cases.

performWorkOnRoot
node_modules/react-dom/cjs/react-dom.development.js:16437

  16434 |   completeRoot(root, finishedWork, expirationTime);
  16435 | } else {
  16436 |   root.finishedWork = null;
&gt; 16437 |   finishedWork = renderRoot(root, expirationTime, false);
  16438 |   if (finishedWork !== null) {
  16439 |     // We've completed the root. Commit it.
  16440 |     completeRoot(root, finishedWork, expirationTime);

performWork
node_modules/react-dom/cjs/react-dom.development.js:16358

  16355 |   }
  16356 | } else {
  16357 |   while (nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime)) {
&gt; 16358 |     performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
  16359 |     findHighestPriorityRoot();
  16360 |   }
  16361 | }

performSyncWork
node_modules/react-dom/cjs/react-dom.development.js:16330

  16327 | }
  16328 | 
  16329 | function performSyncWork() {
&gt; 16330 |   performWork(Sync, false, null);
  16331 | }
  16332 | 
  16333 | function performWork(minExpirationTime, isAsync, dl) {

requestWork
node_modules/react-dom/cjs/react-dom.development.js:16230

  16227 | 
  16228 | // TODO: Get rid of Sync and use current time?
  16229 | if (expirationTime === Sync) {
&gt; 16230 |   performSyncWork();
  16231 | } else {
  16232 |   scheduleCallbackWithExpiration(expirationTime);
  16233 | }

scheduleWork$1
node_modules/react-dom/cjs/react-dom.development.js:16096

  16093 | !isWorking || isCommitting$1 ||
  16094 | // ...unless this is a different root than the one we're rendering.
  16095 | nextRoot !== root) {
&gt; 16096 |   requestWork(root, nextExpirationTimeToWorkOn);
  16097 | }
  16098 | if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {
  16099 |   invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');

scheduleRootUpdate
node_modules/react-dom/cjs/react-dom.development.js:16663

  16660 |   }
  16661 |   enqueueUpdate(current, update, expirationTime);
  16662 | 
&gt; 16663 |   scheduleWork$1(current, expirationTime);
  16664 |   return expirationTime;
  16665 | }
  16666 | 

updateContainerAtExpirationTime
node_modules/react-dom/cjs/react-dom.development.js:16690

  16687 |     container.pendingContext = context;
  16688 |   }
  16689 | 
&gt; 16690 |   return scheduleRootUpdate(current, element, expirationTime, callback);
  16691 | }
  16692 | 
  16693 | function findHostInstance(component) {

updateContainer
node_modules/react-dom/cjs/react-dom.development.js:16717

  16714 |   var current = container.current;
  16715 |   var currentTime = recalculateCurrentTime();
  16716 |   var expirationTime = computeExpirationForFiber(currentTime, current);
&gt; 16717 |   return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
  16718 | }
  16719 | 
  16720 | function getPublicRootInstance(container) {

./node_modules/react-dom/cjs/react-dom.development.js/ReactRoot.prototype.render
node_modules/react-dom/cjs/react-dom.development.js:17000

  16997 |   if (callback !== null) {
  16998 |     work.then(callback);
  16999 |   }
&gt; 17000 |   updateContainer(children, root, null, work._onCommit);
  17001 |   return work;
  17002 | };
  17003 | ReactRoot.prototype.unmount = function (callback) {

legacyRenderSubtreeIntoContainer/&lt;
node_modules/react-dom/cjs/react-dom.development.js:17140

  17137 |     if (parentComponent != null) {
  17138 |       root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
  17139 |     } else {
&gt; 17140 |       root.render(children, callback);
  17141 |     }
  17142 |   });
  17143 | } else {

unbatchedUpdates
node_modules/react-dom/cjs/react-dom.development.js:16557

  16554 |       isUnbatchingUpdates = false;
  16555 |     }
  16556 |   }
&gt; 16557 |   return fn(a);
  16558 | }
  16559 | 
  16560 | // TODO: Batching should be implemented at the renderer level, not within

legacyRenderSubtreeIntoContainer
node_modules/react-dom/cjs/react-dom.development.js:17136

  17133 |   };
  17134 | }
  17135 | // Initial mount should not be batched.
&gt; 17136 | unbatchedUpdates(function () {
  17137 |   if (parentComponent != null) {
  17138 |     root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
  17139 |   } else {

render
node_modules/react-dom/cjs/react-dom.development.js:17195

  17192 |   return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
  17193 | },
  17194 | render: function (element, container, callback) {
&gt; 17195 |   return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
  17196 | },
  17197 | unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
  17198 |   !(parentComponent != null &amp;&amp; has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;

./src/index.js
src/index.js:7

   4 | import App from './App';
   5 | import registerServiceWorker from './registerServiceWorker';
   6 | 
&gt;  7 | ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
   8 | registerServiceWorker();
   9 | 
  10 | 

This screen is visible only in development. It will not appear if the app crashes in production.
Open your browser’s developer console to further inspect this error
</code></pre>
",""
"50539698","how to unsubscribe from subscriptions and events in componentwillunmount?","1","<p>I have a component here and it seems there's a memory leak in there
because I am receiving the warning</p>

<pre><code>Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
</code></pre>

<p>I have read about it but I am not sure how exactly to do that.
Could you tell me how to cancel the events in the component or find the events that should be cancelled.
if you could point me to an article or guide that helps in understanding that would be very helpful too.</p>

<p>here's the code, for the component.</p>

<pre><code>import React, { Component } from ""react"";
import { Modal, Button, Icon, Select, Input, Row, Col, Spin } from ""antd"";
//import PDFJS from './pdf';
import styles from ""./EditPdfDetailsModal.less"";
const Option = Select.Option;
if (window.PDFJS) {
  const PDFJS = window.PDFJS;
  PDFJS.disableWorker = true;
}
export default class EditPdfDetailsModal extends Component {
  state = {
    file: this.props.item.file,
    categoryid: """",
    splitpdfData: """",
    urls: [],
    showSplitFiles: false,
    loading: false
  };

  showSplitFiles = () =&gt; {};

  editMergePdf = () =&gt; {
    var formData = new FormData();
    formData.append(""filepath"", this.props.item.pdfname);
    let editUrl = devUrl + ""trip/getpdfSplitViewtripdoc?json=true"";
    this.setState({ showSplitFiles: true, loading: true });
    var that = this;
    fetch(editUrl, {
      method: ""post"",
      credentials: ""include"",
      body: formData
    })
      .then(function(response) {
        return response.json();
      })
      .then(function(data) {
        let urls = [];
        for (var i = 0; i &lt; data.files.length; i++) {
          let fileurl =
            agencyLibPdfUrl + ""split/"" + data.dir + ""/"" + data.files[i];
          urls.push(fileurl);
        }
        that.setState({ splitpdfData: data, urls });
        //=================================
        if (window.PDFJS) {
          let newurl =
            ""http://172.104.60.70/st_old/uploads/defaultdocs/7/split/1527165241-42557/1_1527165241-42557.pdf"";
          console.log(""that.img"", that);
          PDFJS.getDocument(newurl).then(function getPdfHelloWorld(pdf) {
            //
            // Fetch the first page
            //
            pdf.getPage(1).then(function getPageHelloWorld(page) {
              var scale = 1.5;
              var viewport = page.getViewport(scale);

              //
              // Prepare canvas using PDF page dimensions
              //
              var canvas = that.img;
              var context = canvas.getContext(""2d"");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              //
              // Render PDF page into canvas context
              //
              page.render({ canvasContext: context, viewport: viewport });
            });
          });
        }

        //=================================

        //that.showSplitFiles();
        console.log(""data response : "", data);
        //return data;
      })
      .catch(err =&gt; console.log(err));
  };
  handleNameChange = e =&gt; {
    console.log(""name change : "", e.target.value);
    this.setState({ file: e.target.value });
  };
  handleChange = value =&gt; {
    console.log(""value selected : "", value);
    this.setState({ categoryid: value });
  };

  submitDetails = () =&gt; {
    var formData = new FormData();
    formData.append(""doc_id"", this.props.item.docid);
    formData.append(""docname"", this.state.file);
    formData.append(""id"", this.props.item.docid);
    formData.append(""tripid"", this.props.item.tripid);
    formData.append(""doctype"", ""important"");
    formData.append(""categoryid"", this.state.categoryid);
    formData.append(""submit"", ""Submit"");

    let submitUrl =
      devUrl + ""trip/editDocument/"" + this.props.item.tripid + ""?json=true"";
    var that = this;
    fetch(submitUrl, {
      method: ""post"",
      credentials: ""include"",
      body: formData
    })
      .then(function(response) {
        return response.json();
      })
      .then(function(data) {
        that.props.getUpdatedData();
        that.props.closeModal();
        console.log(""data response : "", data);
        //return data;
      })
      .catch(err =&gt; console.log(err));
  };

  componentWillUnmount() {}

  render() {
    var styling = ""styles.vertical-center-modal"";
    let item = this.props.item;
    let categories = this.props.impcategories;
    let categoryOptions = [];
    categories.map((item, index) =&gt; {
      let option = (
        &lt;Option key={index} value={item.categoryid}&gt;
          {"" ""}
          {item.categoryname}{"" ""}
        &lt;/Option&gt;
      );
      categoryOptions.push(option);
    });
    /*  if(this.state.urls.length&gt;0){
       if(window.PDFJS){

            PDFJS.getDocument(this.state.urls[0]).then(function getPdfHelloWorld(pdf) {
                 //
                 // Fetch the first page
                 //
                 pdf.getPage(1).then(function getPageHelloWorld(page) {
                   var scale = 1.5;
                   var viewport = page.getViewport(scale);

                   //
                   // Prepare canvas using PDF page dimensions
                   //
                   var canvas = this.img;
                   var context = canvas.getContext('2d');
                   canvas.height = viewport.height;
                   canvas.width = viewport.width;

                   //
                   // Render PDF page into canvas context
                   //
                   page.render({canvasContext: context, viewport: viewport});
                 });
               });
        }
     }*/
    let formStyle = { height: ""200px"", width: ""550px"" };
    let splitPdfStyle = { height: ""400px"", width: ""600px"" };
    return (
      &lt;Modal
        visible={this.props.showModal}
        wrapClassName={styling}
        onCancel={this.props.closeModal}
        zIndex={1100}
        bodyStyle={this.state.showSplitFiles ? splitPdfStyle : formStyle}
        footer={[
          &lt;Button
            key=""submit""
            type=""primary""
            onClick={this.submitDetails.bind(this)}
          &gt;
            Submit
          &lt;/Button&gt;
        ]}
      &gt;
        {this.state.showSplitFiles ? (
          &lt;div&gt;
            {!this.state.loading ? (
              &lt;Spin
                style={{ width: ""100%"", margin: ""0 auto"" }}
                tip=""Loading Pdf...""
              /&gt;
            ) : (
              &lt;div&gt;
                show files here&lt;br /&gt;
                &lt;canvas ref={el =&gt; (this.img = el)}&gt; &lt;/canvas&gt;
              &lt;/div&gt;
            )}{"" ""}
          &lt;/div&gt;
        ) : (
          &lt;div&gt;
            &lt;Row gutter={24}&gt;
              &lt;Col md={12} lg={12} xl={12}&gt;
                Category Name:&lt;br /&gt;
                &lt;Select
                  //defaultValue={item.type}
                  placeholder=""Please Select""
                  style={{ width: 220 }}
                  onChange={this.handleChange}
                  getPopupContainer={triggerNode =&gt; triggerNode.parentNode}
                &gt;
                  {categoryOptions}
                &lt;/Select&gt;
              &lt;/Col&gt;
              &lt;Col md={12} lg={12} xl={12}&gt;
                Document Name &lt;br /&gt;{"" ""}
                &lt;Input
                  onChange={this.handleNameChange}
                  placeholder=""Basic usage""
                  value={this.state.file}
                  style={{ width: ""200px"" }}
                /&gt;
              &lt;/Col&gt;
            &lt;/Row&gt;

            &lt;Row&gt;
              &lt;Col&gt;
                {"" ""}
                &lt;div className={styles.buttons}&gt;
                  &lt;Button type=""primary""&gt;Replace Pdf &lt;/Button&gt;
                  &lt;Button onClick={this.editMergePdf.bind(this)} type=""primary""&gt;
                    Edit/Merge Pdf{"" ""}
                  &lt;/Button&gt;
                &lt;/div&gt;{"" ""}
              &lt;/Col&gt;
              &lt;canvas ref={el =&gt; (this.imgs = el)}&gt; &lt;/canvas&gt;
            &lt;/Row&gt;
          &lt;/div&gt;
        )}
      &lt;/Modal&gt;
    );
  }
}
</code></pre>

<p>I looked around for how to cancel the subscriptions but not sure how exactly to do that.
for example I have a click event on a button.
how do I cancel that event ?
and do I need to cancel onchange events too?</p>
","Possible duplicate of [setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op](https://stackoverflow.com/questions/34544314/setstate-can-only-update-a-mounted-or-mounting-component-this-usually-mea)"
"50717218","Calling setState on an unmounted component","3","<p>In a lot of my components I need to do something like this:</p>

<pre><code>handleSubmit() {
  this.setState({loading: true})
  someAsyncFunc()
    .then(() =&gt; {
      return this.props.onSuccess()
    })
    .finally(() =&gt; this.setState({loading: false}))
}
</code></pre>

<p>The <code>onSuccess</code> function</p>

<ul>
<li>may or may not be a promise (if it is, <code>loading</code> should stay true until it is resolved)</li>
<li>may or may not unmount the component (it may close the modal this component is in or even navigate to different page)</li>
</ul>

<p>If the function unmounts the component, <code>this.setState({loading: false})</code> obviously triggers a warning <code>Can't call setState (or forceUpdate) on an unmounted component.</code></p>

<p>My 2 questions:</p>

<ol>
<li>Is there a simple way to avoid the issue ? I don't want to set some <code>_isMounted</code> variable in <code>componentDidMount</code> and <code>componentWillUnmount</code> and then check it when needed in most of my components, plus I may forget to do it next time writing something like this ...</li>
<li>Is it really a problem ? I know that, according to the warning, <code>it indicates a memory leak in my application</code>, but it is not a memory leak in this case, is it ? Maybe ignoring the warning would be ok ...</li>
</ol>

<p>EDIT: The second question is a little bit more important for me than the first. If this really is a problem and I just can't call <code>setState</code> on unmounted component, I'd probably find some workaround myself. But I am curious if I can't just ignore it.</p>

<p>Live example of the problem:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const someAsyncFunc = () =&gt; new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
  	console.log(""someAsyncFunc resolving"");
    resolve(""done"");
  }, 2000);
});

class Example extends React.Component {
  constructor(...args) {
    super(...args);
    this.state = {loading: false};
  }
  
  componentDidMount() {
    setTimeout(() =&gt; this.handleSubmit(), 100);
  }
  
  handleSubmit() {
    this.setState({loading: true})
    someAsyncFunc()
      /*
      .then(() =&gt; {
        return this.props.onSuccess()
      })
      */
      .finally(() =&gt; this.setState({loading: false}))
  }
  
  render() {
    return &lt;div&gt;{String(this.state.loading)}&lt;/div&gt;;
  }
}

class Wrapper extends React.Component {
	constructor(props, ...rest) {
  	super(props, ...rest);
    this.state = {
    	children: props.children
    };
  }
	componentDidMount() {
  	setTimeout(() =&gt; {
    	console.log(""removing"");
    	this.setState({children: []});
    }, 1500)
  }
	render() {
  	return &lt;div&gt;{this.state.children}&lt;/div&gt;;
  }
}

ReactDOM.render(
	&lt;Wrapper&gt;
    &lt;Example /&gt;
	&lt;/Wrapper&gt;,
  document.getElementById(""root"")
);</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper {
  max-height: 100% !important;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div id=""root""&gt;&lt;/div&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","Possible duplicate of [React - setState() on unmounted component](https://stackoverflow.com/questions/32903001/react-setstate-on-unmounted-component)"
"50717218","Calling setState on an unmounted component","3","<p>In a lot of my components I need to do something like this:</p>

<pre><code>handleSubmit() {
  this.setState({loading: true})
  someAsyncFunc()
    .then(() =&gt; {
      return this.props.onSuccess()
    })
    .finally(() =&gt; this.setState({loading: false}))
}
</code></pre>

<p>The <code>onSuccess</code> function</p>

<ul>
<li>may or may not be a promise (if it is, <code>loading</code> should stay true until it is resolved)</li>
<li>may or may not unmount the component (it may close the modal this component is in or even navigate to different page)</li>
</ul>

<p>If the function unmounts the component, <code>this.setState({loading: false})</code> obviously triggers a warning <code>Can't call setState (or forceUpdate) on an unmounted component.</code></p>

<p>My 2 questions:</p>

<ol>
<li>Is there a simple way to avoid the issue ? I don't want to set some <code>_isMounted</code> variable in <code>componentDidMount</code> and <code>componentWillUnmount</code> and then check it when needed in most of my components, plus I may forget to do it next time writing something like this ...</li>
<li>Is it really a problem ? I know that, according to the warning, <code>it indicates a memory leak in my application</code>, but it is not a memory leak in this case, is it ? Maybe ignoring the warning would be ok ...</li>
</ol>

<p>EDIT: The second question is a little bit more important for me than the first. If this really is a problem and I just can't call <code>setState</code> on unmounted component, I'd probably find some workaround myself. But I am curious if I can't just ignore it.</p>

<p>Live example of the problem:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const someAsyncFunc = () =&gt; new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
  	console.log(""someAsyncFunc resolving"");
    resolve(""done"");
  }, 2000);
});

class Example extends React.Component {
  constructor(...args) {
    super(...args);
    this.state = {loading: false};
  }
  
  componentDidMount() {
    setTimeout(() =&gt; this.handleSubmit(), 100);
  }
  
  handleSubmit() {
    this.setState({loading: true})
    someAsyncFunc()
      /*
      .then(() =&gt; {
        return this.props.onSuccess()
      })
      */
      .finally(() =&gt; this.setState({loading: false}))
  }
  
  render() {
    return &lt;div&gt;{String(this.state.loading)}&lt;/div&gt;;
  }
}

class Wrapper extends React.Component {
	constructor(props, ...rest) {
  	super(props, ...rest);
    this.state = {
    	children: props.children
    };
  }
	componentDidMount() {
  	setTimeout(() =&gt; {
    	console.log(""removing"");
    	this.setState({children: []});
    }, 1500)
  }
	render() {
  	return &lt;div&gt;{this.state.children}&lt;/div&gt;;
  }
}

ReactDOM.render(
	&lt;Wrapper&gt;
    &lt;Example /&gt;
	&lt;/Wrapper&gt;,
  document.getElementById(""root"")
);</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper {
  max-height: 100% !important;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div id=""root""&gt;&lt;/div&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","@RIYAJKHAN As I wrote: the `onSuccess` function **may or may not unmount the component** - in some cases, the modal should stay open, without loading of course ..."
"50717218","Calling setState on an unmounted component","3","<p>In a lot of my components I need to do something like this:</p>

<pre><code>handleSubmit() {
  this.setState({loading: true})
  someAsyncFunc()
    .then(() =&gt; {
      return this.props.onSuccess()
    })
    .finally(() =&gt; this.setState({loading: false}))
}
</code></pre>

<p>The <code>onSuccess</code> function</p>

<ul>
<li>may or may not be a promise (if it is, <code>loading</code> should stay true until it is resolved)</li>
<li>may or may not unmount the component (it may close the modal this component is in or even navigate to different page)</li>
</ul>

<p>If the function unmounts the component, <code>this.setState({loading: false})</code> obviously triggers a warning <code>Can't call setState (or forceUpdate) on an unmounted component.</code></p>

<p>My 2 questions:</p>

<ol>
<li>Is there a simple way to avoid the issue ? I don't want to set some <code>_isMounted</code> variable in <code>componentDidMount</code> and <code>componentWillUnmount</code> and then check it when needed in most of my components, plus I may forget to do it next time writing something like this ...</li>
<li>Is it really a problem ? I know that, according to the warning, <code>it indicates a memory leak in my application</code>, but it is not a memory leak in this case, is it ? Maybe ignoring the warning would be ok ...</li>
</ol>

<p>EDIT: The second question is a little bit more important for me than the first. If this really is a problem and I just can't call <code>setState</code> on unmounted component, I'd probably find some workaround myself. But I am curious if I can't just ignore it.</p>

<p>Live example of the problem:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const someAsyncFunc = () =&gt; new Promise(resolve =&gt; {
  setTimeout(() =&gt; {
  	console.log(""someAsyncFunc resolving"");
    resolve(""done"");
  }, 2000);
});

class Example extends React.Component {
  constructor(...args) {
    super(...args);
    this.state = {loading: false};
  }
  
  componentDidMount() {
    setTimeout(() =&gt; this.handleSubmit(), 100);
  }
  
  handleSubmit() {
    this.setState({loading: true})
    someAsyncFunc()
      /*
      .then(() =&gt; {
        return this.props.onSuccess()
      })
      */
      .finally(() =&gt; this.setState({loading: false}))
  }
  
  render() {
    return &lt;div&gt;{String(this.state.loading)}&lt;/div&gt;;
  }
}

class Wrapper extends React.Component {
	constructor(props, ...rest) {
  	super(props, ...rest);
    this.state = {
    	children: props.children
    };
  }
	componentDidMount() {
  	setTimeout(() =&gt; {
    	console.log(""removing"");
    	this.setState({children: []});
    }, 1500)
  }
	render() {
  	return &lt;div&gt;{this.state.children}&lt;/div&gt;;
  }
}

ReactDOM.render(
	&lt;Wrapper&gt;
    &lt;Example /&gt;
	&lt;/Wrapper&gt;,
  document.getElementById(""root"")
);</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.as-console-wrapper {
  max-height: 100% !important;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div id=""root""&gt;&lt;/div&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","In component modal closing and navigation,why you need loading false?Anyway the state associated with it going to destroy"
"50727041","Can't call setState (or forceUpdate) on an unmounted component. Memory leak on react-image-gallery","1","<p>I've been trying to implement the react-image-gallery v0.8.7 (0.8.8 has a <a href=""https://github.com/xiaolin/react-image-gallery/issues/288"" rel=""nofollow noreferrer"">bug</a>) from this npm package: <a href=""http://I&#39;ve%20been%20trying%20to%20implement%20the%20react-image-gallery%20from%20this%20npm%20package:%20https://github.com/xiaolin/react-image-gallery"" rel=""nofollow noreferrer"">https://github.com/xiaolin/react-image-gallery</a> and integrated following the <a href=""https://github.com/xiaolin/react-image-gallery#example"" rel=""nofollow noreferrer"">example</a> as follows (I am developing a Meteor web app):</p>

<pre><code>class MyGallery extends Component {
    constructor(props) {
    super(props);
    this.state = {
      mediaSrc: [],
      isFullScreen: false
    };
  }

  componentWillMount() {
    const mediaSrc = this.props.myObject.pictures.map((picture) =&gt; {
      return { original: picture, thumbnail: picture };
    });
    this.setState({ mediaSrc });
  }

  _onImageClick(event) {
    if (this.state.isFullScreen) {
      this._imageGallery.exitFullScreen();
      this.setState({ isFullScreen: false });
    } else {
      this._imageGallery.fullScreen();
      this.setState({ isFullScreen: true });
    }
  }

  render() {
    return (
      &lt;div className=""dish row""&gt;
        &lt;figure className=""center col-12"" &gt;
          &lt;div className=""dish__preview_container""&gt;
            &lt;ImageGallery
              ref={i =&gt; this._imageGallery = i}
              items={this.state.mediaSrc}
              onClick={this._onImageClick.bind(this)}
              showFullscreenButton={false}
              showIndex
              showPlayButton={false}
              showThumbnails={false}
            /&gt;
         &lt;/div&gt;
      );
  }
}

MyGallery.propTypes = {
  myObject: PropTypes.object.isRequired,
}

}
</code></pre>

<p>The object <code>myObject</code> contains the following value in the pictures array:</p>

<pre><code>[ 'https://media-cdn.tripadvisor.com/media/photo-s/05/6c/2b/9b/america-s-taco-shop.jpg',
  'https://www.cocinavital.mx/wp-content/uploads/2017/09/tostadas-de-tinga-de-pechuga-de-pollo-con-chipotle-video.jpg'
]
</code></pre>

<p>When rendering the ImageGallery is shown as expected, however when clicking on either the button aria-label=""Previous Slide"" or aria-label=""Next Slide"", doesn't show the respective image and throws the following exception on the developer tools console:</p>

<pre><code>Warning: Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
    in ImageGallery (created by MyGallery)
    in div (created by MyGallery)
</code></pre>

<p>Any suggestions for a solution, please?</p>

<p>Update: Had a reset of component state variables on the componenteWillUmnount method. Removed it, also tried with <a href=""https://atmospherejs.com/meteor/reactive-dict"" rel=""nofollow noreferrer"">Meteor Reactive Dic</a>t instead of component state variables. The exception remains, though.</p>
","Most likely caused by your `componentWillUnmount`. It looks like you're trying to ""reset"" the components state, but since the component is being unmounted, it will use the initial state in your constructor the next time it loads. So your reset here isn't necessary."
"50729880","Do react render props cause remounting of the child components?","0","<p>I was just wondering if people know if using the ""render props"" pattern causes excessive mounting/unmounting of the child component. 
For example, adapting from the react docs (<a href=""https://reactjs.org/docs/render-props.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/render-props.html</a>): </p>

<pre><code>&lt;Mouse&gt;
{mouse =&gt; (
    &lt;ShowMousePosition mouse={mouse}/&gt;
  )}
&lt;/Mouse&gt;


class ShowMousePosition extends React.Component {
  componentDidMount(){
    console.log('mounting!')
  }
  render () {
    const {mouse} = this.props
    return (
      &lt;p&gt;The mouse position is {mouse.x}, {mouse.y}&lt;/p&gt;
    )
  }
}
</code></pre>

<p>I know the react docs say:</p>

<blockquote>
  <p>Using a render prop can negate the advantage that comes from using React.PureComponent if you create the function inside a render method. This is because the shallow prop comparison will always return false for new props, and each render in this case will generate a new value for the render prop.</p>
</blockquote>

<p>But, will ""mounting!"" be called over and over as the user moves the mouse around? </p>

<p>Thanks!</p>
",""
"50785159","Reset react-day-picker state after re-render","3","<p>So basically in my app I have a funcionality to create new events by filling up a form.</p>

<p>Unfortunately the problem is that I have a <code>DayPicker</code> component with multi select from <a href=""https://react-day-picker.js.org/examples/selected-multiple"" rel=""nofollow noreferrer"">https://react-day-picker.js.org/examples/selected-multiple</a> and I would like to clear it state on unmount because I want to have new empty calendar in every new form. Without that <code>DayPicker</code> rememebrs old state.</p>

<p>I am also using <code>redux-form</code> from  <a href=""https://redux-form.com/7.3.0/docs/gettingstarted.md/"" rel=""nofollow noreferrer"">https://redux-form.com/7.3.0/docs/gettingstarted.md/</a> </p>

<p>Any ideas how I could achieve that ?</p>

<p><code>MultiDayPicker</code></p>

<pre><code>import React, {Component} from 'react';
import DayPicker, {DateUtils} from 'react-day-picker';
import PropTypes from 'prop-types';

import 'react-day-picker/lib/style.css';

export default class MultiDayPicker extends Component {

  state = {
    selectedDays: []
  };

  handleDayClick = (day, {selected}) =&gt; {
    const {selectedDays} = this.state;

    if (selected) {
      const selectedIndex = selectedDays.findIndex(selectedDay =&gt;
        DateUtils.isSameDay(selectedDay, day)
      );

      selectedDays.splice(selectedIndex, 1);
    } else {
      selectedDays.push(day);
    }

    this.setState({selectedDays});
    this.props.input.onChange(selectedDays);
  };

  render() {
    return (
      &lt;div&gt;
        &lt;DayPicker
          selectedDays={this.state.selectedDays}
          onDayClick={this.handleDayClick}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
","Share some code"
"50785159","Reset react-day-picker state after re-render","3","<p>So basically in my app I have a funcionality to create new events by filling up a form.</p>

<p>Unfortunately the problem is that I have a <code>DayPicker</code> component with multi select from <a href=""https://react-day-picker.js.org/examples/selected-multiple"" rel=""nofollow noreferrer"">https://react-day-picker.js.org/examples/selected-multiple</a> and I would like to clear it state on unmount because I want to have new empty calendar in every new form. Without that <code>DayPicker</code> rememebrs old state.</p>

<p>I am also using <code>redux-form</code> from  <a href=""https://redux-form.com/7.3.0/docs/gettingstarted.md/"" rel=""nofollow noreferrer"">https://redux-form.com/7.3.0/docs/gettingstarted.md/</a> </p>

<p>Any ideas how I could achieve that ?</p>

<p><code>MultiDayPicker</code></p>

<pre><code>import React, {Component} from 'react';
import DayPicker, {DateUtils} from 'react-day-picker';
import PropTypes from 'prop-types';

import 'react-day-picker/lib/style.css';

export default class MultiDayPicker extends Component {

  state = {
    selectedDays: []
  };

  handleDayClick = (day, {selected}) =&gt; {
    const {selectedDays} = this.state;

    if (selected) {
      const selectedIndex = selectedDays.findIndex(selectedDay =&gt;
        DateUtils.isSameDay(selectedDay, day)
      );

      selectedDays.splice(selectedIndex, 1);
    } else {
      selectedDays.push(day);
    }

    this.setState({selectedDays});
    this.props.input.onChange(selectedDays);
  };

  render() {
    return (
      &lt;div&gt;
        &lt;DayPicker
          selectedDays={this.state.selectedDays}
          onDayClick={this.handleDayClick}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
","You're modifying state directly.. you need to copy the state before mutating it"
"50785159","Reset react-day-picker state after re-render","3","<p>So basically in my app I have a funcionality to create new events by filling up a form.</p>

<p>Unfortunately the problem is that I have a <code>DayPicker</code> component with multi select from <a href=""https://react-day-picker.js.org/examples/selected-multiple"" rel=""nofollow noreferrer"">https://react-day-picker.js.org/examples/selected-multiple</a> and I would like to clear it state on unmount because I want to have new empty calendar in every new form. Without that <code>DayPicker</code> rememebrs old state.</p>

<p>I am also using <code>redux-form</code> from  <a href=""https://redux-form.com/7.3.0/docs/gettingstarted.md/"" rel=""nofollow noreferrer"">https://redux-form.com/7.3.0/docs/gettingstarted.md/</a> </p>

<p>Any ideas how I could achieve that ?</p>

<p><code>MultiDayPicker</code></p>

<pre><code>import React, {Component} from 'react';
import DayPicker, {DateUtils} from 'react-day-picker';
import PropTypes from 'prop-types';

import 'react-day-picker/lib/style.css';

export default class MultiDayPicker extends Component {

  state = {
    selectedDays: []
  };

  handleDayClick = (day, {selected}) =&gt; {
    const {selectedDays} = this.state;

    if (selected) {
      const selectedIndex = selectedDays.findIndex(selectedDay =&gt;
        DateUtils.isSameDay(selectedDay, day)
      );

      selectedDays.splice(selectedIndex, 1);
    } else {
      selectedDays.push(day);
    }

    this.setState({selectedDays});
    this.props.input.onChange(selectedDays);
  };

  render() {
    return (
      &lt;div&gt;
        &lt;DayPicker
          selectedDays={this.state.selectedDays}
          onDayClick={this.handleDayClick}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
","@AbidHasan here you go"
"50823024","ESLint throwing no-unused-vars for reactjs data component","0","<p>Does anyone know how to resolve this linting issue? It's claiming that I'm not using the TasksComponent. Thanks!</p>

<blockquote>
  <p>'TasksComponent' is assigned a value but never used. (no-unused-vars)</p>
</blockquote>

<pre><code>describe('root tests', () =&gt; {

    it('renders without crashing', () =&gt; {
        const TasksComponent = TasksWithData(Tasks);
        const root = document.createElement('root');
        ReactDOM.render(&lt;TasksComponent {...taskconfig} /&gt;, root);
        ReactDOM.unmountComponentAtNode(root);
    });

});
</code></pre>

<p>This is my .eslintrc file:</p>

<pre><code>module.exports = {
    ""env"": {
        ""browser"": true,
        ""es6"": true,
        ""jest"": true
    },
    ""extends"": ""eslint:recommended"",
    ""parserOptions"": {
        ""ecmaFeatures"": {
            ""experimentalObjectRestSpread"": true,
            ""jsx"": true
        },
        ""sourceType"": ""module""
    },
    ""plugins"": [
        ""react""
    ],
    ""rules"": {
        ""indent"": [
            ""error"",
            4
        ],
        ""quotes"": [
            ""warn"",
            ""single""
        ],
        ""semi"": [
            ""error"",
            ""always""
        ]
    }
};
</code></pre>
",""
"50876083","How do I transmit a state to a parent component when clicking a react-router Link?","4","<p>I want to build a single page application that works with transitions, that would look like follows:</p>

<pre><code>*------*--------------*-----------*
|      |              |           |
| Shop | Landing Page | Biography |
|      |              |           |
*------*--------------*-----------*
|                                 |
|          Contact page           |
|                                 |
*---------------------------------*
</code></pre>

<p>Basically, when you first come on the website, you arrive on the landing screen. From there, 3 links are available, 'Biography', 'Shop' and 'Contact' ('Contact' is available from the three 'top' pages).</p>

<p>Once you click on the link to go to either 'Shop' or 'Biography', you can go back to the landing or go to the contact page, but you can't go the the ""opposite"" page (hence the schema). Also, when you get to contact page and click 'back', you'll get to the last page you were before.</p>

<p>I created a <a href=""https://codesandbox.io/embed/509q79zpxl"" rel=""nofollow noreferrer"">CodeSandBox</a> to avoid pasting half a kilometer of code that don't necessarly have anything to do with this but are still a bit concerned</p>

<p>So I would like to be able to precisely setup my transitions, like going from left to right when going to 'Biography' (and the opposite when leaving), right to left when going to ""Shop"", and bottom to top when going to the contact form.</p>

<p>After reading tons of issues and documentations about <code>react-transition-group</code>, I had the idea of doing something like this:</p>

<pre><code>// src/App.js
const PageFade = props =&gt; (
  // props.transition would contain ""topBottom"", ""bottomTop"", ""leftRight"" and ""rightLeft"" 
  // (so that I would ajust my CSS in consequence)
  {props.transition === 'topBottom' &amp;&amp;
  &lt;CSSTransition
    {...props}
    classNames={props.transition !== null &amp;&amp; props.transition}
    timeout={1000}
    mountOnEnter={true}
    unmountOnExit={true}
  /&gt;
  }
);
}
</code></pre>

<p>I could do this or create a <code>&lt;CSSTransition /&gt;</code> for each possibility, I don't really know.</p>

<p>My problem is that I need to tell this <code>&lt;CSSTransition /&gt;</code> either what  have been clicked or (better) what transition it needs to display.</p>

<p>To do so, I tried to set a <code>transition</code> state, but it looks like it gets too much refreshed, and my knowledge of React is rusty, and I don't know how to handle all this with react-route.</p>

<p><strong>Update</strong></p>

<p>Thank you all for your answers, and sorry for not answering faster, my computer is freezing beyond madness.</p>

<p>So I created a new class <code>CSSTransitions</code> where I copied / pasted @brandon's answer while adapting it to my needs.
However, I have a problem with the <code>componentWillReceiveProps(nextProps)</code>, because it nextProps.location is null, somehow, the react-router's context isn't passed.</p>

<p>I updated my CodeSandBox, the <code>CSSTransitions</code> class is in an 'utils' directory inside the 'src' directory.</p>

<p>Thank you again for your answers</p>

<p>Thank you in advance</p>
","I posted an answer, but Brandon's answer is better than mine, because he uses react-router link, as the OP required. My answer focus more on how to pass a value up, but ignores the react-router link part completely."
"50876083","How do I transmit a state to a parent component when clicking a react-router Link?","4","<p>I want to build a single page application that works with transitions, that would look like follows:</p>

<pre><code>*------*--------------*-----------*
|      |              |           |
| Shop | Landing Page | Biography |
|      |              |           |
*------*--------------*-----------*
|                                 |
|          Contact page           |
|                                 |
*---------------------------------*
</code></pre>

<p>Basically, when you first come on the website, you arrive on the landing screen. From there, 3 links are available, 'Biography', 'Shop' and 'Contact' ('Contact' is available from the three 'top' pages).</p>

<p>Once you click on the link to go to either 'Shop' or 'Biography', you can go back to the landing or go to the contact page, but you can't go the the ""opposite"" page (hence the schema). Also, when you get to contact page and click 'back', you'll get to the last page you were before.</p>

<p>I created a <a href=""https://codesandbox.io/embed/509q79zpxl"" rel=""nofollow noreferrer"">CodeSandBox</a> to avoid pasting half a kilometer of code that don't necessarly have anything to do with this but are still a bit concerned</p>

<p>So I would like to be able to precisely setup my transitions, like going from left to right when going to 'Biography' (and the opposite when leaving), right to left when going to ""Shop"", and bottom to top when going to the contact form.</p>

<p>After reading tons of issues and documentations about <code>react-transition-group</code>, I had the idea of doing something like this:</p>

<pre><code>// src/App.js
const PageFade = props =&gt; (
  // props.transition would contain ""topBottom"", ""bottomTop"", ""leftRight"" and ""rightLeft"" 
  // (so that I would ajust my CSS in consequence)
  {props.transition === 'topBottom' &amp;&amp;
  &lt;CSSTransition
    {...props}
    classNames={props.transition !== null &amp;&amp; props.transition}
    timeout={1000}
    mountOnEnter={true}
    unmountOnExit={true}
  /&gt;
  }
);
}
</code></pre>

<p>I could do this or create a <code>&lt;CSSTransition /&gt;</code> for each possibility, I don't really know.</p>

<p>My problem is that I need to tell this <code>&lt;CSSTransition /&gt;</code> either what  have been clicked or (better) what transition it needs to display.</p>

<p>To do so, I tried to set a <code>transition</code> state, but it looks like it gets too much refreshed, and my knowledge of React is rusty, and I don't know how to handle all this with react-route.</p>

<p><strong>Update</strong></p>

<p>Thank you all for your answers, and sorry for not answering faster, my computer is freezing beyond madness.</p>

<p>So I created a new class <code>CSSTransitions</code> where I copied / pasted @brandon's answer while adapting it to my needs.
However, I have a problem with the <code>componentWillReceiveProps(nextProps)</code>, because it nextProps.location is null, somehow, the react-router's context isn't passed.</p>

<p>I updated my CodeSandBox, the <code>CSSTransitions</code> class is in an 'utils' directory inside the 'src' directory.</p>

<p>Thank you again for your answers</p>

<p>Thank you in advance</p>
","I'll post as an answer."
"50876083","How do I transmit a state to a parent component when clicking a react-router Link?","4","<p>I want to build a single page application that works with transitions, that would look like follows:</p>

<pre><code>*------*--------------*-----------*
|      |              |           |
| Shop | Landing Page | Biography |
|      |              |           |
*------*--------------*-----------*
|                                 |
|          Contact page           |
|                                 |
*---------------------------------*
</code></pre>

<p>Basically, when you first come on the website, you arrive on the landing screen. From there, 3 links are available, 'Biography', 'Shop' and 'Contact' ('Contact' is available from the three 'top' pages).</p>

<p>Once you click on the link to go to either 'Shop' or 'Biography', you can go back to the landing or go to the contact page, but you can't go the the ""opposite"" page (hence the schema). Also, when you get to contact page and click 'back', you'll get to the last page you were before.</p>

<p>I created a <a href=""https://codesandbox.io/embed/509q79zpxl"" rel=""nofollow noreferrer"">CodeSandBox</a> to avoid pasting half a kilometer of code that don't necessarly have anything to do with this but are still a bit concerned</p>

<p>So I would like to be able to precisely setup my transitions, like going from left to right when going to 'Biography' (and the opposite when leaving), right to left when going to ""Shop"", and bottom to top when going to the contact form.</p>

<p>After reading tons of issues and documentations about <code>react-transition-group</code>, I had the idea of doing something like this:</p>

<pre><code>// src/App.js
const PageFade = props =&gt; (
  // props.transition would contain ""topBottom"", ""bottomTop"", ""leftRight"" and ""rightLeft"" 
  // (so that I would ajust my CSS in consequence)
  {props.transition === 'topBottom' &amp;&amp;
  &lt;CSSTransition
    {...props}
    classNames={props.transition !== null &amp;&amp; props.transition}
    timeout={1000}
    mountOnEnter={true}
    unmountOnExit={true}
  /&gt;
  }
);
}
</code></pre>

<p>I could do this or create a <code>&lt;CSSTransition /&gt;</code> for each possibility, I don't really know.</p>

<p>My problem is that I need to tell this <code>&lt;CSSTransition /&gt;</code> either what  have been clicked or (better) what transition it needs to display.</p>

<p>To do so, I tried to set a <code>transition</code> state, but it looks like it gets too much refreshed, and my knowledge of React is rusty, and I don't know how to handle all this with react-route.</p>

<p><strong>Update</strong></p>

<p>Thank you all for your answers, and sorry for not answering faster, my computer is freezing beyond madness.</p>

<p>So I created a new class <code>CSSTransitions</code> where I copied / pasted @brandon's answer while adapting it to my needs.
However, I have a problem with the <code>componentWillReceiveProps(nextProps)</code>, because it nextProps.location is null, somehow, the react-router's context isn't passed.</p>

<p>I updated my CodeSandBox, the <code>CSSTransitions</code> class is in an 'utils' directory inside the 'src' directory.</p>

<p>Thank you again for your answers</p>

<p>Thank you in advance</p>
","Why don't you pass a callback from the parent component to `CSSTransition`? Then you could associate this callback with a onClick event and send information up."
"50876083","How do I transmit a state to a parent component when clicking a react-router Link?","4","<p>I want to build a single page application that works with transitions, that would look like follows:</p>

<pre><code>*------*--------------*-----------*
|      |              |           |
| Shop | Landing Page | Biography |
|      |              |           |
*------*--------------*-----------*
|                                 |
|          Contact page           |
|                                 |
*---------------------------------*
</code></pre>

<p>Basically, when you first come on the website, you arrive on the landing screen. From there, 3 links are available, 'Biography', 'Shop' and 'Contact' ('Contact' is available from the three 'top' pages).</p>

<p>Once you click on the link to go to either 'Shop' or 'Biography', you can go back to the landing or go to the contact page, but you can't go the the ""opposite"" page (hence the schema). Also, when you get to contact page and click 'back', you'll get to the last page you were before.</p>

<p>I created a <a href=""https://codesandbox.io/embed/509q79zpxl"" rel=""nofollow noreferrer"">CodeSandBox</a> to avoid pasting half a kilometer of code that don't necessarly have anything to do with this but are still a bit concerned</p>

<p>So I would like to be able to precisely setup my transitions, like going from left to right when going to 'Biography' (and the opposite when leaving), right to left when going to ""Shop"", and bottom to top when going to the contact form.</p>

<p>After reading tons of issues and documentations about <code>react-transition-group</code>, I had the idea of doing something like this:</p>

<pre><code>// src/App.js
const PageFade = props =&gt; (
  // props.transition would contain ""topBottom"", ""bottomTop"", ""leftRight"" and ""rightLeft"" 
  // (so that I would ajust my CSS in consequence)
  {props.transition === 'topBottom' &amp;&amp;
  &lt;CSSTransition
    {...props}
    classNames={props.transition !== null &amp;&amp; props.transition}
    timeout={1000}
    mountOnEnter={true}
    unmountOnExit={true}
  /&gt;
  }
);
}
</code></pre>

<p>I could do this or create a <code>&lt;CSSTransition /&gt;</code> for each possibility, I don't really know.</p>

<p>My problem is that I need to tell this <code>&lt;CSSTransition /&gt;</code> either what  have been clicked or (better) what transition it needs to display.</p>

<p>To do so, I tried to set a <code>transition</code> state, but it looks like it gets too much refreshed, and my knowledge of React is rusty, and I don't know how to handle all this with react-route.</p>

<p><strong>Update</strong></p>

<p>Thank you all for your answers, and sorry for not answering faster, my computer is freezing beyond madness.</p>

<p>So I created a new class <code>CSSTransitions</code> where I copied / pasted @brandon's answer while adapting it to my needs.
However, I have a problem with the <code>componentWillReceiveProps(nextProps)</code>, because it nextProps.location is null, somehow, the react-router's context isn't passed.</p>

<p>I updated my CodeSandBox, the <code>CSSTransitions</code> class is in an 'utils' directory inside the 'src' directory.</p>

<p>Thank you again for your answers</p>

<p>Thank you in advance</p>
","Sounds promising, but... How do I do that?"
"50946950","How to destroy root Preact node?","0","<p>I want to destroy the root Preact DOM node. I initially render my component as follows:</p>

<pre><code>import { h, render } from 'preact';
import App from ""./components/App"";

render(&lt;App /&gt;, document.querySelector(""#app"");
</code></pre>

<p>How do I destroy <code>App</code>? Do I simply unmount the <code>#app</code> DOM node, or does Preact offer a method similar to React's <a href=""https://reactjs.org/docs/react-dom.html#unmountcomponentatnode"" rel=""nofollow noreferrer""><code>unmountComponentAtNode()</code></a> method?</p>
",""
"51088515","Test fails when using LinkContainer from react-router-bootstrap","0","<p>So I am making a ReactJS app which includes reactstrap, react-router and react-router-bootstrap. The problem is that when I test components which contain LinkContainer, the following error occurs, making my unit tests fail:</p>

<blockquote>
  <p>console.error node_modules\prop-types\checkPropTypes.js:19
        Warning: Failed context type: The context <code>router</code> is marked as required in <code>LinkContainer</code>, but its value is <code>undefined</code>.
            in LinkContainer (at Header.js:27)</p>
</blockquote>

<p>Could anyone please help me out? This is the code, in header.js for example:</p>

<pre><code>import { LinkContainer } from ""react-router-bootstrap"";
import { ROUTE_POKEDEX } from ""../../constants/constants"";

export default class Header extends Component {
  constructor(props) {
    super(props);

    this.toggle = this.toggle.bind(this);
    this.state = {
      isOpen: false
    };
  }

  toggle() {
    this.setState({
      isOpen: !this.state.isOpen
    });
  }

  render() {
    return (
      &lt;Container fluid className=""header""&gt;
        &lt;Navbar expand=""md""&gt;
          &lt;LinkContainer to={ROUTE_POKEDEX}&gt;
            &lt;NavbarBrand&gt;Pokédex&lt;/NavbarBrand&gt;
          &lt;/LinkContainer&gt;
          &lt;NavbarToggler onClick={this.toggle} /&gt;
        &lt;/Navbar&gt;
      &lt;/Container&gt;
    );
  }
}
</code></pre>

<p>test.js</p>

<pre><code>import Header from ""./Header"";

it(""renders without crashing"", () =&gt; {
  const div = document.createElement(""div"");
  ReactDOM.render(&lt;Header /&gt;, div);
  ReactDOM.unmountComponentAtNode(div);
});

it(""has valid snapshot"", () =&gt; {
  const tree = renderer.create(&lt;Header /&gt;).toJSON();
  expect(tree).toMatchSnapshot();
});
</code></pre>
",""
"51106052","Warning: setState(...): Can only update a mounted or mounting component on a new reactjs app","2","<p>I have the following component:</p>

<pre><code>import React, { Component } from 'react';

import { Row, Col } from 'antd';
import PageHeader from '../../components/utility/pageHeader';
import Box from '../../components/utility/box';
import LayoutWrapper from '../../components/utility/layoutWrapper.js';
import ContentHolder from '../../components/utility/contentHolder';
import basicStyle from '../../settings/basicStyle';
import IntlMessages from '../../components/utility/intlMessages';
import { adalApiFetch } from '../../adalConfig';

export default class extends Component {
  constructor(props) {
    super(props);
    this.state = {
        data: []
    };
    this.fetchData();
  }

  getValues() {
    adalApiFetch(fetch, '/values', {})
      .then((response) =&gt; {

        // This is where you deal with your API response. In this case, we            
        // interpret the response as JSON, and then call `setState` with the
        // pretty-printed JSON-stringified object.
        response.json()
          .then((responseJson) =&gt; {
            this.setState({ data: JSON.stringify(responseJson, null, 2) })
          });
      })
      .catch((error) =&gt; {

        // Don't forget to handle errors!
        console.error(error);
      })

  }

  fetchData() {
    try {
        const data =  this.getValues();
        !this.isCancelled &amp;&amp; this.setState({ data });
    } catch(error) {
        console.log(error);
    }
  }

  render() {
    const { data } = this.state;
    const { rowStyle, colStyle, gutter } = basicStyle;
    const radioStyle = {
        display: 'block',
        height: '30px',
        lineHeight: '30px'
      };
      const plainOptions = ['Apple', 'Pear', 'Orange'];
      const options = [
        { label: 'Apple', value: 'Apple' },
        { label: 'Pear', value: 'Pear' },
        { label: 'Orange', value: 'Orange' }
      ];
      const optionsWithDisabled = [
        { label: 'Apple', value: 'Apple' },
        { label: 'Pear', value: 'Pear' },
        { label: 'Orange', value: 'Orange', disabled: false }
      ];

    return (
      &lt;div&gt;
        &lt;LayoutWrapper&gt;
        &lt;PageHeader&gt;{&lt;IntlMessages id=""pageTitles.TenantAdministration"" /&gt;}&lt;/PageHeader&gt;
        &lt;Row style={rowStyle} gutter={gutter} justify=""start""&gt;
          &lt;Col md={12} sm={12} xs={24} style={colStyle}&gt;
            &lt;Box
              title={&lt;IntlMessages id=""pageTitles.TenantAdministration"" /&gt;}
              subtitle={&lt;IntlMessages id=""pageTitles.TenantAdministration"" /&gt;}
            &gt;
              &lt;ContentHolder&gt;
                  &lt;ul&gt;
                    {data &amp;&amp; data.map(item =&gt; (
                        &lt;li&gt;{item.name}&lt;/li&gt;
                    ))}
                  &lt;/ul&gt;
              &lt;/ContentHolder&gt;
            &lt;/Box&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/LayoutWrapper&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>and my adalconfig</p>

<pre><code>import { AuthenticationContext, adalFetch, withAdalLogin } from 'react-adal';

export const adalConfig = {
  tenant: 'aa-c220-48a2-a73f-1177fa2c098e',
  clientId: 'aa-bd54-456d-8aa7-f8cab3147fd2',
  endpoints: {
    api:'aa-abaa-4519-82cf-e9d022b87536'
  },
  'apiUrl': 'https://webapi-app.azurewebsites.net/api',
  cacheLocation: 'localStorage'
};

export const authContext = new AuthenticationContext(adalConfig);

export const adalApiFetch = (fetch, url, options) =&gt;
  adalFetch(authContext, adalConfig.endpoints.api, fetch, adalConfig.apiUrl+url, options);

export const withAdalLoginApi = withAdalLogin(authContext, adalConfig.endpoints.api);
</code></pre>

<p>and the error in the console is:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmountedA
  component. This is a no-op.</p>
</blockquote>
","Do you have a question?"
"51106052","Warning: setState(...): Can only update a mounted or mounting component on a new reactjs app","2","<p>I have the following component:</p>

<pre><code>import React, { Component } from 'react';

import { Row, Col } from 'antd';
import PageHeader from '../../components/utility/pageHeader';
import Box from '../../components/utility/box';
import LayoutWrapper from '../../components/utility/layoutWrapper.js';
import ContentHolder from '../../components/utility/contentHolder';
import basicStyle from '../../settings/basicStyle';
import IntlMessages from '../../components/utility/intlMessages';
import { adalApiFetch } from '../../adalConfig';

export default class extends Component {
  constructor(props) {
    super(props);
    this.state = {
        data: []
    };
    this.fetchData();
  }

  getValues() {
    adalApiFetch(fetch, '/values', {})
      .then((response) =&gt; {

        // This is where you deal with your API response. In this case, we            
        // interpret the response as JSON, and then call `setState` with the
        // pretty-printed JSON-stringified object.
        response.json()
          .then((responseJson) =&gt; {
            this.setState({ data: JSON.stringify(responseJson, null, 2) })
          });
      })
      .catch((error) =&gt; {

        // Don't forget to handle errors!
        console.error(error);
      })

  }

  fetchData() {
    try {
        const data =  this.getValues();
        !this.isCancelled &amp;&amp; this.setState({ data });
    } catch(error) {
        console.log(error);
    }
  }

  render() {
    const { data } = this.state;
    const { rowStyle, colStyle, gutter } = basicStyle;
    const radioStyle = {
        display: 'block',
        height: '30px',
        lineHeight: '30px'
      };
      const plainOptions = ['Apple', 'Pear', 'Orange'];
      const options = [
        { label: 'Apple', value: 'Apple' },
        { label: 'Pear', value: 'Pear' },
        { label: 'Orange', value: 'Orange' }
      ];
      const optionsWithDisabled = [
        { label: 'Apple', value: 'Apple' },
        { label: 'Pear', value: 'Pear' },
        { label: 'Orange', value: 'Orange', disabled: false }
      ];

    return (
      &lt;div&gt;
        &lt;LayoutWrapper&gt;
        &lt;PageHeader&gt;{&lt;IntlMessages id=""pageTitles.TenantAdministration"" /&gt;}&lt;/PageHeader&gt;
        &lt;Row style={rowStyle} gutter={gutter} justify=""start""&gt;
          &lt;Col md={12} sm={12} xs={24} style={colStyle}&gt;
            &lt;Box
              title={&lt;IntlMessages id=""pageTitles.TenantAdministration"" /&gt;}
              subtitle={&lt;IntlMessages id=""pageTitles.TenantAdministration"" /&gt;}
            &gt;
              &lt;ContentHolder&gt;
                  &lt;ul&gt;
                    {data &amp;&amp; data.map(item =&gt; (
                        &lt;li&gt;{item.name}&lt;/li&gt;
                    ))}
                  &lt;/ul&gt;
              &lt;/ContentHolder&gt;
            &lt;/Box&gt;
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/LayoutWrapper&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>and my adalconfig</p>

<pre><code>import { AuthenticationContext, adalFetch, withAdalLogin } from 'react-adal';

export const adalConfig = {
  tenant: 'aa-c220-48a2-a73f-1177fa2c098e',
  clientId: 'aa-bd54-456d-8aa7-f8cab3147fd2',
  endpoints: {
    api:'aa-abaa-4519-82cf-e9d022b87536'
  },
  'apiUrl': 'https://webapi-app.azurewebsites.net/api',
  cacheLocation: 'localStorage'
};

export const authContext = new AuthenticationContext(adalConfig);

export const adalApiFetch = (fetch, url, options) =&gt;
  adalFetch(authContext, adalConfig.endpoints.api, fetch, adalConfig.apiUrl+url, options);

export const withAdalLoginApi = withAdalLogin(authContext, adalConfig.endpoints.api);
</code></pre>

<p>and the error in the console is:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting
  component. This usually means you called setState() on an unmountedA
  component. This is a no-op.</p>
</blockquote>
","You have various problems in your code. First component constructor is not a right place to make API calls, use `componentDidMount` and `componentDidUpdate` lifecycle methods. Second `const data =  this.getValues();` makes no sense because `getValues` is async. Finally (not finally :)) `getValues` breaks promise chains by not returning a promise."
"51246815","Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application","4","<p>Why am I getting this error?</p>

<blockquote>
  <p>Warning: Can't call setState (or forceUpdate) on an unmounted
  component. This is a no-op, but it indicates a memory leak in your
  application. To fix, cancel all subscriptions and asynchronous tasks
  in the componentWillUnmount method.</p>
</blockquote>

<p><strong>postAction.js</strong></p>

<pre><code>export const getPosts = () =&gt; db.ref('posts').once('value');
</code></pre>

<p><strong>components:</strong></p>

<pre><code>constructor(props) {
  super(props);
  this.state = { posts: null };
}

componentDidMount() {
  getPosts()
    .then(snapshot =&gt; {
      const result = snapshot.val();
      this.setState(() =&gt; ({ posts: result }));
    })
    .catch(error =&gt; {
      console.error(error);
    });
}

componentWillUnmount() {
  this.setState({ posts: null });
}

render() {
  return (
    &lt;div&gt;
      &lt;PostList posts={this.state.posts} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
","Hey you can read react lifecycle hooks docs on official website. It says when component is unmounting, no sort of state updation is done because ultimately that component's UI is being destroyed"
"51300499","Cancel component import in react componentWillUnmount","2","<p>In my react app I have a conditionally imported component like this:</p>

<pre><code>componentDidMount() {
    if (this.props.client === 'abcdf') {
        import('../clients/abcdf/abcdfMenu').then(comp =&gt; {
            this.setState({ sideMenu: comp.default });
        });
    }
}
</code></pre>

<p>Under some circumstances the parent component may be unmounted before the import completes which triggers the warning: <code>Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</code></p>

<p>The only suggestions I have found are either don't use async in components or use a <code>isMounted</code> property in state (anti-pattern?) or cancel the promise with experimental code not suitable for production. </p>

<p>Do you have any suggestion specifically about dynamic imports? Any idea would be highly appreciated.</p>
","Thanks @Jayce444. I guess the previous solutions I had seen about isMounted were actually talking about a deprecated `isMouted()` method. Just found [this](https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html)"
"51340674","Cannot fetch data from an API using componentDidMount: Can't call setState (or forceUpdate) on an unmounted component","0","<p>I'm relatively new to React. I've used it for building a very simple app. I'm trying to add a small feature, but running into following error message. I don't quite understand the root cause yet.</p>

<p><code>
Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
</code></p>

<p>Here's what I'm trying to do. My app has a backend server that provides various APIs, which returns JSON. I'm using React as frontend/client that calls those APIs and renders them.</p>

<p>I have a Parent component named <code>MyReport</code> which uses <code>componentDidMount</code> to call an API to fetch some data. Then in the render method, I pass the data to  another component named <code>MyReportViewer</code>. This component has various other child components such as a Calendar that allows selecting date, a component that shows the data in a table format, a component that shows the same data as a chart.</p>

<p>Now I'm trying to add another child component called <code>MyReportSummary</code> that will be displayed alongside the other components rendered by <code>MyReportViewer</code>.</p>

<p><code>MyReportSummary</code> needs to call another API to fetch some data. This is what it looks like:</p>

<pre><code>import React, { Component } from 'react';

class MyReportSummary extends Component {

    constructor(props) {
        super(props);
        this.state = {
            projectInfo: null,
            isLoading: false,
            error: null
        };
    }

    componentDidMount() {
        this.setState({ isLoading: true });

        let projectInfoApi;

        projectInfoApi = '/api/projects/' + this.props.projectId;

        fetch(projectInfoApi)
            .then(response =&gt; {
                if (response.ok) {
                    return response.json();
                } else {
                    throw new Error('Encountered problem fetching project info')
                }
            })
            .then(data =&gt; this.setState({
                projectInfo: data
            }))
            .catch(fetchError =&gt; this.setState({
                isLoading: false,
                error: fetchError
            }));
    }

    componentWillUnmount() {
        // this.setState({
        //     projectInfo: null
        // });
    }

    render() {
        const { isLoading, error } = this.state;

        if (error) {
            return &lt;p&gt;{error.message}&lt;/p&gt;
        }

        if (isLoading) {
            return &lt;p&gt;Loading...&lt;/p&gt;
        }

        return (
            &lt;div className=""myReportSummary""&gt;
                 Summary of Project name: {projectInfo.name}                    
                 Number of events: {this.props.data.length}
            &lt;/div&gt;
        );
  }
}

export default MyReportSummary;
</code></pre>

<p>I've read that I need to use <code>componentWillUnmount</code> to reset everything, but I'm not sure what exactly I need to reset here and why in this case I need to do it because I don't think I'm trying to change the component after it's been loaded or rendered already.</p>
",""
"51365405","React 16: Error: Unable to find node on an unmounted component","1","<p>I recently upgraded my project from React v15.2.1 to 16.4.1 and my Sidebar component is throwing the following error:</p>

<pre><code>Error: Unable to find node on an unmounted component. bundle.js line 1326 &gt; eval:42:15
invariant
webpack:///./node_modules/fbjs/lib/invariant.js?:42:15
findCurrentFiberUsingSlowPath
webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:3817:7
findCurrentHostFiber
webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:3886:23
findHostInstance
webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:16824:19
findDOMNode
webpack:///./node_modules/react-dom/cjs/react-dom.development.js?:17310:12
handleClickOutside
webpack:///./src/components/simulator/sidebar/Sidebar.js?:99:31
handleClickOutside self-hosted:984:17
</code></pre>

<p>Based on the error message, I believe the error is happening when calling ReactDOM.findDOMNode(this) in the handleClickOutside(event) method.</p>

<p>The component that I am using can be found here: <a href=""https://ashiknesin.com/blog/build-custom-sidebar-component-react/"" rel=""nofollow noreferrer"">https://ashiknesin.com/blog/build-custom-sidebar-component-react/</a>,
I have changed it a little bit to this:</p>

<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import classNames from 'classnames'
import SimulatorForm from './SimulatorForm'
import './Sidebar.scss'

const  openForm = require('../../../public/icons/si-glyph-arrow-left.svg');
const closeForm = require('../../../public/icons/si-glyph-arrow-right.svg');
const   pinForm = require('../../../public/icons/si-glyph-pin-location-love.svg');
const unpinForm = require('../../../public/icons/si-glyph-pin-location-delete.svg');

class Sidebar extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            showMenu: false,
            isMenuPinned: false,
            formIcon: openForm,
            pinIcon: pinForm,
            modelsDescription: props.modelsDescription
        }
        // Methods to pin/unpin the Form
        this.toggleMenu = this.toggleMenu.bind(this)
        this.pinMenu = this.pinMenu.bind(this)
        // Handlers
        this.handleSelectedModelChange = this.props.handleSelectedModelChange
        this.handleNewMasterGraphsData = this.props.handleNewMasterGraphsData
        this.handleNewResults = this.props.handleNewResults
    }
    componentWillReceiveProps(nextProps) {
        this.setState({ modelsDescription: nextProps.modelsDescription});
    }
    componentDidMount() {
        document.addEventListener('click', this.handleClickOutside.bind(this), true);
    }

    componentWillUnmount() {
        document.removeEventListener('click', this.handleClickOutside.bind(this), true);
    }
    pinMenu() {
        this.setState({
            isMenuPinned: !this.state.isMenuPinned,
            pinIcon: this.state.isMenuPinned ? pinForm : unpinForm
        });
    }
    toggleMenu() {
        this.setState({
            showMenu: !this.state.showMenu,
            formIcon: this.state.showMenu ? openForm : closeForm
        });
    }
    handleClickOutside(event) {
        if (!this.state.isMenuPinned) {
            const domNode = ReactDOM.findDOMNode(this);

            if ((!domNode || !domNode.contains(event.target))) {
                this.setState({
                    showMenu: false,
                    formIcon: openForm
                });
            }
        }
    }

    render() {
        const showMenu = this.state.showMenu;
        const sidebarClass = classNames({
            'sidebar': true,
            'sidebar-menu-expanded': showMenu,
            'sidebar-menu-collapsed': !showMenu
        });

        const elementsClass = classNames({
            'expanded-element': true,
            'is-hidden': !showMenu,
        });

        return (
            &lt;nav className={sidebarClass}&gt;
                &lt;img className=""menuIcon"" src={this.state.formIcon} height=""42"" width=""42"" onClick={this.toggleMenu} /&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        {
                            this.state.showMenu ? &lt;img className=""pinIcon"" src={this.state.pinIcon}  height=""42"" width=""42"" onClick={this.pinMenu} /&gt; : null
                        }
                    &lt;/li&gt;
                    &lt;li&gt;
                        {
                            this.state.showMenu ?  &lt;SimulatorForm modelsDescription={this.state.modelsDescription} handleSelectedModelChange={this.handleSelectedModelChange}
                                                    handleNewMasterGraphsData={this.handleNewMasterGraphsData} handleNewResults={this.handleNewResults} /&gt; : null
                        }        
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;
        )
    }
}


export default Sidebar
</code></pre>

<p>Lastly, the error is only thrown when I reload the page. If I don't, it seems to be working perfectly fine. Do you have any suggestions or recommendations to make sure the error is not thrown again?</p>

<p>I have been reading about this on-line and I couldn't find a fix for it. Also, I dont't think this is listed as a breaking change but I could be very wrong.</p>
","Binding a function creates a new function object, and even though the one you pass when you add a handler and the one you pass when you want to remove that handler seem to be the same, they're not considered equal, so you end up not removing that handler. Storing a bound function in a property by setting it in the constructor is one of the ways to resolve your issue."
"51609276","React Warning: Can't call setState (or forceUpdate) on an unmounted component","3","<p>I have 2 components:<br />
Orders - fetch some data and display it.<br />
ErrorHandler - In case some error happen on the server, a modal will show and display a message.<br/>
The ErrorHandler component is warrping the order component<br/></p>

<p>I'm using axios package to load the data in Orders component, and i use axios interceptors to setState about the error, and eject once the component unmounted.</p>

<p>When i navigate to the orders components back and forward i sometimes get an error in the console:</p>

<pre><code>Warning: Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
    in Orders (at ErrorHandler.jsx:40)
    in Auxiliary (at ErrorHandler.jsx:34)
    in _class2 (created by Route)
</code></pre>

<p>I tried to solve it by my previous case <a href=""https://stackoverflow.com/questions/51591743/react-warning-can-only-update-a-mounted-or-mounting-component"">React Warning: Can only update a mounted or mounting component</a> but here i can't make an axios token by the inspectors. Does anyone solve this issue before?</p>

<p>Here are my components:<br/> <br/>
Orders:</p>

<pre><code>import React, { Component } from 'react';
import api from '../../api/api';
import Order from '../../components/Order/Order/Order';
import ErrorHandler from '../../hoc/ErrorHandler/ErrorHandler';

class Orders extends Component {
    state = {
        orders: [],
        loading: true
    }

    componentDidMount() {
        api.get('/orders.json')
            .then(response =&gt; {
                const fetchedOrders = [];
                if (response &amp;&amp; response.data) {
                    for (let key in response.data) {
                        fetchedOrders.push({
                            id: key,
                            ...response.data[key]
                        });
                    }
                }
                this.setState({ loading: false, orders: fetchedOrders });
            })
            .catch(error =&gt; {
                this.setState({ loading: false });
            });
    }

    render() {
        return (
            &lt;div&gt;
                {this.state.orders.map(order =&gt; {
                    return (&lt;Order
                        key={order.id}
                        ingrediencies={order.ingrediencies}
                        price={order.price} /&gt;);
                })}
            &lt;/div&gt;
        );
    }
}

export default ErrorHandler(Orders, api);
</code></pre>

<p>ErrorHandler:</p>

<pre><code>import React, { Component } from 'react';
import Auxiliary from '../Auxiliary/Auxiliary';
import Modal from '../../components/UI/Modal/Modal';

const ErrorHandler = (WrappedComponent, api) =&gt; {
    return class extends Component {
        requestInterceptors = null;
        responseInterceptors = null;
        state = {
            error: null
        };

        componentWillMount() {
            this.requestInterceptors = api.interceptors.request.use(request =&gt; {
                this.setState({ error: null });
                return request;
            });
            this.responseInterceptors = api.interceptors.response.use(response =&gt; response, error =&gt; {
                this.setState({ error: error });
            });
        }

        componentWillUnmount() {
            api.interceptors.request.eject(this.requestInterceptors);
            api.interceptors.response.eject(this.responseInterceptors);
        }

        errorConfirmedHandler = () =&gt; {
            this.setState({ error: null });
        }

        render() {
            return (
                &lt;Auxiliary&gt;
                    &lt;Modal
                        show={this.state.error}
                        modalClosed={this.errorConfirmedHandler}&gt;
                        {this.state.error ? this.state.error.message : null}
                    &lt;/Modal&gt;
                    &lt;WrappedComponent {...this.props} /&gt;
                &lt;/Auxiliary&gt;
            );
        }
    };
};

export default ErrorHandler;
</code></pre>
","Create a React jsFiddle, it's strange that the same error is shown on componentDidMount"
"51609276","React Warning: Can't call setState (or forceUpdate) on an unmounted component","3","<p>I have 2 components:<br />
Orders - fetch some data and display it.<br />
ErrorHandler - In case some error happen on the server, a modal will show and display a message.<br/>
The ErrorHandler component is warrping the order component<br/></p>

<p>I'm using axios package to load the data in Orders component, and i use axios interceptors to setState about the error, and eject once the component unmounted.</p>

<p>When i navigate to the orders components back and forward i sometimes get an error in the console:</p>

<pre><code>Warning: Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
    in Orders (at ErrorHandler.jsx:40)
    in Auxiliary (at ErrorHandler.jsx:34)
    in _class2 (created by Route)
</code></pre>

<p>I tried to solve it by my previous case <a href=""https://stackoverflow.com/questions/51591743/react-warning-can-only-update-a-mounted-or-mounting-component"">React Warning: Can only update a mounted or mounting component</a> but here i can't make an axios token by the inspectors. Does anyone solve this issue before?</p>

<p>Here are my components:<br/> <br/>
Orders:</p>

<pre><code>import React, { Component } from 'react';
import api from '../../api/api';
import Order from '../../components/Order/Order/Order';
import ErrorHandler from '../../hoc/ErrorHandler/ErrorHandler';

class Orders extends Component {
    state = {
        orders: [],
        loading: true
    }

    componentDidMount() {
        api.get('/orders.json')
            .then(response =&gt; {
                const fetchedOrders = [];
                if (response &amp;&amp; response.data) {
                    for (let key in response.data) {
                        fetchedOrders.push({
                            id: key,
                            ...response.data[key]
                        });
                    }
                }
                this.setState({ loading: false, orders: fetchedOrders });
            })
            .catch(error =&gt; {
                this.setState({ loading: false });
            });
    }

    render() {
        return (
            &lt;div&gt;
                {this.state.orders.map(order =&gt; {
                    return (&lt;Order
                        key={order.id}
                        ingrediencies={order.ingrediencies}
                        price={order.price} /&gt;);
                })}
            &lt;/div&gt;
        );
    }
}

export default ErrorHandler(Orders, api);
</code></pre>

<p>ErrorHandler:</p>

<pre><code>import React, { Component } from 'react';
import Auxiliary from '../Auxiliary/Auxiliary';
import Modal from '../../components/UI/Modal/Modal';

const ErrorHandler = (WrappedComponent, api) =&gt; {
    return class extends Component {
        requestInterceptors = null;
        responseInterceptors = null;
        state = {
            error: null
        };

        componentWillMount() {
            this.requestInterceptors = api.interceptors.request.use(request =&gt; {
                this.setState({ error: null });
                return request;
            });
            this.responseInterceptors = api.interceptors.response.use(response =&gt; response, error =&gt; {
                this.setState({ error: error });
            });
        }

        componentWillUnmount() {
            api.interceptors.request.eject(this.requestInterceptors);
            api.interceptors.response.eject(this.responseInterceptors);
        }

        errorConfirmedHandler = () =&gt; {
            this.setState({ error: null });
        }

        render() {
            return (
                &lt;Auxiliary&gt;
                    &lt;Modal
                        show={this.state.error}
                        modalClosed={this.errorConfirmedHandler}&gt;
                        {this.state.error ? this.state.error.message : null}
                    &lt;/Modal&gt;
                    &lt;WrappedComponent {...this.props} /&gt;
                &lt;/Auxiliary&gt;
            );
        }
    };
};

export default ErrorHandler;
</code></pre>
","use componentDidMount"
"51609276","React Warning: Can't call setState (or forceUpdate) on an unmounted component","3","<p>I have 2 components:<br />
Orders - fetch some data and display it.<br />
ErrorHandler - In case some error happen on the server, a modal will show and display a message.<br/>
The ErrorHandler component is warrping the order component<br/></p>

<p>I'm using axios package to load the data in Orders component, and i use axios interceptors to setState about the error, and eject once the component unmounted.</p>

<p>When i navigate to the orders components back and forward i sometimes get an error in the console:</p>

<pre><code>Warning: Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
    in Orders (at ErrorHandler.jsx:40)
    in Auxiliary (at ErrorHandler.jsx:34)
    in _class2 (created by Route)
</code></pre>

<p>I tried to solve it by my previous case <a href=""https://stackoverflow.com/questions/51591743/react-warning-can-only-update-a-mounted-or-mounting-component"">React Warning: Can only update a mounted or mounting component</a> but here i can't make an axios token by the inspectors. Does anyone solve this issue before?</p>

<p>Here are my components:<br/> <br/>
Orders:</p>

<pre><code>import React, { Component } from 'react';
import api from '../../api/api';
import Order from '../../components/Order/Order/Order';
import ErrorHandler from '../../hoc/ErrorHandler/ErrorHandler';

class Orders extends Component {
    state = {
        orders: [],
        loading: true
    }

    componentDidMount() {
        api.get('/orders.json')
            .then(response =&gt; {
                const fetchedOrders = [];
                if (response &amp;&amp; response.data) {
                    for (let key in response.data) {
                        fetchedOrders.push({
                            id: key,
                            ...response.data[key]
                        });
                    }
                }
                this.setState({ loading: false, orders: fetchedOrders });
            })
            .catch(error =&gt; {
                this.setState({ loading: false });
            });
    }

    render() {
        return (
            &lt;div&gt;
                {this.state.orders.map(order =&gt; {
                    return (&lt;Order
                        key={order.id}
                        ingrediencies={order.ingrediencies}
                        price={order.price} /&gt;);
                })}
            &lt;/div&gt;
        );
    }
}

export default ErrorHandler(Orders, api);
</code></pre>

<p>ErrorHandler:</p>

<pre><code>import React, { Component } from 'react';
import Auxiliary from '../Auxiliary/Auxiliary';
import Modal from '../../components/UI/Modal/Modal';

const ErrorHandler = (WrappedComponent, api) =&gt; {
    return class extends Component {
        requestInterceptors = null;
        responseInterceptors = null;
        state = {
            error: null
        };

        componentWillMount() {
            this.requestInterceptors = api.interceptors.request.use(request =&gt; {
                this.setState({ error: null });
                return request;
            });
            this.responseInterceptors = api.interceptors.response.use(response =&gt; response, error =&gt; {
                this.setState({ error: error });
            });
        }

        componentWillUnmount() {
            api.interceptors.request.eject(this.requestInterceptors);
            api.interceptors.response.eject(this.responseInterceptors);
        }

        errorConfirmedHandler = () =&gt; {
            this.setState({ error: null });
        }

        render() {
            return (
                &lt;Auxiliary&gt;
                    &lt;Modal
                        show={this.state.error}
                        modalClosed={this.errorConfirmedHandler}&gt;
                        {this.state.error ? this.state.error.message : null}
                    &lt;/Modal&gt;
                    &lt;WrappedComponent {...this.props} /&gt;
                &lt;/Auxiliary&gt;
            );
        }
    };
};

export default ErrorHandler;
</code></pre>
","Didn't help..still get the error sometimes... :("
"51657949","Force preact-router to reload a page completely","0","<p>I have a page that contains a link to a secondary page that creates a record. Here is the problem I'm running into: If I fill out the fields on the secondary page, and return back to create another item, the previous data is still inside my text boxes.</p>

<p>I don't know if this is just how preact works. I thought that by calling <code>route</code> it would unmount the component, thus clearing state. I even tried adding unique keys to my routes (which I heard forces them to unmount).</p>

<p>I really am at wits end.</p>

<p><strong>app.jsx</strong></p>

<pre><code>const App = () =&gt; (
    &lt;div&gt;
        &lt;Header/&gt;
        &lt;Router history={createHashHistory()}&gt;
            &lt;Home path=""/"" /&gt;
            &lt;DisplayUsers key=""displayUsers"" path=""/display-users""/&gt;                
            &lt;CreateUser key=""createUser"" path=""/create-user""/&gt;                              
        &lt;/Router&gt;
    &lt;/div&gt; 
);
</code></pre>

<p><strong>create-item.jsx</strong></p>

<pre><code>import { h, Component } from ""preact"";
import { route } from 'preact-router';
import { $post } from ""app/services/ajax.jsx"";
import Section from ""app/components/section/section.jsx"";
import UserList from ""app/components/user-list/user-list.jsx"";

class CreateUser extends Component {
    constructor(props) {
        super(props);

        this.state = {
            userName:       """",
            route:          """"
        };
    }       
    handleSubmit = (event) =&gt; {
        event.preventDefault();

        $post(""/api/users"", this.state, () =&gt; 
            {
                route('/display-users');
            }
        );
    }
    handleChange = (event) =&gt; {
        this.setState({
            [event.target.name]: event.target.value
        });
    }   
    render() {
        return (
            &lt;Section title=""New User""&gt;
                &lt;form onSubmit={this.handleSubmit}&gt;
                    &lt;div className=""mat-field""&gt;
                        &lt;label 
                            htmlFor=""userName""
                            className=""mat-field__label""&gt;
                            User Name:
                        &lt;/label&gt;    

                        &lt;input
                            type=""text""
                            id=""userName""
                            name=""userName""
                            className=""mat-field__input""
                            autoComplete=""off""
                            autoFocus=""autoFocus""
                            maxlength=""30""
                            required
                            onChange={this.handleChange}/&gt;                          
                    &lt;/div&gt;

                    &lt;div className=""mat-field""&gt;
                        &lt;label 
                            htmlFor=""route""
                            className=""mat-field__label""&gt;
                            Route To:
                        &lt;/label&gt;    

                        &lt;UserList 
                            name=""route"" 
                            onChange={this.handleChange}/&gt;              
                    &lt;/div&gt;          

                    {/* Buttons */ }

                    &lt;div&gt;
                        &lt;input 
                            type=""submit"" 
                            value=""Create"" 
                            className=""mat-button mat-button--secondary mat-button--raised""/&gt;
                        &lt;a 
                            href=""/display-users""
                            className=""mat-button""&gt;Cancel&lt;/a&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/Section&gt;
        );

    }
}

export default CreateUser;
</code></pre>
",""