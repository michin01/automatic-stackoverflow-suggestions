Id,Title,CommentCount,Body,Text
"29041034","How to detect child renders in a parent component in react.js","2","<p>I'm trying to cache the rendered markup of the <code>App</code> component. I know that this is somehow ""against the rules"" but I'm in a server-less environment (chrome-extension). Upon page load i want to inject the cached <code>App</code> markup into the DOM. The expected result is similar to the experience of having the react-component rendererd on a server. Very much as described here: <a href=""http://www.tabforacause.org/blog/2015/01/29/using-reactjs-and-application-cache-fast-synced-app/"" rel=""nofollow"">http://www.tabforacause.org/blog/2015/01/29/using-reactjs-and-application-cache-fast-synced-app/</a>.</p>

<p>To illustrate my usecase, I have updated the <a href=""http://jsfiddle.net/derflocki/fn3f9x02/5/"" rel=""nofollow"">Thinking in react example</a>: </p>

<ul>
<li>App
<ul>
<li>FilterableProductTable
<ul>
<li>SearchBar</li>
<li>ProductTable (containing from <code>reflux</code> store in state)
<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>As is expected, neither <code>componentDidUpdate</code> nor <code>componentWillUpdate</code> are called in <code>App</code>.</p>

<p>Is it possible to detect updated child components in the <code>App</code> component in a sane way? Preferably without modifying the child component classes?</p>

<p>I would like to avoid moving props/state to <code>App</code>.</p>
","What problem are you trying to solve where the `App` component would need to know about child components changing?"
"29041034","How to detect child renders in a parent component in react.js","2","<p>I'm trying to cache the rendered markup of the <code>App</code> component. I know that this is somehow ""against the rules"" but I'm in a server-less environment (chrome-extension). Upon page load i want to inject the cached <code>App</code> markup into the DOM. The expected result is similar to the experience of having the react-component rendererd on a server. Very much as described here: <a href=""http://www.tabforacause.org/blog/2015/01/29/using-reactjs-and-application-cache-fast-synced-app/"" rel=""nofollow"">http://www.tabforacause.org/blog/2015/01/29/using-reactjs-and-application-cache-fast-synced-app/</a>.</p>

<p>To illustrate my usecase, I have updated the <a href=""http://jsfiddle.net/derflocki/fn3f9x02/5/"" rel=""nofollow"">Thinking in react example</a>: </p>

<ul>
<li>App
<ul>
<li>FilterableProductTable
<ul>
<li>SearchBar</li>
<li>ProductTable (containing from <code>reflux</code> store in state)
<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>As is expected, neither <code>componentDidUpdate</code> nor <code>componentWillUpdate</code> are called in <code>App</code>.</p>

<p>Is it possible to detect updated child components in the <code>App</code> component in a sane way? Preferably without modifying the child component classes?</p>

<p>I would like to avoid moving props/state to <code>App</code>.</p>
","@WiredPrairie I have updated the question to include the bigger picture."
"30974404","How to create a HighCharts chart in react","6","<p>How can I create a component with a HighCharts chart, that create the chart ones on the first render and only update the series data when new data comes in using <code>chart.series[0].setData(data,true);</code></p>
","Then edit [componentDidUpdate](https://github.com/kirjs/react-highcharts/blob/master/src/Highcharts.jsx#L28) - compare previous options (arguments) with new state. If data changes - create new method to call `setData()`. If something else changed, call `renderChart()` again."
"33440604","reactjs - this is not a function error on upgrade","1","<p>I am actually updating <a href=""https://github.com/ezequiel/react-typeahead-component"" rel=""nofollow"">https://github.com/ezequiel/react-typeahead-component</a> this component to be compatible to react >= 0.14 but while changing the methods I just run into one error:</p>

<p>Exchange <code>this.getDOMnode</code> for the reason it is deprecated with <code>this.findDOMnode</code> it occurs an error: <code>Uncaught TypeError: this.findDOMNode is not a function</code></p>

<p>So I tried a lot about that React isn't binding <code>this</code> automatically in 0.14 to several functions. But it did not really helped me out.</p>

<pre class=""lang-js prettyprint-override""><code>module.exports = React.createClass({
  displayName: 'Aria Status',

  propTypes: process.env.NODE_ENV === 'production' ? {} : {
    message: React.PropTypes.string
  },

  componentDidMount: function() {
    var _this = this;

    _this.setTextContent(_this.props.message).bind(this);
  },

  componentDidUpdate: function() {
    var _this = this;

    _this.setTextContent(_this.props.message).bind(this);
  },

  render: function() {
    return (
      React.createElement(""span"", {
        role: ""status"",
        ""aria-live"": ""polite"",
        style: {
          left: '-9999px',
          position: 'absolute'
        }
      })
    );
  },

  setTextContent: function(textContent) {
    this.findDOMNode().textContent = textContent || '';
  }
});
</code></pre>

<p>Maybe someone can point me somewhere to go ahead!</p>
","Take a moment to read https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html"
"34677234","Proper way to implement jwplayer in react component using webpack (react-starter-kit)","0","<p>i am making VideoPlayer react component with jwpalyer and i am using webpack es6 for loading module
webpack support npm module loading &amp; there is no npm for jwplayer</p>

<p>so am trying to include jwplayer.js using es6 import but it giving me error 
ReferenceError: window is not defined</p>

<p>so any one can help me to properly setup jwplayer with webpack</p>

<pre><code>  import React, { PropTypes, Component } from 'react';
  import $ from 'jquery';
  import Player from ""./lib/jwplayer/jwplayer.js"";
  import styles from './VideoPayer.css';
  import withStyles from '../../decorators/withStyles';
  import Link from '../Link';

  @withStyles(styles)
  class VideoPlayer extends Component {

    static propTypes = {
      className: PropTypes.string,
    };

    static defaultProps = {
      file: '',
      image: ''
    };

    constructor(props) {
      super(props);
      this.playerElement = document.getElementById('my-player');
    }


    componentDidMount() {
      if(this.props.file) {
        this.setupPlayer();
      }
    }

    componentDidUpdate() {
      if(this.props.file) {
        this.setupPlayer();
      }
    }

    componentWillUnmount() {
       Player().remove(this.playerElement);
    }

    setupPlayer() {
      if(Player(this.playerElement)) {
        Player(this.playerElement).remove();
      }

      Player(this.playerElement).setup({
        flashplayer: require('./lib/player/jwplayer.flash.swf'),
        file: this.props.file,
        image: this.props.image,
        width: '100%',
        height: '100%',
      });
    }

    render() {
      return (
        &lt;div&gt;
          &lt;div id=""my-player"" className=""video-player""&gt;&lt;/div&gt;
        &lt;/div&gt;
      )
    }
  }

export default VideoPlayer;
</code></pre>
",""
"35566357","velocity-react - animating scrollTop after component update","8","<p>I'm writing a simple ""console"" that shows messages in a chat-like manner. With messages appearing from the bottom, and moving up. </p>

<p>I have the working code, but I'd like to animate the appearing messages by scrolling the container to the bottom each time a new ""li"" is added.</p>

<p>Current code:</p>

<pre><code>import React from 'react';
import { render, findDOMNode } from 'react-dom';


export default React.createClass({
    componentDidUpdate : function(){
        var node = findDOMNode(this);
        node.scrollTop = node.scrollHeight;
    },
    render() {
        return (
            &lt;ul id=""log""&gt;
            {
                this.props.messages.map(function(message, index){
                    return &lt;li key={index}&gt;[{message.time.format('HH:mm:ss')}] {message.action}&lt;/li&gt;
                })
            }
            &lt;/ul&gt;
        )   
    }
})
</code></pre>

<p>The <code>messages</code> prop comes from the parent component and the store.</p>

<p>I found this velocity plugin: <a href=""https://github.com/twitter-fabric/velocity-react"">https://github.com/twitter-fabric/velocity-react</a> and I can't figure out how to use it in my situation. All the examples don't seem to apply (or maybe I just don't understand them).</p>

<p>I'm quite new to react, and some concepts still confuse me, so please be understanding.</p>

<p>I don't want to use jQuery.</p>
","This animation issue is not a blocker, so I let it wait for someone who is an expert on velocityjs. Until then - there's a whole app to make ;) Once I come to the point when I need it badly I will try to figure it out again. And if I fail, I'll probably end up copying the easing functions from velocity :)
Thanks for your input anyway!"
"35566357","velocity-react - animating scrollTop after component update","8","<p>I'm writing a simple ""console"" that shows messages in a chat-like manner. With messages appearing from the bottom, and moving up. </p>

<p>I have the working code, but I'd like to animate the appearing messages by scrolling the container to the bottom each time a new ""li"" is added.</p>

<p>Current code:</p>

<pre><code>import React from 'react';
import { render, findDOMNode } from 'react-dom';


export default React.createClass({
    componentDidUpdate : function(){
        var node = findDOMNode(this);
        node.scrollTop = node.scrollHeight;
    },
    render() {
        return (
            &lt;ul id=""log""&gt;
            {
                this.props.messages.map(function(message, index){
                    return &lt;li key={index}&gt;[{message.time.format('HH:mm:ss')}] {message.action}&lt;/li&gt;
                })
            }
            &lt;/ul&gt;
        )   
    }
})
</code></pre>

<p>The <code>messages</code> prop comes from the parent component and the store.</p>

<p>I found this velocity plugin: <a href=""https://github.com/twitter-fabric/velocity-react"">https://github.com/twitter-fabric/velocity-react</a> and I can't figure out how to use it in my situation. All the examples don't seem to apply (or maybe I just don't understand them).</p>

<p>I'm quite new to react, and some concepts still confuse me, so please be understanding.</p>

<p>I don't want to use jQuery.</p>
","Yes the code above is working. I'd like to animate the scroll. I know how to do this using jQuery, but attaching jQuery to react feels stupid. Meanwhile React animation plugins escape my understanding. I used ""pure"" velocity before, and I know how performant it is. It would be nice to be able to use it in React. So the question is virtually about velocity js, but I'm open to other suggestions."
"35566357","velocity-react - animating scrollTop after component update","8","<p>I'm writing a simple ""console"" that shows messages in a chat-like manner. With messages appearing from the bottom, and moving up. </p>

<p>I have the working code, but I'd like to animate the appearing messages by scrolling the container to the bottom each time a new ""li"" is added.</p>

<p>Current code:</p>

<pre><code>import React from 'react';
import { render, findDOMNode } from 'react-dom';


export default React.createClass({
    componentDidUpdate : function(){
        var node = findDOMNode(this);
        node.scrollTop = node.scrollHeight;
    },
    render() {
        return (
            &lt;ul id=""log""&gt;
            {
                this.props.messages.map(function(message, index){
                    return &lt;li key={index}&gt;[{message.time.format('HH:mm:ss')}] {message.action}&lt;/li&gt;
                })
            }
            &lt;/ul&gt;
        )   
    }
})
</code></pre>

<p>The <code>messages</code> prop comes from the parent component and the store.</p>

<p>I found this velocity plugin: <a href=""https://github.com/twitter-fabric/velocity-react"">https://github.com/twitter-fabric/velocity-react</a> and I can't figure out how to use it in my situation. All the examples don't seem to apply (or maybe I just don't understand them).</p>

<p>I'm quite new to react, and some concepts still confuse me, so please be understanding.</p>

<p>I don't want to use jQuery.</p>
","so u got the react part working and u r seeking pure js scrolling?"
"36047675","JQuery plugin and react events and properties","0","<p>Trying to get a react app working with <strong><a href=""http://getmdl.io/"" rel=""nofollow"">http://getmdl.io/</a></strong> just using client side code. I want a date picker and have found this <a href=""http://www.jqueryscript.net/time-clock/Pretty-Date-Time-Picker-Plugin-For-Bootstrap-Material.html"" rel=""nofollow"">http://www.jqueryscript.net/time-clock/Pretty-Date-Time-Picker-Plugin-For-Bootstrap-Material.html</a> which is rather nice. But I have a problem.  </p>

<p>How do you get a jquery event hooked up to call a function on a react class.</p>

<p>See this code below and the comment is where I want to call it. </p>

<pre><code>var DatePicker = React.createClass({
OnDateSelected: function (e) {
    this.props.onDateSelected(e.currentTarget.value);
},
render: function () {
    return (

        &lt;div className=""mdl-textfield mdl-js-textfield mdl-textfield--expandable""&gt;
            &lt;label className=""mdl-button mdl-js-button mdl-button--icon""&gt;
                &lt;i className=""material-icons""&gt;date_range&lt;/i&gt;
            &lt;/label&gt;
            &lt;div className=""mdl-textfield__expandable-holder""&gt;
                &lt;input id=""datepicker"" value={this.props.selectedDate} className=""mdl-textfield__input"" onChange={this.OnDateSelected} /&gt;
                &lt;label className=""mdl-textfield__label""&gt;Search text&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;

    );
},
componentDidUpdate: function () {
    $(""#datepicker"").bootstrapMaterialDatePicker({ time: false, format: ""DD/MM/YYYY"" });


    $('#datepicker').bootstrapMaterialDatePicker().on('change', function (e, date) {
        // Call OnDateSelected here
    });

}});
</code></pre>
",""
"36311406","Refresh react component","3","<p>My node.js server sends with socket.io new data each 10s. In my web application I update this.state each time that my server sends data and force to update with forceUpdate()</p>

<p>However, my react component doesn't refresh, I don't know why. I followed the doc but I missed something...</p>

<p><strong>Parent :</strong></p>

<pre><code>class DataAnalytics extends React.Component {
  constructor(props) {
    super(props);
    socket = this.props.socket;
    this.state = {data: []};

    socket.on('dataCharts', (res) =&gt; {
      console.log(""new data charts : ""+res);
      var data = JSON.parse(res);   
      this.setState({data: data});
      this.forceUpdate();
    });
  }

  componentWillUnmount() {
    socket.off('dataCharts');
  }

  render() {
    return (
    &lt;div id=""dataAnalytics""&gt;
      &lt;Stats data={this.state.data}&gt;&lt;/Stats&gt;
    &lt;/div&gt;
    );
  }
}

export default DataAnalytics;
</code></pre>

<p><strong>Child :</strong></p>

<pre><code>class Stats extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div className=""stats"" style={{textAlign:'center'}}&gt;
        &lt;h4&gt;Number: &lt;/h4&gt;
      &lt;/div&gt;
    );
  }

  componentDidUpdate() {
    var data = this.props.data;

    if(!jQuery.isEmptyObject(data)) {
      $( "".stats"" ).html(""&lt;h4&gt;Number : data['nb']['counterIn']&lt;/h4&gt;"");
    }
  }
}

export default Stats;
</code></pre>

<p>Anyone know how to refresh automatically my React component.</p>
","I have this.setState() in my parent component... I tried to place it in different method (componentDidUpdate, componentWillMount ...), but same result :/"
"36311406","Refresh react component","3","<p>My node.js server sends with socket.io new data each 10s. In my web application I update this.state each time that my server sends data and force to update with forceUpdate()</p>

<p>However, my react component doesn't refresh, I don't know why. I followed the doc but I missed something...</p>

<p><strong>Parent :</strong></p>

<pre><code>class DataAnalytics extends React.Component {
  constructor(props) {
    super(props);
    socket = this.props.socket;
    this.state = {data: []};

    socket.on('dataCharts', (res) =&gt; {
      console.log(""new data charts : ""+res);
      var data = JSON.parse(res);   
      this.setState({data: data});
      this.forceUpdate();
    });
  }

  componentWillUnmount() {
    socket.off('dataCharts');
  }

  render() {
    return (
    &lt;div id=""dataAnalytics""&gt;
      &lt;Stats data={this.state.data}&gt;&lt;/Stats&gt;
    &lt;/div&gt;
    );
  }
}

export default DataAnalytics;
</code></pre>

<p><strong>Child :</strong></p>

<pre><code>class Stats extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div className=""stats"" style={{textAlign:'center'}}&gt;
        &lt;h4&gt;Number: &lt;/h4&gt;
      &lt;/div&gt;
    );
  }

  componentDidUpdate() {
    var data = this.props.data;

    if(!jQuery.isEmptyObject(data)) {
      $( "".stats"" ).html(""&lt;h4&gt;Number : data['nb']['counterIn']&lt;/h4&gt;"");
    }
  }
}

export default Stats;
</code></pre>

<p>Anyone know how to refresh automatically my React component.</p>
","`this.setState()` might help you"
"36311406","Refresh react component","3","<p>My node.js server sends with socket.io new data each 10s. In my web application I update this.state each time that my server sends data and force to update with forceUpdate()</p>

<p>However, my react component doesn't refresh, I don't know why. I followed the doc but I missed something...</p>

<p><strong>Parent :</strong></p>

<pre><code>class DataAnalytics extends React.Component {
  constructor(props) {
    super(props);
    socket = this.props.socket;
    this.state = {data: []};

    socket.on('dataCharts', (res) =&gt; {
      console.log(""new data charts : ""+res);
      var data = JSON.parse(res);   
      this.setState({data: data});
      this.forceUpdate();
    });
  }

  componentWillUnmount() {
    socket.off('dataCharts');
  }

  render() {
    return (
    &lt;div id=""dataAnalytics""&gt;
      &lt;Stats data={this.state.data}&gt;&lt;/Stats&gt;
    &lt;/div&gt;
    );
  }
}

export default DataAnalytics;
</code></pre>

<p><strong>Child :</strong></p>

<pre><code>class Stats extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div className=""stats"" style={{textAlign:'center'}}&gt;
        &lt;h4&gt;Number: &lt;/h4&gt;
      &lt;/div&gt;
    );
  }

  componentDidUpdate() {
    var data = this.props.data;

    if(!jQuery.isEmptyObject(data)) {
      $( "".stats"" ).html(""&lt;h4&gt;Number : data['nb']['counterIn']&lt;/h4&gt;"");
    }
  }
}

export default Stats;
</code></pre>

<p>Anyone know how to refresh automatically my React component.</p>
","Your setup inside parent looks correct: data should be new on every cycle, and setState() should re-render parent +child, without even need for forceUpdate(). Are you sure the socket works properly? Do you get multiple console.log lines?"
"36573252","Make list.js and react.js work together","0","<p>This is vanila code to run list.js in the browser. And it works with no problem</p>

<pre><code>&lt;script src=""http://listjs.com/no-cdn/list.js""&gt;&lt;/script&gt;
&lt;div id=""users""&gt;
&lt;input class=""search"" placeholder=""Search"" /&gt;
&lt;ul class=""list""&gt;
    &lt;li&gt;
        &lt;h3 class=""name""&gt;Jonny Stromberg&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;h3 class=""name""&gt;Jonas Arnklint&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;h3 class=""name""&gt;Martina Elm&lt;/h3&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
var options = { valueNames: [ 'name' ] };
var userList = new List('users', options);
&lt;/script&gt;
</code></pre>

<p>So I thought it will be simple to that in react, I tried this</p>

<pre><code>import React from ""react"";
import ReactDOM from ""react-dom"";

    class Home extends React.Component{
        componentDidUpdate(){
            const options = { valueNames: [ 'name' ] };
            const userList = new List('users', options);
        }
        render(){ 
            return(
                &lt;div id=""users""&gt;
                    &lt;input class=""search"" placeholder=""Search"" /&gt;
                    &lt;ul class=""list""&gt;
                        &lt;li&gt;
                            &lt;h3 class=""name""&gt;Jonny Stromberg&lt;/h3&gt;
                        &lt;/li&gt;
                        &lt;li&gt;
                            &lt;h3 class=""name""&gt;Jonas Arnklint&lt;/h3&gt;
                        &lt;/li&gt;
                        &lt;li&gt;
                            &lt;h3 class=""name""&gt;Martina Elm&lt;/h3&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            )
        }
    }

    const app = document.getElementById('app');

    ReactDOM.render(&lt;Home /&gt;, app);
</code></pre>

<p>index.html</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div id=""app""&gt;&lt;/div&gt;
&lt;script src=""//cdnjs.cloudflare.com/ajax/libs/list.js/1.2.0/list.min.js""&gt;&lt;/script&gt;
&lt;script src=""bundle.js""&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>But it's not working. And specially no error at all. What could be done here?</p>
",""
"36672338","How to use reactjs with chart-js-rails in a Rails 4 application?","0","<p>So I'm very new to reactjs and using chart-js-rails gem and react-rails gem in a Rails 4 application.  In componentDidMount method I want to essentially create a bar chart.  The data is getting fetched correctly as I can see it in the React chrome dev tools.  </p>

<p>The issue is that I get error <em>chart_container.self-40c721a….js?body=1:17 Uncaught TypeError: barNode.getContext is not a function</em>.  This means somehow the ReactDOM.findDOMNode() is not returning an element that I can perform getContext(""2d"") on.  </p>

<p>1 - Is it possible to use jQuery/Javascript and mix it with React this way to create a Chart.js bar chart in the CView component which will then be rendered in the Container component class?
2 - If no to #1, then what should I do to create a chart?</p>

<pre><code>@Container = React.createClass

  # set initial state before mounting component
  getInitialState: -&gt;
    # set to true once data has been fetched
    getData: false
    # The data JSON array used to display the data in the view
    someData: []

  #some other code here...

  componentDidUpdate: -&gt;
    barNode = ReactDOM.findDOMNode(@refs.barChart)
    barChart = new Chart(barNode.getContext(""2d"")).Bar(@state.someData)

  render: -&gt;
    &lt;div&gt;
      &lt;CView ref=""barChart"" data={@state.someData} /&gt;
    &lt;/div&gt;

@CView = React.createClass
  render: -&gt;
    &lt;p data={@props.data}&gt;&lt;/p&gt;
</code></pre>
",""
"37064242","Disqus's count.js script doesn't run properly in index.html with react.js website","3","<p>I've been having a hell of a time getting the comment count script to work on my react pages. To start, they recommend putting the script in my index.html file, at the bottom of the <code>&lt;body&gt;</code> tag. I've done this, and seen no result.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>  &lt;body&gt;
    &lt;div id=""app""&gt;
    &lt;/div&gt;
    &lt;script src=""static/index.js""&gt;&lt;/script&gt;
    &lt;script id=""dsq-count-scr"" src=""//mtg-hunter.disqus.com/count.js"" async&gt;&lt;/script&gt;
  &lt;/body&gt;</code></pre>
</div>
</div>
</p>

<p>I have an index.js file which is loading all my components, including the component (let's call it ResultComponent.js) which I want to have the comment count <code>&lt;span&gt;</code> tags in. The <code>&lt;span&gt;</code> tags themselves look like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var commentCount = &lt;span className=""disqus-comment-count"" onClick={function() {this.setState({currentSelectedTab: 4})}.bind(this)} 
			data-disqus-identifier={idGoesHere}
			style={{fontVariant:""small-caps""}}&gt;0 Comments&lt;/span&gt;</code></pre>
</div>
</div>
</p>

<p>So far, so simple. I'm not using any <code>&lt;a&gt;</code> tags so I haven't got <code>#disqus_thread</code> anywhere. When I load my page, I expect my comment count to go up, but no such luck. To test this, I copied the raw script, unaltered, from the raw count.js script (which is <a href=""https://mtg-hunter.disqus.com/count.js"">located here</a>). I then pasted it straight into Chrome's devtools console, and it worked; all the relevant comment counters went to their appropriate values.</p>

<p><strong>EDIT</strong>: a day later, more prodding; I added breakpoints in the actual code in the disqus.com domain. The script in the script tag is running just fine at the right time, except it's missing variables when it enters the displayCount() function. There's several variables that just aren't given values so it can't go in and populate the comment counts, it always fails out. I have no idea why this fails when it's called from within my index.html but not when I paste the raw count.js code into my console and do it there. No idea why.</p>

<p>To clarify, this is the relevant code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>e.displayCount = function(b) {
        for (var c, a, d, e = b.counts, b = b.text.comments; c = e.shift(); )
            if (a = j[c.id]) {
                switch (c.comments) {
                case 0:
                    d = b.zero;
                    break;
                case 1:
                    d = b.one;
                    break;
                default:
                    d = b.multiple
                }
                c = d.replace(""{num}"", c.comments);
                a = a.elements;
                for (d = a.length - 1; d &gt;= 0; d--)
                    a[d].innerHTML = c
            }
    }
    ;</code></pre>
</div>
</div>

When it runs properly, from my pasting the script into the console, the <code>j</code> variable is defined. When it runs called from index.html, <code>j</code> is undefined, so it fails at the first <code>if</code>. The calling url is exactly the same in both situations: <code>http://mtg-hunter.disqus.com/count-data.js?1=19767&amp;1=235597&amp;1=373322&amp;1=382310&amp;1=382841&amp;1=382866&amp;1=383023&amp;1=397543&amp;1=397682&amp;1=398434</code>. That gives the <code>b</code> parameter, and when I run the script locally it defines <code>j</code> so that the assignment operator in the if can work (which is a really weird way of doing it, but ok).</p>

<p><strong>edit again:</strong> I should point out I'm doing this on a local test server (<code>localhost:3000</code>), not sure if that makes a difference or not?</p>

<p><strong>edit more:</strong> The answer to my above question turns out to be 'no'. I uploaded my code to my server and the production site also showed that the script wasn't running properly. This is absurd... I'm out of ideas by now.</p>

<p><strong>edit again more:</strong> Partial breakthrough... I added this code to ResultComponent.js:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    componentDidMount() {
    	DISQUSWIDGETS.getCount();
    },

    componentDidUpdate() {
    	DISQUSWIDGETS.getCount();
    },</code></pre>
</div>
</div>
</p>

<p>Good news; when I refresh the page, it shows the right comment count! Hooray! Bad news: when I change parts of the page that hide the Result component, and then bring it back (triggering <code>componentDidUpdate</code>), the <code>DISQUSWIDGETS.getCount()</code> call doesn't work. It still gets called, but the <code>displayCount</code> part of the script never does, so the DOM is never updated with the new information. It's yet another example of this horrid script behaving differently despite being called in exactly the same way...</p>
","No, this is a script that's loaded/created by disqus and it sits at mtg-hunter.disqus.com/count.js."
"37064242","Disqus's count.js script doesn't run properly in index.html with react.js website","3","<p>I've been having a hell of a time getting the comment count script to work on my react pages. To start, they recommend putting the script in my index.html file, at the bottom of the <code>&lt;body&gt;</code> tag. I've done this, and seen no result.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>  &lt;body&gt;
    &lt;div id=""app""&gt;
    &lt;/div&gt;
    &lt;script src=""static/index.js""&gt;&lt;/script&gt;
    &lt;script id=""dsq-count-scr"" src=""//mtg-hunter.disqus.com/count.js"" async&gt;&lt;/script&gt;
  &lt;/body&gt;</code></pre>
</div>
</div>
</p>

<p>I have an index.js file which is loading all my components, including the component (let's call it ResultComponent.js) which I want to have the comment count <code>&lt;span&gt;</code> tags in. The <code>&lt;span&gt;</code> tags themselves look like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var commentCount = &lt;span className=""disqus-comment-count"" onClick={function() {this.setState({currentSelectedTab: 4})}.bind(this)} 
			data-disqus-identifier={idGoesHere}
			style={{fontVariant:""small-caps""}}&gt;0 Comments&lt;/span&gt;</code></pre>
</div>
</div>
</p>

<p>So far, so simple. I'm not using any <code>&lt;a&gt;</code> tags so I haven't got <code>#disqus_thread</code> anywhere. When I load my page, I expect my comment count to go up, but no such luck. To test this, I copied the raw script, unaltered, from the raw count.js script (which is <a href=""https://mtg-hunter.disqus.com/count.js"">located here</a>). I then pasted it straight into Chrome's devtools console, and it worked; all the relevant comment counters went to their appropriate values.</p>

<p><strong>EDIT</strong>: a day later, more prodding; I added breakpoints in the actual code in the disqus.com domain. The script in the script tag is running just fine at the right time, except it's missing variables when it enters the displayCount() function. There's several variables that just aren't given values so it can't go in and populate the comment counts, it always fails out. I have no idea why this fails when it's called from within my index.html but not when I paste the raw count.js code into my console and do it there. No idea why.</p>

<p>To clarify, this is the relevant code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>e.displayCount = function(b) {
        for (var c, a, d, e = b.counts, b = b.text.comments; c = e.shift(); )
            if (a = j[c.id]) {
                switch (c.comments) {
                case 0:
                    d = b.zero;
                    break;
                case 1:
                    d = b.one;
                    break;
                default:
                    d = b.multiple
                }
                c = d.replace(""{num}"", c.comments);
                a = a.elements;
                for (d = a.length - 1; d &gt;= 0; d--)
                    a[d].innerHTML = c
            }
    }
    ;</code></pre>
</div>
</div>

When it runs properly, from my pasting the script into the console, the <code>j</code> variable is defined. When it runs called from index.html, <code>j</code> is undefined, so it fails at the first <code>if</code>. The calling url is exactly the same in both situations: <code>http://mtg-hunter.disqus.com/count-data.js?1=19767&amp;1=235597&amp;1=373322&amp;1=382310&amp;1=382841&amp;1=382866&amp;1=383023&amp;1=397543&amp;1=397682&amp;1=398434</code>. That gives the <code>b</code> parameter, and when I run the script locally it defines <code>j</code> so that the assignment operator in the if can work (which is a really weird way of doing it, but ok).</p>

<p><strong>edit again:</strong> I should point out I'm doing this on a local test server (<code>localhost:3000</code>), not sure if that makes a difference or not?</p>

<p><strong>edit more:</strong> The answer to my above question turns out to be 'no'. I uploaded my code to my server and the production site also showed that the script wasn't running properly. This is absurd... I'm out of ideas by now.</p>

<p><strong>edit again more:</strong> Partial breakthrough... I added this code to ResultComponent.js:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    componentDidMount() {
    	DISQUSWIDGETS.getCount();
    },

    componentDidUpdate() {
    	DISQUSWIDGETS.getCount();
    },</code></pre>
</div>
</div>
</p>

<p>Good news; when I refresh the page, it shows the right comment count! Hooray! Bad news: when I change parts of the page that hide the Result component, and then bring it back (triggering <code>componentDidUpdate</code>), the <code>DISQUSWIDGETS.getCount()</code> call doesn't work. It still gets called, but the <code>displayCount</code> part of the script never does, so the DOM is never updated with the new information. It's yet another example of this horrid script behaving differently despite being called in exactly the same way...</p>
","While not the best solution, it looks like you can update the code. After `count.js` has loaded, assign `DISQUSWIDGETS.displayCount` to a function more to your taste. Or even create a local copy of `count.js` and modify and link to that. At minimum, this might help with debugging."
"37064242","Disqus's count.js script doesn't run properly in index.html with react.js website","3","<p>I've been having a hell of a time getting the comment count script to work on my react pages. To start, they recommend putting the script in my index.html file, at the bottom of the <code>&lt;body&gt;</code> tag. I've done this, and seen no result.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>  &lt;body&gt;
    &lt;div id=""app""&gt;
    &lt;/div&gt;
    &lt;script src=""static/index.js""&gt;&lt;/script&gt;
    &lt;script id=""dsq-count-scr"" src=""//mtg-hunter.disqus.com/count.js"" async&gt;&lt;/script&gt;
  &lt;/body&gt;</code></pre>
</div>
</div>
</p>

<p>I have an index.js file which is loading all my components, including the component (let's call it ResultComponent.js) which I want to have the comment count <code>&lt;span&gt;</code> tags in. The <code>&lt;span&gt;</code> tags themselves look like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var commentCount = &lt;span className=""disqus-comment-count"" onClick={function() {this.setState({currentSelectedTab: 4})}.bind(this)} 
			data-disqus-identifier={idGoesHere}
			style={{fontVariant:""small-caps""}}&gt;0 Comments&lt;/span&gt;</code></pre>
</div>
</div>
</p>

<p>So far, so simple. I'm not using any <code>&lt;a&gt;</code> tags so I haven't got <code>#disqus_thread</code> anywhere. When I load my page, I expect my comment count to go up, but no such luck. To test this, I copied the raw script, unaltered, from the raw count.js script (which is <a href=""https://mtg-hunter.disqus.com/count.js"">located here</a>). I then pasted it straight into Chrome's devtools console, and it worked; all the relevant comment counters went to their appropriate values.</p>

<p><strong>EDIT</strong>: a day later, more prodding; I added breakpoints in the actual code in the disqus.com domain. The script in the script tag is running just fine at the right time, except it's missing variables when it enters the displayCount() function. There's several variables that just aren't given values so it can't go in and populate the comment counts, it always fails out. I have no idea why this fails when it's called from within my index.html but not when I paste the raw count.js code into my console and do it there. No idea why.</p>

<p>To clarify, this is the relevant code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>e.displayCount = function(b) {
        for (var c, a, d, e = b.counts, b = b.text.comments; c = e.shift(); )
            if (a = j[c.id]) {
                switch (c.comments) {
                case 0:
                    d = b.zero;
                    break;
                case 1:
                    d = b.one;
                    break;
                default:
                    d = b.multiple
                }
                c = d.replace(""{num}"", c.comments);
                a = a.elements;
                for (d = a.length - 1; d &gt;= 0; d--)
                    a[d].innerHTML = c
            }
    }
    ;</code></pre>
</div>
</div>

When it runs properly, from my pasting the script into the console, the <code>j</code> variable is defined. When it runs called from index.html, <code>j</code> is undefined, so it fails at the first <code>if</code>. The calling url is exactly the same in both situations: <code>http://mtg-hunter.disqus.com/count-data.js?1=19767&amp;1=235597&amp;1=373322&amp;1=382310&amp;1=382841&amp;1=382866&amp;1=383023&amp;1=397543&amp;1=397682&amp;1=398434</code>. That gives the <code>b</code> parameter, and when I run the script locally it defines <code>j</code> so that the assignment operator in the if can work (which is a really weird way of doing it, but ok).</p>

<p><strong>edit again:</strong> I should point out I'm doing this on a local test server (<code>localhost:3000</code>), not sure if that makes a difference or not?</p>

<p><strong>edit more:</strong> The answer to my above question turns out to be 'no'. I uploaded my code to my server and the production site also showed that the script wasn't running properly. This is absurd... I'm out of ideas by now.</p>

<p><strong>edit again more:</strong> Partial breakthrough... I added this code to ResultComponent.js:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    componentDidMount() {
    	DISQUSWIDGETS.getCount();
    },

    componentDidUpdate() {
    	DISQUSWIDGETS.getCount();
    },</code></pre>
</div>
</div>
</p>

<p>Good news; when I refresh the page, it shows the right comment count! Hooray! Bad news: when I change parts of the page that hide the Result component, and then bring it back (triggering <code>componentDidUpdate</code>), the <code>DISQUSWIDGETS.getCount()</code> call doesn't work. It still gets called, but the <code>displayCount</code> part of the script never does, so the DOM is never updated with the new information. It's yet another example of this horrid script behaving differently despite being called in exactly the same way...</p>
","Seems like reactjs may be doing something to your expected context. Can you adjust `displayCount` such that you can pass `j` as an additional argument?"
"37587524","Filter ListView data in react native","0","<p>I am trying to write a fliter for my List View in react native. But It is not working , and I don't know why. 
Here is my Class - </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {
  AppRegistry,
  Image,
  ListView,
  StyleSheet,
  Text,
  TextInput,
  Navigator,
  TouchableHighlight,
  TouchableOpacity,
  filter,
  View
} from 'react-native';
var REQUEST_URL = GLOBAL.STATES_URL + '?apikey=' + GLOBAL.API_KEY;

class MainPage extends Component {
    
  constructor(props) {
    super(props);
    this.state = {
      dataSource: new ListView.DataSource({
        rowHasChanged: (row1, row2) =&gt; row1 !== row2,
      }),
      loaded: false,
      searchText: '',
      state: '',
    };
  }
  
  componentDidMount() {
    this.fetchData();
  }
  
  componentDidUpdate() {
    if (this.state.searchText === '') {
      this.fetchData();
    }
  }
  
  filterStates(searchText, states) {
    var text = searchText.toLowerCase();
    var rows = [];
   
   for (var i=0; i &lt; states.length; i++) {
     var stateName = states[i].name.toLowerCase();
     if(stateName.search(text) !== -1){
         rows.push({
              name : states[i].name,
          });
     }
   }
       
    this.setState({
       dataSource: this.state.dataSource.cloneWithRows(rows),
       loaded : true,
     });
  }
  
  fetchData() {
    fetch(REQUEST_URL)
      .then((response) =&gt; response.json())
      .then((responseData) =&gt; {
        this.setState({
          dataSource: this.state.dataSource.cloneWithRows(responseData),
          loaded: true,
        });
      })
      .done();
  }
 
  setSearchText(event){
    var searchText = event.nativeEvent.text;
    this.setState({searchText});

    fetch(REQUEST_URL)
    .then((data) =&gt; {
          this.filterStates(searchText, data);    
    })
    .done();
 }
  
    
  render() {
    return (
      &lt;Navigator
          renderScene={this.renderScene.bind(this)}
          navigator={this.props.navigator}
          navigationBar={
            &lt;Navigator.NavigationBar style={{backgroundColor: '#246dd5'}}
                routeMapper={NavigationBarRouteMapper} /&gt;
          }
         /&gt;
    );
  }
  
  
  renderScene(route, navigator) {
    if (!this.state.loaded) {
      return this.renderLoadingView();
    }

    return (
      &lt;View style={styles.combo}&gt;
      
       &lt;TextInput
         style={styles.searchBar}
         value={this.state.searchText}
         onChange={this.setSearchText.bind(this)}
         placeholder='Search' /&gt;   
      &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={this.renderState.bind(this)}
        // renderScrollComponent={props =&gt; &lt;RecyclerViewBackedScrollView {...props} /&gt;}
        renderSeparator={(sectionID, rowID) =&gt; &lt;View key={`${sectionID}-${rowID}`} style={styles.separator} /&gt;}
        style={styles.listView}
      /&gt;
      &lt;/View&gt;
      
    );
  }
  
  renderLoadingView() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text&gt;
          Loading States...
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  renderState(state,route,navigator) {
    return (
      &lt;TouchableHighlight onPress={this.gotoPersonPage.bind(this,state)}&gt;
         &lt;View style={styles.row}&gt; 
             &lt;View style={styles.container}&gt;
                   &lt;Text style={styles.name}&gt;{state.name}&lt;/Text&gt;
             &lt;/View&gt;
         &lt;/View&gt;
      &lt;/TouchableHighlight&gt;
   
    );
  }
  
  
  gotoPersonPage(state) {
    this.props.navigator.push({
      id: 'PersonPage',
      name: 'PersonPage',
      data: {name:state.name , abbreviation:state.abbreviation},
    });
  }
}</code></pre>
</div>
</div>
</p>

<p>Can Anybody please tell that what is the issue in the above code, and solution for that issue.
Thanks in advance.</p>
",""
"37627648","Correct way to fetch data when switching route on same level in react-router?","0","<p>What is the correct way to fetch data when switching route on same level?
Because, according to <a href=""https://github.com/reactjs/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow"">this</a>, switching route on same level will
only call <code>componentWillReceiveProps</code> and <code>componentDidUpdate</code>.
And <code>componentDidMount</code> is only called the first time route is entered.</p>

<p>With route configuration like this:</p>

<pre><code>render((
  &lt;Provider store={store}&gt;
    &lt;Router&gt;
      &lt;Route path=""/"" component={App}&gt;
        &lt;Route path=""/:userId"" component={Profile}/&gt;
      &lt;/Route&gt;
    &lt;/Router&gt;
  &lt;/Provider&gt;
), document.getElementById('root'));
</code></pre>

<p>The Profile component is:</p>

<pre><code>class Profile extends React.Component {
  componentDidMount() {
    // initial data
    this.fetchUserData();
  }
  componentWillReceiveProps(nextProps) {
    if (this.props.params.userId !== nextProps.params.userId) {
      this.fetchUserData();
    }
  }
  shouldComponentUpdate(nextProps) {
    return this.props.params.userId !== nextProps.params.userId;
  }
  render() {
    return (
      &lt;div className=""profile""&gt;&lt;/div&gt;
    );
  }
}
</code></pre>

<p>The data will be stored in application state field (<code>props.userData</code>). But,
that's obviously will mess up with rendering cycle because route is
switched before fetch data is finished.</p>

<p>But, if I change to this:</p>

<pre><code>// deepEqual is function to check object equality recursively
componentWillReceiveProps(nextProps) {
  if (!deepEqual(this.props.userData, nextProps.userData)) {
    this.fetchUserData();
  }
}
shouldComponentUpdate(nextProps) {
  return !deepEqual(this.props.userData, nextProps.userData);
}
</code></pre>

<p>This won't work because before <code>userData</code> is fetched, those props is
deeply equal.</p>

<p>So, how to fetch data when switching route on same route level?</p>
",""
"38561660","How to tell react.js NOT to reconcile or interfere from a certain element?","1","<p>One of my components has a <code>div</code> element into which I would like to spill and handle/mutate my own DOM - without React interfering. </p>

<p>I am using d3.js for that manual DOM manipulation, and no I am not looking for react-d3 solutions, I need plain d3 in there. </p>

<p>All works well for me, except the reacts console warnings:</p>

<p><code>
warning.js:44Warning: Unknown prop `xmlns` on &lt;svg&gt; tag. Remove this prop from the element. For details, see
</code></p>

<p>and</p>

<p><code>
warning.js:44 Warning: Unknown DOM property class. Did you mean className?
</code></p>

<p>So It complains about me using <code>class</code> instead of <code>className</code> or about having some html attributes which are not react style etc.. </p>

<p>I'd like to tell React that from this component and below, it shouldn’t interfere, I will manage the DOM below this component manually.</p>

<p>Code looks something like this:</p>

<pre><code>import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import SomeD3CustomComp from '../some-d3-custom-comp.js';

export default class MyComponent extends Component {

  componentDidMount() {
   this.injectChart();
  }

  componentDidUpdate() {
   this.injectChart();
  }

  injectChart() {
    const comp = findDOMNode(this.refs.nonReactContainer);
    const { chart } = this.props;
    const { shouldRender, data } = chart;
    if (shouldRender) {
      SomeD3CustomComp.render(comp, data);
    }
  }

  render() {
    const { chart, someOtherData } = this.props;
    const { shouldRender } = chart;
    return(
      &lt;article&gt;
        {
          shouldRender &amp;&amp;
          &lt;div className=""non-react-element"" ref=""nonReactContainer""&gt;&lt;/div&gt;
        }
        &lt;div className=""react-element""&gt;{someOtherData}&lt;/div&gt;
      &lt;/article&gt;
    );
  }
}
</code></pre>

<hr>

<h2>Update:</h2>

<p>The suggestion of returning <code>false</code> on <code>shouldComponentUpdate</code> doesnt take away the error messages I have stated above, maybe because of the fact that <code>shouldComponentUpdate</code> happens only when there is an update - after the first inject on <code>componentDidMount</code>. </p>

<p>Another problem with that approach is that if return <code>false</code> code never gets to the render method where more logic is implemented such as in the example above where I check if to render the container non react element. This is the way I simply remove all previously injected elements, in the previous state. </p>

<p>So I am still looking for help with that...</p>

<hr>

<h2>Solved!</h2>

<p>false alarm :/ just found out that those warning messages were related to a different part of the code. Was a strange coincidence from the time this new feature was developed and some older problem. Conclusion: look harder at the warning messages! 
So this integration with d3 actually works nice.</p>
","Possible duplicate of [React - Ignore subnodes](http://stackoverflow.com/questions/24864947/react-ignore-subnodes)"
"38928525","React does not render recursive reactive components","0","<p>Given this component : </p>

<pre><code>import React, { Component } from 'react';
import TrackerReact from 'meteor/ultimatejs:tracker-react';

export default class SubscriptionView extends TrackerReact(Component) {

  constructor(props) {
    super(props);

    let params = props.params || [];

    if (!Array.isArray(params)) {
      params = [params];
    }

    this.state = {
      subscription: {
        collection: Meteor.subscribe(props.subscription, ...params)
      }
    };
  }

  componentWillUnmount() {
    this.state.subscription.collection.stop();
  }


  render() {
    let loaded = this.state.subscription.collection.ready();

    if (!loaded) {
      return (
        &lt;section className=""subscription-view""&gt;
          &lt;h3&gt;Loading...&lt;/h3&gt;
        &lt;/section&gt;
      );
    }

    return (
      &lt;section className=""subscription-view""&gt;
        { this.props.children }
      &lt;/section&gt;
    );
  }
};
</code></pre>

<p>And another component :</p>

<pre><code>import SubscriptionView from './SubscriptionView.jsx';

export const Foo = () =&gt; (
  &lt;SubscriptionView subscription=""allFoo""&gt;
    &lt;SubscriptionView subscription=""singleBar"" params={ 123 }&gt;
      &lt;div&gt;Rendered!&lt;/div&gt;
    &lt;/SubscriptionView&gt;
  &lt;/SubscriptionView&gt;
);
</code></pre>

<p>The first <code>Subscription</code> is re-rendered when the data is available, however the second one is rendered only once and nothing more. If I place a <code>console.log(this.props.subscription, ready);</code> inside the render function of <code>SubscriptionView</code>, I see</p>

<pre><code>allFoo false
allFoo true
singleBar false
</code></pre>

<p>and that's it.</p>

<p>On the server side, both publish methods are</p>

<pre><code>Meteor.publish('allFoo', function () {
  console.log(""Subscribing foos"");
  return Foos.find();
});

Meteor.publish('singleBar', function (id) {
  console.log(""Subscribing bar"", id);
  return Bars.find({ _id: id });
});
</code></pre>

<p>Both of the publish methods are being called.</p>

<p>Why isn't the second <code>SubscriptionView</code> reactive?</p>

<hr>

<h3><strong>* Solution *</strong></h3>

<p>This is based on <a href=""https://stackoverflow.com/questions/38928525/react-does-not-render-recursive-reactive-components/38928560?noredirect=1#comment65214011_38928560"">alexi2</a>'s comment :</p>

<pre><code>import React, { Component } from 'react';
import TrackerReact from 'meteor/ultimatejs:tracker-react';

export default class SubscriptionLoader extends TrackerReact(Component) {

  constructor(props) {
    super(props);

    let params = props.params || [];

    if (!Array.isArray(params)) {
      params = [params];
    }

    this.state = {
      done: false,
      subscription: {
        collection: Meteor.subscribe(props.subscription, ...params)
      }
    };
  }

  componentWillUnmount() {
    this.state.subscription.collection.stop();
  }

  componentDidUpdate() {
    if (!this.state.done) {
      this.setState({ done: true });

      this.props.onReady &amp;&amp; this.props.onReady();
    }
  }


  render() {
    let loaded = this.state.subscription.collection.ready();

    if (!loaded) {
      return (
        &lt;div&gt;Loading...&lt;/div&gt;
      );
    }

    return null;
  }
};
</code></pre>

<p>Then, inside the parent component's <code>render</code> method :</p>

<pre><code>&lt;section className=""inventory-item-view""&gt;
  &lt;SubscriptionLoader subscription='singleBar' params={ this.props.id } onReady={ this.setReady.bind(this, 'barReady') } /&gt;
  &lt;SubscriptionLoader subscription='allFoos' onReady={ this.setReady.bind(this, 'foosReady') } /&gt;
  { content }
&lt;/section&gt;
</code></pre>

<p>Where <code>setReady</code> merely sets the component's state, and <code>content</code> has a value only if <code>this.state.barReady &amp;&amp; this.state.foosReady</code> is true.</p>

<p>It works!</p>
",""
"39609325","reactjs: how to detect data changed and show notification","3","<p>hi guys im new in reactjs
i just want to know the react way, method/lifecycle that can render component (notification component) when ajax data result is different with previous state?</p>

<pre><code>var NewsList = React.createClass({
  getInitialState: function() {
    return ({
      data: [],
      showNotif: false,
      showLoading: false
    });
  },
  showNotification: function() {
    return (
      &lt;Notification msg=""new data"" /&gt;
    );
  },
  ajaxRequest: function() {
  //do ajax request, load the result to this.state.data
  },
  componentWillMount: function() {
    this.setState({showLoading: true});
  },
  componentDidMount: function() {
    this.ajaxRequest();
    setInterval(this.ajaxRequest, 2000);
  },
  componentDidUpdate: function(prevProps, prevState) {
    if (this.state.data != prevState.data) {
      //this.setState({showNotif: !this.state.showNotif});
    }
  },
  render: function() {
    var loadingElement, notifElement;
    if (this.state.showLoading) {
      loadingElement = &lt;Loader /&gt;
    }
    if(this.state.showNotif) {
      notifElement = this.showNotification();
    }
    return (
      &lt;div&gt;
        {notifElement}
        {loadingElement}
        &lt;NewsItem data={this.state.data} /&gt;
      &lt;/div&gt;
    );
});
</code></pre>

<p>so if you can see i expect the <code>ComponentDidUpdate</code> will read the changed state.data and if it's changed (meaning the ajax result has new updated), it will set <code>this.state.showNotif</code> to <code>true</code> and  render will call <code>showNotification()</code> but it's not (it's blinking, true-false set back and forth, so it's called many times)</p>

<p>what should i do to achieve it and make it right?</p>
","great, i can see your point and somehow it's working. i dont know if this is a good practice or not, but thanks"
"39609325","reactjs: how to detect data changed and show notification","3","<p>hi guys im new in reactjs
i just want to know the react way, method/lifecycle that can render component (notification component) when ajax data result is different with previous state?</p>

<pre><code>var NewsList = React.createClass({
  getInitialState: function() {
    return ({
      data: [],
      showNotif: false,
      showLoading: false
    });
  },
  showNotification: function() {
    return (
      &lt;Notification msg=""new data"" /&gt;
    );
  },
  ajaxRequest: function() {
  //do ajax request, load the result to this.state.data
  },
  componentWillMount: function() {
    this.setState({showLoading: true});
  },
  componentDidMount: function() {
    this.ajaxRequest();
    setInterval(this.ajaxRequest, 2000);
  },
  componentDidUpdate: function(prevProps, prevState) {
    if (this.state.data != prevState.data) {
      //this.setState({showNotif: !this.state.showNotif});
    }
  },
  render: function() {
    var loadingElement, notifElement;
    if (this.state.showLoading) {
      loadingElement = &lt;Loader /&gt;
    }
    if(this.state.showNotif) {
      notifElement = this.showNotification();
    }
    return (
      &lt;div&gt;
        {notifElement}
        {loadingElement}
        &lt;NewsItem data={this.state.data} /&gt;
      &lt;/div&gt;
    );
});
</code></pre>

<p>so if you can see i expect the <code>ComponentDidUpdate</code> will read the changed state.data and if it's changed (meaning the ajax result has new updated), it will set <code>this.state.showNotif</code> to <code>true</code> and  render will call <code>showNotification()</code> but it's not (it's blinking, true-false set back and forth, so it's called many times)</p>

<p>what should i do to achieve it and make it right?</p>
","I think you should check if the new data is different *before* saving it to state, like `if (isDifferent(this.state.data, ajaxData)) { this.setState({ data: ajaxData, showNotif: true }) }`"
"39609325","reactjs: how to detect data changed and show notification","3","<p>hi guys im new in reactjs
i just want to know the react way, method/lifecycle that can render component (notification component) when ajax data result is different with previous state?</p>

<pre><code>var NewsList = React.createClass({
  getInitialState: function() {
    return ({
      data: [],
      showNotif: false,
      showLoading: false
    });
  },
  showNotification: function() {
    return (
      &lt;Notification msg=""new data"" /&gt;
    );
  },
  ajaxRequest: function() {
  //do ajax request, load the result to this.state.data
  },
  componentWillMount: function() {
    this.setState({showLoading: true});
  },
  componentDidMount: function() {
    this.ajaxRequest();
    setInterval(this.ajaxRequest, 2000);
  },
  componentDidUpdate: function(prevProps, prevState) {
    if (this.state.data != prevState.data) {
      //this.setState({showNotif: !this.state.showNotif});
    }
  },
  render: function() {
    var loadingElement, notifElement;
    if (this.state.showLoading) {
      loadingElement = &lt;Loader /&gt;
    }
    if(this.state.showNotif) {
      notifElement = this.showNotification();
    }
    return (
      &lt;div&gt;
        {notifElement}
        {loadingElement}
        &lt;NewsItem data={this.state.data} /&gt;
      &lt;/div&gt;
    );
});
</code></pre>

<p>so if you can see i expect the <code>ComponentDidUpdate</code> will read the changed state.data and if it's changed (meaning the ajax result has new updated), it will set <code>this.state.showNotif</code> to <code>true</code> and  render will call <code>showNotification()</code> but it's not (it's blinking, true-false set back and forth, so it's called many times)</p>

<p>what should i do to achieve it and make it right?</p>
","`this.state.data != prevState.data` will always give you `true`.                               You need something like `_.isEqual()` from lodash"
"39626921","React-Three-Renderer refs not current in componentDidUpdate (MVCE included)","1","<p>I'm using react-three-renderer (<a href=""https://www.npmjs.com/package/react-three-renderer"">npm</a>, <a href=""https://github.com/toxicFork/react-three-renderer"">github</a>) for building a scene with <a href=""http://threejs.org/"">three.js</a>.</p>

<p>I'm having a problem that I've boiled down to an MVCE. Refs aren't updating in the sequence I expect them to. First, here's the main code to look at:</p>

<pre><code>var React = require('react');
var React3 = require('react-three-renderer');
var THREE = require('three');
var ReactDOM = require('react-dom');

class Simple extends React.Component {
  constructor(props, context) {
    super(props, context);

    // construct the position vector here, because if we use 'new' within render,
    // React will think that things have changed when they have not.
    this.cameraPosition = new THREE.Vector3(0, 0, 5);

    this.state = {
      shape: 'box'
    };

    this.toggleShape = this.toggleShape.bind(this);
  }

  toggleShape() {
    if(this.state.shape === 'box') {
      this.setState({ shape: 'circle' });
    } else {
      this.setState({ shape: 'box' });
    }
  }

  renderShape() {
    if(this.state.shape === 'box') {
      return &lt;mesh&gt;
        &lt;boxGeometry
          width={1}
          height={1}
          depth={1}
          name='box'
          ref={
            (shape) =&gt; {
              this.shape = shape;
              console.log('box ref ' + shape);
            }
          }
        /&gt;
        &lt;meshBasicMaterial
          color={0x00ff00}
        /&gt;
      &lt;/mesh&gt;;
    } else {
      return &lt;mesh&gt;
        &lt;circleGeometry
          radius={2}
          segments={50}
          name='circle'
          ref={
            (shape) =&gt; {
              this.shape = shape;
              console.log('circle ref ' + shape);
            }
          }
        /&gt;
        &lt;meshBasicMaterial
          color={0x0000ff}
        /&gt;
      &lt;/mesh&gt;
    }
  }

  componentDidUpdate() {
    console.log('componentDidUpdate: the active shape is ' + this.shape.name);
  }

  render() {
    const width = window.innerWidth; // canvas width
    const height = window.innerHeight; // canvas height

    var position = new THREE.Vector3(0, 0, 10);
    var scale = new THREE.Vector3(100,50,1);

    var shape = this.renderShape();

    return (&lt;div&gt;
        &lt;button onClick={this.toggleShape}&gt;Toggle Shape&lt;/button&gt;
        &lt;React3
          mainCamera=""camera""
          width={width}
          height={height}
          onAnimate={this._onAnimate}&gt;
          &lt;scene&gt;
            &lt;perspectiveCamera
              name=""camera""
              fov={75}
              aspect={width / height}
              near={0.1}
              far={1000}
              position={this.cameraPosition}/&gt;
            {shape}
          &lt;/scene&gt;
        &lt;/React3&gt;
    &lt;/div&gt;);
  }
}

ReactDOM.render(&lt;Simple/&gt;, document.querySelector('.root-anchor'));
</code></pre>

<p>This renders a basic scene with a green box, a fork of the example on react-three-renderer's github landing page. The button on the top left toggles the shape in the scene to be a blue circle, and if clicked again, back to the green box. I'm doing some logging in the ref callbacks and in <code>componentDidUpdate</code>. Here's where the core of the problem I'm encountering occurs. After clicking the toggle button for the first time, I expect the ref for the shape to be pointing to the circle. But as you can see from the logging, in <code>componentDidUpdate</code> the ref is still pointing to the box:</p>

<blockquote>
  <p>componentDidUpdate: the active shape is box</p>
</blockquote>

<p>Logging in lines after that reveals the ref callbacks are hit</p>

<blockquote>
  <p>box ref null [React calls null on the old ref to prevent memory leaks]</p>
  
  <p>circle ref [object Object]</p>
</blockquote>

<p>You can drop breakpoints in to verify and to inspect. I would expect these two things to happen before we enter <code>componentDidUpdate</code>, but as you can see, it's happening in reverse. Why is this? Is there an underlying issue in react-three-renderer (if so, can you diagnose it?), or am I misunderstanding React refs?</p>

<p>The MVCE is available in <a href=""https://github.com/ParagonTruss/Refs-Availability-Test"">this github repository</a>. Download it, run <code>npm install</code>, and open _dev/public/home.html.</p>

<p>Thanks in advance.</p>
","I don't think you're misunderstanding React refs. Doing the same thing without React Three Renderer gives the behavior you want: https://jsfiddle.net/pa4nd46k/."
"40692336","react-bootstrap modal, how to handle child component?","0","<p>I'm using a Modal based on the example code from the docs: <a href=""https://react-bootstrap.github.io/components.html#modals-live"" rel=""nofollow noreferrer"">https://react-bootstrap.github.io/components.html#modals-live</a>. What I want is for a child component to be rendered only when 1) it's data is ready, and 2) when the modal is opened. Also, the child component needs to know how wide the area is it has to work with (because it's doing some d3.js svg drawing inside).</p>

<p>I'm also, btw, using <code>fixed-data-table</code>, so the data (a <code>concept</code>) is put in state and the Model is opened on row click:</p>

<pre><code>onRowClick={(evt, idx, obj)=&gt;{
  let concept = filteredDataList.getObjectAt(idx);
  this.openModal();
  this.setState({concept});
}}
</code></pre>

<p>As per the Modal docs example, the Modal sits there in the render and exists in the DOM in a closed state until something opens it. However, the Modal.Body doesn't seem to exist till the Modal is open. My bright idea is that the child, <code>ConceptDetail</code>, can get the ClientWidth from a ref to its containing div.</p>

<pre><code>let conceptDetail = '';
if (this.state.concept) {
    conceptDetail = &lt;ConceptDetail 
                        containerRefs={this.refs}
                        concept={concept} /&gt;/
}

&lt;Modal&gt;
   ...
  &lt;Modal.Body&gt;
    &lt;div ref=""modalBody"" style={{width:'100%'}}&gt;
        {conceptDetail}
    &lt;/div&gt;
  &lt;/Modal.Body&gt;
  ...
&lt;/Modal&gt;
</code></pre>

<p>This <em>would</em> work, except the ref isn't ready until after the child component is rendered. To figure out what's going on, I did this:</p>

<pre><code>componentWillUpdate(){
  if (this.refs.modalBody) {
    let { clientWidth } = this.refs.modalBody;
    alert(`will update, width: ${clientWidth}`);
  } else {
    alert('will update, no modalBody ref');
  }
}
componentDidUpdate(){
  if (this.refs.modalBody) {
    let { clientWidth } = this.refs.modalBody;
    alert(`did update, width: ${clientWidth}`);
  } else {
    alert('did update, no modalBody ref');
  }
}
</code></pre>

<p>When I click a row, I see the alert <code>will update, no modalBody ref</code>, followed by the alert <code>did update, width: 868</code>, and then the child component displays. But the child didn't get the width (or the updated ref) because it actually renders before the <code>componentDidUpdate</code>. The reason I see the alert first (I assume) is because the Modal is animated and doesn't appear instantly on rendering. When I close the Modal, I actually do see for a quick flash that it has finally received the correct width, but at that point I don't need it anymore.</p>

<p>So, most specifically, my question is: How can a child component of a Modal be informed of the modal body's width? I would be even more grateful if someone might explain the right way to do what I'm trying to do in general: Trigger display of a Modal with a child component that would like to receive data and container dimensions as props.</p>
",""
"40964705","Dynamically add scrollable tab mdl react ?","0","<p>I'm using material design lite and react. I managed to add dynamically tab when using separate layout and tabs but when I try to use mdl-layout__tab-bar mdl-js-ripple-effect I can't update the layout so the tab isn't working.</p>

<pre><code>&lt;div className=""mdl-layout mdl-js-layout mdl-layout--fixed-header""&gt;
        &lt;header className=""mdl-layout__header""&gt;
            &lt;div className=""mdl-layout__header-row""&gt;
                &lt;span className=""mdl-layout-title""&gt;Title&lt;/span&gt;
            &lt;/div&gt;
            &lt;div className=""mdl-layout__tab-bar mdl-js-ripple-effect""&gt;
                {
                    this.state.tabs.map((tab, i) =&gt; {
                        let tabId = '#' + tab.id;
                        let className = 'mdl-layout__tab';
                        tab.active ? className += ' is-active' : className + '';

                        return &lt;a key={i} href={tabId} className={className}&gt;{tab.name}&lt;/a&gt;
                    })
                }
                &lt;a key={this.state.tabs.length} href='#add-new'
                   className={'mdl-layout__tab ' + ADD_NEW}&gt;+&lt;/a&gt;
            &lt;/div&gt;
        &lt;/header&gt;
        &lt;div className=""mdl-layout__drawer""&gt;
            &lt;span className=""mdl-layout-title""&gt;Title&lt;/span&gt;
            &lt;nav className=""mdl-navigation""&gt;
                &lt;a className=""mdl-navigation__link"" href=""""&gt;Link&lt;/a&gt;
                &lt;a className=""mdl-navigation__link"" href=""""&gt;Link&lt;/a&gt;
                &lt;li&gt;
                    &lt;hr/&gt;
                &lt;/li&gt;
                &lt;span className=""asdf""&gt;
                    &lt;a className=""mdl-navigation__link"" href=""""&gt;Add new&lt;/a&gt;
                &lt;/span&gt;
            &lt;/nav&gt;
        &lt;/div&gt;
        &lt;main className=""mdl-layout__content""&gt;
            {
                this.state.tabs.map((tab, i) =&gt; {
                    return &lt;Tab key={i} id={tab.id} active={tab.active} content={tab.content}/&gt;
                })
            }
            &lt;Tab key={this.state.tabs.length} id='add-new' active={false}&gt;&lt;/Tab&gt;
        &lt;/main&gt;
    &lt;/div&gt;;
</code></pre>

<p>This is my render function and the tab  element is added properly, but when I click on it the tabs panel isn't shown.</p>

<pre><code>componentDidUpdate() {
    if (!this.layout) {
        this.layout = MaterialLayout.apply(MaterialLayout.prototype,[document.getElementsByClassName('mdl-layout')[0]]);
    }
    let id = this.state.tabs[this.state.tabs.length - 1].id;
    let tabs = document.getElementsByClassName('mdl-layout__tab-bar')[0].getElementsByTagName('a');
    let panels = document.getElementsByClassName('mdl-layout__content')[0].getElementsByClassName('mdl-layout__tab-panel ');
    MaterialLayoutTab(document.getElementsByTagName(""a[href="" + id + ""]""), tabs, panels, this.layout);
    this.registerListener();
    componentHandler.upgradeDom();
}
</code></pre>

<p>I tried anything but still can't upgrade the tabs ;/ 
Any suggestions will be highly appreciated.</p>
",""
"41781836","google-maps-react user location not working","1","<p>I am trying to display the user location on the map using google-maps-react. I followed the fullstack tutorial, but I just can't seem to display the user location.  I will display my Map.js  Component below.  Please help me point out what I am doing wrong. Thank you.</p>

<pre><code>import React, { Component } from 'react'
import ReactDOM from 'react-dom';

class Map extends Component {
  constructor(props) {
    super(props);

    const {lat, lng} = this.props.initialCenter;
    this.state = {
      currentLocation: {
        lat: lat,
        lng: lng
      }
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.google !== this.props.google) {
      this.loadMap();
    }
    if (prevState.currentLocation !== this.state.currentLocation) {
      this.recenterMap();
    }
  }
  recenterMap() {
    const map = this.map;
    const curr = this.state.currentLocation;

    const google = this.props.google;
    const maps = google.maps;

    if (map) {
        let center = new maps.LatLng(curr.lat, curr.lng)
        map.panTo(center)
    }
  }
  componentDidMount() {
    if (this.props.centerAroundCurrentLocation) {
        if (navigator &amp;&amp; navigator.geolocation) {
            navigator.geolocation.getCurrentPosition((pos) =&gt; {
                const coords = pos.coords;
                this.setState({
                    currentLocation: {
                        lat: coords.latitude,
                        lng: coords.longitude
                    }
                })
            })
        }
    }
    this.loadMap();
  }
  loadMap() {
    if (this.props &amp;&amp; this.props.google) {
      // google is available
      const {google} = this.props;
      const maps = google.maps;

      const mapRef = this.refs.map;
      const node = ReactDOM.findDOMNode(mapRef);

      let {initialCenter, zoom} = this.props;
      const {lat, lng} = initialCenter;
      const center = new maps.LatLng(lat, lng);
      const mapConfig = Object.assign({}, {
        center: center,
        zoom: zoom
      })
      this.map = new maps.Map(node, mapConfig);
    }
  }
  render() {
    const style = {
      width: '100vw',
      height: '100vh'
    }
    return (
      &lt;div ref='map' style={style}&gt;
        Loading map...
      &lt;/div&gt;
    )
  }
}

Map.propTypes = {
  google: React.PropTypes.object,
  zoom: React.PropTypes.number,
  initialCenter: React.PropTypes.object,
  centerAroundCurrentLocation: React.PropTypes.bool
}
Map.defaultProps = {
  zoom: 13,
  // San Francisco, by default
  initialCenter: {
    lat: 37.774929,
    lng: -122.419416
  },
  centerAroundCurrentLocation: false
}


export default Map
</code></pre>
","Did you ever find out the problem?"
"41853164","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","6","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","Yes something like that! Provide a props method to flush the state you are reading from, and use it in the `componentWillUnmount()` method."
"41853164","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","6","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","@cdaiga thanks a lot for answering so by clearing the state should I do it manually like state=[] or tehre is a way that I  am not aware of?"
"41853164","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","6","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","@cdaiga Thanks a lot man :)"
"41853164","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","6","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","Use the componentWillUnmount() life cycle method to clear the state before you navigate to another page."
"41853164","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","6","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","@cdaiga Man you fixed one of my biggest problem during last week. Could you please add it as an answer for future new react developers?"
"41853164","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","6","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","Hahaha, @Hamed Minaee, I am also a react newbie."
"41886929","I want my menu to update based on which view I'm on React (alternative to reactdom.render)","5","<p>I'm now convinced I am doing this wrong based on the fact that my app doesn't show the menu unless I open dev tools..</p>

<p>On my landing page, I have a menu bar that has the app name/logo as well as menu items and a log in button in my webapp, like this:
<a href=""https://i.stack.imgur.com/ooayP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ooayP.png"" alt=""landing page menu""></a></p>

<p>I've added that by having my <code>main.html</code> file contain:</p>

<pre><code>&lt;div id=""render-target""&gt;
    &lt;div id=""header-container""&gt;&lt;/div&gt;
    &lt;div id=""app-container""&gt;&lt;/div&gt;
    &lt;div id=""footer-container""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>and my <code>main.jsx</code> file's <code>render()</code> function look like this:</p>

<pre><code>render(
    &lt;div className='container'&gt;
        &lt;div id=""header-container""&gt;
            &lt;MenuBar /&gt;
        &lt;/div&gt;

        &lt;div id=""app-container""&gt;
            &lt;TableSelect /&gt;
        &lt;/div&gt;

        &lt;div id=""footer-container""&gt;
        // some footer code
        &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('render-target'));
</code></pre>

<p>Now, the user can select a ""table"" and load the data from that, which takes them to a different view.</p>

<p>So, basically from the <code>TableSelect</code> view, the user clicks a checkbox and loads a <code>TableLoad</code> view, which loads a table for display (in a super not OK way probably, since it calls <code>ReactDOM.render(&lt;TableDisplay tableId={this.props.id}/&gt;,document.getElementById('app-container'));</code>)</p>

<p>Then, in the <code>TableDisplay</code> view I have </p>

<pre><code>componentDidUpdate() {
    ReactDOM.render(&lt;MenuBar currentView=""tableDisplay"" rows={this.props.rows} cols={this.props.cols} tableId={this.props.tableId} /&gt;, document.getElementById('header-container'));
}
</code></pre>

<p>which calls the <code>MenuBar</code> view with the current data properties (or rather, replaces the DOM). What I want to see is below, including the Edit button:</p>

<p><a href=""https://i.stack.imgur.com/q181P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q181P.png"" alt=""new menu""></a></p>

<p>This seems to only get triggered unreliably... (though without fail if I have Chrome Dev tools open). I think it's just taking some time for the state to pass and I only show the menu <code>if (this.state.currentView !== ""loadTable"" &amp;&amp; this.props.cols !== undefined &amp;&amp; this.props.rows !== undefined)</code>. </p>

<p>I guess I know that <code>ReactDOM.render</code> is not what I want here, but I want to show the menu even if I don't have column/row data and I need to pass the column/row data once I get it. It feels like a Menu shouldn't need data information, but in order to add data to the table I have to have that data somehow. </p>

<hr>

<p>It's really clear to me that I'm doing a lot of things the non-react way. My app is currently deployed at <a href=""https://ideal-engine.herokuapp.com"" rel=""nofollow noreferrer"">ideal-engine.herokuapp.com</a> and the code is at <a href=""https://github.com/adinutzyc21/ideal-engine/tree/master/compareApp"" rel=""nofollow noreferrer"">github repo</a>, if anyone who knows React and feels altruistic enough to do a code review let me know.</p>
","as a side note, in your main.html, you don't need  `<div id=""render-target"">
    <div id=""header-container""></div>
    <div id=""app-container""></div>
    <div id=""footer-container""></div>
</div>` - ALL the inside rendering is taken care of, so it should just be `<div id=""render-target""></div>`"
"41886929","I want my menu to update based on which view I'm on React (alternative to reactdom.render)","5","<p>I'm now convinced I am doing this wrong based on the fact that my app doesn't show the menu unless I open dev tools..</p>

<p>On my landing page, I have a menu bar that has the app name/logo as well as menu items and a log in button in my webapp, like this:
<a href=""https://i.stack.imgur.com/ooayP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ooayP.png"" alt=""landing page menu""></a></p>

<p>I've added that by having my <code>main.html</code> file contain:</p>

<pre><code>&lt;div id=""render-target""&gt;
    &lt;div id=""header-container""&gt;&lt;/div&gt;
    &lt;div id=""app-container""&gt;&lt;/div&gt;
    &lt;div id=""footer-container""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>and my <code>main.jsx</code> file's <code>render()</code> function look like this:</p>

<pre><code>render(
    &lt;div className='container'&gt;
        &lt;div id=""header-container""&gt;
            &lt;MenuBar /&gt;
        &lt;/div&gt;

        &lt;div id=""app-container""&gt;
            &lt;TableSelect /&gt;
        &lt;/div&gt;

        &lt;div id=""footer-container""&gt;
        // some footer code
        &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('render-target'));
</code></pre>

<p>Now, the user can select a ""table"" and load the data from that, which takes them to a different view.</p>

<p>So, basically from the <code>TableSelect</code> view, the user clicks a checkbox and loads a <code>TableLoad</code> view, which loads a table for display (in a super not OK way probably, since it calls <code>ReactDOM.render(&lt;TableDisplay tableId={this.props.id}/&gt;,document.getElementById('app-container'));</code>)</p>

<p>Then, in the <code>TableDisplay</code> view I have </p>

<pre><code>componentDidUpdate() {
    ReactDOM.render(&lt;MenuBar currentView=""tableDisplay"" rows={this.props.rows} cols={this.props.cols} tableId={this.props.tableId} /&gt;, document.getElementById('header-container'));
}
</code></pre>

<p>which calls the <code>MenuBar</code> view with the current data properties (or rather, replaces the DOM). What I want to see is below, including the Edit button:</p>

<p><a href=""https://i.stack.imgur.com/q181P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q181P.png"" alt=""new menu""></a></p>

<p>This seems to only get triggered unreliably... (though without fail if I have Chrome Dev tools open). I think it's just taking some time for the state to pass and I only show the menu <code>if (this.state.currentView !== ""loadTable"" &amp;&amp; this.props.cols !== undefined &amp;&amp; this.props.rows !== undefined)</code>. </p>

<p>I guess I know that <code>ReactDOM.render</code> is not what I want here, but I want to show the menu even if I don't have column/row data and I need to pass the column/row data once I get it. It feels like a Menu shouldn't need data information, but in order to add data to the table I have to have that data somehow. </p>

<hr>

<p>It's really clear to me that I'm doing a lot of things the non-react way. My app is currently deployed at <a href=""https://ideal-engine.herokuapp.com"" rel=""nofollow noreferrer"">ideal-engine.herokuapp.com</a> and the code is at <a href=""https://github.com/adinutzyc21/ideal-engine/tree/master/compareApp"" rel=""nofollow noreferrer"">github repo</a>, if anyone who knows React and feels altruistic enough to do a code review let me know.</p>
","this might help https://facebook.github.io/react/docs/conditional-rendering.html"
"41886929","I want my menu to update based on which view I'm on React (alternative to reactdom.render)","5","<p>I'm now convinced I am doing this wrong based on the fact that my app doesn't show the menu unless I open dev tools..</p>

<p>On my landing page, I have a menu bar that has the app name/logo as well as menu items and a log in button in my webapp, like this:
<a href=""https://i.stack.imgur.com/ooayP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ooayP.png"" alt=""landing page menu""></a></p>

<p>I've added that by having my <code>main.html</code> file contain:</p>

<pre><code>&lt;div id=""render-target""&gt;
    &lt;div id=""header-container""&gt;&lt;/div&gt;
    &lt;div id=""app-container""&gt;&lt;/div&gt;
    &lt;div id=""footer-container""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>and my <code>main.jsx</code> file's <code>render()</code> function look like this:</p>

<pre><code>render(
    &lt;div className='container'&gt;
        &lt;div id=""header-container""&gt;
            &lt;MenuBar /&gt;
        &lt;/div&gt;

        &lt;div id=""app-container""&gt;
            &lt;TableSelect /&gt;
        &lt;/div&gt;

        &lt;div id=""footer-container""&gt;
        // some footer code
        &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('render-target'));
</code></pre>

<p>Now, the user can select a ""table"" and load the data from that, which takes them to a different view.</p>

<p>So, basically from the <code>TableSelect</code> view, the user clicks a checkbox and loads a <code>TableLoad</code> view, which loads a table for display (in a super not OK way probably, since it calls <code>ReactDOM.render(&lt;TableDisplay tableId={this.props.id}/&gt;,document.getElementById('app-container'));</code>)</p>

<p>Then, in the <code>TableDisplay</code> view I have </p>

<pre><code>componentDidUpdate() {
    ReactDOM.render(&lt;MenuBar currentView=""tableDisplay"" rows={this.props.rows} cols={this.props.cols} tableId={this.props.tableId} /&gt;, document.getElementById('header-container'));
}
</code></pre>

<p>which calls the <code>MenuBar</code> view with the current data properties (or rather, replaces the DOM). What I want to see is below, including the Edit button:</p>

<p><a href=""https://i.stack.imgur.com/q181P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q181P.png"" alt=""new menu""></a></p>

<p>This seems to only get triggered unreliably... (though without fail if I have Chrome Dev tools open). I think it's just taking some time for the state to pass and I only show the menu <code>if (this.state.currentView !== ""loadTable"" &amp;&amp; this.props.cols !== undefined &amp;&amp; this.props.rows !== undefined)</code>. </p>

<p>I guess I know that <code>ReactDOM.render</code> is not what I want here, but I want to show the menu even if I don't have column/row data and I need to pass the column/row data once I get it. It feels like a Menu shouldn't need data information, but in order to add data to the table I have to have that data somehow. </p>

<hr>

<p>It's really clear to me that I'm doing a lot of things the non-react way. My app is currently deployed at <a href=""https://ideal-engine.herokuapp.com"" rel=""nofollow noreferrer"">ideal-engine.herokuapp.com</a> and the code is at <a href=""https://github.com/adinutzyc21/ideal-engine/tree/master/compareApp"" rel=""nofollow noreferrer"">github repo</a>, if anyone who knows React and feels altruistic enough to do a code review let me know.</p>
","The only part of a React component that should render anything is the `render` method, which will automatically be called when your props or state change. If you want to render something conditionally, use conditionals in your `render` method. `componentDidUpdate` is not a place to render things."
"41886929","I want my menu to update based on which view I'm on React (alternative to reactdom.render)","5","<p>I'm now convinced I am doing this wrong based on the fact that my app doesn't show the menu unless I open dev tools..</p>

<p>On my landing page, I have a menu bar that has the app name/logo as well as menu items and a log in button in my webapp, like this:
<a href=""https://i.stack.imgur.com/ooayP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ooayP.png"" alt=""landing page menu""></a></p>

<p>I've added that by having my <code>main.html</code> file contain:</p>

<pre><code>&lt;div id=""render-target""&gt;
    &lt;div id=""header-container""&gt;&lt;/div&gt;
    &lt;div id=""app-container""&gt;&lt;/div&gt;
    &lt;div id=""footer-container""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>and my <code>main.jsx</code> file's <code>render()</code> function look like this:</p>

<pre><code>render(
    &lt;div className='container'&gt;
        &lt;div id=""header-container""&gt;
            &lt;MenuBar /&gt;
        &lt;/div&gt;

        &lt;div id=""app-container""&gt;
            &lt;TableSelect /&gt;
        &lt;/div&gt;

        &lt;div id=""footer-container""&gt;
        // some footer code
        &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('render-target'));
</code></pre>

<p>Now, the user can select a ""table"" and load the data from that, which takes them to a different view.</p>

<p>So, basically from the <code>TableSelect</code> view, the user clicks a checkbox and loads a <code>TableLoad</code> view, which loads a table for display (in a super not OK way probably, since it calls <code>ReactDOM.render(&lt;TableDisplay tableId={this.props.id}/&gt;,document.getElementById('app-container'));</code>)</p>

<p>Then, in the <code>TableDisplay</code> view I have </p>

<pre><code>componentDidUpdate() {
    ReactDOM.render(&lt;MenuBar currentView=""tableDisplay"" rows={this.props.rows} cols={this.props.cols} tableId={this.props.tableId} /&gt;, document.getElementById('header-container'));
}
</code></pre>

<p>which calls the <code>MenuBar</code> view with the current data properties (or rather, replaces the DOM). What I want to see is below, including the Edit button:</p>

<p><a href=""https://i.stack.imgur.com/q181P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q181P.png"" alt=""new menu""></a></p>

<p>This seems to only get triggered unreliably... (though without fail if I have Chrome Dev tools open). I think it's just taking some time for the state to pass and I only show the menu <code>if (this.state.currentView !== ""loadTable"" &amp;&amp; this.props.cols !== undefined &amp;&amp; this.props.rows !== undefined)</code>. </p>

<p>I guess I know that <code>ReactDOM.render</code> is not what I want here, but I want to show the menu even if I don't have column/row data and I need to pass the column/row data once I get it. It feels like a Menu shouldn't need data information, but in order to add data to the table I have to have that data somehow. </p>

<hr>

<p>It's really clear to me that I'm doing a lot of things the non-react way. My app is currently deployed at <a href=""https://ideal-engine.herokuapp.com"" rel=""nofollow noreferrer"">ideal-engine.herokuapp.com</a> and the code is at <a href=""https://github.com/adinutzyc21/ideal-engine/tree/master/compareApp"" rel=""nofollow noreferrer"">github repo</a>, if anyone who knows React and feels altruistic enough to do a code review let me know.</p>
","You most definitely do not want to call ReactDOM.render anywhere inside of a component. That's the function that renders your app initially, and it shouldn't need to be called more than once."
"41886929","I want my menu to update based on which view I'm on React (alternative to reactdom.render)","5","<p>I'm now convinced I am doing this wrong based on the fact that my app doesn't show the menu unless I open dev tools..</p>

<p>On my landing page, I have a menu bar that has the app name/logo as well as menu items and a log in button in my webapp, like this:
<a href=""https://i.stack.imgur.com/ooayP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ooayP.png"" alt=""landing page menu""></a></p>

<p>I've added that by having my <code>main.html</code> file contain:</p>

<pre><code>&lt;div id=""render-target""&gt;
    &lt;div id=""header-container""&gt;&lt;/div&gt;
    &lt;div id=""app-container""&gt;&lt;/div&gt;
    &lt;div id=""footer-container""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>and my <code>main.jsx</code> file's <code>render()</code> function look like this:</p>

<pre><code>render(
    &lt;div className='container'&gt;
        &lt;div id=""header-container""&gt;
            &lt;MenuBar /&gt;
        &lt;/div&gt;

        &lt;div id=""app-container""&gt;
            &lt;TableSelect /&gt;
        &lt;/div&gt;

        &lt;div id=""footer-container""&gt;
        // some footer code
        &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('render-target'));
</code></pre>

<p>Now, the user can select a ""table"" and load the data from that, which takes them to a different view.</p>

<p>So, basically from the <code>TableSelect</code> view, the user clicks a checkbox and loads a <code>TableLoad</code> view, which loads a table for display (in a super not OK way probably, since it calls <code>ReactDOM.render(&lt;TableDisplay tableId={this.props.id}/&gt;,document.getElementById('app-container'));</code>)</p>

<p>Then, in the <code>TableDisplay</code> view I have </p>

<pre><code>componentDidUpdate() {
    ReactDOM.render(&lt;MenuBar currentView=""tableDisplay"" rows={this.props.rows} cols={this.props.cols} tableId={this.props.tableId} /&gt;, document.getElementById('header-container'));
}
</code></pre>

<p>which calls the <code>MenuBar</code> view with the current data properties (or rather, replaces the DOM). What I want to see is below, including the Edit button:</p>

<p><a href=""https://i.stack.imgur.com/q181P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q181P.png"" alt=""new menu""></a></p>

<p>This seems to only get triggered unreliably... (though without fail if I have Chrome Dev tools open). I think it's just taking some time for the state to pass and I only show the menu <code>if (this.state.currentView !== ""loadTable"" &amp;&amp; this.props.cols !== undefined &amp;&amp; this.props.rows !== undefined)</code>. </p>

<p>I guess I know that <code>ReactDOM.render</code> is not what I want here, but I want to show the menu even if I don't have column/row data and I need to pass the column/row data once I get it. It feels like a Menu shouldn't need data information, but in order to add data to the table I have to have that data somehow. </p>

<hr>

<p>It's really clear to me that I'm doing a lot of things the non-react way. My app is currently deployed at <a href=""https://ideal-engine.herokuapp.com"" rel=""nofollow noreferrer"">ideal-engine.herokuapp.com</a> and the code is at <a href=""https://github.com/adinutzyc21/ideal-engine/tree/master/compareApp"" rel=""nofollow noreferrer"">github repo</a>, if anyone who knows React and feels altruistic enough to do a code review let me know.</p>
","So, as far as I can tell, I can only pass props between children and parents. How can I pass them between siblings?

I have `MenuBar` and `TableSelect` and I need to pass data between them..."
"42402234","react.js and WebRTC RTCPeerConnection.addStream is not an object","0","<p>I want to make a simple video chat on <code>react.js</code> and <code>WebRTC</code>. But in line <code>pc.addStream(localStream)</code> error occurs:</p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object.</p>
</blockquote>

<p>And I don't understand why I can't see the log in the line:</p>

<p><code>pc.onicecandidate = (e)=&gt;{
   console.log('onicecandidate');</code></p>

<p>That is all code:    </p>

<pre><code>class App extends Component {
  constructor(props) {
    super(props);
  }
  componentDidUpdate(){
    loadScript(""https://webrtc.github.io/adapter/adapter-latest.js"");
    let localVideo, remoteVideo, peerConnection, localStream;
    $('#start').on('click', ()=&gt;{ start(true) });

    let id = uuid();
    localVideo = document.getElementById('localVideo');
    remoteVideo = document.getElementById('remoteVideo');


    if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
          localStream = stream;
          localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
   }else{ alert('Your browser does not support getUserMedia API'); }

   function start(isCaller) {
      peerConnection = new RTCPeerConnection( { 'iceServers':  [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
      peerConnection.onicecandidate = ( e ) =&gt; {
        if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
        }
     };
      peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
      };
      peerConnection.addStream(localStream);
      if(isCaller) { 
        peerConnection.createOffer().then(
          createdDescription).catch(errorHandler);
      }
   }
   if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){        
        if(!peerConnection) start(false);
        let signal = JSON.parse(i.text);
        if(signal._id == id) return;
        if(signal.sdp) {
             peerConnection.setRemoteDescription(new   RTCSessionDescription(signal.sdp)).then(()=&gt; {
            if(signal.sdp.type == 'offer') {             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
            }
        }).catch(errorHandler);
      }else if(signal.ice) {
        peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
      }
    }
  }


  function createdDescription(description) {
    peerConnection.setLocalDescription(description).then(()=&gt; {        
       Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
    }).catch(errorHandler);
  }
  function errorHandler(error) { console.log(error); }
}

  }
  render() {
    return (
        &lt;div id=""container""&gt;
          &lt;video id=""localVideo"" autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
          &lt;video id=""remoteVideo"" autoPlay style={{width:""40%""}}&gt;&lt;/video&gt;
          &lt;br/&gt;
        &lt;/div&gt;
    );
  }
}

export default createContainer( ()=&gt; {
  const subscriptionRtc = Meteor.subscribe('rtc');
  const loadingRtc = !subscriptionRtc.ready();
  return {
    loadingRtc:loadingRtc,
    messagesRtc: msgRtc.find().fetch(),
  };
}, App);
</code></pre>
",""
"42456975","Error simple WebRTC chat on react.js and meteor.js","6","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","When you click on the button and call the function `start`. `TypeError: Argument 1 of RTCPeerConnection.addStream is not an object`"
"42456975","Error simple WebRTC chat on react.js and meteor.js","6","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","I don't understand. Are you not seeing local video, remote video, or neither? Any error messages?"
"42456975","Error simple WebRTC chat on react.js and meteor.js","6","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","I only see the local video and not see remote video"
"42456975","Error simple WebRTC chat on react.js and meteor.js","6","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","I updated the question"
"42456975","Error simple WebRTC chat on react.js and meteor.js","6","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","I assume you're not seeing local video then since I gather `localStream` is `undefined`. Has the user given permission to share their camera? `navigator.mediaDevices.getUserMedia` won't complete until they do, and nothing in your code waits for it to complete, which means your success callback never runs and never sets `localStream`, so that's plausible."
"42456975","Error simple WebRTC chat on react.js and meteor.js","6","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","Seems like a timing issue. The TypeError suggests `start` is being called before the `getUserMedia` success callback has run. Insert a couple of `console.log` statements to verify the order in which things happen. The way you've written it, local video must be visible on both ends before one side pushes the start button. Not the best approach imho."
"42540397","react-router: Calling componentWillUnmount across different non-nested routes","0","<p>I am using react-router with a route structure like so:</p>

<pre><code>const routes = (
  &lt;Router history={browserHistory}&gt;
    &lt;Route path=""/main"" component={MainPage}&gt;&lt;/Route&gt;
    &lt;Route path=""/charts/:chartID"" component={App}&gt;&lt;/Route&gt;
  &lt;/Router&gt;
)
</code></pre>

<p>I am trying to do a call to a meteor method when a user switches away from ""/charts/:chartID"" to ""/main"". I only want the method to be called once if possible</p>

<p>In App.js, I used the life cycle methods:</p>

<pre><code>  componentDidUpdate(){
    Meteor.call('test',""update"");   
  } // prints ""update""

  componentWillUnmount(){
    Meteor.call('test',""unmount"");
  } // nothing happens when url changes
</code></pre>

<p>Main.js (server):</p>

<pre><code>Meteor.methods({
    'test'(obj){
        console.log(obj)
    }
})
</code></pre>

<p>I read from this <a href=""https://github.com/ReactTraining/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow noreferrer"">source</a> that components should unmount when the url changes in my situation, but seems like I may have missed out something. How should I be resolving this?</p>

<p>Any help is greatly appreciated!</p>
",""
"42670121","Scroll to bottom after componentDidUpdate","0","<p>Inside a div items are added dynamically. After the componentDidUpdate I want to scroll the content of a div, so that the last list-item gets visible.</p>

<p>css</p>

<pre><code>div { 
   height: 100px;
   overflow-y: scroll;
}
</code></pre>

<p>react js</p>

<pre><code> return(
 &lt;div&gt;
  ...
  &lt;div ref='wrap'&gt;
   &lt;ul&gt;
     &lt;li&gt;item&lt;/li&gt;
      ..
     &lt;li&gt;last item&lt;/li&gt;
   &lt;/ul&gt;
 &lt;/div&gt;
    ...
&lt;/div&gt;)
</code></pre>
",""
"42872062","componentDidUpdate does not fire","4","<p>So I've been struggling to figure out the react-redux ecosystem for a while now. I'm almost there but there is still something that keep giving is me issues, and that's the componentDidUpdate method. When I dispatch an async action, the store is reducer is called correctly and the component's state does update.</p>

<p>But for some reason, the componentDidUpdate method does not fire, there is no re-render, and I cannot access the updated props. I can see it change in devtools, if I console.log(this.props.blogStore). At first it shows as an empty object but when on click it opens and shows the updated state.</p>

<p>I've tried as many life cycle methods as I can but nothing seems to work, including componentWillReceiveProps.</p>

<p>Any idea what I'm doing wrong?</p>

<p>Here is the code:</p>

<p><strong>index.js</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';

import App from './App';
import Datastore from 'Datastore';

const store = Datastore()

store.subscribe(() =&gt; console.log(""state changed"", store.getState()))

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById('app')
);
</code></pre>

<p><strong>Datastore.js</strong></p>

<pre><code>import { combineReducers, createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk'

import Mainmenu from 'reducers/Mainmenu';
import Blogstore from 'reducers/Blogstore';

const reducer = combineReducers({
    Mainmenu,
    Blogstore,
})

export default function Datastore() {
    const store = createStore(
        reducer,
        applyMiddleware(thunk)
    )

    return store
}
</code></pre>

<p><strong>reducer</strong></p>

<pre><code>import Article from 'lib/Article';
import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';

const initialBlogState = {
}

const Blogstore = (state=initialBlogState, action) =&gt; {
    switch(action.type) {
        case SAVE_ARTICLE_LIST:
            state.init = true
            state.articles = action.payload
            return state
        case ARTICLE_LOAD:
            return state
        case ARTICLE_UPDATE:
            return state
    }
    return state
}

export default Blogstore;
</code></pre>

<p><strong>blog-actions.js</strong></p>

<pre><code>import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';
import APIFetch from '../lib/Fetch';

export function getArticlePids() {
    return dispatch =&gt; {
        APIFetch().get(""/blog/list"").then(response =&gt; {
            dispatch({
                type: SAVE_ARTICLE_LIST,
                payload: response.data
            })
        })
    }
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import * as blogActions from '../actions/blog-actions';

@connect(state =&gt; ({
    blogStore: state.Blogstore
}))
export default class Blog extends React.Component {
    constructor() {
        super()
    }

    componentDidMount() {
        this.props.dispatch(blogActions.getArticlePids())
    }

    componentDidUpdate(prevProps) {
        console.log(""update"", prevProps)
    }

    render() {
        console.log(""render"", this.props.blogStore)

        return (
            &lt;div&gt;&lt;h1&gt;Blog&lt;/h1&gt;&lt;/div&gt;
        )

    }
}
</code></pre>

<p>That is pretty much it. I won't bother pasting the App and Router that are between index.js and the component because there is nothing of interest there. Just a basic react router and components that have nothing to do with this.</p>
","I think the render function needs to return a different result in order for the reconciliation to detect changes: https://facebook.github.io/react/docs/react-component.html#componentdidupdate

so on your return function you have to returns something like:

<div>{this.props.blogStore}</div> for it to work"
"42872062","componentDidUpdate does not fire","4","<p>So I've been struggling to figure out the react-redux ecosystem for a while now. I'm almost there but there is still something that keep giving is me issues, and that's the componentDidUpdate method. When I dispatch an async action, the store is reducer is called correctly and the component's state does update.</p>

<p>But for some reason, the componentDidUpdate method does not fire, there is no re-render, and I cannot access the updated props. I can see it change in devtools, if I console.log(this.props.blogStore). At first it shows as an empty object but when on click it opens and shows the updated state.</p>

<p>I've tried as many life cycle methods as I can but nothing seems to work, including componentWillReceiveProps.</p>

<p>Any idea what I'm doing wrong?</p>

<p>Here is the code:</p>

<p><strong>index.js</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';

import App from './App';
import Datastore from 'Datastore';

const store = Datastore()

store.subscribe(() =&gt; console.log(""state changed"", store.getState()))

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById('app')
);
</code></pre>

<p><strong>Datastore.js</strong></p>

<pre><code>import { combineReducers, createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk'

import Mainmenu from 'reducers/Mainmenu';
import Blogstore from 'reducers/Blogstore';

const reducer = combineReducers({
    Mainmenu,
    Blogstore,
})

export default function Datastore() {
    const store = createStore(
        reducer,
        applyMiddleware(thunk)
    )

    return store
}
</code></pre>

<p><strong>reducer</strong></p>

<pre><code>import Article from 'lib/Article';
import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';

const initialBlogState = {
}

const Blogstore = (state=initialBlogState, action) =&gt; {
    switch(action.type) {
        case SAVE_ARTICLE_LIST:
            state.init = true
            state.articles = action.payload
            return state
        case ARTICLE_LOAD:
            return state
        case ARTICLE_UPDATE:
            return state
    }
    return state
}

export default Blogstore;
</code></pre>

<p><strong>blog-actions.js</strong></p>

<pre><code>import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';
import APIFetch from '../lib/Fetch';

export function getArticlePids() {
    return dispatch =&gt; {
        APIFetch().get(""/blog/list"").then(response =&gt; {
            dispatch({
                type: SAVE_ARTICLE_LIST,
                payload: response.data
            })
        })
    }
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import * as blogActions from '../actions/blog-actions';

@connect(state =&gt; ({
    blogStore: state.Blogstore
}))
export default class Blog extends React.Component {
    constructor() {
        super()
    }

    componentDidMount() {
        this.props.dispatch(blogActions.getArticlePids())
    }

    componentDidUpdate(prevProps) {
        console.log(""update"", prevProps)
    }

    render() {
        console.log(""render"", this.props.blogStore)

        return (
            &lt;div&gt;&lt;h1&gt;Blog&lt;/h1&gt;&lt;/div&gt;
        )

    }
}
</code></pre>

<p>That is pretty much it. I won't bother pasting the App and Router that are between index.js and the component because there is nothing of interest there. Just a basic react router and components that have nothing to do with this.</p>
","Could you also post your reducer? Looks like you got side effect somewhere."
"42872062","componentDidUpdate does not fire","4","<p>So I've been struggling to figure out the react-redux ecosystem for a while now. I'm almost there but there is still something that keep giving is me issues, and that's the componentDidUpdate method. When I dispatch an async action, the store is reducer is called correctly and the component's state does update.</p>

<p>But for some reason, the componentDidUpdate method does not fire, there is no re-render, and I cannot access the updated props. I can see it change in devtools, if I console.log(this.props.blogStore). At first it shows as an empty object but when on click it opens and shows the updated state.</p>

<p>I've tried as many life cycle methods as I can but nothing seems to work, including componentWillReceiveProps.</p>

<p>Any idea what I'm doing wrong?</p>

<p>Here is the code:</p>

<p><strong>index.js</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';

import App from './App';
import Datastore from 'Datastore';

const store = Datastore()

store.subscribe(() =&gt; console.log(""state changed"", store.getState()))

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById('app')
);
</code></pre>

<p><strong>Datastore.js</strong></p>

<pre><code>import { combineReducers, createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk'

import Mainmenu from 'reducers/Mainmenu';
import Blogstore from 'reducers/Blogstore';

const reducer = combineReducers({
    Mainmenu,
    Blogstore,
})

export default function Datastore() {
    const store = createStore(
        reducer,
        applyMiddleware(thunk)
    )

    return store
}
</code></pre>

<p><strong>reducer</strong></p>

<pre><code>import Article from 'lib/Article';
import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';

const initialBlogState = {
}

const Blogstore = (state=initialBlogState, action) =&gt; {
    switch(action.type) {
        case SAVE_ARTICLE_LIST:
            state.init = true
            state.articles = action.payload
            return state
        case ARTICLE_LOAD:
            return state
        case ARTICLE_UPDATE:
            return state
    }
    return state
}

export default Blogstore;
</code></pre>

<p><strong>blog-actions.js</strong></p>

<pre><code>import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';
import APIFetch from '../lib/Fetch';

export function getArticlePids() {
    return dispatch =&gt; {
        APIFetch().get(""/blog/list"").then(response =&gt; {
            dispatch({
                type: SAVE_ARTICLE_LIST,
                payload: response.data
            })
        })
    }
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import * as blogActions from '../actions/blog-actions';

@connect(state =&gt; ({
    blogStore: state.Blogstore
}))
export default class Blog extends React.Component {
    constructor() {
        super()
    }

    componentDidMount() {
        this.props.dispatch(blogActions.getArticlePids())
    }

    componentDidUpdate(prevProps) {
        console.log(""update"", prevProps)
    }

    render() {
        console.log(""render"", this.props.blogStore)

        return (
            &lt;div&gt;&lt;h1&gt;Blog&lt;/h1&gt;&lt;/div&gt;
        )

    }
}
</code></pre>

<p>That is pretty much it. I won't bother pasting the App and Router that are between index.js and the component because there is nothing of interest there. Just a basic react router and components that have nothing to do with this.</p>
","@Shota Sure, just included it in the code block. It's very barebones atm, since I'm simply just trying things out to try get it all to work."
"42872062","componentDidUpdate does not fire","4","<p>So I've been struggling to figure out the react-redux ecosystem for a while now. I'm almost there but there is still something that keep giving is me issues, and that's the componentDidUpdate method. When I dispatch an async action, the store is reducer is called correctly and the component's state does update.</p>

<p>But for some reason, the componentDidUpdate method does not fire, there is no re-render, and I cannot access the updated props. I can see it change in devtools, if I console.log(this.props.blogStore). At first it shows as an empty object but when on click it opens and shows the updated state.</p>

<p>I've tried as many life cycle methods as I can but nothing seems to work, including componentWillReceiveProps.</p>

<p>Any idea what I'm doing wrong?</p>

<p>Here is the code:</p>

<p><strong>index.js</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';

import App from './App';
import Datastore from 'Datastore';

const store = Datastore()

store.subscribe(() =&gt; console.log(""state changed"", store.getState()))

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById('app')
);
</code></pre>

<p><strong>Datastore.js</strong></p>

<pre><code>import { combineReducers, createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk'

import Mainmenu from 'reducers/Mainmenu';
import Blogstore from 'reducers/Blogstore';

const reducer = combineReducers({
    Mainmenu,
    Blogstore,
})

export default function Datastore() {
    const store = createStore(
        reducer,
        applyMiddleware(thunk)
    )

    return store
}
</code></pre>

<p><strong>reducer</strong></p>

<pre><code>import Article from 'lib/Article';
import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';

const initialBlogState = {
}

const Blogstore = (state=initialBlogState, action) =&gt; {
    switch(action.type) {
        case SAVE_ARTICLE_LIST:
            state.init = true
            state.articles = action.payload
            return state
        case ARTICLE_LOAD:
            return state
        case ARTICLE_UPDATE:
            return state
    }
    return state
}

export default Blogstore;
</code></pre>

<p><strong>blog-actions.js</strong></p>

<pre><code>import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';
import APIFetch from '../lib/Fetch';

export function getArticlePids() {
    return dispatch =&gt; {
        APIFetch().get(""/blog/list"").then(response =&gt; {
            dispatch({
                type: SAVE_ARTICLE_LIST,
                payload: response.data
            })
        })
    }
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import * as blogActions from '../actions/blog-actions';

@connect(state =&gt; ({
    blogStore: state.Blogstore
}))
export default class Blog extends React.Component {
    constructor() {
        super()
    }

    componentDidMount() {
        this.props.dispatch(blogActions.getArticlePids())
    }

    componentDidUpdate(prevProps) {
        console.log(""update"", prevProps)
    }

    render() {
        console.log(""render"", this.props.blogStore)

        return (
            &lt;div&gt;&lt;h1&gt;Blog&lt;/h1&gt;&lt;/div&gt;
        )

    }
}
</code></pre>

<p>That is pretty much it. I won't bother pasting the App and Router that are between index.js and the component because there is nothing of interest there. Just a basic react router and components that have nothing to do with this.</p>
","@ospfranco Tried that but doesn't seem to do anything. I'm also trying to call this.forceUpdate() after the dispatch but I think it just re-renders the component before the promise finishes."
"43478003","Child does not update when generated via array react","0","<p>I've made a simple react app where i am generated child components via an array that is inside my state:</p>

<p>School.js:</p>

<pre><code>import React from 'react';
import Person from './Person';

export default class School extends React.Component {
  constructor() {
    super();
    this.state = {
      persons: [
        {id: 0, name: ""person0""},
        {id: 1, name: ""person1""},
        {id: 2, name: ""person2""},
        {id: 3, name: ""person3""},
        {id: 4, name: ""person4""},
        {id: 5, name: ""person5""},
        {id: 6, name: ""person6""},
        {id: 7, name: ""person7""},
        {id: 8, name: ""person8""},
        {id: 9, name: ""person9""}
      ]
    };

    this.personList = this.state.persons.map((p) =&gt;
      &lt;Person key={p.id} info={p} updateState={this.updateState.bind(this)} /&gt;
    );
  }

  updateState(){
    this.setState({
      persons: [
        {id: 0, name: ""person000000000""},
        {id: 1, name: ""person100000000""},
        {id: 2, name: ""person200000000""},
        {id: 3, name: ""person300000000""},
        {id: 4, name: ""person400000000""},
        {id: 5, name: ""person500000000""},
        {id: 6, name: ""person600000000""},
        {id: 7, name: ""person700000000""},
        {id: 8, name: ""person800000000""},
        {id: 9, name: ""person900000000""}
      ]
    });
    console.log(this.state);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;All my persons:&lt;/h1&gt;
        &lt;ul&gt;
          {this.personList}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>Person.js:</p>

<pre><code>import React from 'react';

export default class Person extends React.Component {
    constructor(){
        super();
    }

    componentDidUpdate(){
        console.log(""updated"");
    }

    render(){
        return(
            &lt;p onClick={this.props.updateState}&gt;I'm {this.props.info.name} and my id is {this.props.info.id}&lt;/p&gt;
        );
    }
}
</code></pre>

<p>My childs are rendered, but when i update the state via onClick on one of my childs, the state is updated (you can check it when you console.log in 'updateState' method in School), but my childs are not rerendered.</p>

<p>How does this come and why? Can you create children like this (via array in state)?</p>

<p>Thanks!</p>
",""
"43541451","React - componentDidUpdate called infinite times","2","<p>I'm new to React and I feel I didn't catch the component lifecycle flow, this is the component I have:</p>

<pre><code>import React, {Component, PropTypes} from 'react';
import { connect } from 'react-redux';
import { fetchMyWishlist, fetchSpecificBook } from '../actions/index';

class Cart extends Component {

  static contextTypes = {
        router:PropTypes.object
    };

  constructor(props) {
    super(props);
    this.state = { currentCart:[], currentBook:[], wishlist:[] };

    var self = this;
    if (this.props.authenticated){
      this.props.fetchMyWishlist(this.props.signedInUserInfo._id).then(function(data){
        self.setState({ currentCart: data});
      });
    }
    else {
      this.context.router.push('/signin');
    }
  }

  componentWillMount(){}

  componentDidMount(){
    // I get undefined here
    console.log(""component has been mounted: ""+this.state.currentCart.payload);
  }

  componentDidUpdate(prevProps, prevState){
    var jsonObj = this.state.currentCart.payload;
    console.log(""test: ""+JSON.stringify(this.state.currentCart.payload));
    var self = this;
    if ((jsonObj) &amp;&amp; (jsonObj.data)){   
      return jsonObj.data.map(function(book){
          self.props.fetchSpecificBook(book.itemID);
      });
    }
  }


  render() {
    console.log(""rendering"");

    return (
      &lt;div&gt;
        &lt;div&gt;
          &lt;h3&gt;Your wishlist&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

function mapStateToProps(state){
  return {
    currentCart: state.bookReducer.currentCart,
    currentBook: state.bookReducer.currentBook,
    authenticated: state.auth.authenticated,
    signedInUserInfo:state.auth.signedInUserInfo
  };
}

export default connect(mapStateToProps, {fetchMyWishlist, fetchSpecificBook})(Cart);
</code></pre>

<p>This is what I'm doing: inside the constructor the action <code>fetchMyWishlist</code> is called and it returns an array of book ids. The reducer updates the <code>currentCart</code> state with the result of <code>fetchMyWishlist</code> action.</p>

<p>First thing I don't understand is why in componentDidMount <code>this.state.currentCart.payload</code> is undefined.
So I try to do my operations inside <code>componentDidUpdate</code> where <code>this.state.currentCart.payload</code> is defined and I can iterate through it.
Here for each book I try to retrieve additional information via <code>fetchSpecificBook</code> action.
The problem here is that I get infinite number of action calls.
What I'd like to do is to store all additional books information into an array.</p>

<p>How do I go about this? </p>
","i will suggest to the lifecycle methods and there flow: https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle , you will get  the reason of the error."
"43541451","React - componentDidUpdate called infinite times","2","<p>I'm new to React and I feel I didn't catch the component lifecycle flow, this is the component I have:</p>

<pre><code>import React, {Component, PropTypes} from 'react';
import { connect } from 'react-redux';
import { fetchMyWishlist, fetchSpecificBook } from '../actions/index';

class Cart extends Component {

  static contextTypes = {
        router:PropTypes.object
    };

  constructor(props) {
    super(props);
    this.state = { currentCart:[], currentBook:[], wishlist:[] };

    var self = this;
    if (this.props.authenticated){
      this.props.fetchMyWishlist(this.props.signedInUserInfo._id).then(function(data){
        self.setState({ currentCart: data});
      });
    }
    else {
      this.context.router.push('/signin');
    }
  }

  componentWillMount(){}

  componentDidMount(){
    // I get undefined here
    console.log(""component has been mounted: ""+this.state.currentCart.payload);
  }

  componentDidUpdate(prevProps, prevState){
    var jsonObj = this.state.currentCart.payload;
    console.log(""test: ""+JSON.stringify(this.state.currentCart.payload));
    var self = this;
    if ((jsonObj) &amp;&amp; (jsonObj.data)){   
      return jsonObj.data.map(function(book){
          self.props.fetchSpecificBook(book.itemID);
      });
    }
  }


  render() {
    console.log(""rendering"");

    return (
      &lt;div&gt;
        &lt;div&gt;
          &lt;h3&gt;Your wishlist&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

function mapStateToProps(state){
  return {
    currentCart: state.bookReducer.currentCart,
    currentBook: state.bookReducer.currentBook,
    authenticated: state.auth.authenticated,
    signedInUserInfo:state.auth.signedInUserInfo
  };
}

export default connect(mapStateToProps, {fetchMyWishlist, fetchSpecificBook})(Cart);
</code></pre>

<p>This is what I'm doing: inside the constructor the action <code>fetchMyWishlist</code> is called and it returns an array of book ids. The reducer updates the <code>currentCart</code> state with the result of <code>fetchMyWishlist</code> action.</p>

<p>First thing I don't understand is why in componentDidMount <code>this.state.currentCart.payload</code> is undefined.
So I try to do my operations inside <code>componentDidUpdate</code> where <code>this.state.currentCart.payload</code> is defined and I can iterate through it.
Here for each book I try to retrieve additional information via <code>fetchSpecificBook</code> action.
The problem here is that I get infinite number of action calls.
What I'd like to do is to store all additional books information into an array.</p>

<p>How do I go about this? </p>
","I have removed `redux` tags because you are using redux library but not the redux architecture."
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","Let us [continue this discussion in chat](http://chat.stackoverflow.com/rooms/142459/discussion-between-chris-and-codincat)."
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","I do have some guard conditions to prevent this."
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","How many times does `render()` run when going from `Foo` to `Dashboard`?"
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","@Chris 1, but after that Dashboard will dispatch 4 actions in total and each of them will cause a re-render"
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","Well the problem is that `componentDidUpdate` will run each time there is a re-render. Which is bad on its own, especially if it's an expensive algorithm. You need to figure out a way to prevent that from happening. Maybe add a flag which is toggled when the 4 actions are finished."
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","@Chris In my real code it's 5, but the 2~5 `render`s are just to fill data to the Dashboard."
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","I just removed these actions to test and the `render()` only executes 1 time"
"43583471","Defer componentDidUpdate, make it execute after browser paints","8","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","So it renders 5 times?"
"43726814","How to fix warning caused by Flow Function Types using eslint-plugin-react?","1","<p>I'm getting a warning on the following line on my react component</p>

<pre><code>handleToggle: Function;
</code></pre>

<p>I'm using <a href=""https://github.com/yannickcr/eslint-plugin-react"" rel=""nofollow noreferrer"">eslint-plugin-react</a> and <a href=""https://flow.org/"" rel=""nofollow noreferrer"">Flow</a> and I'm getting a warning ""handleToggle should be placed after constructor"". This is related to rule react/sort-comp. I tried with the following on my .eslintrc.json</p>

<pre><code> ""react/sort-comp"": [1, {
  ""order"": [
    ""static-methods"",
    ""lifecycle"",
    ""everything-else"",
    ""render""
  ],
  ""groups"": {
    ""lifecycle"": [
      ""displayName"",
      ""propTypes"",
      ""contextTypes"",
      ""childContextTypes"",
      ""/^.*: Function$/"",
      ""mixins"",
      ""statics"",
      ""defaultProps"",
      ""state"",
      ""constructor"",
      ""getDefaultProps"",
      ""getInitialState"",
      ""getChildContext"",
      ""componentWillMount"",
      ""componentDidMount"",
      ""componentWillReceiveProps"",
      ""shouldComponentUpdate"",
      ""componentWillUpdate"",
      ""componentDidUpdate"",
      ""componentWillUnmount""
    ]
  }
}]
</code></pre>

<p>But I'm unable to fix the warning. I want the Function Types before constructor the same as the other Type Definition. How can I achieve this?</p>
","It would help if you included a code snippet that illustrates how you want your code to be organized, and exhibits the undesirable warning."
"43778512","How to sroll list item into view after componentDidUpdate?","5","<p>If have a react js view with a long list of items. After rendering I want to select a certain list item via ref and scroll it into the view to make it visible to the user. At the moment I need a timeout, because that certain item has not been created in the dom on componentDidUpdate. How can I achieve the scroll into the view without a timeout?</p>

<p>React</p>

<pre><code> componentDidUpdate() {

  const that = this;

  setTimeout(function() {
    that.refs.itemSelected.scrollIntoView();
  }, 1000);

 },
</code></pre>
","So the list of items is populated asynchronously?"
"43778512","How to sroll list item into view after componentDidUpdate?","5","<p>If have a react js view with a long list of items. After rendering I want to select a certain list item via ref and scroll it into the view to make it visible to the user. At the moment I need a timeout, because that certain item has not been created in the dom on componentDidUpdate. How can I achieve the scroll into the view without a timeout?</p>

<p>React</p>

<pre><code> componentDidUpdate() {

  const that = this;

  setTimeout(function() {
    that.refs.itemSelected.scrollIntoView();
  }, 1000);

 },
</code></pre>
","If the list gets populated from state or a prop componentDidUpdate will be called after everything has rendered"
"43778512","How to sroll list item into view after componentDidUpdate?","5","<p>If have a react js view with a long list of items. After rendering I want to select a certain list item via ref and scroll it into the view to make it visible to the user. At the moment I need a timeout, because that certain item has not been created in the dom on componentDidUpdate. How can I achieve the scroll into the view without a timeout?</p>

<p>React</p>

<pre><code> componentDidUpdate() {

  const that = this;

  setTimeout(function() {
    that.refs.itemSelected.scrollIntoView();
  }, 1000);

 },
</code></pre>
","@Chris sometimes the list gets updated and needs to be scrolled accordingly"
"43778512","How to sroll list item into view after componentDidUpdate?","5","<p>If have a react js view with a long list of items. After rendering I want to select a certain list item via ref and scroll it into the view to make it visible to the user. At the moment I need a timeout, because that certain item has not been created in the dom on componentDidUpdate. How can I achieve the scroll into the view without a timeout?</p>

<p>React</p>

<pre><code> componentDidUpdate() {

  const that = this;

  setTimeout(function() {
    that.refs.itemSelected.scrollIntoView();
  }, 1000);

 },
</code></pre>
","I understand that, but it is being populated asynchronously, right? :)"
"43778512","How to sroll list item into view after componentDidUpdate?","5","<p>If have a react js view with a long list of items. After rendering I want to select a certain list item via ref and scroll it into the view to make it visible to the user. At the moment I need a timeout, because that certain item has not been created in the dom on componentDidUpdate. How can I achieve the scroll into the view without a timeout?</p>

<p>React</p>

<pre><code> componentDidUpdate() {

  const that = this;

  setTimeout(function() {
    that.refs.itemSelected.scrollIntoView();
  }, 1000);

 },
</code></pre>
","as a side note: you can use an arrow function syntax in your `setTimeout` so you don't have to use the old re-referencing trick, `const that = this;`"
"43845980","where to insert my todo in reactJs using axios post request?","4","<p>where to write axios post request to insert todo into database.If I write axios post request in componentDidUpdate() whenever click on checkbox for todo_completed status it will insert in database. duplicate record maintains fro true and false. i dont understand where to call post request in todoApp.jsx
Here is my Code
todoapp.jsx</p>

<pre><code>    var React = require('react');
    var TodoSearch = require('TodoSearch');
    var AddTodo = require('AddTodo');
    var TodoList = require('TodoList');
    var axios= require('axios');
    var TodoApp=React.createClass({
        getInitialState:function(){
            return{
                todo_completed:false,
                strSearchText:'',
                todos:[]

            };
        },
        componentDidMount:function(){
            var that=this;
            axios.post('/displaytodo').then(function (response){
                console.log(""display"");
                var todos=response.data;
                console.log(todos);
                that.setState({
                    todos:response.data
                });
            }).catch(function (error){
                console.log(error);
            });

        },
        componentDidUpdate:function(){
            var todo_text="""";
            var todo_completed="""";
            this.state.todos.forEach(function(todo){
                todo_text= todo.todo_text;
                todo_completed=todo.todo_completed;
            });
//insert todo in database
            axios.post('/addtodo',{
                todo_text:todo_text,
                todo_completed:todo_completed

            }).then(function (response) {

                console.log(""data"");
            }).catch(function (error) {
                console.log(error);
            });
            },
        handleAddTodo:function(todo_text){
            alert(""new todo ""+todo_text);
                    //insert query needed to add todo
             this.setState({
                todos:[
                ...this.state.todos,
                {
                    todo_text:todo_text,
                    todo_completed:false    
                }
                ]
             });
                },
        handleToggle:function(todo_id){
            var updatedTodos=this.state.todos.map((todo)=&gt;{
                if(todo.todo_id===todo_id){
                    todo.todo_completed=!todo.todo_completed;
                }
                return todo;
            });
            //update query required for completed status
            this.setState({
                todos:updatedTodos
            })
            //alert(id);
        },
        handleSearch:function(boolShowCompleted,strSearchText){
            this.setState({
                boolShowCompleted:boolShowCompleted,
                strSearchText:strSearchText.toLowerCase()

            });
        },
        render:function(){
            var urlValue = this.props.params.sessionValue;
            console.log(urlValue);
            var {todos}=this.state;
            return(
                &lt;div&gt;
                    {urlValue}
                    &lt;TodoSearch onSearch={this.handleSearch}/&gt;
                    &lt;TodoList todos={todos} onToggle={this.handleToggle}/&gt;
                    &lt;AddTodo onAddTodo={this.handleAddTodo}/&gt;
                &lt;/div&gt;
                )
        }
    });
    module.exports=TodoApp;
</code></pre>

<p><strong>AddTodo.jsx</strong></p>

<pre><code> var AddTodo = React.createClass({
             handleSubmit: function(e) {
                 e.preventDefault();
                 var strTodoText = this.refs.strTodoText.value;
                 if (strTodoText.length &gt; 0) {
                     this.refs.strTodoText.value = '';
                     this.props.onAddTodo(strTodoText);
                 } else {
                     this.refs.strTodoText.focus();
                 }
             },
             render: function() {

                     return ( &lt; div &gt;
                                 &lt; form onSubmit = { this.handleSubmit } &gt; 

                                 &lt; input type = ""text""  ref = ""strTodoText"" / &gt; 
                                 &lt; button className = ""button"" &gt; Add Todo &lt; /button&gt; 
                                 &lt;/form &gt; Add todo..... 
                              &lt; /div&gt;
                            )
             } 
 });
</code></pre>
","yes exactly..here is my AddTodo.jsx  
var AddTodo=React.createClass({
handleSubmit:function(e){
e.preventDefault();
var strTodoText = this.refs.strTodoText.value;
			if (strTodoText.length > 0){
	         this.refs.strTodoText.value = '';
	         this.props.onAddTodo(strTodoText);
	        } else {
	        this.refs.strTodoText.focus();}
	  	},
	render:function(){
		return(
			<div>
				<form onSubmit={this.handleSubmit}>
					<input type=""text"" ref=""strTodoText""/>
					<button className=""button"">Add Todo </button>
				</form>
			Add todo.....
			</div>)}
});
});"
"43845980","where to insert my todo in reactJs using axios post request?","4","<p>where to write axios post request to insert todo into database.If I write axios post request in componentDidUpdate() whenever click on checkbox for todo_completed status it will insert in database. duplicate record maintains fro true and false. i dont understand where to call post request in todoApp.jsx
Here is my Code
todoapp.jsx</p>

<pre><code>    var React = require('react');
    var TodoSearch = require('TodoSearch');
    var AddTodo = require('AddTodo');
    var TodoList = require('TodoList');
    var axios= require('axios');
    var TodoApp=React.createClass({
        getInitialState:function(){
            return{
                todo_completed:false,
                strSearchText:'',
                todos:[]

            };
        },
        componentDidMount:function(){
            var that=this;
            axios.post('/displaytodo').then(function (response){
                console.log(""display"");
                var todos=response.data;
                console.log(todos);
                that.setState({
                    todos:response.data
                });
            }).catch(function (error){
                console.log(error);
            });

        },
        componentDidUpdate:function(){
            var todo_text="""";
            var todo_completed="""";
            this.state.todos.forEach(function(todo){
                todo_text= todo.todo_text;
                todo_completed=todo.todo_completed;
            });
//insert todo in database
            axios.post('/addtodo',{
                todo_text:todo_text,
                todo_completed:todo_completed

            }).then(function (response) {

                console.log(""data"");
            }).catch(function (error) {
                console.log(error);
            });
            },
        handleAddTodo:function(todo_text){
            alert(""new todo ""+todo_text);
                    //insert query needed to add todo
             this.setState({
                todos:[
                ...this.state.todos,
                {
                    todo_text:todo_text,
                    todo_completed:false    
                }
                ]
             });
                },
        handleToggle:function(todo_id){
            var updatedTodos=this.state.todos.map((todo)=&gt;{
                if(todo.todo_id===todo_id){
                    todo.todo_completed=!todo.todo_completed;
                }
                return todo;
            });
            //update query required for completed status
            this.setState({
                todos:updatedTodos
            })
            //alert(id);
        },
        handleSearch:function(boolShowCompleted,strSearchText){
            this.setState({
                boolShowCompleted:boolShowCompleted,
                strSearchText:strSearchText.toLowerCase()

            });
        },
        render:function(){
            var urlValue = this.props.params.sessionValue;
            console.log(urlValue);
            var {todos}=this.state;
            return(
                &lt;div&gt;
                    {urlValue}
                    &lt;TodoSearch onSearch={this.handleSearch}/&gt;
                    &lt;TodoList todos={todos} onToggle={this.handleToggle}/&gt;
                    &lt;AddTodo onAddTodo={this.handleAddTodo}/&gt;
                &lt;/div&gt;
                )
        }
    });
    module.exports=TodoApp;
</code></pre>

<p><strong>AddTodo.jsx</strong></p>

<pre><code> var AddTodo = React.createClass({
             handleSubmit: function(e) {
                 e.preventDefault();
                 var strTodoText = this.refs.strTodoText.value;
                 if (strTodoText.length &gt; 0) {
                     this.refs.strTodoText.value = '';
                     this.props.onAddTodo(strTodoText);
                 } else {
                     this.refs.strTodoText.focus();
                 }
             },
             render: function() {

                     return ( &lt; div &gt;
                                 &lt; form onSubmit = { this.handleSubmit } &gt; 

                                 &lt; input type = ""text""  ref = ""strTodoText"" / &gt; 
                                 &lt; button className = ""button"" &gt; Add Todo &lt; /button&gt; 
                                 &lt;/form &gt; Add todo..... 
                              &lt; /div&gt;
                            )
             } 
 });
</code></pre>
","I haven't seen your AddTodo component. but it should have an input field for todo_text and a button. on button click you should pass the newly typed todo_text to the handleAddTodo function."
"43845980","where to insert my todo in reactJs using axios post request?","4","<p>where to write axios post request to insert todo into database.If I write axios post request in componentDidUpdate() whenever click on checkbox for todo_completed status it will insert in database. duplicate record maintains fro true and false. i dont understand where to call post request in todoApp.jsx
Here is my Code
todoapp.jsx</p>

<pre><code>    var React = require('react');
    var TodoSearch = require('TodoSearch');
    var AddTodo = require('AddTodo');
    var TodoList = require('TodoList');
    var axios= require('axios');
    var TodoApp=React.createClass({
        getInitialState:function(){
            return{
                todo_completed:false,
                strSearchText:'',
                todos:[]

            };
        },
        componentDidMount:function(){
            var that=this;
            axios.post('/displaytodo').then(function (response){
                console.log(""display"");
                var todos=response.data;
                console.log(todos);
                that.setState({
                    todos:response.data
                });
            }).catch(function (error){
                console.log(error);
            });

        },
        componentDidUpdate:function(){
            var todo_text="""";
            var todo_completed="""";
            this.state.todos.forEach(function(todo){
                todo_text= todo.todo_text;
                todo_completed=todo.todo_completed;
            });
//insert todo in database
            axios.post('/addtodo',{
                todo_text:todo_text,
                todo_completed:todo_completed

            }).then(function (response) {

                console.log(""data"");
            }).catch(function (error) {
                console.log(error);
            });
            },
        handleAddTodo:function(todo_text){
            alert(""new todo ""+todo_text);
                    //insert query needed to add todo
             this.setState({
                todos:[
                ...this.state.todos,
                {
                    todo_text:todo_text,
                    todo_completed:false    
                }
                ]
             });
                },
        handleToggle:function(todo_id){
            var updatedTodos=this.state.todos.map((todo)=&gt;{
                if(todo.todo_id===todo_id){
                    todo.todo_completed=!todo.todo_completed;
                }
                return todo;
            });
            //update query required for completed status
            this.setState({
                todos:updatedTodos
            })
            //alert(id);
        },
        handleSearch:function(boolShowCompleted,strSearchText){
            this.setState({
                boolShowCompleted:boolShowCompleted,
                strSearchText:strSearchText.toLowerCase()

            });
        },
        render:function(){
            var urlValue = this.props.params.sessionValue;
            console.log(urlValue);
            var {todos}=this.state;
            return(
                &lt;div&gt;
                    {urlValue}
                    &lt;TodoSearch onSearch={this.handleSearch}/&gt;
                    &lt;TodoList todos={todos} onToggle={this.handleToggle}/&gt;
                    &lt;AddTodo onAddTodo={this.handleAddTodo}/&gt;
                &lt;/div&gt;
                )
        }
    });
    module.exports=TodoApp;
</code></pre>

<p><strong>AddTodo.jsx</strong></p>

<pre><code> var AddTodo = React.createClass({
             handleSubmit: function(e) {
                 e.preventDefault();
                 var strTodoText = this.refs.strTodoText.value;
                 if (strTodoText.length &gt; 0) {
                     this.refs.strTodoText.value = '';
                     this.props.onAddTodo(strTodoText);
                 } else {
                     this.refs.strTodoText.focus();
                 }
             },
             render: function() {

                     return ( &lt; div &gt;
                                 &lt; form onSubmit = { this.handleSubmit } &gt; 

                                 &lt; input type = ""text""  ref = ""strTodoText"" / &gt; 
                                 &lt; button className = ""button"" &gt; Add Todo &lt; /button&gt; 
                                 &lt;/form &gt; Add todo..... 
                              &lt; /div&gt;
                            )
             } 
 });
</code></pre>
","when i add axios post rrequest in  handleAddTodo it contains last added todo in post request"
"43845980","where to insert my todo in reactJs using axios post request?","4","<p>where to write axios post request to insert todo into database.If I write axios post request in componentDidUpdate() whenever click on checkbox for todo_completed status it will insert in database. duplicate record maintains fro true and false. i dont understand where to call post request in todoApp.jsx
Here is my Code
todoapp.jsx</p>

<pre><code>    var React = require('react');
    var TodoSearch = require('TodoSearch');
    var AddTodo = require('AddTodo');
    var TodoList = require('TodoList');
    var axios= require('axios');
    var TodoApp=React.createClass({
        getInitialState:function(){
            return{
                todo_completed:false,
                strSearchText:'',
                todos:[]

            };
        },
        componentDidMount:function(){
            var that=this;
            axios.post('/displaytodo').then(function (response){
                console.log(""display"");
                var todos=response.data;
                console.log(todos);
                that.setState({
                    todos:response.data
                });
            }).catch(function (error){
                console.log(error);
            });

        },
        componentDidUpdate:function(){
            var todo_text="""";
            var todo_completed="""";
            this.state.todos.forEach(function(todo){
                todo_text= todo.todo_text;
                todo_completed=todo.todo_completed;
            });
//insert todo in database
            axios.post('/addtodo',{
                todo_text:todo_text,
                todo_completed:todo_completed

            }).then(function (response) {

                console.log(""data"");
            }).catch(function (error) {
                console.log(error);
            });
            },
        handleAddTodo:function(todo_text){
            alert(""new todo ""+todo_text);
                    //insert query needed to add todo
             this.setState({
                todos:[
                ...this.state.todos,
                {
                    todo_text:todo_text,
                    todo_completed:false    
                }
                ]
             });
                },
        handleToggle:function(todo_id){
            var updatedTodos=this.state.todos.map((todo)=&gt;{
                if(todo.todo_id===todo_id){
                    todo.todo_completed=!todo.todo_completed;
                }
                return todo;
            });
            //update query required for completed status
            this.setState({
                todos:updatedTodos
            })
            //alert(id);
        },
        handleSearch:function(boolShowCompleted,strSearchText){
            this.setState({
                boolShowCompleted:boolShowCompleted,
                strSearchText:strSearchText.toLowerCase()

            });
        },
        render:function(){
            var urlValue = this.props.params.sessionValue;
            console.log(urlValue);
            var {todos}=this.state;
            return(
                &lt;div&gt;
                    {urlValue}
                    &lt;TodoSearch onSearch={this.handleSearch}/&gt;
                    &lt;TodoList todos={todos} onToggle={this.handleToggle}/&gt;
                    &lt;AddTodo onAddTodo={this.handleAddTodo}/&gt;
                &lt;/div&gt;
                )
        }
    });
    module.exports=TodoApp;
</code></pre>

<p><strong>AddTodo.jsx</strong></p>

<pre><code> var AddTodo = React.createClass({
             handleSubmit: function(e) {
                 e.preventDefault();
                 var strTodoText = this.refs.strTodoText.value;
                 if (strTodoText.length &gt; 0) {
                     this.refs.strTodoText.value = '';
                     this.props.onAddTodo(strTodoText);
                 } else {
                     this.refs.strTodoText.focus();
                 }
             },
             render: function() {

                     return ( &lt; div &gt;
                                 &lt; form onSubmit = { this.handleSubmit } &gt; 

                                 &lt; input type = ""text""  ref = ""strTodoText"" / &gt; 
                                 &lt; button className = ""button"" &gt; Add Todo &lt; /button&gt; 
                                 &lt;/form &gt; Add todo..... 
                              &lt; /div&gt;
                            )
             } 
 });
</code></pre>
","you should make your axios request inside the handleAddTodo method instead of componentDidUpdate."
"43888397","reactjs Target container is not a DOM element error","3","<p>I am using reactjs and react GA for google analytic integration i have the following error in the console:</p>

<pre><code>Uncaught (in promise) Error: _registerComponent(...): Target container is not a DOM element.
at invariant (bundle.js:2844)
at Object._renderNewRootComponent (bundle.js:41047)
at Object._renderSubtreeIntoContainer (bundle.js:41137)
at Object.renderSubtreeIntoContainer [as unstable_renderSubtreeIntoContainer] (bundle.js:41079)
at OverlayTrigger.renderOverlay (bundle.js:85430)
at OverlayTrigger.componentDidUpdate (bundle.js:85319)
at measureLifeCyclePerf (bundle.js:90119)
at bundle.js:90773
at CallbackQueue.notifyAll (bundle.js:39950)
at ReactReconcileTransaction.close (bundle.js:95219)
</code></pre>

<p>I am trying to resolve the issue using several resources.But i couldn't find a solution.</p>

<p><strong>Code:</strong>
Videoplayer.jsx</p>

<pre><code>    import React, {Component} from 'react';
import {Link} from 'react-router';
import videojs from 'video.js';
import {Image, Modal} from 'react-bootstrap/lib';
import 'videojs-contrib-hls';
import GA from '../GA.jsx';

const liveVideoUrl = 'http://vid-129002.hls.chinanetcenter.broadcastapp.agoraio.cn/live/';
class VideoPlayer extends Component {
    constructor(props) {
        super(props);

        this.hideModal = this.hideModal.bind(this);
        this.state = {showPopup: false};        
        this.broadcastData = this.props.broadcastData;
        this.videoUrl = this.broadcastData.recordedUrl;
        this.videoType = 'video/mp4';
        let videoStreamName = this.broadcastData.streamId;
        this.live = null;

        if (this.broadcastData.status !== 'RECORDED') {
            this.videoUrl = liveVideoUrl + videoStreamName + '/playlist.m3u8';
            this.live = (&lt;Image className=""live-logo"" src=""/images/svg/live.svg""/&gt;);
            this.videoType = 'application/x-mpegURL';
        }
    }
    componentDidMount () {
        const
            self = this,
            options = {
                autoplay: true,
                controls: true,
                preload: ""auto"",
                hls: {
                    withCredentials: true
                }
            };

        const playerTarget = 'play_video';
        this.player = videojs(this.videoNode, options);
        this.player.src({
          src: this.videoUrl,
          type: this.videoType,
        });
        this.player.on('ended', () =&gt; {
            self.setState({showPopup: true});
        });



        if (this.player.play()) {
            GA.ManualGA(playerTarget);
        }

    }

    componentWillUnmount() {
        this.player &amp;&amp; this.player.dispose();
        this.player = null;
    }

    hideModal() {
        this.setState({showPopup: false});
    }

    render() {
        let screenShotUrl = this.broadcastData.screenShotUrl;
        let downloadLinkNode = [];

        if (screenShotUrl == null) {
            screenShotUrl = '/images/default-screenshot.png'
        }

        const style = {
            ""backgroundImage"": ""url("" + screenShotUrl + "")""
        };

        if (this.showBanner) {
            if (this.isIphone) {
                downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click"" /&gt;&lt;/Link&gt;);
            } else {
                downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;&lt;/Link&gt;);
            }
        } else {
            downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click""/&gt;
                &lt;/Link&gt;
            );
            downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;
                &lt;/Link&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;div className=""blur-bg"" style={style}/&gt;
                &lt;video className=""video-js vjs-sublime-skin vjs-big-play-centered"" data-setup='{ ""inactivityTimeout"": 0 }' ref={ r =&gt; { this.videoNode = r; } }/&gt;
                {this.live}
                &lt;Modal show={this.state.showPopup} dialogClassName=""app-download-play-end"" onHide={this.hideModal}&gt;
                    &lt;Modal.Header closeButton /&gt;
                    &lt;Modal.Body&gt;
                        &lt;Image src=""/images/swoo-logo-popup.svg"" className=""logo""/&gt;&lt;br/&gt;
                        &lt;Image src=""/images/svg/logo_black.svg""/&gt;
                        &lt;div className=""title""&gt;To view more broadcasts, install SWOO app&lt;/div&gt;
                        &lt;h5&gt;Get the App&lt;/h5&gt;
                        {downloadLinkNode}
                    &lt;/Modal.Body&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}

export default VideoPlayer
</code></pre>

<p><strong>GA.JSX</strong></p>

<pre><code>    function GA(ReactGA) {
    const objects = ['channel_click', 'channel_home_click', 'share_btn_click', 'share_btn_click', 'terms_cond_click', 'privacy_policy_click', 'discover_btn_click', 'profile_btn_click', 'app_dld_close_btn_click', 'top_broadcaster_click', 'app_dld_andoid_btn_click', 'broadcast_live_click', 'broadcast_recorded_click',
     'app_dld_ios_btn_click', 'app_dld_ios_homebtn_click', 'app_dld_andoid_homebtn_click', 'app_dld_aftervideo_android_click', 'app_dld_aftervideo_ios_click', 'play_video', 'pause_video'];

        ReactGA.initialize('UA-96792697-3');''
        document.addEventListener('click',(e) =&gt; {
            let target = e.target.getAttribute('data-ga');
            let additional_value = e.target.getAttribute('data-value');

            if (objects.indexOf(target) &gt;= 0) {
                ReactGA.event({category:'swoo', action: target});
            }

        });

         function ManualGA(target) {
                    ReactGA.event({category:'swoo', action: target});
        }
 }

export default GA;
</code></pre>

<p><strong>Index.jsx:</strong></p>

<pre><code>import React from 'react';
import {render} from 'react-dom';
import {Router, Route, IndexRoute, browserHistory, Redirect} from 'react-router';
import {Provider} from 'react-redux';
import Layout from './components/layout/layout.jsx';
import HomePageContainer from './containers/homePageContainer.jsx';
import SearchPageContainer from './containers/searchPageContainer.jsx';
import configureStore from './store/configureStore.jsx';
import BroadcastDetailContainer from './containers/broadcastDetailContainer.jsx';
import GA from './components/GA.jsx';
//import ManualGA from './components/GA.jsx';
import ReactGA from 'react-ga';
/////////-- Static Pages --///////////
import PrivacyPolicyContainer from './containers/privacyPolicyContainer.jsx';
import PrivacyPolicyforwebContainer from './containers/privacyPolicyforwebContainer.jsx';
import TermsofServiceContainer from './containers/termsOfService.jsx';
import TermsofServiceforwebContainer from './containers/termsofServiceforwebContainer.jsx';
import NotFoundPage from './containers/notFoundPage.jsx';

require(""./stylesheets/customResponsive.css"");
require(""./stylesheets/customStyle.css"");
require(""./stylesheets/videojs.css"");

ReactGA.initialize('UA-96791297-3');
GA(ReactGA);
//ManualGA(ReactGA);


/////////-- End Static Pages --///////////

const store = configureStore();

function fireTracking() {
    ReactGA.pageview(window.location.pathname);
}

render
(
    &lt;Provider store={store}&gt;
        &lt;Router onUpdate={fireTracking} history={browserHistory}&gt;
            &lt;Route component={Layout}&gt;
                &lt;Redirect from='/' to='/home'/&gt;
                &lt;Route path=""/home"" component={HomePageContainer}/&gt;
                &lt;Route path=""/search"" component={SearchPageContainer}/&gt;
                &lt;Route path=""/broadcast/:broadcastId"" component={BroadcastDetailContainer}/&gt;
                &lt;Route path={""/privacy-policy""} component={PrivacyPolicyContainer}/&gt;
                &lt;Route path={""/privacy""} component={PrivacyPolicyforwebContainer}/&gt;
                &lt;Route path={""/terms-of-service""} component={TermsofServiceContainer}/&gt;
                &lt;Route path={""/tos""} component={TermsofServiceforwebContainer}/&gt;
                &lt;Route path=""*"" component={NotFoundPage} /&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;,
    document.getElementById('container')
);
</code></pre>

<p>In <code>videoPlayer.jsx</code> I am getting the abbove error at</p>

<pre><code>if (this.player.play()) {
  GA.ManualGA(playerTarget);
}
</code></pre>
","I hav ethe following code in index.html <!--Container for React rendering-->
<div id=""container""></div>"
"43888397","reactjs Target container is not a DOM element error","3","<p>I am using reactjs and react GA for google analytic integration i have the following error in the console:</p>

<pre><code>Uncaught (in promise) Error: _registerComponent(...): Target container is not a DOM element.
at invariant (bundle.js:2844)
at Object._renderNewRootComponent (bundle.js:41047)
at Object._renderSubtreeIntoContainer (bundle.js:41137)
at Object.renderSubtreeIntoContainer [as unstable_renderSubtreeIntoContainer] (bundle.js:41079)
at OverlayTrigger.renderOverlay (bundle.js:85430)
at OverlayTrigger.componentDidUpdate (bundle.js:85319)
at measureLifeCyclePerf (bundle.js:90119)
at bundle.js:90773
at CallbackQueue.notifyAll (bundle.js:39950)
at ReactReconcileTransaction.close (bundle.js:95219)
</code></pre>

<p>I am trying to resolve the issue using several resources.But i couldn't find a solution.</p>

<p><strong>Code:</strong>
Videoplayer.jsx</p>

<pre><code>    import React, {Component} from 'react';
import {Link} from 'react-router';
import videojs from 'video.js';
import {Image, Modal} from 'react-bootstrap/lib';
import 'videojs-contrib-hls';
import GA from '../GA.jsx';

const liveVideoUrl = 'http://vid-129002.hls.chinanetcenter.broadcastapp.agoraio.cn/live/';
class VideoPlayer extends Component {
    constructor(props) {
        super(props);

        this.hideModal = this.hideModal.bind(this);
        this.state = {showPopup: false};        
        this.broadcastData = this.props.broadcastData;
        this.videoUrl = this.broadcastData.recordedUrl;
        this.videoType = 'video/mp4';
        let videoStreamName = this.broadcastData.streamId;
        this.live = null;

        if (this.broadcastData.status !== 'RECORDED') {
            this.videoUrl = liveVideoUrl + videoStreamName + '/playlist.m3u8';
            this.live = (&lt;Image className=""live-logo"" src=""/images/svg/live.svg""/&gt;);
            this.videoType = 'application/x-mpegURL';
        }
    }
    componentDidMount () {
        const
            self = this,
            options = {
                autoplay: true,
                controls: true,
                preload: ""auto"",
                hls: {
                    withCredentials: true
                }
            };

        const playerTarget = 'play_video';
        this.player = videojs(this.videoNode, options);
        this.player.src({
          src: this.videoUrl,
          type: this.videoType,
        });
        this.player.on('ended', () =&gt; {
            self.setState({showPopup: true});
        });



        if (this.player.play()) {
            GA.ManualGA(playerTarget);
        }

    }

    componentWillUnmount() {
        this.player &amp;&amp; this.player.dispose();
        this.player = null;
    }

    hideModal() {
        this.setState({showPopup: false});
    }

    render() {
        let screenShotUrl = this.broadcastData.screenShotUrl;
        let downloadLinkNode = [];

        if (screenShotUrl == null) {
            screenShotUrl = '/images/default-screenshot.png'
        }

        const style = {
            ""backgroundImage"": ""url("" + screenShotUrl + "")""
        };

        if (this.showBanner) {
            if (this.isIphone) {
                downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click"" /&gt;&lt;/Link&gt;);
            } else {
                downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;&lt;/Link&gt;);
            }
        } else {
            downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click""/&gt;
                &lt;/Link&gt;
            );
            downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;
                &lt;/Link&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;div className=""blur-bg"" style={style}/&gt;
                &lt;video className=""video-js vjs-sublime-skin vjs-big-play-centered"" data-setup='{ ""inactivityTimeout"": 0 }' ref={ r =&gt; { this.videoNode = r; } }/&gt;
                {this.live}
                &lt;Modal show={this.state.showPopup} dialogClassName=""app-download-play-end"" onHide={this.hideModal}&gt;
                    &lt;Modal.Header closeButton /&gt;
                    &lt;Modal.Body&gt;
                        &lt;Image src=""/images/swoo-logo-popup.svg"" className=""logo""/&gt;&lt;br/&gt;
                        &lt;Image src=""/images/svg/logo_black.svg""/&gt;
                        &lt;div className=""title""&gt;To view more broadcasts, install SWOO app&lt;/div&gt;
                        &lt;h5&gt;Get the App&lt;/h5&gt;
                        {downloadLinkNode}
                    &lt;/Modal.Body&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}

export default VideoPlayer
</code></pre>

<p><strong>GA.JSX</strong></p>

<pre><code>    function GA(ReactGA) {
    const objects = ['channel_click', 'channel_home_click', 'share_btn_click', 'share_btn_click', 'terms_cond_click', 'privacy_policy_click', 'discover_btn_click', 'profile_btn_click', 'app_dld_close_btn_click', 'top_broadcaster_click', 'app_dld_andoid_btn_click', 'broadcast_live_click', 'broadcast_recorded_click',
     'app_dld_ios_btn_click', 'app_dld_ios_homebtn_click', 'app_dld_andoid_homebtn_click', 'app_dld_aftervideo_android_click', 'app_dld_aftervideo_ios_click', 'play_video', 'pause_video'];

        ReactGA.initialize('UA-96792697-3');''
        document.addEventListener('click',(e) =&gt; {
            let target = e.target.getAttribute('data-ga');
            let additional_value = e.target.getAttribute('data-value');

            if (objects.indexOf(target) &gt;= 0) {
                ReactGA.event({category:'swoo', action: target});
            }

        });

         function ManualGA(target) {
                    ReactGA.event({category:'swoo', action: target});
        }
 }

export default GA;
</code></pre>

<p><strong>Index.jsx:</strong></p>

<pre><code>import React from 'react';
import {render} from 'react-dom';
import {Router, Route, IndexRoute, browserHistory, Redirect} from 'react-router';
import {Provider} from 'react-redux';
import Layout from './components/layout/layout.jsx';
import HomePageContainer from './containers/homePageContainer.jsx';
import SearchPageContainer from './containers/searchPageContainer.jsx';
import configureStore from './store/configureStore.jsx';
import BroadcastDetailContainer from './containers/broadcastDetailContainer.jsx';
import GA from './components/GA.jsx';
//import ManualGA from './components/GA.jsx';
import ReactGA from 'react-ga';
/////////-- Static Pages --///////////
import PrivacyPolicyContainer from './containers/privacyPolicyContainer.jsx';
import PrivacyPolicyforwebContainer from './containers/privacyPolicyforwebContainer.jsx';
import TermsofServiceContainer from './containers/termsOfService.jsx';
import TermsofServiceforwebContainer from './containers/termsofServiceforwebContainer.jsx';
import NotFoundPage from './containers/notFoundPage.jsx';

require(""./stylesheets/customResponsive.css"");
require(""./stylesheets/customStyle.css"");
require(""./stylesheets/videojs.css"");

ReactGA.initialize('UA-96791297-3');
GA(ReactGA);
//ManualGA(ReactGA);


/////////-- End Static Pages --///////////

const store = configureStore();

function fireTracking() {
    ReactGA.pageview(window.location.pathname);
}

render
(
    &lt;Provider store={store}&gt;
        &lt;Router onUpdate={fireTracking} history={browserHistory}&gt;
            &lt;Route component={Layout}&gt;
                &lt;Redirect from='/' to='/home'/&gt;
                &lt;Route path=""/home"" component={HomePageContainer}/&gt;
                &lt;Route path=""/search"" component={SearchPageContainer}/&gt;
                &lt;Route path=""/broadcast/:broadcastId"" component={BroadcastDetailContainer}/&gt;
                &lt;Route path={""/privacy-policy""} component={PrivacyPolicyContainer}/&gt;
                &lt;Route path={""/privacy""} component={PrivacyPolicyforwebContainer}/&gt;
                &lt;Route path={""/terms-of-service""} component={TermsofServiceContainer}/&gt;
                &lt;Route path={""/tos""} component={TermsofServiceforwebContainer}/&gt;
                &lt;Route path=""*"" component={NotFoundPage} /&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;,
    document.getElementById('container')
);
</code></pre>

<p>In <code>videoPlayer.jsx</code> I am getting the abbove error at</p>

<pre><code>if (this.player.play()) {
  GA.ManualGA(playerTarget);
}
</code></pre>
","have you defined the `id='container'` with any `div` in index.html file ? if not then use this `<div id='container'></div>`"
"43888397","reactjs Target container is not a DOM element error","3","<p>I am using reactjs and react GA for google analytic integration i have the following error in the console:</p>

<pre><code>Uncaught (in promise) Error: _registerComponent(...): Target container is not a DOM element.
at invariant (bundle.js:2844)
at Object._renderNewRootComponent (bundle.js:41047)
at Object._renderSubtreeIntoContainer (bundle.js:41137)
at Object.renderSubtreeIntoContainer [as unstable_renderSubtreeIntoContainer] (bundle.js:41079)
at OverlayTrigger.renderOverlay (bundle.js:85430)
at OverlayTrigger.componentDidUpdate (bundle.js:85319)
at measureLifeCyclePerf (bundle.js:90119)
at bundle.js:90773
at CallbackQueue.notifyAll (bundle.js:39950)
at ReactReconcileTransaction.close (bundle.js:95219)
</code></pre>

<p>I am trying to resolve the issue using several resources.But i couldn't find a solution.</p>

<p><strong>Code:</strong>
Videoplayer.jsx</p>

<pre><code>    import React, {Component} from 'react';
import {Link} from 'react-router';
import videojs from 'video.js';
import {Image, Modal} from 'react-bootstrap/lib';
import 'videojs-contrib-hls';
import GA from '../GA.jsx';

const liveVideoUrl = 'http://vid-129002.hls.chinanetcenter.broadcastapp.agoraio.cn/live/';
class VideoPlayer extends Component {
    constructor(props) {
        super(props);

        this.hideModal = this.hideModal.bind(this);
        this.state = {showPopup: false};        
        this.broadcastData = this.props.broadcastData;
        this.videoUrl = this.broadcastData.recordedUrl;
        this.videoType = 'video/mp4';
        let videoStreamName = this.broadcastData.streamId;
        this.live = null;

        if (this.broadcastData.status !== 'RECORDED') {
            this.videoUrl = liveVideoUrl + videoStreamName + '/playlist.m3u8';
            this.live = (&lt;Image className=""live-logo"" src=""/images/svg/live.svg""/&gt;);
            this.videoType = 'application/x-mpegURL';
        }
    }
    componentDidMount () {
        const
            self = this,
            options = {
                autoplay: true,
                controls: true,
                preload: ""auto"",
                hls: {
                    withCredentials: true
                }
            };

        const playerTarget = 'play_video';
        this.player = videojs(this.videoNode, options);
        this.player.src({
          src: this.videoUrl,
          type: this.videoType,
        });
        this.player.on('ended', () =&gt; {
            self.setState({showPopup: true});
        });



        if (this.player.play()) {
            GA.ManualGA(playerTarget);
        }

    }

    componentWillUnmount() {
        this.player &amp;&amp; this.player.dispose();
        this.player = null;
    }

    hideModal() {
        this.setState({showPopup: false});
    }

    render() {
        let screenShotUrl = this.broadcastData.screenShotUrl;
        let downloadLinkNode = [];

        if (screenShotUrl == null) {
            screenShotUrl = '/images/default-screenshot.png'
        }

        const style = {
            ""backgroundImage"": ""url("" + screenShotUrl + "")""
        };

        if (this.showBanner) {
            if (this.isIphone) {
                downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click"" /&gt;&lt;/Link&gt;);
            } else {
                downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;&lt;/Link&gt;);
            }
        } else {
            downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click""/&gt;
                &lt;/Link&gt;
            );
            downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;
                &lt;/Link&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;div className=""blur-bg"" style={style}/&gt;
                &lt;video className=""video-js vjs-sublime-skin vjs-big-play-centered"" data-setup='{ ""inactivityTimeout"": 0 }' ref={ r =&gt; { this.videoNode = r; } }/&gt;
                {this.live}
                &lt;Modal show={this.state.showPopup} dialogClassName=""app-download-play-end"" onHide={this.hideModal}&gt;
                    &lt;Modal.Header closeButton /&gt;
                    &lt;Modal.Body&gt;
                        &lt;Image src=""/images/swoo-logo-popup.svg"" className=""logo""/&gt;&lt;br/&gt;
                        &lt;Image src=""/images/svg/logo_black.svg""/&gt;
                        &lt;div className=""title""&gt;To view more broadcasts, install SWOO app&lt;/div&gt;
                        &lt;h5&gt;Get the App&lt;/h5&gt;
                        {downloadLinkNode}
                    &lt;/Modal.Body&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}

export default VideoPlayer
</code></pre>

<p><strong>GA.JSX</strong></p>

<pre><code>    function GA(ReactGA) {
    const objects = ['channel_click', 'channel_home_click', 'share_btn_click', 'share_btn_click', 'terms_cond_click', 'privacy_policy_click', 'discover_btn_click', 'profile_btn_click', 'app_dld_close_btn_click', 'top_broadcaster_click', 'app_dld_andoid_btn_click', 'broadcast_live_click', 'broadcast_recorded_click',
     'app_dld_ios_btn_click', 'app_dld_ios_homebtn_click', 'app_dld_andoid_homebtn_click', 'app_dld_aftervideo_android_click', 'app_dld_aftervideo_ios_click', 'play_video', 'pause_video'];

        ReactGA.initialize('UA-96792697-3');''
        document.addEventListener('click',(e) =&gt; {
            let target = e.target.getAttribute('data-ga');
            let additional_value = e.target.getAttribute('data-value');

            if (objects.indexOf(target) &gt;= 0) {
                ReactGA.event({category:'swoo', action: target});
            }

        });

         function ManualGA(target) {
                    ReactGA.event({category:'swoo', action: target});
        }
 }

export default GA;
</code></pre>

<p><strong>Index.jsx:</strong></p>

<pre><code>import React from 'react';
import {render} from 'react-dom';
import {Router, Route, IndexRoute, browserHistory, Redirect} from 'react-router';
import {Provider} from 'react-redux';
import Layout from './components/layout/layout.jsx';
import HomePageContainer from './containers/homePageContainer.jsx';
import SearchPageContainer from './containers/searchPageContainer.jsx';
import configureStore from './store/configureStore.jsx';
import BroadcastDetailContainer from './containers/broadcastDetailContainer.jsx';
import GA from './components/GA.jsx';
//import ManualGA from './components/GA.jsx';
import ReactGA from 'react-ga';
/////////-- Static Pages --///////////
import PrivacyPolicyContainer from './containers/privacyPolicyContainer.jsx';
import PrivacyPolicyforwebContainer from './containers/privacyPolicyforwebContainer.jsx';
import TermsofServiceContainer from './containers/termsOfService.jsx';
import TermsofServiceforwebContainer from './containers/termsofServiceforwebContainer.jsx';
import NotFoundPage from './containers/notFoundPage.jsx';

require(""./stylesheets/customResponsive.css"");
require(""./stylesheets/customStyle.css"");
require(""./stylesheets/videojs.css"");

ReactGA.initialize('UA-96791297-3');
GA(ReactGA);
//ManualGA(ReactGA);


/////////-- End Static Pages --///////////

const store = configureStore();

function fireTracking() {
    ReactGA.pageview(window.location.pathname);
}

render
(
    &lt;Provider store={store}&gt;
        &lt;Router onUpdate={fireTracking} history={browserHistory}&gt;
            &lt;Route component={Layout}&gt;
                &lt;Redirect from='/' to='/home'/&gt;
                &lt;Route path=""/home"" component={HomePageContainer}/&gt;
                &lt;Route path=""/search"" component={SearchPageContainer}/&gt;
                &lt;Route path=""/broadcast/:broadcastId"" component={BroadcastDetailContainer}/&gt;
                &lt;Route path={""/privacy-policy""} component={PrivacyPolicyContainer}/&gt;
                &lt;Route path={""/privacy""} component={PrivacyPolicyforwebContainer}/&gt;
                &lt;Route path={""/terms-of-service""} component={TermsofServiceContainer}/&gt;
                &lt;Route path={""/tos""} component={TermsofServiceforwebContainer}/&gt;
                &lt;Route path=""*"" component={NotFoundPage} /&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;,
    document.getElementById('container')
);
</code></pre>

<p>In <code>videoPlayer.jsx</code> I am getting the abbove error at</p>

<pre><code>if (this.player.play()) {
  GA.ManualGA(playerTarget);
}
</code></pre>
","Possible duplicate of [Invariant Violation: \_registerComponent(...): Target container is not a DOM element](http://stackoverflow.com/questions/26566317/invariant-violation-registercomponent-target-container-is-not-a-dom-elem)"
"43930500","react-boilerplate authentication login page flashes on page reload","4","<p>I'm working on an app with a login page and the rest of the pages of the app (should be logged in to view). I'm using  <a href=""https://github.com/react-boilerplate/react-boilerplate"" rel=""nofollow noreferrer""><code>react-boilerplate</code></a>. From this <a href=""https://github.com/react-boilerplate/react-boilerplate/issues/453#issuecomment-223279221"" rel=""nofollow noreferrer""><code>example</code></a>, I edited my <code>asyncInjectors.js</code> file to have <code>redirectToLogin</code> and <code>redirectToDashboard</code> methods:</p>

<pre><code>//asyncInjectors.js
export function redirectToLogin(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (!isAuthenticated) {
      replaceState({
        pathname: '/login',
        state: {
          nextPathname: nextState.location.pathname,
        },
      });
    }
  };
}

export function redirectToDashboard(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (isAuthenticated) {
      replaceState('/');
    }
  }
}
</code></pre>

<p>Then I just set the <code>redirectToLogin</code> as the <code>onEnter</code> of the pages and <code>redirectToDashboard</code> for the login page.</p>

<p>It works fine but when the page is refreshed (<strong><code>F5</code></strong>) when logged in, the login page renders briefly and then renders the actual page. The login page just dispatches an <code>authenticate</code> action in <code>componentWillMount</code> and then redirects in <code>componentDidUpdate</code>:</p>

<pre><code>//login.js
componentWillMount() {
  this.props.dispatch(authenticate());
}

componentDidUpdate(prevProps, prevState) {
  if (this.props.isAuthenticated) {
    const nextPathname = prevProps.location.state ? prevProps.location.state.nextPathname : '/';

    browserHistory.push(nextPathname);
  }
}
</code></pre>

<p>The container for the pages also has the same <code>componentWillMount</code> code. Not sure if it's because of the sagas but here's the code:</p>

<pre><code>//sagas.js
export function* login({ user, password }) {
    try {
        const token = yield call(app.authenticate, {
            strategy: 'local',
            user,
            password,
        });

        return token;
    } catch (error) {
        return onError(error);
    }
}

// For page refresh after logging in
export function* authenticate() {
    try {
        const token = yield call(app.authenticate);

        return token;
    } catch (error) {
        return onError(error);
    }
}

export function* logout() {
    try {
        const response = yield call(app.logout);

        return response;
    } catch (error) {
        return onError(error);
    }
}

export function* loginFlow() {
    while (true) {
        const request = yield take(LOGIN_REQUEST);
        const winner = yield race({
            auth: call(login, request.data),
            logout: take(LOGOUT_REQUEST),
        });

        if (winner.auth &amp;&amp; winner.auth.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export function* logoutFlow() {
    while (true) {
        yield take(LOGOUT_REQUEST);
        yield put(actions.setAuthState(false));
        yield call(logout);
        browserHistory.push('/login');
    }
}

export function* authenticateFlow() {
    while (true) {
        yield take(AUTHENTICATE);

        const response = yield call(authenticate);

        if (response &amp;&amp; response.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export default [
    loginFlow,
    logoutFlow,
    authenticateFlow,
];
</code></pre>

<p>How do I get rid of the flashing login page?</p>

<p>EDIT:
When I tried <a href=""https://stackoverflow.com/a/44051537/769326"">gouroujo</a>'s answer, I couldn't logout.</p>

<pre><code>//asyncInjectors.js
import jwtDecode from 'jwt-decode';

export function redirectToLogin(store) {
    return (nextState, replaceState, callback) =&gt; {
        const token = localStorage.token;

        if (token) {
            const jwt = jwtDecode(token);

            if (jwt.exp &lt;= (new Date().getTime() / 1000)) {
                store.dispatch(actions.setAuthState(false));

                replaceState({
                    pathname: '/login',
                    state: {
                        nextPathname: nextState.location.pathname,
                    },
                });
            }
        }

        store.dispatch(actions.setAuthState(true));
        callback();
    };
}
</code></pre>

<p>When I hit refresh, the <code>login page</code> doesn't show but now I can't log out.</p>
","To log out you should delete the stored token manualy : `localStorage.removeItem('token')` 
Moreover you should use `localStorage.getItem('token')` and `localStorage.setItem('token', <TOKEN>)` to get and set your token."
"43930500","react-boilerplate authentication login page flashes on page reload","4","<p>I'm working on an app with a login page and the rest of the pages of the app (should be logged in to view). I'm using  <a href=""https://github.com/react-boilerplate/react-boilerplate"" rel=""nofollow noreferrer""><code>react-boilerplate</code></a>. From this <a href=""https://github.com/react-boilerplate/react-boilerplate/issues/453#issuecomment-223279221"" rel=""nofollow noreferrer""><code>example</code></a>, I edited my <code>asyncInjectors.js</code> file to have <code>redirectToLogin</code> and <code>redirectToDashboard</code> methods:</p>

<pre><code>//asyncInjectors.js
export function redirectToLogin(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (!isAuthenticated) {
      replaceState({
        pathname: '/login',
        state: {
          nextPathname: nextState.location.pathname,
        },
      });
    }
  };
}

export function redirectToDashboard(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (isAuthenticated) {
      replaceState('/');
    }
  }
}
</code></pre>

<p>Then I just set the <code>redirectToLogin</code> as the <code>onEnter</code> of the pages and <code>redirectToDashboard</code> for the login page.</p>

<p>It works fine but when the page is refreshed (<strong><code>F5</code></strong>) when logged in, the login page renders briefly and then renders the actual page. The login page just dispatches an <code>authenticate</code> action in <code>componentWillMount</code> and then redirects in <code>componentDidUpdate</code>:</p>

<pre><code>//login.js
componentWillMount() {
  this.props.dispatch(authenticate());
}

componentDidUpdate(prevProps, prevState) {
  if (this.props.isAuthenticated) {
    const nextPathname = prevProps.location.state ? prevProps.location.state.nextPathname : '/';

    browserHistory.push(nextPathname);
  }
}
</code></pre>

<p>The container for the pages also has the same <code>componentWillMount</code> code. Not sure if it's because of the sagas but here's the code:</p>

<pre><code>//sagas.js
export function* login({ user, password }) {
    try {
        const token = yield call(app.authenticate, {
            strategy: 'local',
            user,
            password,
        });

        return token;
    } catch (error) {
        return onError(error);
    }
}

// For page refresh after logging in
export function* authenticate() {
    try {
        const token = yield call(app.authenticate);

        return token;
    } catch (error) {
        return onError(error);
    }
}

export function* logout() {
    try {
        const response = yield call(app.logout);

        return response;
    } catch (error) {
        return onError(error);
    }
}

export function* loginFlow() {
    while (true) {
        const request = yield take(LOGIN_REQUEST);
        const winner = yield race({
            auth: call(login, request.data),
            logout: take(LOGOUT_REQUEST),
        });

        if (winner.auth &amp;&amp; winner.auth.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export function* logoutFlow() {
    while (true) {
        yield take(LOGOUT_REQUEST);
        yield put(actions.setAuthState(false));
        yield call(logout);
        browserHistory.push('/login');
    }
}

export function* authenticateFlow() {
    while (true) {
        yield take(AUTHENTICATE);

        const response = yield call(authenticate);

        if (response &amp;&amp; response.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export default [
    loginFlow,
    logoutFlow,
    authenticateFlow,
];
</code></pre>

<p>How do I get rid of the flashing login page?</p>

<p>EDIT:
When I tried <a href=""https://stackoverflow.com/a/44051537/769326"">gouroujo</a>'s answer, I couldn't logout.</p>

<pre><code>//asyncInjectors.js
import jwtDecode from 'jwt-decode';

export function redirectToLogin(store) {
    return (nextState, replaceState, callback) =&gt; {
        const token = localStorage.token;

        if (token) {
            const jwt = jwtDecode(token);

            if (jwt.exp &lt;= (new Date().getTime() / 1000)) {
                store.dispatch(actions.setAuthState(false));

                replaceState({
                    pathname: '/login',
                    state: {
                        nextPathname: nextState.location.pathname,
                    },
                });
            }
        }

        store.dispatch(actions.setAuthState(true));
        callback();
    };
}
</code></pre>

<p>When I hit refresh, the <code>login page</code> doesn't show but now I can't log out.</p>
","not verry pretty but : `window.location.reload()` should work and ensure that your application is clean after logout."
"43930500","react-boilerplate authentication login page flashes on page reload","4","<p>I'm working on an app with a login page and the rest of the pages of the app (should be logged in to view). I'm using  <a href=""https://github.com/react-boilerplate/react-boilerplate"" rel=""nofollow noreferrer""><code>react-boilerplate</code></a>. From this <a href=""https://github.com/react-boilerplate/react-boilerplate/issues/453#issuecomment-223279221"" rel=""nofollow noreferrer""><code>example</code></a>, I edited my <code>asyncInjectors.js</code> file to have <code>redirectToLogin</code> and <code>redirectToDashboard</code> methods:</p>

<pre><code>//asyncInjectors.js
export function redirectToLogin(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (!isAuthenticated) {
      replaceState({
        pathname: '/login',
        state: {
          nextPathname: nextState.location.pathname,
        },
      });
    }
  };
}

export function redirectToDashboard(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (isAuthenticated) {
      replaceState('/');
    }
  }
}
</code></pre>

<p>Then I just set the <code>redirectToLogin</code> as the <code>onEnter</code> of the pages and <code>redirectToDashboard</code> for the login page.</p>

<p>It works fine but when the page is refreshed (<strong><code>F5</code></strong>) when logged in, the login page renders briefly and then renders the actual page. The login page just dispatches an <code>authenticate</code> action in <code>componentWillMount</code> and then redirects in <code>componentDidUpdate</code>:</p>

<pre><code>//login.js
componentWillMount() {
  this.props.dispatch(authenticate());
}

componentDidUpdate(prevProps, prevState) {
  if (this.props.isAuthenticated) {
    const nextPathname = prevProps.location.state ? prevProps.location.state.nextPathname : '/';

    browserHistory.push(nextPathname);
  }
}
</code></pre>

<p>The container for the pages also has the same <code>componentWillMount</code> code. Not sure if it's because of the sagas but here's the code:</p>

<pre><code>//sagas.js
export function* login({ user, password }) {
    try {
        const token = yield call(app.authenticate, {
            strategy: 'local',
            user,
            password,
        });

        return token;
    } catch (error) {
        return onError(error);
    }
}

// For page refresh after logging in
export function* authenticate() {
    try {
        const token = yield call(app.authenticate);

        return token;
    } catch (error) {
        return onError(error);
    }
}

export function* logout() {
    try {
        const response = yield call(app.logout);

        return response;
    } catch (error) {
        return onError(error);
    }
}

export function* loginFlow() {
    while (true) {
        const request = yield take(LOGIN_REQUEST);
        const winner = yield race({
            auth: call(login, request.data),
            logout: take(LOGOUT_REQUEST),
        });

        if (winner.auth &amp;&amp; winner.auth.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export function* logoutFlow() {
    while (true) {
        yield take(LOGOUT_REQUEST);
        yield put(actions.setAuthState(false));
        yield call(logout);
        browserHistory.push('/login');
    }
}

export function* authenticateFlow() {
    while (true) {
        yield take(AUTHENTICATE);

        const response = yield call(authenticate);

        if (response &amp;&amp; response.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export default [
    loginFlow,
    logoutFlow,
    authenticateFlow,
];
</code></pre>

<p>How do I get rid of the flashing login page?</p>

<p>EDIT:
When I tried <a href=""https://stackoverflow.com/a/44051537/769326"">gouroujo</a>'s answer, I couldn't logout.</p>

<pre><code>//asyncInjectors.js
import jwtDecode from 'jwt-decode';

export function redirectToLogin(store) {
    return (nextState, replaceState, callback) =&gt; {
        const token = localStorage.token;

        if (token) {
            const jwt = jwtDecode(token);

            if (jwt.exp &lt;= (new Date().getTime() / 1000)) {
                store.dispatch(actions.setAuthState(false));

                replaceState({
                    pathname: '/login',
                    state: {
                        nextPathname: nextState.location.pathname,
                    },
                });
            }
        }

        store.dispatch(actions.setAuthState(true));
        callback();
    };
}
</code></pre>

<p>When I hit refresh, the <code>login page</code> doesn't show but now I can't log out.</p>
","@gouroujo `app.authenticate` and `app.logout` sets and removes the localStorage token respectively."
"43930500","react-boilerplate authentication login page flashes on page reload","4","<p>I'm working on an app with a login page and the rest of the pages of the app (should be logged in to view). I'm using  <a href=""https://github.com/react-boilerplate/react-boilerplate"" rel=""nofollow noreferrer""><code>react-boilerplate</code></a>. From this <a href=""https://github.com/react-boilerplate/react-boilerplate/issues/453#issuecomment-223279221"" rel=""nofollow noreferrer""><code>example</code></a>, I edited my <code>asyncInjectors.js</code> file to have <code>redirectToLogin</code> and <code>redirectToDashboard</code> methods:</p>

<pre><code>//asyncInjectors.js
export function redirectToLogin(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (!isAuthenticated) {
      replaceState({
        pathname: '/login',
        state: {
          nextPathname: nextState.location.pathname,
        },
      });
    }
  };
}

export function redirectToDashboard(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (isAuthenticated) {
      replaceState('/');
    }
  }
}
</code></pre>

<p>Then I just set the <code>redirectToLogin</code> as the <code>onEnter</code> of the pages and <code>redirectToDashboard</code> for the login page.</p>

<p>It works fine but when the page is refreshed (<strong><code>F5</code></strong>) when logged in, the login page renders briefly and then renders the actual page. The login page just dispatches an <code>authenticate</code> action in <code>componentWillMount</code> and then redirects in <code>componentDidUpdate</code>:</p>

<pre><code>//login.js
componentWillMount() {
  this.props.dispatch(authenticate());
}

componentDidUpdate(prevProps, prevState) {
  if (this.props.isAuthenticated) {
    const nextPathname = prevProps.location.state ? prevProps.location.state.nextPathname : '/';

    browserHistory.push(nextPathname);
  }
}
</code></pre>

<p>The container for the pages also has the same <code>componentWillMount</code> code. Not sure if it's because of the sagas but here's the code:</p>

<pre><code>//sagas.js
export function* login({ user, password }) {
    try {
        const token = yield call(app.authenticate, {
            strategy: 'local',
            user,
            password,
        });

        return token;
    } catch (error) {
        return onError(error);
    }
}

// For page refresh after logging in
export function* authenticate() {
    try {
        const token = yield call(app.authenticate);

        return token;
    } catch (error) {
        return onError(error);
    }
}

export function* logout() {
    try {
        const response = yield call(app.logout);

        return response;
    } catch (error) {
        return onError(error);
    }
}

export function* loginFlow() {
    while (true) {
        const request = yield take(LOGIN_REQUEST);
        const winner = yield race({
            auth: call(login, request.data),
            logout: take(LOGOUT_REQUEST),
        });

        if (winner.auth &amp;&amp; winner.auth.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export function* logoutFlow() {
    while (true) {
        yield take(LOGOUT_REQUEST);
        yield put(actions.setAuthState(false));
        yield call(logout);
        browserHistory.push('/login');
    }
}

export function* authenticateFlow() {
    while (true) {
        yield take(AUTHENTICATE);

        const response = yield call(authenticate);

        if (response &amp;&amp; response.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export default [
    loginFlow,
    logoutFlow,
    authenticateFlow,
];
</code></pre>

<p>How do I get rid of the flashing login page?</p>

<p>EDIT:
When I tried <a href=""https://stackoverflow.com/a/44051537/769326"">gouroujo</a>'s answer, I couldn't logout.</p>

<pre><code>//asyncInjectors.js
import jwtDecode from 'jwt-decode';

export function redirectToLogin(store) {
    return (nextState, replaceState, callback) =&gt; {
        const token = localStorage.token;

        if (token) {
            const jwt = jwtDecode(token);

            if (jwt.exp &lt;= (new Date().getTime() / 1000)) {
                store.dispatch(actions.setAuthState(false));

                replaceState({
                    pathname: '/login',
                    state: {
                        nextPathname: nextState.location.pathname,
                    },
                });
            }
        }

        store.dispatch(actions.setAuthState(true));
        callback();
    };
}
</code></pre>

<p>When I hit refresh, the <code>login page</code> doesn't show but now I can't log out.</p>
","There's no problem with the actual logging out when it's called. The problem is, the saga itself isn't called"
"43998643","How to break infinite loop in componentDidUpdate in reactjs","0","<p>I am currently making dashboards using reactjs in which there are 4 tabs or buttons charts are creating properly but only problem is that when we click on different dashboard and it has same chart in same pannel than chart is not updating i have used both componentDidMount() and componentDidUpdate though its giving proper output but its creating an infinite loop i have also applied some conditions but its still in infinite loop Can anyone help me??</p>

<p>here is my code</p>

<pre><code>class BarChartComponent extends React.Component 
{

   constructor(props) 
   {
      super(props);

      this.state = {
         data: null
      }
   };

   componentDidMount()
    {
            var that = this;
            $.ajax({
                    method: ""GET"",
                    url: ""http://10.0.3.8:8050/querydata?query_id=""+that.props.id,
                    success: function(data) 
                    {

                        console.log(""component did mount method called"");
                        console.log(1,JSON.stringify(data));
                        var BarChartData  = [
                        {
                            key: ""totals"",
                            values: []
                        }
                        ];
                        data.forEach(function (d)
                        {
                            d.value= +d.value
                            BarChartData[0].values.push(d)
                        }) 
                        console.log(2,JSON.stringify(BarChartData))
                        that.setState({data:BarChartData});
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown)
                    { 
                        console.error(""Status: "" + textStatus);
                        console.error(""Error: "" + errorThrown); 
                    }       
                });         
    }

    componentDidUpdate(prevProps, prevState)
    {
                if(prevState.data !== this.state.data )
                {
                    var that = this;
                    $.ajax({
                        method: ""GET"",
                        url: ""http://10.0.3.8:8050/querydata?query_id=""+that.props.id,
                        success: function(data) 
                        {

                            console.log(""component did update method called"");
                            var BarChartData  = [
                            {
                                key: ""totals"",
                                values: []
                            }
                            ];
                            data.forEach(function (d)
                            {
                                d.value= +d.value
                                BarChartData[0].values.push(d)
                            }) 

                            if( prevProps.id !== that.state.id )
                            {
                                that.setState({data:BarChartData});
                                console.log(3,JSON.stringify(BarChartData))
                                console.log(4,JSON.stringify(that.state.data))
                            }                   
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown)
                        { 
                            console.error(""Status: "" + textStatus);
                            console.error(""Error: "" + errorThrown); 
                        }       
                    });         

                }
    }



    render()
    {

        if (this.state.data==null)
        {
            return (&lt;h1&gt;Loading...&lt;/h1&gt;);
        }
        return (


             &lt;NVD3Chart type=""discreteBarChart"" datum={this.state.data} x=""name"" y=""value""/&gt;

        );
    }
}

window.BarChartComponent = BarChartComponent;
</code></pre>
",""
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","Best practice for AJAX calls is to put them inside your reducer/s and not in component lifecycle methods"
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","@JavaEvgen not sure what you mean? Are you referring to this line in the rendering file, componentDidMount(){
    var p = this.props.fetchEvents(1)
  }, than that is just a call to redux saga, not to actual ajax call."
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","@Maverick Apologies, I was not able to see the links first."
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","@Maverick Can you show us the error with stacktrace and let us know, whether the reducer is throwing that error?"
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","@NagarajTantri I am sorry, which code ? This is the whole thing which is there in the description. If you open those urls you will see the code."
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","please post the code that you have been using for this. That will tell us which part of code is causing that error."
"44107644","react-big-calendar fetch events from remote url redux issue","7","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","@NagarajTantri the image attached, is what the stacktrace is. I have added one more image, please have a look."
"44146281","Render after componentWillReceiveProps and before componentDidUpdate","0","<p>Here's my problem:</p>

<p>I'm new at reactjs and I'm trying to make this app using SWAPI (swapi.co). For now I need to list characters and some info about them. The problem is I have this component called <code>SelectedCharacter</code> that returns some info about a character that was selected in a div.</p>

<p>The moment a character is passed through props to this component, I get a response via xmlhttp and the info is displayed. The thing is that I want to put a <code>""Loading...""</code> message while the data is fetched. This is how I was trying to figure it out:</p>

<p>I set up the <code>componentWillReceiveProps</code> function, where I test if I'll need to load stuff and the <code>componentDidUpdate</code>, where I fetch the data from this api and update the status.</p>

<p>I know, from react life cycle, that a render is called between <code>componentWillReceiveProps</code> and <code>componentDidUpdate</code>, and it indeed is.</p>

<p>I expected, then, that if I did this:</p>

<pre><code>render() {
  if (criteria) {
    return &lt;div&gt;Loading...&lt;/div&gt;
  }
}
</code></pre>

<p>The thing is: even if this criteria is true (I tested it using <code>console.log()</code>), the message doesn't show until the next re-render. Am I doing anything too wrong here? If it helps, my code is at <a href=""https://github.com/piubellofelipe/StarWars"" rel=""nofollow noreferrer"">github.com/piubellofelipe/StarWars</a>, the problem is at the selected_characters.js, in the src paste.</p>

<p>Thanks</p>
",""
"44213961","Trying to manipulate a div with reactjs on async data","0","<p>I try to animate a div with reactjs using async data via redux and it's not clear to me when can I have a reference to the virtual dom on state <code>loaded</code>.</p>

<p>In my case I have a div with id <code>header</code> where I would like to push down the container when data was populated.</p>

<p>If I try in componentDidMount than I get <code>Cannot read property 'style' of undefined</code> because componentDidMount still having a reference to an on load container</p>

<pre><code>class HomePage extends React.Component {

    constructor(props) {
        super(props);

        this.state = {
            sliderLength: null
        }
    }

    componentDidMount() {
        this.props.actions.getSlides()


        if(this.header) {

            setTimeout(function() {
                this.header.style.bottom = -(this.header.clientHeight - 40) + 'px';
            }, 2000);
        }
            //header.style.bottom = -pushBottom+'px';

    }


    componentWillReceiveProps(nextProps) {
        let {loaded} = nextProps
        if(loaded === true ) {
            this.animateHeader()
        }
    }

    animateHeader() {

    }

    componentWillMount() {
        const {slides} = this.props;
        this.setState({
            sliderLength: slides.length,
            slides: slides
        });
    }


    render() {
        const {slides, post, loaded} = this.props;

        if(loaded ===true ) {

            let sliderTeaser = _.map(slides, function (slide) {
                if(slide.status === 'publish') {
                    return  &lt;Link  key={slide.id}  to={'portfolio/' + slide.slug}&gt;&lt;img key={slide.id} className=""Img__Teaser"" src={slide.featured_image_url.full} /&gt;&lt;/Link&gt;
                }
            });

            let about = _.map(post, function (data) {
                return data.content.rendered;
            })

            return (
                &lt;div className=""homePage""&gt;
                    &lt;Slider columns={1}  autoplay={true} post={post} slides={slides} /&gt;

                    &lt;div id=""header"" ref={ (header) =&gt; this.header = header}&gt;
                        &lt;div className=""title""&gt;Title&lt;/div&gt;
                        &lt;div className=""text-content""&gt;
                            &lt;div dangerouslySetInnerHTML={createMarkup(about)}/&gt;
                        &lt;/div&gt;

                        &lt;div className=""sliderTeaser""&gt;
                            {sliderTeaser}
                        &lt;/div&gt;

                        &lt;div className=""columns""&gt;
                            &lt;div className=""column""&gt;&lt;/div&gt;
                            &lt;div className=""column""&gt;&lt;/div&gt;
                            &lt;div className=""column""&gt;&lt;/div&gt;
                        &lt;/div&gt;

                    &lt;/div&gt;

                    &lt;div id=""bgHover""&gt;&lt;/div&gt;
                &lt;/div&gt;
            );
        } else {
            return &lt;div&gt;...Loading&lt;/div&gt;
        }

    }
}

function mapStateToProps(state) {
    return {
        slides: state.slides,
        post: state.post,
        loaded: state.loaded
    };
}

function mapDispatchToProps(dispatch) {
    return {
        actions: bindActionCreators(slidesActions, dispatch)
    };
}

function createMarkup(markup) {
    return {__html: markup};
}

export default connect(mapStateToProps, mapDispatchToProps)(HomePage);
</code></pre>

<p>How do I deal in this case with states?</p>

<p><strong>Between I found a solution but not sure if is the right workaround</strong></p>

<pre><code>componentDidUpdate() {
        if(this.header) {
            setTimeout(function() {
                this.header.style.bottom = -(this.header.clientHeight - 35) + 'px';
            }, 2000);
        }
    }
</code></pre>
",""
"44280565","GSAP Draggable with react ES6 actual this","0","<p>Im using <code>gsap</code> Draggable with <code>reactjs</code> <code>ES6</code>, I create new draggable like this in react component <code>componentDidUpdate</code> lifecycle method</p>

<pre><code>import React, { Component } from 'react'
import Draggable from 'gsap/Draggable'

class DraggableContainer extends Component {

    render(){
        ...
    }
    componentDidUpdate(){
        const draggable = Draggable.create('.box', {
            onPress: ()=&gt;{
                // currentElement suppost to contain dom element of clicked, but its undefined because 'this' is 'DraggableContainer'
                const currentElement = this.target

            }   
        })
    }
}
</code></pre>

<p>inside method body of <code>onPress</code> this.target should give current element but its undefined and <code>this</code> is wrong context.</p>

<p>How can i access current elent inside this method?</p>
",""
"44309306","Exporting functions with reactjs and babel","0","<p>I have a project using reactjs, which is transpiled by babel. I use the es2015 and react transforms in my <code>.babelrc</code>. I am currently refactoring and in my first pass I basically did <code>export class foo</code> for everything I needed. A lot of these classes should really just be functions, so I am trying to rewrite them as such, but I keep getting the same error. My main application file looks somethings like this:</p>

<pre><code>import React, { Component } from 'react';

import {Foo, Bar} from './components/ui.js';

class Application extends Component {

  constructor(props){
    super(props);
    this.state = {
      object: null
    }
  }

  componentDidMount(){
    // code
  }

  componentDidUpdate(){
    // other code
  }

  render(){
    return(
      &lt;div&gt;
        &lt;Foo /&gt;
        &lt;Bar /&gt;
      &lt;/div&gt;
    )
  }

}

module.exports = Application
</code></pre>

<p>And my import from <code>ui.js</code> is like this:</p>

<pre><code>import React, { Component } from 'react';

export class Foo extends Component {
  constructor(props){
    super(props);
  }

  render() {
    return (
      // Some JSX
    )      
  }
}


export class Bar extends Component {
  constructor(props){
    super(props);

  }

  render() {
    return (
      // Some other JSX
    )      
  }
}
</code></pre>

<p>When I try and change one of these exported classes to a function, for example:</p>

<pre><code>// Note: I have tried a variety of syntax such as function, const, etc...
export var Bar {
  render() {
    return (
      // Some other JSX
    )      
  }
}
</code></pre>

<p>I get the following error: </p>

<pre><code>SyntaxError: Unexpected token &lt;line where I declare a function&gt;
</code></pre>

<p>I am not sure what I am doing wrong, and my google searches are only coming up with answers to other problems.</p>
",""
"44487215","react-google-maps: how to use fitBounds, panBy, panTo, panToBounds public APIs?","1","<p>According to the <a href=""https://github.com/tomchentw/react-google-maps/blob/master/src/lib/GoogleMap.js#L125-L131"" rel=""nofollow noreferrer"">React Google Maps library</a>, you can call these four methods from the ref object.</p>

<p>What seems weird, is that these methods are supposed to receive two parameters, a map instance and other arguments, like so:</p>

<pre><code>fitBounds(map, args) { return map.fitBounds(...args); }
</code></pre>

<p>However, when calling fitBounds() this way, nothing happens on the map, no bounds are changed and no errors are thrown. This is the way I have structured the component, calling fitBounds in componentDidUpdate:</p>

<pre><code>import React from 'react'
import { withGoogleMap, GoogleMap, InfoWindow, Marker, OverlayView } from 'react-google-maps'
import InfoBox from 'react-google-maps/lib/addons/InfoBox'
import map from 'lodash/map'

// Higher-Order Component
const AllocatedPlacesMap = withGoogleMap(props =&gt; (
  &lt;GoogleMap
    center={props.center}
    defaultZoom={4}
    options={{ scrollwheel: false, minZoom: 3, maxZoom: 15 }}
    onCenterChanged={props.onCenterChanged}
    ref={props.onMapMounted}&gt;
    {props.markers.map((marker, index) =&gt; (
      &lt;Marker
        key={index}
        position={marker.position}
      /&gt;
    ))}
  &lt;/GoogleMap&gt;
));

class Map extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
    };
  }

  getCenter = () =&gt; {
    this._bounds = new google.maps.LatLngBounds();

    this.props.markers.forEach((marker, index) =&gt; {
      const position = new google.maps.LatLng(marker.lat, marker.lng);
      this._bounds.extend(position);
    });

    return this._bounds.getCenter();
  }

  componentDidUpdate() {
    this._map.fitBounds(this._map, this._bounds);
  }

  handleMapMounted = (map) =&gt; {
    this._map = map;
  }

  render() {
    return (
      &lt;div className=""allocated-places""&gt;
        &lt;AllocatedPlacesMap
          containerElement={
            &lt;div style={{ height: `100%` }} /&gt;
          }
          mapElement={
            &lt;div style={{ height: `100%` }} /&gt;
          }
          center={this.getCenter()}
          markers={props.markers}
          onMapMounted={this.handleMapMounted}
        /&gt;
      &lt;/div&gt;
    )
  }
}

export default Map;
</code></pre>

<p>Any idea of what is the correct way to call fitBounds() in this case? documentation and examples seem to be lacking in this regard.</p>
","fitBounds() no longer requires a map instance as first parameter. This bug was also fixed in v9 of the library."
"44502039","Create a masonry with bricks.js and react","3","<h2>Code Situation</h2>

<p>I have a simple react app setup. The home component should be a image gallery with a masonry layout. I found this library: <a href=""https://github.com/callmecavs/bricks.js"" rel=""nofollow noreferrer"">Bricks.js</a>
I load the data <strong>(name, date, url to image)</strong> of the items from my api with <a href=""https://github.com/github/fetch"" rel=""nofollow noreferrer"">fetch</a>. </p>

<p>Here are some parts of my code in Home.js:</p>

<p>The <strong>constructor()</strong></p>

<pre><code>constructor() {
  super();
  this.state = {
    galleryItems: []
  };
  this.instance = {}
}
</code></pre>

<p>This function loads the data of the items.</p>

<pre><code>getItems(limit){
  fetch('http://localhost:3000/api/posts/next/' + limit)
    .then((response) =&gt; {
      return response.json()
    }).then((data) =&gt; {
      this.setState({galleryItems: data});
    })
}
</code></pre>

<p>I used the <strong>componentDidMount()</strong> function to load 5 items and create the Bricks.js instance.</p>

<pre><code>componentDidMount(){
  this.getItems(5)
  //sizes for Brick.js
  const sizes = [
    { columns: 5, gutter: 3 },
    { mq: '768px', columns: 2, gutter: 3 },
    { mq: '1024px', columns: 3, gutter: 3 }
  ]
  //init instance
  this.instance = Bricks({
    container: '.gallery',
    packed: 'packed',
    sizes: sizes
  })
  this.instance.resize(true);  //&lt;-adds a resize event listener
  if (this.state.galleryItems.length &gt; 0) {
    this.instance.pack() //&lt;- This should create the masonry layout
  }
}
</code></pre>

<p>And for loading more image I wrote this in the <strong>componentDidUpdate()</strong> function.</p>

<pre><code>componentDidUpdate(){
  if (this.state.galleryItems.length &gt; 0) {
    return this.instance.pack()
  }
  else{
    return this.instance.update() //&lt;- updates the layout
  }
}
</code></pre>

<p>The <strong>render()</strong> function converts the data from the server to a <code>&lt;Item&gt;</code> which is just another component that creates a <code>&lt;img&gt;</code> element</p>

<pre><code>render() {
  const items = this.state.galleryItems.map((item, _id) =&gt; {
    return &lt;Item key={_id} url={this.state.url + item.url}&gt;&lt;/Item&gt;
  })
  return (
    &lt;div&gt;
      Home Component
      &lt;div className=""gallery""&gt;
        {items}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<h2>Problem</h2>

<p>If I open my app in firefox it works fine. But in chrome the images are just on top of each other. If I resize the window the masonry layout is created fine. I seems chrome is either too fast or slow.
What is wrong with my code that this can happen?</p>
","I was having a really similar issue because I was fetching items from my server that contained iframes. The component would load faster than the iframes could render, so the Masonry component couldn't get an accurate height of all the items in time (resulting in a height too small; this makes the images fall on top of each other). What ended up helping me was rerendering the component once all the items I fetched loaded."
"44502039","Create a masonry with bricks.js and react","3","<h2>Code Situation</h2>

<p>I have a simple react app setup. The home component should be a image gallery with a masonry layout. I found this library: <a href=""https://github.com/callmecavs/bricks.js"" rel=""nofollow noreferrer"">Bricks.js</a>
I load the data <strong>(name, date, url to image)</strong> of the items from my api with <a href=""https://github.com/github/fetch"" rel=""nofollow noreferrer"">fetch</a>. </p>

<p>Here are some parts of my code in Home.js:</p>

<p>The <strong>constructor()</strong></p>

<pre><code>constructor() {
  super();
  this.state = {
    galleryItems: []
  };
  this.instance = {}
}
</code></pre>

<p>This function loads the data of the items.</p>

<pre><code>getItems(limit){
  fetch('http://localhost:3000/api/posts/next/' + limit)
    .then((response) =&gt; {
      return response.json()
    }).then((data) =&gt; {
      this.setState({galleryItems: data});
    })
}
</code></pre>

<p>I used the <strong>componentDidMount()</strong> function to load 5 items and create the Bricks.js instance.</p>

<pre><code>componentDidMount(){
  this.getItems(5)
  //sizes for Brick.js
  const sizes = [
    { columns: 5, gutter: 3 },
    { mq: '768px', columns: 2, gutter: 3 },
    { mq: '1024px', columns: 3, gutter: 3 }
  ]
  //init instance
  this.instance = Bricks({
    container: '.gallery',
    packed: 'packed',
    sizes: sizes
  })
  this.instance.resize(true);  //&lt;-adds a resize event listener
  if (this.state.galleryItems.length &gt; 0) {
    this.instance.pack() //&lt;- This should create the masonry layout
  }
}
</code></pre>

<p>And for loading more image I wrote this in the <strong>componentDidUpdate()</strong> function.</p>

<pre><code>componentDidUpdate(){
  if (this.state.galleryItems.length &gt; 0) {
    return this.instance.pack()
  }
  else{
    return this.instance.update() //&lt;- updates the layout
  }
}
</code></pre>

<p>The <strong>render()</strong> function converts the data from the server to a <code>&lt;Item&gt;</code> which is just another component that creates a <code>&lt;img&gt;</code> element</p>

<pre><code>render() {
  const items = this.state.galleryItems.map((item, _id) =&gt; {
    return &lt;Item key={_id} url={this.state.url + item.url}&gt;&lt;/Item&gt;
  })
  return (
    &lt;div&gt;
      Home Component
      &lt;div className=""gallery""&gt;
        {items}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<h2>Problem</h2>

<p>If I open my app in firefox it works fine. But in chrome the images are just on top of each other. If I resize the window the masonry layout is created fine. I seems chrome is either too fast or slow.
What is wrong with my code that this can happen?</p>
","Hmm that might work? But that's also a lot of calculating. I meant waiting for all the images to load, then trigger a re-render on the masonry component. That way when the masonry component re-renders, it has the accurate height of all the images inside it. First test if it will even work by in componentDidMount(), add setTimeout(this.forceUpdate, 5000); That will tell the component to update after 5 seconds (hopefully all the images would have loaded by then). If that fixes your problem, then you find a way to detect if all the images loaded and if it did, rerender the component"
"44502039","Create a masonry with bricks.js and react","3","<h2>Code Situation</h2>

<p>I have a simple react app setup. The home component should be a image gallery with a masonry layout. I found this library: <a href=""https://github.com/callmecavs/bricks.js"" rel=""nofollow noreferrer"">Bricks.js</a>
I load the data <strong>(name, date, url to image)</strong> of the items from my api with <a href=""https://github.com/github/fetch"" rel=""nofollow noreferrer"">fetch</a>. </p>

<p>Here are some parts of my code in Home.js:</p>

<p>The <strong>constructor()</strong></p>

<pre><code>constructor() {
  super();
  this.state = {
    galleryItems: []
  };
  this.instance = {}
}
</code></pre>

<p>This function loads the data of the items.</p>

<pre><code>getItems(limit){
  fetch('http://localhost:3000/api/posts/next/' + limit)
    .then((response) =&gt; {
      return response.json()
    }).then((data) =&gt; {
      this.setState({galleryItems: data});
    })
}
</code></pre>

<p>I used the <strong>componentDidMount()</strong> function to load 5 items and create the Bricks.js instance.</p>

<pre><code>componentDidMount(){
  this.getItems(5)
  //sizes for Brick.js
  const sizes = [
    { columns: 5, gutter: 3 },
    { mq: '768px', columns: 2, gutter: 3 },
    { mq: '1024px', columns: 3, gutter: 3 }
  ]
  //init instance
  this.instance = Bricks({
    container: '.gallery',
    packed: 'packed',
    sizes: sizes
  })
  this.instance.resize(true);  //&lt;-adds a resize event listener
  if (this.state.galleryItems.length &gt; 0) {
    this.instance.pack() //&lt;- This should create the masonry layout
  }
}
</code></pre>

<p>And for loading more image I wrote this in the <strong>componentDidUpdate()</strong> function.</p>

<pre><code>componentDidUpdate(){
  if (this.state.galleryItems.length &gt; 0) {
    return this.instance.pack()
  }
  else{
    return this.instance.update() //&lt;- updates the layout
  }
}
</code></pre>

<p>The <strong>render()</strong> function converts the data from the server to a <code>&lt;Item&gt;</code> which is just another component that creates a <code>&lt;img&gt;</code> element</p>

<pre><code>render() {
  const items = this.state.galleryItems.map((item, _id) =&gt; {
    return &lt;Item key={_id} url={this.state.url + item.url}&gt;&lt;/Item&gt;
  })
  return (
    &lt;div&gt;
      Home Component
      &lt;div className=""gallery""&gt;
        {items}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<h2>Problem</h2>

<p>If I open my app in firefox it works fine. But in chrome the images are just on top of each other. If I resize the window the masonry layout is created fine. I seems chrome is either too fast or slow.
What is wrong with my code that this can happen?</p>
","@bwalshy So a solution/workaround would be to store the sizes of the images and create a div with the correct sizes first so the images could load into the framing div?"
"44674711","Can not show message from the reducer in react","3","<p>I am trying to show <code>message</code> <code>'hello brozz..'</code> from the reducer to a component <code>render()</code> method.<code>ComponentDidMount()</code> get the <code>this.props.message</code> as <a href=""https://i.stack.imgur.com/qpNj6.png"" rel=""nofollow noreferrer"">please see the image</a>. And my reducer is like </p>

<pre><code> export const geod = (state ={}, action) =&gt; {
      console.log('inside reducer');
        switch(action.type){


            case 'INITIAL_MESSAGE':

              return [
                        ...state, {
                          message:'hello brozz..'
                        }
                      ]
            case 'CLICK_MESSAGE':
                  return [ 
                            ...state, { 
                                            message: ''
                                      }
                          ]
            default:
                    return state;
        }

     };
</code></pre>

<p>But I can not use <code>this.props.message</code> as <code>&lt;div&gt;&lt;div&gt;{this.props.message}&lt;/div&gt;&lt;/div&gt;</code> inside the render method. I am getting the error </p>

<pre><code>Objects are not valid as a React child (found: object with keys {}). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons
</code></pre>

<p>My component is,</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
import { initialMessageAction, clickButtonAction } from './redux.js';
import { connect } from 'react-redux';
import { Message } from './messageComponent';

class App extends Component {

  componentWillMount() {
    console.log('component will mount');
    let data = this.props.initialMessageAction();
  }
  componentDidUpdate() {
    console.log('comp Did Update')
    console.log(this.props.message)
  }
  render() {

    return (
      &lt;div className=""App""&gt;
        &lt;div className=""App-header""&gt;        
        &lt;/div&gt;
        &lt;p className=""App-intro""&gt;
        react-redux-data-flow
        &lt;/p&gt; 
              &lt;div&gt;{this.props.message}&lt;/div&gt;
             &lt;div&gt;{this.props? &lt;div&gt;hi ..&lt;button onClick={ () =&gt; this.props.clickButtonAction() }&gt;hide message&lt;/button&gt;&lt;/div&gt;: ''}&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}


    const mapStateToProps = (state, ownProperty) =&gt; ({ 

    message:state.geod,   


  });   

   const mapDispatchToProps =  { 

     initialMessageAction,
    clickButtonAction

  } 

  export default connect(
                             mapStateToProps,
                             mapDispatchToProps

                    )(App);
</code></pre>
","Do you have mapStateToProps inside your component? Please show me your component code?"
"44674711","Can not show message from the reducer in react","3","<p>I am trying to show <code>message</code> <code>'hello brozz..'</code> from the reducer to a component <code>render()</code> method.<code>ComponentDidMount()</code> get the <code>this.props.message</code> as <a href=""https://i.stack.imgur.com/qpNj6.png"" rel=""nofollow noreferrer"">please see the image</a>. And my reducer is like </p>

<pre><code> export const geod = (state ={}, action) =&gt; {
      console.log('inside reducer');
        switch(action.type){


            case 'INITIAL_MESSAGE':

              return [
                        ...state, {
                          message:'hello brozz..'
                        }
                      ]
            case 'CLICK_MESSAGE':
                  return [ 
                            ...state, { 
                                            message: ''
                                      }
                          ]
            default:
                    return state;
        }

     };
</code></pre>

<p>But I can not use <code>this.props.message</code> as <code>&lt;div&gt;&lt;div&gt;{this.props.message}&lt;/div&gt;&lt;/div&gt;</code> inside the render method. I am getting the error </p>

<pre><code>Objects are not valid as a React child (found: object with keys {}). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons
</code></pre>

<p>My component is,</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
import { initialMessageAction, clickButtonAction } from './redux.js';
import { connect } from 'react-redux';
import { Message } from './messageComponent';

class App extends Component {

  componentWillMount() {
    console.log('component will mount');
    let data = this.props.initialMessageAction();
  }
  componentDidUpdate() {
    console.log('comp Did Update')
    console.log(this.props.message)
  }
  render() {

    return (
      &lt;div className=""App""&gt;
        &lt;div className=""App-header""&gt;        
        &lt;/div&gt;
        &lt;p className=""App-intro""&gt;
        react-redux-data-flow
        &lt;/p&gt; 
              &lt;div&gt;{this.props.message}&lt;/div&gt;
             &lt;div&gt;{this.props? &lt;div&gt;hi ..&lt;button onClick={ () =&gt; this.props.clickButtonAction() }&gt;hide message&lt;/button&gt;&lt;/div&gt;: ''}&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}


    const mapStateToProps = (state, ownProperty) =&gt; ({ 

    message:state.geod,   


  });   

   const mapDispatchToProps =  { 

     initialMessageAction,
    clickButtonAction

  } 

  export default connect(
                             mapStateToProps,
                             mapDispatchToProps

                    )(App);
</code></pre>
","Why `geod` in `prevState` is object and in `nextState` is array?
Show your component."
"44674711","Can not show message from the reducer in react","3","<p>I am trying to show <code>message</code> <code>'hello brozz..'</code> from the reducer to a component <code>render()</code> method.<code>ComponentDidMount()</code> get the <code>this.props.message</code> as <a href=""https://i.stack.imgur.com/qpNj6.png"" rel=""nofollow noreferrer"">please see the image</a>. And my reducer is like </p>

<pre><code> export const geod = (state ={}, action) =&gt; {
      console.log('inside reducer');
        switch(action.type){


            case 'INITIAL_MESSAGE':

              return [
                        ...state, {
                          message:'hello brozz..'
                        }
                      ]
            case 'CLICK_MESSAGE':
                  return [ 
                            ...state, { 
                                            message: ''
                                      }
                          ]
            default:
                    return state;
        }

     };
</code></pre>

<p>But I can not use <code>this.props.message</code> as <code>&lt;div&gt;&lt;div&gt;{this.props.message}&lt;/div&gt;&lt;/div&gt;</code> inside the render method. I am getting the error </p>

<pre><code>Objects are not valid as a React child (found: object with keys {}). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons
</code></pre>

<p>My component is,</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
import { initialMessageAction, clickButtonAction } from './redux.js';
import { connect } from 'react-redux';
import { Message } from './messageComponent';

class App extends Component {

  componentWillMount() {
    console.log('component will mount');
    let data = this.props.initialMessageAction();
  }
  componentDidUpdate() {
    console.log('comp Did Update')
    console.log(this.props.message)
  }
  render() {

    return (
      &lt;div className=""App""&gt;
        &lt;div className=""App-header""&gt;        
        &lt;/div&gt;
        &lt;p className=""App-intro""&gt;
        react-redux-data-flow
        &lt;/p&gt; 
              &lt;div&gt;{this.props.message}&lt;/div&gt;
             &lt;div&gt;{this.props? &lt;div&gt;hi ..&lt;button onClick={ () =&gt; this.props.clickButtonAction() }&gt;hide message&lt;/button&gt;&lt;/div&gt;: ''}&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}


    const mapStateToProps = (state, ownProperty) =&gt; ({ 

    message:state.geod,   


  });   

   const mapDispatchToProps =  { 

     initialMessageAction,
    clickButtonAction

  } 

  export default connect(
                             mapStateToProps,
                             mapDispatchToProps

                    )(App);
</code></pre>
","@Andrew I included my component above."
"45077004","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","6","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","Yes, I'm using Chrome Version 59.0.3071.115 (Official Build) (64-bit) and it says 29, I guess that if it's greater that that it's supported.
At first I was tempted to use element.scrollIntoView({block: ""start"", behavior: ""smooth""}) but read not many browser supported parameters yet so I sticked to basic support.
I also tryed boolean parameter (true and false) just in case but doen't help
thanks for the hint @Finbarr O'B"
"45077004","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","6","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","I just cloned your github 'reacty' and works fine also on my end,
I just tried removing the bootstrap CSS classes as you did but still not working, now that I know it works on this simpler version , i'm gonna work on simplifying the code to make it work and start there , thanks i'll keep you posted"
"45077004","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","6","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","Are you sure scrollIntoView is supported on the browser version you are using?  https://developer.mozilla.org/en/docs/Web/API/Element/scrollIntoView#Browser_compatibility"
"45077004","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","6","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","Also, it may help to check if 'input' is truthy in your ref callback, remember the ref is called with the element on mount and null on unmount (https://facebook.github.io/react/docs/refs-and-the-dom.html)"
"45077004","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","6","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","Ok, in componentDidMount works just fine, but in componentDidUpdate (where I need it) it scrolls up automatically  so I'm trying to find a way to prevent default but I don't know how to get the event or context to do so.
Reading this entry: https://stackoverflow.com/questions/35522220/react-ref-with-focus-doesnt-work-without-settimeout-my-example

I found a work-around  setting a TimeOut in componentDidUpdate to trigger the scrollIntoView()
this will do for now but I would like to do it the right way"
"45077004","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","6","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","The simplest truthy check is to do `if(input){ this.textInput = input; }`, but I suspect this isn't your problem. I've just tried to run your code, and it appears to work in my case. I had to include componentDidMount() however as I was not manipulating state anywhere in my component (componentDidUpdate() is only called if the component state is changed). I also removed the bootstrap CSS classes. See here: https://github.com/finbarrobrien/reacty/blob/master/src/App.js"
"45177522","Is there a way to continuously get an value from a redux store one at a time? react redux","1","<p>i have a async fetch that gets values like A001, A002, names and so on from an API. But sometimes i get 3 or more values with 1 api fetch and i loose some because i show only 3 values at a time in my react component.</p>

<p>So i look for a way to continuously show 1 entry from the store for like 2 seconds and then the next entry and so on.</p>

<p>Can someone please help me here?</p>

<p><strong>Actions</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let lastId = 0;
let pathArray = window.location.pathname.split('/');

export const fetchLastId = () =&gt; dispatch =&gt; {
    const url = '/api/display/sites/' + pathArray[3] + '/displays/' + pathArray[5] + '/show';
    fetch(url, {
        method: 'GET',
        mode: 'cors',
        headers: {
            'Authorization': ''
        },
        'Content-Type': 'application/json' 
    }).then(function(response) {
            return response.json();
    }).then(function(data) {
        if (data.length) {
            lastId = data[0].id;
        } else {
            lastId = 0;
        }
        console.log('Die Letzte ID war ' + lastId);
    }).catch(function(error) {
        console.log('Fehler: ', error);
    })
}

export const fetchLastCalls = () =&gt; dispatch =&gt; {
    const url = '/api/display/sites/' + pathArray[3] + '/displays/' + pathArray[5] + '/calls?id_greater_than=' + lastId;
    fetch(url, {
        method: 'GET',
        mode: 'cors',
        headers: {
            'Authorization': ''
        },
        'Content-Type': 'application/json' 
    }).then(function(response) {
            return response.json();
    }).then(function(data) {
        data.reverse();
        if (data.length) {
            for (let item of data) {
                switch (item.service_id) {
                case 24:
                    dispatch({ type: 'SERVICE_1', payload: item })
                    break;
                case 25:
                    dispatch({ type: 'SERVICE_2', payload: item })
                    break;
                default:
                    console.log('Aufruf im Falschen Dienst getätigt.')
                }
                lastId = item.id;
            }
        } else {
            console.log('Keine neuen Aufrufe.');
        }    
    }).catch(function(error) {
        console.log('Fehler: ', error);
    })
}</code></pre>
</div>
</div>
</p>

<p><strong>Reducer</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let initialState = [];

function service1(state = initialState, action) {
    if (action.type === 'SERVICE_1') {
        return [action.payload, ...state];
    }
    return state;
}

export default service1;</code></pre>
</div>
</div>
</p>

<p><strong>Container</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { connect } from 'react-redux';

import { NewCall } from '../components/NewCall';
import { LastCall } from '../components/LastCall';

import { fetchLastId , fetchLastCalls } from '../actions/index';

class Service1 extends React.Component {
    componentWillMount() {
        this.props.onFetchLastId();
    }
    componentDidMount() {
        setInterval(function() {
            this.props.onFetchLastCalls();
        }.bind(this), 1000);
    }
    renderNewTicket() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.ticket}&gt;{call.ticket}&lt;/p&gt;
            );
        });
    }
    renderNewPlace() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.desk_id}&gt;{call.desk_id}&lt;/p&gt;
            );
        });
    }
    renderLastTicket() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.ticket}&gt;{call.ticket}&lt;/p&gt;
            )
        })
    }
    renderLastPlace() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.desk_id}&gt;{call.desk_id}&lt;/p&gt;
            )
        })
    }
    componentDidUpdate() {

    }
    render() {
        return(
            &lt;div&gt;
                &lt;NewCall 
                    call={ this.renderNewTicket() } 
                    place={ this.renderNewPlace() } 
                /&gt;
                &lt;LastCall 
                    call={ this.renderLastTicket() } 
                    place={ this.renderLastPlace() }
                    rollOn={1} 
                /&gt;
                &lt;LastCall 
                    call={ this.renderLastTicket() } 
                    place={ this.renderLastPlace() }
                    rollOn={2} 
                /&gt;
            &lt;/div&gt;
        );
    }
}

function mapStateToProps(state) {
    return {
        calls: state.service1
    };
}

let mapDispatchToProps = {
  onFetchLastId: fetchLastId,
  onFetchLastCalls: fetchLastCalls
}


export default connect(mapStateToProps, mapDispatchToProps)(Service1);</code></pre>
</div>
</div>
</p>

<p><strong>1 Output Component</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { Textfit } from 'react-textfit';

import Blink from './Blink';

const inlineStyle = {
    width: 945,
    height: 249
};

export class NewCall extends React.Component {
    render() {
        return(
            &lt;div&gt;
                &lt;div className=""flex-item-grey ticketNrGr""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyle} className=""textfit"" max={200}&gt;&lt;Blink&gt;{this.props.call[0]}&lt;/Blink&gt;&lt;/Textfit&gt;
                &lt;/div&gt;
                &lt;div className=""flex-item-grey platzNrGr""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyle} className=""textfit"" max={200}&gt;&lt;Blink&gt;{this.props.place[0]}&lt;/Blink&gt;&lt;/Textfit&gt;        
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}</code></pre>
</div>
</div>
</p>

<p><strong>Second Output Component</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { Textfit } from 'react-textfit';

const inlineStyleCall = {
    width: 735,
    height: 195
};

const inlineStyleDesk = {
    width: 200,
    height: 195
};

export class LastCall extends React.Component {
    render() {
        return(
            &lt;div className=""flex-container-aufrufKl""&gt;
                &lt;div className=""flex-item-grey ticketNrKl""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyleCall} className=""textfit"" max={200}&gt;{this.props.call[this.props.rollOn]}&lt;/Textfit&gt;
                &lt;/div&gt;
                &lt;div className=""flex-item-grey platzNrKl""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyleDesk} className=""textfit"" max={200}&gt;{this.props.place[this.props.rollOn]}&lt;/Textfit&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}</code></pre>
</div>
</div>
</p>
","show some code so we can help."
"45178122","Changing a state with the route changes in ReactJS and react-router?","5","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative to that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p><strong>Update:</strong></p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<pre><code>constructor(props) {
    super(props);

    this.state = {
        title: 'David Powell',
        nav: {},
        currentPage: """",
        pageContent: """",
        pageTitle: """",
        pageTemplate: """",
        pageId: 0,
        pageCustomMeta: {},
        archiveData: []
    }
}
</code></pre>

<p>When a page is called I set the values based on what the api returns. I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<pre><code>getPageData(slug){
    console.log(this.state);
    axios.get('http://admin.sitedata.co/pages?slug='+slug)
    .then((response) =&gt; {
        console.log(response.data);

        this.setState({
            pageContent:response.data[0].content.rendered,
            currentPage:slug,
            pageTitle:response.data[0].title.rendered,
            pageTemplate:response.data[0].template,
            pageId:response.data[0].id,
            pageCustomMeta:response.data[0].post_meta,
            archiveData:[]
        },function(){
            console.log(this.state);
            /*
            *   set the page title
            *   check if the page is at home
            *   get page custom meta
            */
            document.title = this.state.pageTitle;
            this.isHome();
            //this.getPageCustomMeta(this.state.pageId);
        });

    })
    .catch((error) =&gt; {
        console.log(error);
    });
}
</code></pre>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","This is an older post. I'm unsure if you still need help. If so, try recreating this on a [codesandbox](https://codesandbox.io). This will give anyone wanting to troubleshoot a clear view of what your code does and it'll help with debugging."
"45178122","Changing a state with the route changes in ReactJS and react-router?","5","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative to that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p><strong>Update:</strong></p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<pre><code>constructor(props) {
    super(props);

    this.state = {
        title: 'David Powell',
        nav: {},
        currentPage: """",
        pageContent: """",
        pageTitle: """",
        pageTemplate: """",
        pageId: 0,
        pageCustomMeta: {},
        archiveData: []
    }
}
</code></pre>

<p>When a page is called I set the values based on what the api returns. I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<pre><code>getPageData(slug){
    console.log(this.state);
    axios.get('http://admin.sitedata.co/pages?slug='+slug)
    .then((response) =&gt; {
        console.log(response.data);

        this.setState({
            pageContent:response.data[0].content.rendered,
            currentPage:slug,
            pageTitle:response.data[0].title.rendered,
            pageTemplate:response.data[0].template,
            pageId:response.data[0].id,
            pageCustomMeta:response.data[0].post_meta,
            archiveData:[]
        },function(){
            console.log(this.state);
            /*
            *   set the page title
            *   check if the page is at home
            *   get page custom meta
            */
            document.title = this.state.pageTitle;
            this.isHome();
            //this.getPageCustomMeta(this.state.pageId);
        });

    })
    .catch((error) =&gt; {
        console.log(error);
    });
}
</code></pre>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","Question updated with code and more info."
"45178122","Changing a state with the route changes in ReactJS and react-router?","5","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative to that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p><strong>Update:</strong></p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<pre><code>constructor(props) {
    super(props);

    this.state = {
        title: 'David Powell',
        nav: {},
        currentPage: """",
        pageContent: """",
        pageTitle: """",
        pageTemplate: """",
        pageId: 0,
        pageCustomMeta: {},
        archiveData: []
    }
}
</code></pre>

<p>When a page is called I set the values based on what the api returns. I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<pre><code>getPageData(slug){
    console.log(this.state);
    axios.get('http://admin.sitedata.co/pages?slug='+slug)
    .then((response) =&gt; {
        console.log(response.data);

        this.setState({
            pageContent:response.data[0].content.rendered,
            currentPage:slug,
            pageTitle:response.data[0].title.rendered,
            pageTemplate:response.data[0].template,
            pageId:response.data[0].id,
            pageCustomMeta:response.data[0].post_meta,
            archiveData:[]
        },function(){
            console.log(this.state);
            /*
            *   set the page title
            *   check if the page is at home
            *   get page custom meta
            */
            document.title = this.state.pageTitle;
            this.isHome();
            //this.getPageCustomMeta(this.state.pageId);
        });

    })
    .catch((error) =&gt; {
        console.log(error);
    });
}
</code></pre>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","more code, please."
"45178122","Changing a state with the route changes in ReactJS and react-router?","5","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative to that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p><strong>Update:</strong></p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<pre><code>constructor(props) {
    super(props);

    this.state = {
        title: 'David Powell',
        nav: {},
        currentPage: """",
        pageContent: """",
        pageTitle: """",
        pageTemplate: """",
        pageId: 0,
        pageCustomMeta: {},
        archiveData: []
    }
}
</code></pre>

<p>When a page is called I set the values based on what the api returns. I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<pre><code>getPageData(slug){
    console.log(this.state);
    axios.get('http://admin.sitedata.co/pages?slug='+slug)
    .then((response) =&gt; {
        console.log(response.data);

        this.setState({
            pageContent:response.data[0].content.rendered,
            currentPage:slug,
            pageTitle:response.data[0].title.rendered,
            pageTemplate:response.data[0].template,
            pageId:response.data[0].id,
            pageCustomMeta:response.data[0].post_meta,
            archiveData:[]
        },function(){
            console.log(this.state);
            /*
            *   set the page title
            *   check if the page is at home
            *   get page custom meta
            */
            document.title = this.state.pageTitle;
            this.isHome();
            //this.getPageCustomMeta(this.state.pageId);
        });

    })
    .catch((error) =&gt; {
        console.log(error);
    });
}
</code></pre>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","There should be a routing object in props of the route target component."
"45178122","Changing a state with the route changes in ReactJS and react-router?","5","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative to that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p><strong>Update:</strong></p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<pre><code>constructor(props) {
    super(props);

    this.state = {
        title: 'David Powell',
        nav: {},
        currentPage: """",
        pageContent: """",
        pageTitle: """",
        pageTemplate: """",
        pageId: 0,
        pageCustomMeta: {},
        archiveData: []
    }
}
</code></pre>

<p>When a page is called I set the values based on what the api returns. I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<pre><code>getPageData(slug){
    console.log(this.state);
    axios.get('http://admin.sitedata.co/pages?slug='+slug)
    .then((response) =&gt; {
        console.log(response.data);

        this.setState({
            pageContent:response.data[0].content.rendered,
            currentPage:slug,
            pageTitle:response.data[0].title.rendered,
            pageTemplate:response.data[0].template,
            pageId:response.data[0].id,
            pageCustomMeta:response.data[0].post_meta,
            archiveData:[]
        },function(){
            console.log(this.state);
            /*
            *   set the page title
            *   check if the page is at home
            *   get page custom meta
            */
            document.title = this.state.pageTitle;
            this.isHome();
            //this.getPageCustomMeta(this.state.pageId);
        });

    })
    .catch((error) =&gt; {
        console.log(error);
    });
}
</code></pre>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","When a component mounts, it shouldn't have a state in the first place unless you added it on purpose before mounting. React-router passes a data component when it routes, it doesn't maintain a passed around state. Definitely need more code."
"45322183","Testing a component after state has been updated in componentDidMount using enzyme jest react-native","1","<p>I have a component in react-native</p>

<pre><code>export default class SearchResultsScreen extends Component {
   constructor(props){
      super(props);
      this.state = {
        centres: [],
      };
  };

   componentDidMount() {
        let searchUrl =`${hostname}centres_search/`;
        let lat = this.props.origin_lat;
        let long = this.props.origin_long;
        let distance = this.props.distance;
        let url = `${searchUrl}origin_lat=${lat}&amp;origin_long=${long}&amp;distance=${distance}`
        console.log('before fetch called');
        fetch(url)
          .then((response) =&gt; response.json())
          .then((responseJson) =&gt; {
             console.log('before state updated '+responseJson[0].name);
             this.setState({
              centres: responseJson,
             });
             console.log('after fetch called '+responseJson[0].name);
          })
          .catch((error)=&gt;{
             console.log('error '+error);
             this.setState({
               centres: [],
             });
          });
   }

   static navigationOptions = {
      title: 'Centers',
      headerTitleStyle: navigationHeaderStyle
   };

   render() {
      let centresList;
      if(typeof this.state.centres == 'undefined' ||
          this.state.centres.length == 0) {
          centresList = &lt;Text&gt;No results found&lt;/Text&gt;
      } else {
         centresList = &lt;FlatList
             data={this.state.centres}
             keyExtractor={(item, index) =&gt; item._centre_id}
             renderItem={({item}) =&gt; &lt;CentreComponent Centre={item}/&gt;}
             ItemSeparatorComponent={() =&gt; &lt;ListSeperator /&gt;}
          /&gt;
      }

    return(
       &lt;View&gt;
          {centresList}
          &lt;ListSeperator /&gt;
       &lt;/View&gt;
    );
   };
}
</code></pre>

<p>So basically it loads  CentreComponent(s) based on the response from fetch (i.e the number of results it gets).</p>

<p>In my test with Jest I am trying to assert two Components of type CentreComponent exist. My test looks like this:</p>

<pre><code>jest.disableAutomock();
import 'react-native';
import React from 'react';
import {shallow, mount, render} from 'enzyme';
import SearchResultsScreen from '../../src/SearchResultsScreen/index';
import CentreComponent from 
    '../../src/SearchResultsScreen/CentreComponent';
import renderer from 'react-test-renderer';

describe('SearchResultsScreen', () =&gt; {
  test.only('renders more than one CentreComponent', () =&gt; {
    jest.useFakeTimers();
    global.fetch = jest.fn().mockImplementation(() =&gt; {
        let kc = [{
          _centre_id: 1,
          name: 'test',
          address_1: 'abc',
          address_2: 'def',
          city: 'so',
          postcode: 'tt',
        }, {
          _centre_id: 2,
          name: 'testee',
          address_1: 'abc',
          address_2: 'def',
          city: 'so',
          postcode: 'tt',
        }]
        console.log('mock fetch called');

        return new Promise((resolve, reject) =&gt; {
          process.nextTick(
            () =&gt; resolve({ok: true, json: function(){return kc}})
          );
        });
     });

     const checkbox = mount(&lt;SearchResultsScreen origin_long='5' origin_lat='2' distance='5'/&gt;);
     jest.runAllTicks();
     checkbox.update();
     expect(checkbox.find(KarCentreComponent)).toHaveLength(2);
   });
});
</code></pre>

<p>When I run the test 
      jest.js --env=jsdom </p>

<p>I see the following console.log being printed in order:</p>

<pre><code>console.log('before fetch called');
console.log('mock fetch called');
console.log('before state updated '+responseJson[0].name);

Error at line:
console.log('error '+error);
</code></pre>

<p>The error which I get is:</p>

<pre><code>  { Invariant Violation: Element type is invalid: expected a string (for 
  built-in components) or a class/function (for composite components) 
  but got: undefined. You likely forgot to export your component from 
  the file it's defined in. Check the render method of 
  `SearchResultsScreen`
</code></pre>

<p>So my suspicion is that, when componentDidUpdate is calling</p>

<pre><code>  this.setState({
          centres: responseJson,
         });
</code></pre>

<p>It is throwing an exception which is being caught by the ""catch"".</p>
","to whoever is reading this question, this seems to be an issue with react-native/jest, as FlatList is being retruned as undefined. 

https://github.com/facebook/react-native/issues/14514"
"45376845","Why is react-transition-group not calling componentWillEnter nor componentWillLeave on route change?","0","<p>I am following this hackernoon guide <a href=""https://hackernoon.com/animated-page-transitions-with-react-router-4-reacttransitiongroup-and-animated-1ca17bd97a1a"" rel=""nofollow noreferrer"">https://hackernoon.com/animated-page-transitions-with-react-router-4-reacttransitiongroup-and-animated-1ca17bd97a1a</a> in order to apply enter and leave animations to my react components when a route changes. I have obviously adapted the code to fit my site, and have decided not to use Animated but rather just pure CSS. Right now I'm just testing the code with console.log statements, and I noticed that componentWillEnter and componentWillLeave are not being called on route changes. Also, componentWillAppear only gets called once. </p>

<p>Here is the relevant code for each component, including App.js and index.js:</p>

<p>Animated Wrapper:</p>

<pre><code>import React, {Component} from ""react"";
import styles from '../styles/AnimatedWrapper.css';

const AnimatedWrapper = WrappedComponent =&gt;
  class AnimatedWrapper extends Component {
    componentWillAppear(cb) {
      console.log('componentWillAppear');
      cb();
    }
    componentWillEnter(cb) {
      console.log('componentWillEnter');
      cb();
    }
    componentWillLeave(cb) {
      console.log('componentWillLeave');
      cb();
    }
    render() {
      return (
        &lt;div id=""animated-wrapper"" className={styles.animatedPageWrapper}&gt;
          &lt;WrappedComponent {...this.props}/&gt;
        &lt;/div&gt;
      );}
    };

export default AnimatedWrapper;
</code></pre>

<p>App.js:</p>

<pre><code>import React, { Component } from 'react';
import { Route, Switch } from 'react-router-dom';
import TransitionGroup from ""react-transition-group/TransitionGroup"";

import Navbar from ""./components/Navbar"";
import Footer from ""./components/Footer"";
import Slider from ""./components/Slider"";
import ComingSoon from ""./components/ComingSoon"";

const firstChild = props =&gt; {
  const childrenArray = React.Children.toArray(props.children);
  return childrenArray[0] || null;
}

class App extends Component {
  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;Navbar /&gt;
        &lt;Switch&gt;
          &lt;Route
            path=""/coming-soon""
            children={({ match, ...rest }) =&gt; (
              &lt;TransitionGroup component={firstChild}&gt;
                {match &amp;&amp; &lt;ComingSoon {...rest} /&gt;}
              &lt;/TransitionGroup&gt;
          )}/&gt;
          &lt;Route
             path=""/""
             children={({ match, ...rest }) =&gt; (
               &lt;TransitionGroup component={firstChild}&gt;
                 {match &amp;&amp; &lt;Slider {...rest} /&gt;}
               &lt;/TransitionGroup&gt;
          )}/&gt;
        &lt;/Switch&gt;
        &lt;Footer /&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>

<p>index.js:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  &lt;BrowserRouter&gt;
     &lt;App /&gt;
   &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);
</code></pre>

<p>Slider.js:</p>

<pre><code>import React, { Component } from 'react';
import _ from 'lodash';

// components
import AnimatedWrapper from './AnimatedWrapper';
import Separator from './Separator';

// styles
import styles from '../styles/Slider.css';

// images
import Apartment from ""../../public/images/apartment.jpg"";
import Floor from ""../../public/images/floor.jpg"";
import Furniture from ""../../public/images/furniture.jpg"";
import Kitchen1 from ""../../public/images/kitchen.jpg"";
import Kitchen2 from ""../../public/images/kitchen-2.jpg"";

class SliderComponent extends Component {
  constructor(props) {
    super(props);

    this.state = {
      currentSlide: 0,
      slides: [Apartment, Floor, Furniture, Kitchen1, Kitchen2]
    };
  }

  componentDidMount() {
    this.zoomAnimation();
    this.slideContentAnimation();

    this.sliderInterval = setInterval(() =&gt; {
      if (this.state.currentSlide === 4) {
        if (this.refs.slider) {
          this.setState({ currentSlide: 0 });
        }
      } else {
        if (this.refs.slider) {
          this.setState({ currentSlide: this.state.currentSlide + 1 });
        }
      }
    }, 6000);
  }

  componentWillUpdate() {
    const currentContent = document.getElementById(`content-${this.state.currentSlide}`);
    setTimeout(() =&gt; {
      currentContent.classList.remove(`${styles.currentContent}`);
    }, 1500);
  }

  componentDidUpdate() {
    this.zoomAnimation();
    this.slideContentAnimation();
  }

  setSlide(number) {
    this.setState({ currentSlide: number });
  }

  zoomAnimation() {
    setTimeout(() =&gt; {
      const currentSlide = document.getElementById(`slide-${this.state.currentSlide}`);
      currentSlide.classList.add(`${styles.slideZoom}`);
    }, 500);
  }

  slideContentAnimation() {
    setTimeout(() =&gt; {
      const currentContent = document.getElementById(`content-${this.state.currentSlide}`);
      if (currentContent) {
        currentContent.classList.add(`${styles.currentContent}`);
      }
    }, 1500);
  }

  renderSlides() {
    return this.state.slides.map((slide, index) =&gt; {
      const isCurrent = index === this.state.currentSlide;

      const slideStyle = {
        backgroundImage: `url(${this.state.slides[index]})`
      }

      return (
        &lt;div
          id={`slide-${index}`}
          key={`slide-${index}`}
          className={`
            ${styles.slide}
            ${isCurrent ? styles.currentSlide : null}
          `}
          style={slideStyle}
          alt=""slide""&gt;
            &lt;div
              id={`content-${index}`}
              key={`content-${index}`}
              className={`
                ${styles.content}
            `}&gt;
              &lt;h1&gt;{`WE SPECIALIZE IN KITCHENS ${index}`}&lt;/h1&gt;
              &lt;Separator
                containerWidth={720}
                circleWidth={5}
                circleHeight={5}
                backgroundColor=""#fff""
                lineWidth={350}
                lineColor=""#fff""
              /&gt;
              &lt;div
                className={`${styles['hvr-sweep-to-top']} ${styles.btn}`}&gt;
                More Information
              &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
      );
    });
  }

  renderNavBar() {
    return (
      &lt;div className={styles.sliderNav}&gt;
        {_.range(5).map((index) =&gt; {
          return (
            &lt;div
              key={index}
              onClick={() =&gt; this.setSlide(index)}
              className={this.state.currentSlide === index ? styles.current : null}&gt;
            &lt;/div&gt;
          )
        })}
      &lt;/div&gt;
    )
  }

  render() {
    return (
      &lt;div className={styles.container} ref=""slider""&gt;
        &lt;div className={styles.slidesContainer}&gt;
          {this.renderSlides()}
        &lt;/div&gt;

        {this.renderNavBar()}
      &lt;/div&gt;
    );
  }
}

const Slider = AnimatedWrapper(SliderComponent);
export default Slider;
</code></pre>

<p>ComingSoon.js:</p>

<pre><code>import React from 'react';
import AnimatedWrapper from './AnimatedWrapper';
import styles from '../styles/ComingSoon.css';

const ComingSoonComponent = function() {
  return (
    &lt;div&gt;
      &lt;div className={styles.mainContent}&gt;
        &lt;div&gt;
          &lt;h1 className={styles.mainTitle}&gt;{`Coming Soon`}&lt;/h1&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

const ComingSoon = AnimatedWrapper(ComingSoonComponent);
export default ComingSoon;
</code></pre>
",""
"45380764","How to update a state object in the DOM from componentDidMount() (not componentDidUpdate())?","5","<p>I'm trying to conditionally show or not show per say a button based on data that I receive from clicking on a point. I realized that regular jquery functions to add a class don't really work in React. So I figured I could store strings in the state like</p>

<pre><code>this.state: {
    hidden_components: {
        add_comment: ""hide""
    }
}
</code></pre>

<p>This way I can conditionally show or hide a button by </p>

<pre><code>&lt;button className={this.state.hidden_components.add_comment}&gt; Add Comment &lt;/button&gt;
</code></pre>

<p>After the render() I have more or less:</p>

<pre><code>componentDidMount() {
  this.state.g = new Dygraph
  this.state.modal = new Modal 

  this.state.modal.setContent(use some ID here to reference a div that is hidden but will show up in the modal)

  const set_hidden_container = () =&gt; {
      // I'm just going to use this = notation instead of setState()
      // this is supposed to reset the 
      this.state.hidden_components = ""hide""
      if (check_comment(this.state.points[at some index].value)) {
        this.state.hidden_components = ""show""
      }
  }

  this.state.g.updateOptions( {

    pointClickCallback: (event, p) =&gt; {
      console.log(""i clicked a point on the graph"")
      this.setState({
        currentPoint: p
      })

      set_hidden_containers()

      // force update
      this.setState({
        currentPoint: p
      })

      // I want the modal to open a div of things that only show jsx based on logic in set_hidden_container()
      this.state.modal.open()
    }
  }

componentDidUpdate() {
  // logic goes here for like event listeners and anything that queries the DOM after initialization
}
</code></pre>

<p>Then in componentDidMount() I have a function that depending on the data received from clicking on a point I do the following:
1) reset all the classes stored in the state to ""hide""
2) based on conditions set some of them to ""show""
3) concatenate all the classes stored in the state with various styling classes </p>

<p>UPDATE: 
I've long since found an easier solution to this problem, however, I'm guessing some people might have similar issues. Therefore, I'll update this question with more psuedocode and a workaround: maybe someone down the line can solve this. This component is particularly frustrating to work with because I haven't been able to make it as modular as I want because of the particular library I'm working with. There are actually about a 1000 lines in this component (I know I know not good).  </p>

<p>WORKAROUND:
For those of you who are having trouble with a component's lifecycle in dynamically setting parts of the DOM but don't want to use global variables to set classNames, jquery functions, or use react syntax to show components containing the content I recommend you do the following. </p>

<p>You can still have a set_hidden_container() set content dynamically, you just have to set things based on an id with innerHTML instead of setting a state object to be a string ""show"". The important thing is, however, that for every time you need to dynamically change content you reset these references to be empty as well as force an update. You can simply change the state of anything and then in componentDidUpdate() you can insert 1) a conditional to check if the innerHTML was actually set or not (since you're not always going to be displaying everything) and 2) within that conditional you can set whatever logic you want associated with the content showing on the page.</p>
","Can you add more of your code? Maybe make a simplified version if it's too long and convoluted. Right now you have paragraphs of text trying to explain your app flow but it's still pretty hard to visualize. If I understand correctly, your real problem is that you don't know how to reference an object declared in `componentDidMount` in other lifecycle methods?"
"45380764","How to update a state object in the DOM from componentDidMount() (not componentDidUpdate())?","5","<p>I'm trying to conditionally show or not show per say a button based on data that I receive from clicking on a point. I realized that regular jquery functions to add a class don't really work in React. So I figured I could store strings in the state like</p>

<pre><code>this.state: {
    hidden_components: {
        add_comment: ""hide""
    }
}
</code></pre>

<p>This way I can conditionally show or hide a button by </p>

<pre><code>&lt;button className={this.state.hidden_components.add_comment}&gt; Add Comment &lt;/button&gt;
</code></pre>

<p>After the render() I have more or less:</p>

<pre><code>componentDidMount() {
  this.state.g = new Dygraph
  this.state.modal = new Modal 

  this.state.modal.setContent(use some ID here to reference a div that is hidden but will show up in the modal)

  const set_hidden_container = () =&gt; {
      // I'm just going to use this = notation instead of setState()
      // this is supposed to reset the 
      this.state.hidden_components = ""hide""
      if (check_comment(this.state.points[at some index].value)) {
        this.state.hidden_components = ""show""
      }
  }

  this.state.g.updateOptions( {

    pointClickCallback: (event, p) =&gt; {
      console.log(""i clicked a point on the graph"")
      this.setState({
        currentPoint: p
      })

      set_hidden_containers()

      // force update
      this.setState({
        currentPoint: p
      })

      // I want the modal to open a div of things that only show jsx based on logic in set_hidden_container()
      this.state.modal.open()
    }
  }

componentDidUpdate() {
  // logic goes here for like event listeners and anything that queries the DOM after initialization
}
</code></pre>

<p>Then in componentDidMount() I have a function that depending on the data received from clicking on a point I do the following:
1) reset all the classes stored in the state to ""hide""
2) based on conditions set some of them to ""show""
3) concatenate all the classes stored in the state with various styling classes </p>

<p>UPDATE: 
I've long since found an easier solution to this problem, however, I'm guessing some people might have similar issues. Therefore, I'll update this question with more psuedocode and a workaround: maybe someone down the line can solve this. This component is particularly frustrating to work with because I haven't been able to make it as modular as I want because of the particular library I'm working with. There are actually about a 1000 lines in this component (I know I know not good).  </p>

<p>WORKAROUND:
For those of you who are having trouble with a component's lifecycle in dynamically setting parts of the DOM but don't want to use global variables to set classNames, jquery functions, or use react syntax to show components containing the content I recommend you do the following. </p>

<p>You can still have a set_hidden_container() set content dynamically, you just have to set things based on an id with innerHTML instead of setting a state object to be a string ""show"". The important thing is, however, that for every time you need to dynamically change content you reset these references to be empty as well as force an update. You can simply change the state of anything and then in componentDidUpdate() you can insert 1) a conditional to check if the innerHTML was actually set or not (since you're not always going to be displaying everything) and 2) within that conditional you can set whatever logic you want associated with the content showing on the page.</p>
","To be honest, I think the solution to this makes this method not as versatile as I thought for any components that directly work with several parts of the React lifecycle. However, you have to move ALL relevant variables into the state object so that it can be globally referenced and then set conditionals for any eventlisteners or queries you are doing in the DOM so that it's only triggered when the DOM is set. Also this is annoying because I think you have to trigger state changes to update the component. In any case, I am not using this method because there is still one other problem."
"45380764","How to update a state object in the DOM from componentDidMount() (not componentDidUpdate())?","5","<p>I'm trying to conditionally show or not show per say a button based on data that I receive from clicking on a point. I realized that regular jquery functions to add a class don't really work in React. So I figured I could store strings in the state like</p>

<pre><code>this.state: {
    hidden_components: {
        add_comment: ""hide""
    }
}
</code></pre>

<p>This way I can conditionally show or hide a button by </p>

<pre><code>&lt;button className={this.state.hidden_components.add_comment}&gt; Add Comment &lt;/button&gt;
</code></pre>

<p>After the render() I have more or less:</p>

<pre><code>componentDidMount() {
  this.state.g = new Dygraph
  this.state.modal = new Modal 

  this.state.modal.setContent(use some ID here to reference a div that is hidden but will show up in the modal)

  const set_hidden_container = () =&gt; {
      // I'm just going to use this = notation instead of setState()
      // this is supposed to reset the 
      this.state.hidden_components = ""hide""
      if (check_comment(this.state.points[at some index].value)) {
        this.state.hidden_components = ""show""
      }
  }

  this.state.g.updateOptions( {

    pointClickCallback: (event, p) =&gt; {
      console.log(""i clicked a point on the graph"")
      this.setState({
        currentPoint: p
      })

      set_hidden_containers()

      // force update
      this.setState({
        currentPoint: p
      })

      // I want the modal to open a div of things that only show jsx based on logic in set_hidden_container()
      this.state.modal.open()
    }
  }

componentDidUpdate() {
  // logic goes here for like event listeners and anything that queries the DOM after initialization
}
</code></pre>

<p>Then in componentDidMount() I have a function that depending on the data received from clicking on a point I do the following:
1) reset all the classes stored in the state to ""hide""
2) based on conditions set some of them to ""show""
3) concatenate all the classes stored in the state with various styling classes </p>

<p>UPDATE: 
I've long since found an easier solution to this problem, however, I'm guessing some people might have similar issues. Therefore, I'll update this question with more psuedocode and a workaround: maybe someone down the line can solve this. This component is particularly frustrating to work with because I haven't been able to make it as modular as I want because of the particular library I'm working with. There are actually about a 1000 lines in this component (I know I know not good).  </p>

<p>WORKAROUND:
For those of you who are having trouble with a component's lifecycle in dynamically setting parts of the DOM but don't want to use global variables to set classNames, jquery functions, or use react syntax to show components containing the content I recommend you do the following. </p>

<p>You can still have a set_hidden_container() set content dynamically, you just have to set things based on an id with innerHTML instead of setting a state object to be a string ""show"". The important thing is, however, that for every time you need to dynamically change content you reset these references to be empty as well as force an update. You can simply change the state of anything and then in componentDidUpdate() you can insert 1) a conditional to check if the innerHTML was actually set or not (since you're not always going to be displaying everything) and 2) within that conditional you can set whatever logic you want associated with the content showing on the page.</p>
","Yes! That is a big problem. To be honest, I can do this so many different ways that this isn't actually obstructing my project but I really want to learn React thoroughly. And yes I think I'll try adding more code"
"45380764","How to update a state object in the DOM from componentDidMount() (not componentDidUpdate())?","5","<p>I'm trying to conditionally show or not show per say a button based on data that I receive from clicking on a point. I realized that regular jquery functions to add a class don't really work in React. So I figured I could store strings in the state like</p>

<pre><code>this.state: {
    hidden_components: {
        add_comment: ""hide""
    }
}
</code></pre>

<p>This way I can conditionally show or hide a button by </p>

<pre><code>&lt;button className={this.state.hidden_components.add_comment}&gt; Add Comment &lt;/button&gt;
</code></pre>

<p>After the render() I have more or less:</p>

<pre><code>componentDidMount() {
  this.state.g = new Dygraph
  this.state.modal = new Modal 

  this.state.modal.setContent(use some ID here to reference a div that is hidden but will show up in the modal)

  const set_hidden_container = () =&gt; {
      // I'm just going to use this = notation instead of setState()
      // this is supposed to reset the 
      this.state.hidden_components = ""hide""
      if (check_comment(this.state.points[at some index].value)) {
        this.state.hidden_components = ""show""
      }
  }

  this.state.g.updateOptions( {

    pointClickCallback: (event, p) =&gt; {
      console.log(""i clicked a point on the graph"")
      this.setState({
        currentPoint: p
      })

      set_hidden_containers()

      // force update
      this.setState({
        currentPoint: p
      })

      // I want the modal to open a div of things that only show jsx based on logic in set_hidden_container()
      this.state.modal.open()
    }
  }

componentDidUpdate() {
  // logic goes here for like event listeners and anything that queries the DOM after initialization
}
</code></pre>

<p>Then in componentDidMount() I have a function that depending on the data received from clicking on a point I do the following:
1) reset all the classes stored in the state to ""hide""
2) based on conditions set some of them to ""show""
3) concatenate all the classes stored in the state with various styling classes </p>

<p>UPDATE: 
I've long since found an easier solution to this problem, however, I'm guessing some people might have similar issues. Therefore, I'll update this question with more psuedocode and a workaround: maybe someone down the line can solve this. This component is particularly frustrating to work with because I haven't been able to make it as modular as I want because of the particular library I'm working with. There are actually about a 1000 lines in this component (I know I know not good).  </p>

<p>WORKAROUND:
For those of you who are having trouble with a component's lifecycle in dynamically setting parts of the DOM but don't want to use global variables to set classNames, jquery functions, or use react syntax to show components containing the content I recommend you do the following. </p>

<p>You can still have a set_hidden_container() set content dynamically, you just have to set things based on an id with innerHTML instead of setting a state object to be a string ""show"". The important thing is, however, that for every time you need to dynamically change content you reset these references to be empty as well as force an update. You can simply change the state of anything and then in componentDidUpdate() you can insert 1) a conditional to check if the innerHTML was actually set or not (since you're not always going to be displaying everything) and 2) within that conditional you can set whatever logic you want associated with the content showing on the page.</p>
","@AndyNoelker I updated the post I'm not sure if that makes things clearer. I need to set the foundation of the content I'm changing (such as the modal) and then change what's on that foundation depending on a pointClickCallBack function specific to the javascript library I'm using to generate the graph. If I move a minimum of what I just explained the entire graph will update resetting other parts I want to remain constant (for example if a user is zoomed in on a part of the graph)."
"45380764","How to update a state object in the DOM from componentDidMount() (not componentDidUpdate())?","5","<p>I'm trying to conditionally show or not show per say a button based on data that I receive from clicking on a point. I realized that regular jquery functions to add a class don't really work in React. So I figured I could store strings in the state like</p>

<pre><code>this.state: {
    hidden_components: {
        add_comment: ""hide""
    }
}
</code></pre>

<p>This way I can conditionally show or hide a button by </p>

<pre><code>&lt;button className={this.state.hidden_components.add_comment}&gt; Add Comment &lt;/button&gt;
</code></pre>

<p>After the render() I have more or less:</p>

<pre><code>componentDidMount() {
  this.state.g = new Dygraph
  this.state.modal = new Modal 

  this.state.modal.setContent(use some ID here to reference a div that is hidden but will show up in the modal)

  const set_hidden_container = () =&gt; {
      // I'm just going to use this = notation instead of setState()
      // this is supposed to reset the 
      this.state.hidden_components = ""hide""
      if (check_comment(this.state.points[at some index].value)) {
        this.state.hidden_components = ""show""
      }
  }

  this.state.g.updateOptions( {

    pointClickCallback: (event, p) =&gt; {
      console.log(""i clicked a point on the graph"")
      this.setState({
        currentPoint: p
      })

      set_hidden_containers()

      // force update
      this.setState({
        currentPoint: p
      })

      // I want the modal to open a div of things that only show jsx based on logic in set_hidden_container()
      this.state.modal.open()
    }
  }

componentDidUpdate() {
  // logic goes here for like event listeners and anything that queries the DOM after initialization
}
</code></pre>

<p>Then in componentDidMount() I have a function that depending on the data received from clicking on a point I do the following:
1) reset all the classes stored in the state to ""hide""
2) based on conditions set some of them to ""show""
3) concatenate all the classes stored in the state with various styling classes </p>

<p>UPDATE: 
I've long since found an easier solution to this problem, however, I'm guessing some people might have similar issues. Therefore, I'll update this question with more psuedocode and a workaround: maybe someone down the line can solve this. This component is particularly frustrating to work with because I haven't been able to make it as modular as I want because of the particular library I'm working with. There are actually about a 1000 lines in this component (I know I know not good).  </p>

<p>WORKAROUND:
For those of you who are having trouble with a component's lifecycle in dynamically setting parts of the DOM but don't want to use global variables to set classNames, jquery functions, or use react syntax to show components containing the content I recommend you do the following. </p>

<p>You can still have a set_hidden_container() set content dynamically, you just have to set things based on an id with innerHTML instead of setting a state object to be a string ""show"". The important thing is, however, that for every time you need to dynamically change content you reset these references to be empty as well as force an update. You can simply change the state of anything and then in componentDidUpdate() you can insert 1) a conditional to check if the innerHTML was actually set or not (since you're not always going to be displaying everything) and 2) within that conditional you can set whatever logic you want associated with the content showing on the page.</p>
","State is not the only way to reference things inside React components. It is totally valid to save objects to the `this` variable outside of using state. Could you add more code to this post, even if it is simplified pseudo code to better exemplify your app's flow and what you are trying to do?"
"45611651","react-virtualized Infinite scroller issues with dynamic height","0","<p>I am trying to mock Facebook feed like scroller in my application with <a href=""https://github.com/bvaughn/react-virtualized"" rel=""nofollow noreferrer"">react-virtualized</a>. I am following the reference from <a href=""https://github.com/bvaughn/tweets/blob/37d0139736346db16b9681d5b859a4e127964518/src/components/TweetList.js#L126-L132"" rel=""nofollow noreferrer"">here</a>. I am trying to load two feeds at a time and after that <code>loadMoreRows</code> would be called to fetch the next two. I have hardcoded my feed size to 10 for testing purpose. It works well till 4th feed. Then I am not able to move after that smoothly. <code>rowRenderer</code> is triggering the numbers again and again which results in vibration effect on the screen. If I somehow move to the 10th feed and I scroll back, <code>rowRenderer</code> starts from 0 again. I assume it is due to varying height. Similar to the reference, I have used <code>CellMeasurerCache</code> and <code>CellMeasurer</code> to find the dynamic <code>height</code> and <code>width</code> and passing that to list. </p>

<pre><code>class Scroller extends React.Component {
  _cache = new CellMeasurerCache({ defaultHeight: 100, fixedWidth: true });
  _resizeAllFlag = false; 
  _mostRecentWidth = 0;
  constructor(props) {
    super(props);
    this.state = {
      localCache: []
    }
  }
  componentDidMount(){
    this._loadData(0); 
  }
  componentDidUpdate(prevProps, prevState) {
    console.log(this._list);
    if(this._resizeAllFlag){
      this._resizeAllFlag = false;
      this._cache.clearAll();
      this._recomputeRowHeights();
    } else if(this.state.localCache !== prevState.localCache) {
      this._cache.clear(index, 0);
      this._recomputeRowHeights(index);
    }
  }
  ._loadData = (offset, callback) =&gt; {
    //Loads data from server and sets it in this.state.localCache
  }
  _recomputeRowHeights = (index) =&gt; {
    if (this._list) {
      console.log('Recomputing');
      this._list.recomputeRowHeights(index);
    }
  }
  _isRowLoaded = ({ index }) =&gt; {
    return !!this.state.localCache[index];
  }
  _loadMoreRows = ({ startIndex, stopIndex }) =&gt; {
    this._loadData(startIndex, (() =&gt; promiseResolver));
    let promiseResolver;
    return new Promise((resolve) =&gt; {
      promiseResolver = resolve;
    });
  }
  rowRenderer = ({ index, key, style, parent }) =&gt; {
    const row = this.state.localCache[index];
    let content;
    if (row) {
      content = (&lt;Feed data={row}/&gt;);
    } else {
      content = (&lt;CustomLoader /&gt;);
    }
    return (
      &lt;CellMeasurer
        cache={this._cache}
        columnIndex={0}
        key={key}
        parent={parent}
        rowIndex={index}
        width={this._mostRecentWidth}
      &gt; 
        {content} 
      &lt;/CellMeasurer&gt;);
  }
  _setListRef = (ref) =&gt; {
    this._list = ref;
    this._registerList(ref);
  };
  _resizeAll = () =&gt; {
    this._resizeAllFlag = false;
    this._cache.clearAll();
    if (this._list) {
      this._list.recomputeRowHeights();
    }
  };
  render() {
    const { localCache } = this.state;
    return (
      &lt;div className=""flex_grow""&gt;
        &lt;InfiniteLoader
          isRowLoaded={this._isRowLoaded}
          loadMoreRows={this._loadMoreRows}
          rowCount={10}
        &gt;
          {({ onRowsRendered, registerChild }) =&gt;
            &lt;AutoSizer disableHeight&gt;
              {({ width, height }) =&gt; {
                if (this._mostRecentWidth &amp;&amp; this._mostRecentWidth !== width) {
                  this._resizeAllFlag = true;
                  setTimeout(this._resizeAll, 0);
                }
                this._mostRecentWidth = width;
                this._registerList = registerChild;
                return (
                  &lt;List
                    deferredMeasurementCache={this._cache}
                    overscanRowCount={1}
                    ref={this._setListRef}
                    height={height}
                    onRowsRendered={onRowsRendered}
                    rowCount={10}
                    rowHeight={this._cache.rowHeight}
                    rowRenderer={this.rowRenderer}
                    width={width}
                  /&gt;
                ) 
              }
              }
            &lt;/AutoSizer&gt;}
        &lt;/InfiniteLoader&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Update</strong></p>

<p>I might have deleted style props in content that is being passed. As per @Adrien's suggestion, I added it. My issues were not solved after adding style props.</p>

<pre><code>rowRenderer = ({ index, key, style, parent }) =&gt; {
  const row = this.state.localCache[index];
  let content;
  if (row) {
    content = (&lt;Feed style={style} data={row}/&gt;);
  } else {
    content = (&lt;CustomLoader style={style}/&gt;);
  }
  return (
    &lt;CellMeasurer
      cache={this._cache}
      columnIndex={0}
      key={key}
      parent={parent}
      rowIndex={index}
      width={this._mostRecentWidth}
    &gt; 
      {content} 
    &lt;/CellMeasurer&gt;);
} 
</code></pre>

<p>And my Feed component</p>

<pre><code>class Feed extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const { style } = this.props;
    return (
      &lt;div className=""flex_grow"" style={style}&gt;
        {/* Feed related JSX */}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>My components seems to be overlapping. What could have been wrong?</p>

<p><strong>AnswerGist</strong>:
<a href=""https://gist.github.com/beb4/cc91f4e9b8982d172613cff248090769"" rel=""nofollow noreferrer"">https://gist.github.com/beb4/cc91f4e9b8982d172613cff248090769</a></p>
",""
"45657321","TypeError: Cannot read property 'length' of null in react component","2","<p>Okay so I've gotten pretty far in creating the React Component for ChartJS, however when testing I get the following error:</p>

<pre><code>FAIL  lib\chart\chart.test.tsx
  ● renders without crashing

    TypeError: Cannot read property 'length' of null

      at Object.acquireContext (node_modules/chart.js/src/platforms/platform.dom.js:189:19)
      at Chart.construct (node_modules/chart.js/src/core/core.controller.js:72:27)
      at new Chart (node_modules/chart.js/src/core/core.js:7:8)
      at Chart.Object.&lt;anonymous&gt;.Chart.renderChart (lib/chart/chart.tsx:233:26)
      at Chart.Object.&lt;anonymous&gt;.Chart.componentDidMount (lib/chart/chart.tsx:42:10)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:264:25
      at measureLifeCyclePerf (node_modules/react-dom/lib/ReactCompositeComponent.js:75:12)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:263:11
      at CallbackQueue.notifyAll (node_modules/react-dom/lib/CallbackQueue.js:76:22)
      at ReactReconcileTransaction.close (node_modules/react-dom/lib/ReactReconcileTransaction.js:80:26)
      at ReactReconcileTransaction.closeAll (node_modules/react-dom/lib/Transaction.js:209:25)
      at ReactReconcileTransaction.perform (node_modules/react-dom/lib/Transaction.js:156:16)
      at batchedMountComponentIntoNode (node_modules/react-dom/lib/ReactMount.js:126:15)
      at ReactDefaultBatchingStrategyTransaction.perform (node_modules/react-dom/lib/Transaction.js:143:20)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:26)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:27)
      at Object._renderNewRootComponent (node_modules/react-dom/lib/ReactMount.js:319:18)
      at Object._renderSubtreeIntoContainer (node_modules/react-dom/lib/ReactMount.js:401:32)
      at Object.render (node_modules/react-dom/lib/ReactMount.js:422:23)
      at Object.&lt;anonymous&gt; (lib/chart/chart.test.tsx:7:12)
          at Promise (&lt;anonymous&gt;)
      at Promise.resolve.then.el (node_modules/p-map/index.js:42:16)
          at &lt;anonymous&gt;
      at process._tickCallback (internal/process/next_tick.js:169:7)

  × renders without crashing (275ms)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.314s, estimated 3s
Ran all test suites related to changed files.
</code></pre>

<p>However, I've spent a long time looking over the code and haven't been able to figure out why it refuses to work properly. The error starts at the <code>renderChart()</code> function at creating a new chart instance. My first guess would be the for some reason it's not registering the canvas element despite being called by its id.  But when the content of renderChart is moved into the render() function it still gives the same error. Here's the code being tested:</p>

<pre><code>import * as React from 'react'
import * as ClassNames from 'classnames'
import * as ChartJS from 'chart.js'
const IsEqual = require('lodash.isequal')
const Find = require('lodash.find')
const subChart = require('chart.js')

interface IChartProps {
  /** The user-defined classes */
  readonly className?: string
  readonly width?: number
  readonly height?: number
  readonly reRender?: boolean

  readonly type: ChartJS.ChartType
  readonly data: ChartJS.ChartData
  readonly options: ChartJS.ChartOptions
  readonly getDatasetAtEvent?: Function
  readonly getElementAtEvent?: Function
  readonly getElementsAtEvent?: Function
  readonly onElementsClick?: Function
  readonly datasetKeyProvider?: Function
}

interface IChartState {
  /** Add your states here */
}

export class Chart extends React.Component&lt;IChartProps, IChartState&gt; {
  // tslint:disable-next-line
  private chartInstance: any
  private shadowData: {}
  constructor(props: IChartProps) {
    super(props)
  }

  public componentWillMount() {
    // this.chartInstance = undefined
  }

  public componentDidMount() {
    this.renderChart()
  }

  // public componentWillReceiveProps(nextProps: IChartProps) {}

  public shouldComponentUpdate(nextProps: IChartProps, nextState: IChartState) {
    const props = this.props
    if (nextProps.reRender === true) {
      return true
    }

    if (props.height !== nextProps.height || props.width !== nextProps.width) {
      return true
    }

    if (props.type !== nextProps.type) {
      return true
    }

    if (!IsEqual(props.options, nextProps.options)) {
      return true
    }

    const nextData = this.transformDataProp(nextProps)

    if (!IsEqual(this.shadowData, nextData)) {
      return true
    }

    return false
  }

  // public componentWillUpdate(nextProps: IChartProps, nextState: IChartState) {}

  public componentDidUpdate(prevProps: IChartProps, prevState: IChartState) {
    if (this.props.reRender) {
      this.chartInstance.destroy()
      this.renderChart()
      return
    }
    this.updateChart()
  }

  public transformDataProp(props: IChartProps) {
    const data = props.data
    if (typeof data === 'function') {
      const node = document.getElementById('bar-chart') as HTMLCanvasElement
      return data(node)
    } else {
      return data
    }
  }

  public memoizeDataProps(props?: IChartProps) {
    if (!this.props.data) {
      return
    }
    const data = this.transformDataProp(this.props)

    this.shadowData = {
      ...data,
      datasets:
        data.datasets &amp;&amp;
        data.datasets.map((set: string[]) =&gt; {
          return { ...set }
        })
    }
    return data
  }

  public updateChart() {
    const options = this.props.options

    const data = this.memoizeDataProps(this.props)

    if (!this.chartInstance) {
      return
    }

    if (options) {
      this.chartInstance.options = subChart.helpers.configMerge(
        this.chartInstance.options,
        options
      )
    }

    let currentDatasets =
      (this.chartInstance.config.data &amp;&amp;
        this.chartInstance.config.data.datasets) ||
      []
    const nextDatasets = data.datasets || []

    const currentDatasetKeys = currentDatasets.map(
      this.props.datasetKeyProvider
    )
    const nextDatasetKeys = nextDatasets.map(this.props.datasetKeyProvider)
    const newDatasets = nextDatasets.filter(
      (d: object) =&gt;
        currentDatasetKeys.indexOf(this.props.datasetKeyProvider(d)) === -1
    )

    for (let idx = currentDatasets.length - 1; idx &gt;= 0; idx -= 1) {
      const currentDatasetKey = this.props.datasetKeyProvider(
        currentDatasets[idx]
      )
      if (nextDatasetKeys.indexOf(currentDatasetKey) === -1) {
        // deleted series
        currentDatasets.splice(idx, 1)
      } else {
        const retainedDataset = Find(
          nextDatasets,
          (d: object) =&gt; this.props.datasetKeyProvider(d) === currentDatasetKey
        )
        if (retainedDataset) {
          // update it in place if it is a retained dataset
          currentDatasets[idx].data.splice(retainedDataset.data.length)
          retainedDataset.data.forEach((point: number, pid: number) =&gt; {
            currentDatasets[idx].data[pid] = retainedDataset.data[pid]
          })
          // const { data, ...otherProps } = retainedDataset
          currentDatasets[idx] = {
            data: currentDatasets[idx].data,
            ...currentDatasets[idx],
            ...retainedDataset.otherProps
          }
        }
      }
    }
    // finally add any new series
    newDatasets.forEach((d: object) =&gt; currentDatasets.push(d))
    const { datasets, ...rest } = data

    this.chartInstance.config.data = {
      ...this.chartInstance.config.data,
      ...rest
    }

    this.chartInstance.update()
  }

  public componentWillUnmount() {
    this.chartInstance.destroy()
  }

  public onClickEvent = (event: React.MouseEvent&lt;HTMLCanvasElement&gt;) =&gt; {
    // this.props.getDatasetAtEvent &amp;&amp;
    this.props.getDatasetAtEvent(
      this.chartInstance.getDatasetAtEvent(event),
      event
    )

    // this.props.getElementAtEvent &amp;&amp;
    this.props.getElementAtEvent(
      this.chartInstance.getElementAtEvent(event),
      event
    )

    // this.props.getElementsAtEvent &amp;&amp;
    this.props.getElementsAtEvent(
      this.chartInstance.getElementsAtEvent(event),
      event
    )

    // this.props.onElementsClick &amp;&amp;
    this.props.onElementsClick(
      this.chartInstance.getElementsAtEvent(event),
      event
    )
  }

  public render() {
    const className = ClassNames('chart', this.props.className)

    // bar.update()
    return (
      &lt;div className={className}&gt;
        &lt;canvas
          id=""chart-instance""
          width={this.props.width ? this.props.width : '400'}
          height={this.props.height ? this.props.height : '400'}
          onClick={this.onClickEvent}
        /&gt;
      &lt;/div&gt;
    )
  }

  public renderChart() {
    const { options, type, data } = this.props
    const node = document.getElementById('chart-instance') as HTMLCanvasElement
    // const data = this.memoizeDataProps()

    this.chartInstance = new ChartJS(node, {
      type,
      data,
      options
    })
  }
}
</code></pre>

<p>can someone help me figure out why this won't work properly?</p>
","Since you haven't posted test itself, I suppose `length` is a property of some element. Try like this:
`const wrapper = mount(<YourElement />);
wrapper.find('ElementYourWantLengthOf').props().length`

You might also be calling `length` on an array of nodes returned by `find()`. Then, obviously, `find()` finds nothing which might be a consequence of a component not being mounted properly.

Anyways, post your test code, then we'll see."
"45657321","TypeError: Cannot read property 'length' of null in react component","2","<p>Okay so I've gotten pretty far in creating the React Component for ChartJS, however when testing I get the following error:</p>

<pre><code>FAIL  lib\chart\chart.test.tsx
  ● renders without crashing

    TypeError: Cannot read property 'length' of null

      at Object.acquireContext (node_modules/chart.js/src/platforms/platform.dom.js:189:19)
      at Chart.construct (node_modules/chart.js/src/core/core.controller.js:72:27)
      at new Chart (node_modules/chart.js/src/core/core.js:7:8)
      at Chart.Object.&lt;anonymous&gt;.Chart.renderChart (lib/chart/chart.tsx:233:26)
      at Chart.Object.&lt;anonymous&gt;.Chart.componentDidMount (lib/chart/chart.tsx:42:10)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:264:25
      at measureLifeCyclePerf (node_modules/react-dom/lib/ReactCompositeComponent.js:75:12)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:263:11
      at CallbackQueue.notifyAll (node_modules/react-dom/lib/CallbackQueue.js:76:22)
      at ReactReconcileTransaction.close (node_modules/react-dom/lib/ReactReconcileTransaction.js:80:26)
      at ReactReconcileTransaction.closeAll (node_modules/react-dom/lib/Transaction.js:209:25)
      at ReactReconcileTransaction.perform (node_modules/react-dom/lib/Transaction.js:156:16)
      at batchedMountComponentIntoNode (node_modules/react-dom/lib/ReactMount.js:126:15)
      at ReactDefaultBatchingStrategyTransaction.perform (node_modules/react-dom/lib/Transaction.js:143:20)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:26)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:27)
      at Object._renderNewRootComponent (node_modules/react-dom/lib/ReactMount.js:319:18)
      at Object._renderSubtreeIntoContainer (node_modules/react-dom/lib/ReactMount.js:401:32)
      at Object.render (node_modules/react-dom/lib/ReactMount.js:422:23)
      at Object.&lt;anonymous&gt; (lib/chart/chart.test.tsx:7:12)
          at Promise (&lt;anonymous&gt;)
      at Promise.resolve.then.el (node_modules/p-map/index.js:42:16)
          at &lt;anonymous&gt;
      at process._tickCallback (internal/process/next_tick.js:169:7)

  × renders without crashing (275ms)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.314s, estimated 3s
Ran all test suites related to changed files.
</code></pre>

<p>However, I've spent a long time looking over the code and haven't been able to figure out why it refuses to work properly. The error starts at the <code>renderChart()</code> function at creating a new chart instance. My first guess would be the for some reason it's not registering the canvas element despite being called by its id.  But when the content of renderChart is moved into the render() function it still gives the same error. Here's the code being tested:</p>

<pre><code>import * as React from 'react'
import * as ClassNames from 'classnames'
import * as ChartJS from 'chart.js'
const IsEqual = require('lodash.isequal')
const Find = require('lodash.find')
const subChart = require('chart.js')

interface IChartProps {
  /** The user-defined classes */
  readonly className?: string
  readonly width?: number
  readonly height?: number
  readonly reRender?: boolean

  readonly type: ChartJS.ChartType
  readonly data: ChartJS.ChartData
  readonly options: ChartJS.ChartOptions
  readonly getDatasetAtEvent?: Function
  readonly getElementAtEvent?: Function
  readonly getElementsAtEvent?: Function
  readonly onElementsClick?: Function
  readonly datasetKeyProvider?: Function
}

interface IChartState {
  /** Add your states here */
}

export class Chart extends React.Component&lt;IChartProps, IChartState&gt; {
  // tslint:disable-next-line
  private chartInstance: any
  private shadowData: {}
  constructor(props: IChartProps) {
    super(props)
  }

  public componentWillMount() {
    // this.chartInstance = undefined
  }

  public componentDidMount() {
    this.renderChart()
  }

  // public componentWillReceiveProps(nextProps: IChartProps) {}

  public shouldComponentUpdate(nextProps: IChartProps, nextState: IChartState) {
    const props = this.props
    if (nextProps.reRender === true) {
      return true
    }

    if (props.height !== nextProps.height || props.width !== nextProps.width) {
      return true
    }

    if (props.type !== nextProps.type) {
      return true
    }

    if (!IsEqual(props.options, nextProps.options)) {
      return true
    }

    const nextData = this.transformDataProp(nextProps)

    if (!IsEqual(this.shadowData, nextData)) {
      return true
    }

    return false
  }

  // public componentWillUpdate(nextProps: IChartProps, nextState: IChartState) {}

  public componentDidUpdate(prevProps: IChartProps, prevState: IChartState) {
    if (this.props.reRender) {
      this.chartInstance.destroy()
      this.renderChart()
      return
    }
    this.updateChart()
  }

  public transformDataProp(props: IChartProps) {
    const data = props.data
    if (typeof data === 'function') {
      const node = document.getElementById('bar-chart') as HTMLCanvasElement
      return data(node)
    } else {
      return data
    }
  }

  public memoizeDataProps(props?: IChartProps) {
    if (!this.props.data) {
      return
    }
    const data = this.transformDataProp(this.props)

    this.shadowData = {
      ...data,
      datasets:
        data.datasets &amp;&amp;
        data.datasets.map((set: string[]) =&gt; {
          return { ...set }
        })
    }
    return data
  }

  public updateChart() {
    const options = this.props.options

    const data = this.memoizeDataProps(this.props)

    if (!this.chartInstance) {
      return
    }

    if (options) {
      this.chartInstance.options = subChart.helpers.configMerge(
        this.chartInstance.options,
        options
      )
    }

    let currentDatasets =
      (this.chartInstance.config.data &amp;&amp;
        this.chartInstance.config.data.datasets) ||
      []
    const nextDatasets = data.datasets || []

    const currentDatasetKeys = currentDatasets.map(
      this.props.datasetKeyProvider
    )
    const nextDatasetKeys = nextDatasets.map(this.props.datasetKeyProvider)
    const newDatasets = nextDatasets.filter(
      (d: object) =&gt;
        currentDatasetKeys.indexOf(this.props.datasetKeyProvider(d)) === -1
    )

    for (let idx = currentDatasets.length - 1; idx &gt;= 0; idx -= 1) {
      const currentDatasetKey = this.props.datasetKeyProvider(
        currentDatasets[idx]
      )
      if (nextDatasetKeys.indexOf(currentDatasetKey) === -1) {
        // deleted series
        currentDatasets.splice(idx, 1)
      } else {
        const retainedDataset = Find(
          nextDatasets,
          (d: object) =&gt; this.props.datasetKeyProvider(d) === currentDatasetKey
        )
        if (retainedDataset) {
          // update it in place if it is a retained dataset
          currentDatasets[idx].data.splice(retainedDataset.data.length)
          retainedDataset.data.forEach((point: number, pid: number) =&gt; {
            currentDatasets[idx].data[pid] = retainedDataset.data[pid]
          })
          // const { data, ...otherProps } = retainedDataset
          currentDatasets[idx] = {
            data: currentDatasets[idx].data,
            ...currentDatasets[idx],
            ...retainedDataset.otherProps
          }
        }
      }
    }
    // finally add any new series
    newDatasets.forEach((d: object) =&gt; currentDatasets.push(d))
    const { datasets, ...rest } = data

    this.chartInstance.config.data = {
      ...this.chartInstance.config.data,
      ...rest
    }

    this.chartInstance.update()
  }

  public componentWillUnmount() {
    this.chartInstance.destroy()
  }

  public onClickEvent = (event: React.MouseEvent&lt;HTMLCanvasElement&gt;) =&gt; {
    // this.props.getDatasetAtEvent &amp;&amp;
    this.props.getDatasetAtEvent(
      this.chartInstance.getDatasetAtEvent(event),
      event
    )

    // this.props.getElementAtEvent &amp;&amp;
    this.props.getElementAtEvent(
      this.chartInstance.getElementAtEvent(event),
      event
    )

    // this.props.getElementsAtEvent &amp;&amp;
    this.props.getElementsAtEvent(
      this.chartInstance.getElementsAtEvent(event),
      event
    )

    // this.props.onElementsClick &amp;&amp;
    this.props.onElementsClick(
      this.chartInstance.getElementsAtEvent(event),
      event
    )
  }

  public render() {
    const className = ClassNames('chart', this.props.className)

    // bar.update()
    return (
      &lt;div className={className}&gt;
        &lt;canvas
          id=""chart-instance""
          width={this.props.width ? this.props.width : '400'}
          height={this.props.height ? this.props.height : '400'}
          onClick={this.onClickEvent}
        /&gt;
      &lt;/div&gt;
    )
  }

  public renderChart() {
    const { options, type, data } = this.props
    const node = document.getElementById('chart-instance') as HTMLCanvasElement
    // const data = this.memoizeDataProps()

    this.chartInstance = new ChartJS(node, {
      type,
      data,
      options
    })
  }
}
</code></pre>

<p>can someone help me figure out why this won't work properly?</p>
","the error is telling you what the problem is. Whatever you're calling ```length``` on doesn't exist. Can you post the test that is failing? Does the component render even though that test is failing?"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","you want to run it when the data is not undfiend and only once. so once the data is loaded set a flag to true saying the data is loaded, see below answer"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","@TimCodes:`potentialComReturn` and `potentialBrandReturn` I tried that update by giving if condition oon potentialComReturn in `componentDidUpdate`   but t didn't work"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","what value is undefined in componentDidMount function?"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","Any time your state or props change componentDidUpdate is ran, which is causing the function to run multiple times"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","need a flag to see if the data has been rendered yet"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","@TimCodes: have updated the code"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","what does your if statement look like ?"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","I didn't get you.. I have given condition undefined right?"
"45965712","d3 is running in multiple times in react","9","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","Just use the 'constructor' for initializing your data"
"45986869","scroll to bottom/row on react-virtualized with autosizer and cellmeasurer","1","<p>I am building a chat app and using react-virtualized to manage display / infinite load (through a custom method, not the HOC) of chat messages. I am using Autosizer to fill the container div, and cellmeasurer to calculate row heights. Everything is working great except when I attempt to scroll down to the last/newest message at the bottom of the list, it takes me allllmost there. Typically the next to bottom row is visible and I need to scroll down just a bit more to see the actual bottom row.</p>

<p>Here are relevant snippets:</p>

<p>Render Method:</p>

<pre><code>render() {
    const hasNextPage = this.props.contact ? this.props.contact.messages.length &lt; this.props.contact.totalMessageCount : false
    // const totalMessageCount = this.props.contact ? this.props.contact.totalMessageCount : 0
    const contactMessages = this.props.contact ? sortBy(this.props.contact.messages, ""created_at"") : []
    const rowCount = contactMessages.length // hasNextPage ? contactMessages.length + 1 : contactMessages.length

    // auto resizer copy-spiration
    // https://github.com/bvaughn/tweets/blob/37d0139736346db16b9681d5b859a4e127964518/src/components/TweetList.js#L126-L132
    const _rowRenderer = ({ index, key, parent, style }) =&gt; {
      let content;
      if (index === 0 &amp;&amp; hasNextPage) {
        content = 'Loading...'
      } else {
        content = &lt;ChatMessage message={contactMessages[index]} /&gt;
      }

      return (
        &lt;CellMeasurer
          cache={this._cache}
          columnIndex={0}
          key={key}
          parent={parent}
          rowIndex={index}
          width={this._mostRecentWidth}
        &gt;
          &lt;div
            key={key}
            style={style}
          &gt;
            {content}
          &lt;/div&gt;
        &lt;/CellMeasurer&gt;
      );
    };

    return (
      &lt;div style={{ height: '65vh' }}&gt;
        &lt;AutoSizer&gt;
          {({ height, width }) =&gt; (
            &lt;List
              deferredMeasurementCache={this._cache}
              // eslint-disable-next-line no-return-assign
              ref={ref =&gt; this.chatWindow = ref}
              onRowsRendered={(renderData) =&gt; this.handleRowsRendered(renderData, hasNextPage, rowCount)}
              rowRenderer={_rowRenderer}
              height={height}
              width={width}
              rowHeight={this._cache.rowHeight}
              rowCount={rowCount}
            /&gt;
          )}
        &lt;/AutoSizer&gt;

      &lt;/div&gt;
    )
  }
</code></pre>

<p>And my call to scroll on componentDidUpdate:</p>

<pre><code>componentDidUpdate() {
    if (this.chatWindow &amp;&amp; !this.state.initialized &amp;&amp; this.props.contact) {
      // this.chatWindow.recomputeRowHeights(this.props.contact.messages.length - 10)
      this.chatWindow.scrollToRow(this.props.contact.messages.length || 0)
    }
  }
</code></pre>

<p>Any ideas how I can achieve that list little amount of scroll to make the bottom message visible?</p>
","Can you put this in a CodeSandbox or something somewhere I can take a look at it in its entirety? (Preferable something I can just run in the browser, no checkout step required.)"
"46135198","How to call nested react function","2","<p><strong>Objective:</strong> When my Game component receives a prop I want <code>componentDidUpdate()</code> to call a function called <code>consolelog</code> which is a child of another function called <code>gamecode()</code>. </p>

<p><strong>Problem:</strong> using <code>this.gameCode.consolelog()</code> always returns an error saying that <code>consolelog</code> is not a function of <code>gameCode</code>.</p>

<p><strong>Note:</strong> <code>Gamecode()</code> is imported into my react component (Game) from a file called <code>gamecode.js</code></p>

<p><strong>Component:</strong></p>

<pre><code>import React, {Component} from 'react';

import {gameCode, showLeaderboard} from '../utility/gamecode';

class Game extends Component{
  constructor(props){
    super();
    this.state = {
      drawL : null
    }
  };

  componentDidMount(){
    this.gameCode();
  };

  componentDidUpdate(){
    //will run when the state changes
    if(this.props.leaderboard){
        var a = this.props.leaderboard;
        this.gameCode.consolelog(a);
    }
  }   

  render(){
    return(
      &lt;div className=""Game""&gt;
        &lt;canvas id=""canvas""&gt;&lt;/canvas&gt;
        &lt;button onClick={this.props.getleaderboard} className=""showleaders""&gt;Show leaderboard&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Game;
</code></pre>

<p><strong>GameCode.js function:</strong></p>

<pre><code>gameCode(){
  //the main function initializes some stuff immediately and start running the update() and draw() functions
  const canvas = document.getElementById('canvas');
  canvas.width = 800;
  canvas.height= 600;
  const ctx = canvas.getContext(""2d"");
  const FPS = 30;
  setInterval(() =&gt; {
      update();
      draw();
  }, 1000/FPS);

  //but sometimes I need to call other functions on demand, but these functions depend on what the parent function and other sibling functions
  function consolelog(a){
    console.log(""success!"");
    console.log(a);
  }
}
</code></pre>
","Why ""a child of another function""? Why can't you just export `consolelog` as its own function, and import it into your module?"
"46135198","How to call nested react function","2","<p><strong>Objective:</strong> When my Game component receives a prop I want <code>componentDidUpdate()</code> to call a function called <code>consolelog</code> which is a child of another function called <code>gamecode()</code>. </p>

<p><strong>Problem:</strong> using <code>this.gameCode.consolelog()</code> always returns an error saying that <code>consolelog</code> is not a function of <code>gameCode</code>.</p>

<p><strong>Note:</strong> <code>Gamecode()</code> is imported into my react component (Game) from a file called <code>gamecode.js</code></p>

<p><strong>Component:</strong></p>

<pre><code>import React, {Component} from 'react';

import {gameCode, showLeaderboard} from '../utility/gamecode';

class Game extends Component{
  constructor(props){
    super();
    this.state = {
      drawL : null
    }
  };

  componentDidMount(){
    this.gameCode();
  };

  componentDidUpdate(){
    //will run when the state changes
    if(this.props.leaderboard){
        var a = this.props.leaderboard;
        this.gameCode.consolelog(a);
    }
  }   

  render(){
    return(
      &lt;div className=""Game""&gt;
        &lt;canvas id=""canvas""&gt;&lt;/canvas&gt;
        &lt;button onClick={this.props.getleaderboard} className=""showleaders""&gt;Show leaderboard&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Game;
</code></pre>

<p><strong>GameCode.js function:</strong></p>

<pre><code>gameCode(){
  //the main function initializes some stuff immediately and start running the update() and draw() functions
  const canvas = document.getElementById('canvas');
  canvas.width = 800;
  canvas.height= 600;
  const ctx = canvas.getContext(""2d"");
  const FPS = 30;
  setInterval(() =&gt; {
      update();
      draw();
  }, 1000/FPS);

  //but sometimes I need to call other functions on demand, but these functions depend on what the parent function and other sibling functions
  function consolelog(a){
    console.log(""success!"");
    console.log(a);
  }
}
</code></pre>
","The reason I don't want to do that is because I have other subfunctions that rely on variables/functions that are scoped to `GameCode()`.

This is a canvas html game and so I have subfunctions called `update` and `draw` that draw to the canvas and I don't want multiple functions drawing to it."
"46146824","""this"" undefined in exported react function","0","<p><strong>Problem:</strong> When the exported function is called by my React component, <code>console.log(this)</code> displays undefined. I was expecting it to return the component since I have bound it in my constructor.</p>

<p><strong>Leaderboard.js:</strong></p>

<pre><code>import React from 'react';
import {leaderboard, createLeaderboard} from '../utility/gamecode';

class Leaderboard extends React.Component{
  constructor(props){
    super(props);
    this.showLeaderboard = showLeaderboard.bind(this);
    this.state = {
    }
  };

  componentDidUpdate(){
    if(this.props.leaderboard){
      showLeaderboard();
    }
  }

  render(){
    return(
      &lt;div className=""leaderboard hidden""&gt;
      &lt;/div&gt;
    )
  }

}

export default Leaderboard;
</code></pre>

<p><strong>gamecode.js:</strong></p>

<pre><code>export function showLeaderboard(){
 console.log(this);
}
//-----------------------
export function createLeaderboard(props){
}
</code></pre>
",""
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","@bennygenel `response.data` is array of json objects"
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","You can't just compare 2 object arrays with equality operators. Check [this answer](https://stackoverflow.com/a/27212/2315280) on how to do it  and please check [shouldComponentUpdate](https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate) event of React"
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","Whats the response data? is it a string?"
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","@bennygenel axios doesn't directly do `setState()` instead it calls `setData()` which checks for equality before executing `setState()`"
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","You are calling `this.setData(response.data);` in axios success callback, that has setState"
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","@ShubhamKhatri where is `setState()` inside axios?? axios is calling `setData()` which checks equality before executing `setState()`"
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","@ShubhamKhatri setData() also have `if(this.state.data != data.data)` condition. See the commented portions those value's are equal. Then also it is getting executed."
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","You are setting state this causes axios call and that sets state and that causes component to update and that sets state and that causes update and that sets state and that causes update and that sets state and that causes update and that sets state and that causes update and that sets state and that causes update and that sets state and that causes update and that sets state...."
"46195559","Why does componentDidUpdate() create an infinite loop?","9","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","Why do you have a axios request in the componentDidUpdate, that axios request will be executed on every render and further because it does a setState it goes on loop"
"46600990","React Mobx componentDidUpdate is not updating when observable changes","2","<p>I'm new to Mobx and reactjs in general, I have knowledge in Redux and react native, and in Redux when I used to call an action and the props get updated, the <code>componentDidUpdate</code> life cycle method is triggered.</p>

<p>The scenario I'm having now is login. so the user fills the form, clicks submit, and the submit calls a Mobx action (asynchronous), and when the server responds, an observable is updated, and then it navigates to a main page (navigation happens in the component).</p>

<p>Here is my store code.</p>

<pre><code>import { autorun, observable, action, runInAction, computed, useStrict } from 'mobx';

useStrict(true);

class LoginStore {
    @observable authenticated = false;
    @observable token = '';

    @computed get isAuthenticated() { return this.authenticated; }


    @action login = async (credentials) =&gt; {
        const res = await window.swaggerClient.Auth.login(credentials)l
        // checking response for erros
        runInAction(() =&gt; {
            this.token = res.obj.token;
            this.authenticated = true;
        });
    }
}

const store = new LoginStore();

export default store;

export { LoginStore };
</code></pre>

<p>and this handler is in my component.</p>

<pre><code>handleSubmit = (e) =&gt; {
        e.preventDefault();

        this.props.form.validateFields((err, values) =&gt; {
            if (!err) {
                this.props.store.login(values);
            }
        });
    }

    componentDidUpdate() {
        if (this.props.store.isAuthenticated) {
            const cookies = new Cookies();
            cookies.set('_cookie_name', this.props.store.token);
            this.props.history.push('main');
        }
    }
</code></pre>

<p>It's not the ideal code, I'm just experimenting, but I'm not quite getting it.</p>

<p>Also, if I use the computed value <code>(isAuthenticated)</code> in the <code>render</code> life cycle method, the <code>componentDidUpdate</code> is triggered, but if I didn't use it in the <code>render</code> method, the <code>componentDidUpdate</code> is not triggered.
For example, if I do this</p>

<pre><code>render() {
  if (this.props.store.isAuthenticated) return null
  // .... rest of the code here
}
</code></pre>

<p>the above will trigger the componentDidUpdate.</p>

<p>Am I missing something? is there a better way to do it with Mobx?
Thanks</p>
","@Tholle yeah definitely the logic should be separated from the view, I'm just experimenting with mobx, and I wanted to know about this case specifically. 
Thanks for the suggestion :)"
"46600990","React Mobx componentDidUpdate is not updating when observable changes","2","<p>I'm new to Mobx and reactjs in general, I have knowledge in Redux and react native, and in Redux when I used to call an action and the props get updated, the <code>componentDidUpdate</code> life cycle method is triggered.</p>

<p>The scenario I'm having now is login. so the user fills the form, clicks submit, and the submit calls a Mobx action (asynchronous), and when the server responds, an observable is updated, and then it navigates to a main page (navigation happens in the component).</p>

<p>Here is my store code.</p>

<pre><code>import { autorun, observable, action, runInAction, computed, useStrict } from 'mobx';

useStrict(true);

class LoginStore {
    @observable authenticated = false;
    @observable token = '';

    @computed get isAuthenticated() { return this.authenticated; }


    @action login = async (credentials) =&gt; {
        const res = await window.swaggerClient.Auth.login(credentials)l
        // checking response for erros
        runInAction(() =&gt; {
            this.token = res.obj.token;
            this.authenticated = true;
        });
    }
}

const store = new LoginStore();

export default store;

export { LoginStore };
</code></pre>

<p>and this handler is in my component.</p>

<pre><code>handleSubmit = (e) =&gt; {
        e.preventDefault();

        this.props.form.validateFields((err, values) =&gt; {
            if (!err) {
                this.props.store.login(values);
            }
        });
    }

    componentDidUpdate() {
        if (this.props.store.isAuthenticated) {
            const cookies = new Cookies();
            cookies.set('_cookie_name', this.props.store.token);
            this.props.history.push('main');
        }
    }
</code></pre>

<p>It's not the ideal code, I'm just experimenting, but I'm not quite getting it.</p>

<p>Also, if I use the computed value <code>(isAuthenticated)</code> in the <code>render</code> life cycle method, the <code>componentDidUpdate</code> is triggered, but if I didn't use it in the <code>render</code> method, the <code>componentDidUpdate</code> is not triggered.
For example, if I do this</p>

<pre><code>render() {
  if (this.props.store.isAuthenticated) return null
  // .... rest of the code here
}
</code></pre>

<p>the above will trigger the componentDidUpdate.</p>

<p>Am I missing something? is there a better way to do it with Mobx?
Thanks</p>
","An observer React Component will re-render when the observables that got de-referenced in the last render are changed. Maybe it would be better to put this logic separated from the view?"
"46629977","Add google trends in react","0","<p>How do you add components such as charts in google trends in reactjs?</p>

<pre><code>componentDidUpdate() {
    const that = this
    const keyword = ""your keyword""

    conts script = document.createElement(""script"")
    script.src = ""https://ssl.gstatic.com/trends_nrtr/760_RC08/embed_loader.js""
    script.async = true

    ReactDOM.findDOMNode(this.refs.trendsWrapper1).appendChild(script)

    script.onload = function () {
       trends.embed.renderExploreWidgetTo(ReactDOM.findDOMNode(that.refs.trendsWrapper1), ""TIMESERIES"", {""comparisonItem"":[{""keyword"":keyword,""geo"":"""",""time"":""today 5-y""}],""category"":0,""property"":""""}, {""exploreQuery"":""q=%2Fm%2F0rfgxy2"",""guestPath"":""https://www.google.co.uk:443/trends/embed/""})
    }

}
</code></pre>

<p>I tried this and didn't work. Please try to suggest a much easier method than this as well.</p>
",""
"46722599","Print the filter data by data and interviewer in table using reactjs?","0","<p>I am creating interview form using <code>reactjs</code>, in which I am using the route to accessing different links. I am using <code>firebase</code> for storing the data.</p>

<p><a href=""https://i.stack.imgur.com/LxCga.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LxCga.png"" alt=""enter image description here""></a></p>

<pre class=""lang-js prettyprint-override""><code> class Contact extends React.Component {
          constructor() {
            super();
            this.state = {
              arr: [],
              records:[],
              Address:'',
              printabledata:[],
              singledata:{},
              date:'',
              iround:''

            };
            self = this;
              this.printAllRecord = this.printAllRecord.bind(this);
              this.filterByInterviewer = this.filterByInterviewer.bind(this);
              this.filterByDate = this.filterByDate.bind(this);
              this.handleChangedate = this.handleChangedate.bind(this);
              this.handleChangeiround = this.handleChangeiround.bind(this);
                      }
                       handleChangedate(event) {
                          this.setState({date: event.target.value.toUpperCase()});
                        }
                         handleChangeiround(event) {
                          this.setState({iround: event.target.value});
                        }


          componentWillMount() {  
          var formdata2 = firebase.database().ref(""vishal-aaede/"");
            formdata2.on(""value"", function (snap) {
                data = snap.val();
                self.setState({arr: data});
            });
          }

          componentDidUpdate(){
            var data=this.state.arr,
              headerArray=[];
              for (var key in data){
                headerArray.push(key);
              }console.log(headerArray);


           headerArray.forEach(function(val){
            self.printAllRecord(data[val]);
            self.state.records.push(data[val]);
              console.log(data[val].Address);
           });
           self.state.singledata=data[headerArray[0]];       
          }
          printAllRecord(param,index) {         
            self.state.printabledata.push(&lt;tr&gt;
              &lt;td&gt;{param.Name}&lt;/td&gt;
              &lt;td&gt;{param.Round}&lt;/td&gt;
              &lt;td&gt;{param.Email}&lt;/td&gt;
              &lt;td&gt;{param.Date}&lt;/td&gt;
              &lt;td&gt;{param.Phone}&lt;/td&gt;
              &lt;td&gt;{param.Address}&lt;/td&gt;
              &lt;td&gt;{param.Gender}&lt;/td&gt;
              &lt;td&gt;{param.Fresh}&lt;/td&gt;
              &lt;td&gt;{param.time}&lt;/td&gt;
            &lt;/tr&gt;);     
          }
        filterByInterviewer(){
           self.state.records.forEach(function(val){
           if(val.Round==self.state.iround){
             self.printAllRecord(val);
             console.log(val.Round+"" - ""+val.Name);
           }
         });
        }
        filterByDate(){
         self.state.records.forEach(function(val){
           if(val.Date==self.state.date){
             self.printAllRecord(val);
             console.log(val.Date+"" - ""+val.Name);
           }
         });
        }
           render() {
               return (
                 &lt;div&gt;
                   &lt;h2&gt;Candidate RECORD !!!!&lt;/h2&gt;
                   &lt;div&gt;
                      &lt;div&gt;
                        &lt;div className = ""container""&gt;
                          &lt;form classNameName = ""form-horizontal"" name = ""record_form"" id = ""record_form""&gt;            
                            &lt;div className = ""form-group row""&gt;
                              &lt;label className = ""control-label col-lg-4"" htmlFor = ""filterdatetxt""&gt;Date:&lt;/label&gt;
                              &lt;div className = ""col-lg-5""&gt;
                              &lt;input type = ""date"" className = ""form-control"" ref = ""filterdatetxt"" name = ""filterdatetxt"" id = ""filterdatetxt"" placeholder = ""Enter Date"" onChange={this.handleChangedate} /&gt;
                              &lt;/div&gt;
                             &lt;div className = ""col-lg-3""&gt;
                              &lt;button name = ""filter_date_btn"" id = ""filter_date_btn"" type = ""button"" className = ""btn btn-danger"" onClick={this.filterByDate}&gt;Filter By Date&lt;/button&gt;
                             &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className = ""form-group row""&gt;
                              &lt;label className = ""control-label col-lg-4"" htmlFor = ""interview_round""&gt;Feedback By Interviewer:&lt;/label&gt;
                              &lt;div className = ""col-lg-5""&gt;
                              &lt;select className = ""form-control"" ref = ""interview_round"" onChange={this.handleChangeiround} id = ""interview_round"" name = ""interview_round""  &gt;
                                &lt;option value = ""1""&gt;Select Round&lt;/option&gt;
                                     &lt;option value = ""HR""&gt;HR&lt;/option&gt;
                                     &lt;option value = ""TR""&gt;Technical Round&lt;/option&gt;
                                     &lt;option value = ""FR""&gt;Final Round&lt;/option&gt;
                              &lt;/select&gt;
                              &lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;
                              &lt;button name = ""filter_date_btn"" id = ""filter_date_btn"" type = ""button"" className = ""btn btn-danger""  onClick={this.filterByInterviewer} &gt;Filter By Interviewer&lt;/button&gt;
                            &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className = ""row""&gt;
                            &lt;div className = ""col-lg-3""&gt;&lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;

                            &lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;
                            &lt;Link to=""/contact""&gt;
                              &lt;button name = ""view_all_btn"" id = ""view_all_btn"" type = ""button"" className = ""btn btn-danger""  &gt;View All Record&lt;/button&gt;
                              &lt;/Link&gt;
                            &lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;
                               &lt;IndexLink to=""/"" activeClassName=""active""&gt;
                              &lt;button name = ""back_btn"" id = ""back_btn"" type = ""button"" className = ""btn btn-danger"" &gt;Go Back&lt;/button&gt;
                              &lt;/IndexLink&gt;
                            &lt;/div&gt;
                            &lt;/div&gt;
                          &lt;/form&gt;
                          &lt;div className=""blank_div""&gt;&lt;/div&gt;
                        &lt;/div&gt;        
                      &lt;/div&gt;
                      &lt;div className=""row""&gt; 

                        &lt;div className=""col-sm-12""&gt;
                          &lt;div className = ""container-fluid table-responsive""&gt;            
                            &lt;table className = ""table table-bordered""&gt;
                              &lt;thead&gt;
                                &lt;tr&gt;
                                 &lt;th&gt;Name&lt;/th&gt;
                                 &lt;th&gt;Interview Round&lt;/th&gt;
                                 &lt;th&gt;Email&lt;/th&gt;
                                 &lt;th&gt;Date&lt;/th&gt;
                                 &lt;th&gt;Phone Number&lt;/th&gt;
                                 &lt;th&gt;Address&lt;/th&gt;
                                 &lt;th&gt;Gender&lt;/th&gt;  
                                 &lt;th&gt;Experience&lt;/th&gt;
                                 &lt;th&gt;Time&lt;/th&gt;
                               &lt;/tr&gt;
                              &lt;/thead&gt;
                             &lt;tbody&gt;
                              {this.state.printabledata}
                             &lt;/tbody&gt;
                          &lt;/table&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;

                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
               )
             }
            }
</code></pre>

<p>Here is the image in which you can see the users data. When users fill the interview form and submit the data that data go to firebase I fetch that data in the table.</p>

<p>So here 2 filter buttons. The main issue is that when I click on the date that time data filter and print all data on that date. Same for interviewer round.</p>

<p>I do all thing and all filter data are so on console but I want it to on my table</p>
",""
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","@BrunnoVodolaMartins any thoughts on how can i add the css"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","Awesome! I'll add that as an answer."
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","yep adding .default fixed it thanks @MattHolland"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","@user2359997 i don't think that the missing CSS files are the issue here. That would only make your components look unstyled. Could you please post the entire code of the component that sorrounds your `VirtualizedSelect`?"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","@BrunnoVodolaMartins added more code"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","@Onyekachi added more code"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","Usually that happens when you forget to export some component you've created. Have you checked that already? Also, if you could provide a little but more of code that would help."
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","Try `var VirtualizedSelect = require('react-virtualized-select').default;`"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","@BrunnoVodolaMartins thanks for the response ! as per the sample code in Git we need to import css like i mentioned which i didn't do ...do u think that's causing the issue ?"
"47104177","Error while using react-virtualized-select","10","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","can I see how you used the element in your component. Show more code"
"47213527","react-virtualized: Drop down is unresponsive suddenly with no error code in the console","0","<p>I'm trying to use React Virtualized Select <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> for drop down and my react component code is here We are not able to select the option from drop down</p>

<p>this is before selecting the option 
<a href=""https://i.stack.imgur.com/KvPqD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KvPqD.png"" alt=""enter image description here""></a></p>

<p>this is after selecting the option 
<a href=""https://i.stack.imgur.com/ZIMG8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZIMG8.png"" alt=""enter image description here""></a></p>

<p>please find my react component code below</p>

<pre><code>var React = require('react');
var ReactDOM = require('react-dom');
var SearchActions = require('../actions/SearchActions');
var AppStore = require('../stores/AppStore');
var AppActions = require('../actions/AppActions');
var Utils = require('../utils/Utils');
var SearchAccountSelector = require('./SearchAccountSelector');
var queryString = require('query-string');
var SearchHint = require('./SearchHint');
var VirtualizedSelect = require('react-virtualized-select').default;
module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: [],
            selectedPartner: null

        };
    },

    componentDidMount () {
        let self = this;
        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
        var qS = queryString.parse(location.search);
        AppActions.getPartnersAllowed();
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

    },
    componentDidUpdate: function () {
        let self = this;
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

    [AppStore.events.onSecurityCheck] () {
        console.log('onSecurityCheck', arguments);
        this.setState(function (prev, cur) {
            var st = {
                authenticated: AppStore.authenticated
            };
            if (!AppStore.authenticated) {
                st.async = false;
            }
            return st;
        });
    },

    [AppStore.events.onAccountSearch] (data) {

        var accountsNum = data.errorMessage ? 0 : this.numberOfAccountsFound(data);
        var state = {
            async: false,
            data: data.errorMessage ? {} : data,
            showAccountSelection: false,
            selected: null,
            error: null
        };
        console.log('[' + accountsNum + '] accounts found when search completed', data);

        if (accountsNum == 0) {
            state.error = data.errorMessage ? data.errorMessage : 'No accounts found';

        } else if (accountsNum == 1) {
            // if there is single account found selecting it and closing search panel
            state.selected = this.getFirstKey(data);
            state.visible = false;
            AppActions.selectAccount(state.selected);// auto select account if there is no ambiguites
            SearchActions.cDVR({query: state.selected});
        } else {
            // if multiple account found lets user select a correct one
            state.showAccountSelection = true;

        }

        this.setState(state);
    },

    [AppStore.events.onSelectAccount]() {
        if (AppStore.isValidUserProfile()) {
            this.setState({
                visible: false
            });
        }
    },

    [AppStore.events.onLogin]() {
        //Handling properly case when session is timed out so user will return to previos screen
        if (!this.state.selected) {
            this.setState({
                visible: true
            });
        }
    },

    [AppStore.events.onLogout](event) {
        if(!event || !event.byTimeout){
            this.setState({   data: null,
                showAccountSelection: false,
                selected: null,
                search: ''
            });
        }
    },
    [AppStore.events.onResized](windowSize){
        this.setState({width: windowSize.innerWidth, height: innerHeight})
    },


    numberOfAccountsFound(data) {
        var size = 0, key;
        if (!data) {
            return size;
        }
        for (key in data) {
            if (data.hasOwnProperty(key)) size++;
        }
        return size;
    },

    getFirstKey(data){
        for (let key in data) {
            if (data.hasOwnProperty(key)) return key;
        }
    },

    handleClick(event) {
        event.preventDefault();
        this.refs.searchHint.removePopover();
        console.log('clicked event', event);
        this.setState({
                data: null,
                async: true,
                error: null
            }
        );
        var query = this.refs.inputSearch.value.trim();
        this.setState({search: query});
        if (query &amp;&amp; this.state.selectedPartner) {
            //extract receiver Id from Recording Id, by extracting string between V&amp;L or A&amp;L
            let selectedPartner = this.state.selectedPartner;
            AppActions.resetFieldsForNewSearch();
            var receiverIdPattern = new RegExp('(V|A)(.*?)L');
            var parsedReceiverId = receiverIdPattern.exec(query);
            if (parsedReceiverId != null &amp;&amp; parsedReceiverId[2] != null) {
                let receiverId = parsedReceiverId[2];
                AppActions.setSearchQuery(query);
                //use receiverId to perform search
                query = receiverId;
            } else {
                AppActions.clearRecIdSearch();
            }
            SearchActions.cDVR({query: query});
            AppStore.selectedPartner = selectedPartner.value;
            SearchActions.search({query: query, selectedPartner: selectedPartner.value});
            Utils.updateQueryString('search', query);
        } else {
            this.setState({async: false, error: 'Invalid Input'});
        }
    },

    openNav(){
        this.setState({visible: true});
        AppActions.hideBodyScrollBar();
    },
    closeNav(){
        this.refs.searchHint.refs.popover.close();
        this.setState({visible: false});
        AppActions.showBodyScrollBar();
    },

    searchIcon(){
        if (this.state.authenticated) {
            return (&lt;span id=""search"" onClick={this.openNav}&gt;&lt;i className=""fa fa-search search-icon pointer"" style={{fontSize: '1.4em'}}/&gt;&lt;/span&gt;);
        }
    },

    setPartnerList(partnerList) {
        let partnerOptionsList = this.getOptions(partnerList);
        this.setState({optionPartnerList : partnerOptionsList})

    },

    getOptions(partnerList) {
        let options = partnerList.map( x =&gt; ({value :x,label: x}));
        return options;
    },

    errorRender() {
        let style = this.state.error ? {visibility: 'visible'} : {visibility: 'hidden'};
        return (
            &lt;div style={style} className=""alert alert-danger"" role=""alert""&gt;
                &lt;i className=""fa fa-exclamation-triangle""&gt;&lt;/i&gt; {this.state.error}
            &lt;/div&gt;);
    },

    toggleOverlayStyle(state){
        this.setState({overlayOverflowY : state});
    },
    [AppStore.events.onResized](windowSize) {
        let state = AppStore.innerHeight &lt; 900 &amp;&amp; this.refs.searchHint &amp;&amp; this.refs.searchHint.state.showSearchHint ? 'auto' : 'hidden';
        this.toggleOverlayStyle(state);
    },
    [AppStore.events.onPartnersAllowedUpdated](partnerList) {
        this.setPartnerList(partnerList);
    },

    render: function () {
        var self= this;


        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (
            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                        &lt;VirtualizedSelect
                            placeholder=""Select Partner""
                            options={self.state.optionPartnerList}
                            onChange={(selectValue) =&gt; this.setState({selectedPartner: selectValue})}
                            value={this.state.selectedPartner}
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
});
</code></pre>

<p>Except for the highlighted part i don't know what the issue is whether css or js 
<a href=""https://i.stack.imgur.com/CtSor.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CtSor.png"" alt=""enter image description here""></a></p>
",""
"47382591","Using mobx store only outside of the react components render function","0","<p>I have a react component that wraps a class that renders WebGL using three.js with the DOM and connects mobx store value and it changes with the class lifecycle methods.</p>

<p>The passed in mobx store is only used outside of the components render function in lifecycle functions <em>(componentDidMount,  componentDidUpdate, ..)</em>. Noticed that when the store changes, the component doesn't trigger a rerender. But I make a useless read within the render functions, such as in the example below passing a <code>triggerRerenderListenerProp={this.props.store.debugSettings.showStats}</code> prop to the div, the component becomes active only to <code>store.debugSettings.showStats</code> changes.</p>

<p><strong>Is there a way of making the component listen to store changes wihtout using the store itself in the render function?</strong></p>

<pre><code>import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {observer} from 'mobx-react';

import MapPreview from 'classes/MapPreview';

import style from './Preview.css';

class Preview extends Component {
  static propTypes = {
    store: PropTypes.object.isRequired,
    imageUrl: PropTypes.string.isRequired
  };

  constructor (props) {
    super(props);

    this.containerEl = null;
  }

  componentDidMount () {
    const options = {
      debugSettings: this.props.store.debugSettings,
      previewSettings: this.props.store.previewSettings
    };

    this.preview = new MapPreview(this.containerEl, options);
    this.preview.setImage(imageUrl);
  }

  componentDidUpdate () {
    this.preview.updateOptions({
      debugSettings: this.props.store.debugSettings,
      previewSettings: this.props.store.previewSettings
    });
  }

  render () {
    return (
      &lt;div
        className={style.normal}
        ref={(el) =&gt; { this.containerEl = el; }}
        triggerRerenderListenerProp={this.props.store.debugSettings.showStats}
      /&gt;
    );
  }
}

export default observer(Preview);
</code></pre>
",""
"47471200","Error 'ref is not a prop' when using ref on a div inside of a react component","6","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","Thats weird, I can't reproduce the issue with the same code running on 16.0.0"
"47471200","Error 'ref is not a prop' when using ref on a div inside of a react component","6","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","Which version of react are you running?"
"47471200","Error 'ref is not a prop' when using ref on a div inside of a react component","6","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","version :16.0.0"
"47471200","Error 'ref is not a prop' when using ref on a div inside of a react component","6","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","I  did look at this and it didn't help. if I use a string as a ref and then reference it by this.refs.string it still gives me the same error. I thought by using the callback you can just access it by by using the this keyword and the name you chose for the property you add to the class."
"47471200","Error 'ref is not a prop' when using ref on a div inside of a react component","6","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","Checked https://stackoverflow.com/questions/38089895/react-ref-is-not-a-prop ?"
"47471200","Error 'ref is not a prop' when using ref on a div inside of a react component","6","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","did you copy and paste the code?"
"47980540","React app, componentDidUpdate - jumping list, infinite loop","0","<p>I have react aplication. I would like to switch between id in url. Every click in the tab should show different kind of product list. I used from method componentDidUpdate. The problem is, when I click in the next tab, the list is jumping from previous list to the present list several times. I have read that it might be a problem with using setState in method componentDidUpdate and it can cause a infinite loop. I've tried something different things to do, but I have no idea, what I should change in my code. 
Could you have any idea, how to fix this jumping thing?</p>

<pre><code>  constructor(props) {
    super(props);
    this.state = {
      food: []
    };
    var ingredient_type = this.props.params.id;

    fetch('/food/type/'+ingredient_type)
      .then(res =&gt; res.json())
      .then(food=&gt; this.setState({food}));
  }


   componentDidUpdate(){
   var ingredient_type = this.props.params.id;

    return fetch('/food/type/'+ingredient_type)
      .then(res =&gt; res.json())
      .then(food=&gt; this.setState({food}));
  }



    render() { 
      let product_list = this.state.food.map((product, id) =&gt; &lt;div className=""row"" key={id}&gt; 
                                  &lt;p  className=""cal_list col-lg-4 col-md-4 col-sm-4"" &gt;{product.name}&lt;/p&gt; 
                                  &lt;p  className=""cal_list1 col-lg-2 col-md-2 col-sm-2"" &gt;{product.calories}&lt;/p&gt; 
                                  &lt;p  className=""cal_list2 col-lg-2 col-md-2 col-sm-2"" &gt;{product.protein}&lt;/p&gt; 
                                  &lt;p  className=""cal_list3 col-lg-2 col-md-2 col-sm-2"" &gt;{product.fat}&lt;/p&gt;
                                  &lt;p  className=""cal_list4 col-lg-2 col-md-2 col-sm-2"" &gt;{product.carb}&lt;/p&gt; &lt;/div&gt;)
</code></pre>
",""
"48023263","How do I pass a prop into a react-router Route?","0","<p>I'm trying to learn react router (v4) in depth by building a simple app with firebase, what i am doing is when a user login with google using firebase they will be redirected to another component and when they go to the root path again '/' they will no longer see the login ( i am doing this by redirecting based on state )</p>

<p>I have two problems</p>

<p>My first problem is on successful authentication the user will be redirected to the /dashboard as expected but if i go back or type the root path again the login page will be shown briefly and then redirect.. i think because my method is not fast enough which is the <code>componentWillMount();</code></p>

<p>My second problem is i want to pass in some props to the dashboard but i don't know how, i've been looking and searching in the internet but i have no idea how to implement it... </p>

<p>this is my login.js, i want to pass the currentUser to dashboard and also when user goes back to the login path and if they are logged in i want to redirect them fast enough without showing the login page...</p>

<pre><code>  state = {
        currentUser: null,
        successLogin: false
    }

    googleAuth = () =&gt; {
        auth.signInWithPopup(provider).then(response =&gt; {
            const token = response.credential.accessToken;
            const currentUser = response.user;
        }).catch(error =&gt; {
            console.log(error.code , 'occured');
        })
    }

    // firebase.auth().signInWithPopup(provider).then(function(result) {
    //   var token = result.credential.accessToken;
    //   var user = result.user;
    // }).catch(function(error) {
    //   var errorCode = error.code;
    //   var errorMessage = error.message;
    //   var email = error.email;
    //   var credential = error.credential;
    // });

    componentDidMount() {
        auth.onAuthStateChanged(user =&gt; {
            if(user) {
                console.log('a user was successfuly logged in')
                this.setState({
                    currentUser: user.displayName,
                    successLogin: true
                })
            } else {
                console.log('eerror')
            }
        })
    }

    componentDidUpdate() {
        if(this.state.successLogin){
            this.props.history.replace(""/dashboard"");
        } else {
            console.log('not a successful login');
        }
    }

    componentWillMount() {
        if(this.state.successLogin){
            &lt;Redirect to=""/dashboard""/&gt;
        }
    }
</code></pre>

<p>here is my dashboard im creating new state for the user since i don't know how to get the currentUser state from the login...</p>

<pre><code> state = {
        user: null
    }

    componentDidMount(){
       auth.onAuthStateChanged(user =&gt; {
            this.setState({
                user: user.displayName
            })
       })
    }
    render(){
        const { user } = this.state;
        return (
            &lt;h1&gt; DashBoard {user}&lt;/h1&gt;
            )
    }
}
</code></pre>

<p>this is my routes.js</p>

<pre><code>&lt;BrowserRouter&gt;
     &lt;div&gt;
          &lt;Switch&gt;
            &lt;Route path='/' exact component={Login} /&gt;
            &lt;Route path='/register' component={Register} /&gt; 
            &lt;Route path='/dashboard' component={MainDashBoard} /&gt;
          &lt;/Switch&gt;
      &lt;/div&gt;
&lt;/BrowserRouter&gt;
</code></pre>

<p>I know that i can use redux but i don't want to jump into redux yet....</p>
",""
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","@AdamKipnis I correct that, but I wrote this  wrong here.Sorry"
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","You're passing `mapDispatchToProps` in to `connect()`. It should be `mapStateToProps`."
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","@CarlosC IF you mean this ,i try know but still see  myarray ,its still empty. componentDidMount() {
       this.props.getdata();
      }"
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","Your just passing an array to the dataSource which is not what expects. It expects a ListViewDataSource. See https://facebook.github.io/react-native/docs/listview.html#datasource"
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","You should dispatch your action from componentDidMount. See https://reactjs.org/docs/react-component.html#componentwillmount."
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","@CarlosC sorry ,i forget to change it while writing here.It is myarray"
"48037387","Fetch data is empty in componentwillMount in react native redux","7","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","Where is `this.props.arr1` coming from?"
"48070546","Managing state for a loading bar in react with react-router","5","<p>I have an app in React which uses material-ui's responsive drawer component. Let's call it ResponsiveDrawer. In this component I have a state variable called ""loading"".</p>

<pre><code>class ResponsiveDrawer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            loading:false
        }
        this.setLoading = this.setLoading.bind(this);
    }
    setLoading(loading) {
        this.setState({loading:loading});
    }
    ...
</code></pre>

<p>I want to display a LinearProgress component at the top of the page, depending on the <code>loading</code> state variable.</p>

<pre><code>    ...
    render() {
        return (
            &lt;div className={classes.root}&gt;
                {this.state.loading ? &lt;LinearProgress/&gt; : """"} 
                ...
</code></pre>

<p>Inside ResponsiveDrawer I am also using react router to render some child components.</p>

<pre><code>                ...
                &lt;main className={classes.content}&gt;
                    &lt;div className={classes.contentWrapper}&gt;
                        &lt;Switch&gt;
                            &lt;Route
                                exact
                                path=""/investments""
                                component={InvestmentsComponent}
                            /&gt;
                            ...
                        &lt;/Switch&gt;
                     &lt;/div&gt;
               &lt;/main&gt;
          &lt;/div&gt;
</code></pre>

<p>Inside Investments component, I am doing a fetch from an API.
What I would like to do, is to set the loading state in the ResponsiveDrawer component to <code>true</code> and then set it back to <code>false</code> upon successful fetch.</p>

<p>So I passed the setLoading function of the ResponsiveDrawer into InvestmentsComponent as props:</p>

<pre><code> InvestmentsComponent = &lt;Investments setLoading={this.setLoading} /&gt;
</code></pre>

<p>And then tried to set it to true on <code>componentDidMount()</code></p>

<pre><code>    componentDidMount() {
        this.props.setLoading(true);
        fetchInvestments(); // sets loading to false upon completion
    }

     fetchInvestments() {
        fetch(""/api/investments"", {
            credentials: ""same-origin"",
            headers: {
                ""Cache-Control"": ""no-cache""
            }
        })
            .then(res =&gt; {
                if (!res.ok) throw Error(res.status);
                return res.json();
            })
            .then(responseJson =&gt; {
                this.props.setLoading(false);
                this.setState({ investments: responseJson });
            })
            .catch(err =&gt; {
                console.error(""Unable to fetch investments""); // show error message
            });
    }
</code></pre>

<p>However, when I do this, react goes into infinite loop - I assume that when the state of <code>loading</code> changes, it also reloads the investments component route which then sets the loading state again.</p>

<p>I end up with:</p>

<blockquote>
  <p>Maximum update depth exceeded. This can happen when a component
  repeatedly calls setState inside componentWillUpdate or
  componentDidUpdate. React limits the number of nested updates to
  prevent infinite loops.</p>
</blockquote>

<p>What could be a potential solution to this conundrum?</p>
","@Jackyef thanks, I thought about it too but that solution does not fully satisfy me. ResponsiveDrawer will eventually contain routes to many components. I suppose that managing every API call in it would quickly become a nightmare. Do you perhaps know if something like Redux could help with managing the state?"
"48070546","Managing state for a loading bar in react with react-router","5","<p>I have an app in React which uses material-ui's responsive drawer component. Let's call it ResponsiveDrawer. In this component I have a state variable called ""loading"".</p>

<pre><code>class ResponsiveDrawer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            loading:false
        }
        this.setLoading = this.setLoading.bind(this);
    }
    setLoading(loading) {
        this.setState({loading:loading});
    }
    ...
</code></pre>

<p>I want to display a LinearProgress component at the top of the page, depending on the <code>loading</code> state variable.</p>

<pre><code>    ...
    render() {
        return (
            &lt;div className={classes.root}&gt;
                {this.state.loading ? &lt;LinearProgress/&gt; : """"} 
                ...
</code></pre>

<p>Inside ResponsiveDrawer I am also using react router to render some child components.</p>

<pre><code>                ...
                &lt;main className={classes.content}&gt;
                    &lt;div className={classes.contentWrapper}&gt;
                        &lt;Switch&gt;
                            &lt;Route
                                exact
                                path=""/investments""
                                component={InvestmentsComponent}
                            /&gt;
                            ...
                        &lt;/Switch&gt;
                     &lt;/div&gt;
               &lt;/main&gt;
          &lt;/div&gt;
</code></pre>

<p>Inside Investments component, I am doing a fetch from an API.
What I would like to do, is to set the loading state in the ResponsiveDrawer component to <code>true</code> and then set it back to <code>false</code> upon successful fetch.</p>

<p>So I passed the setLoading function of the ResponsiveDrawer into InvestmentsComponent as props:</p>

<pre><code> InvestmentsComponent = &lt;Investments setLoading={this.setLoading} /&gt;
</code></pre>

<p>And then tried to set it to true on <code>componentDidMount()</code></p>

<pre><code>    componentDidMount() {
        this.props.setLoading(true);
        fetchInvestments(); // sets loading to false upon completion
    }

     fetchInvestments() {
        fetch(""/api/investments"", {
            credentials: ""same-origin"",
            headers: {
                ""Cache-Control"": ""no-cache""
            }
        })
            .then(res =&gt; {
                if (!res.ok) throw Error(res.status);
                return res.json();
            })
            .then(responseJson =&gt; {
                this.props.setLoading(false);
                this.setState({ investments: responseJson });
            })
            .catch(err =&gt; {
                console.error(""Unable to fetch investments""); // show error message
            });
    }
</code></pre>

<p>However, when I do this, react goes into infinite loop - I assume that when the state of <code>loading</code> changes, it also reloads the investments component route which then sets the loading state again.</p>

<p>I end up with:</p>

<blockquote>
  <p>Maximum update depth exceeded. This can happen when a component
  repeatedly calls setState inside componentWillUpdate or
  componentDidUpdate. React limits the number of nested updates to
  prevent infinite loops.</p>
</blockquote>

<p>What could be a potential solution to this conundrum?</p>
","Ah, I see. I think the ideal solution would be to do the fetching in the parent component, then pass the response to the `InvestmentsComponent`. This way, `InvestmentsComponent` only have the responsibility of displaying the response. The parent's component can fetch the data and set its own state accordingly."
"48070546","Managing state for a loading bar in react with react-router","5","<p>I have an app in React which uses material-ui's responsive drawer component. Let's call it ResponsiveDrawer. In this component I have a state variable called ""loading"".</p>

<pre><code>class ResponsiveDrawer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            loading:false
        }
        this.setLoading = this.setLoading.bind(this);
    }
    setLoading(loading) {
        this.setState({loading:loading});
    }
    ...
</code></pre>

<p>I want to display a LinearProgress component at the top of the page, depending on the <code>loading</code> state variable.</p>

<pre><code>    ...
    render() {
        return (
            &lt;div className={classes.root}&gt;
                {this.state.loading ? &lt;LinearProgress/&gt; : """"} 
                ...
</code></pre>

<p>Inside ResponsiveDrawer I am also using react router to render some child components.</p>

<pre><code>                ...
                &lt;main className={classes.content}&gt;
                    &lt;div className={classes.contentWrapper}&gt;
                        &lt;Switch&gt;
                            &lt;Route
                                exact
                                path=""/investments""
                                component={InvestmentsComponent}
                            /&gt;
                            ...
                        &lt;/Switch&gt;
                     &lt;/div&gt;
               &lt;/main&gt;
          &lt;/div&gt;
</code></pre>

<p>Inside Investments component, I am doing a fetch from an API.
What I would like to do, is to set the loading state in the ResponsiveDrawer component to <code>true</code> and then set it back to <code>false</code> upon successful fetch.</p>

<p>So I passed the setLoading function of the ResponsiveDrawer into InvestmentsComponent as props:</p>

<pre><code> InvestmentsComponent = &lt;Investments setLoading={this.setLoading} /&gt;
</code></pre>

<p>And then tried to set it to true on <code>componentDidMount()</code></p>

<pre><code>    componentDidMount() {
        this.props.setLoading(true);
        fetchInvestments(); // sets loading to false upon completion
    }

     fetchInvestments() {
        fetch(""/api/investments"", {
            credentials: ""same-origin"",
            headers: {
                ""Cache-Control"": ""no-cache""
            }
        })
            .then(res =&gt; {
                if (!res.ok) throw Error(res.status);
                return res.json();
            })
            .then(responseJson =&gt; {
                this.props.setLoading(false);
                this.setState({ investments: responseJson });
            })
            .catch(err =&gt; {
                console.error(""Unable to fetch investments""); // show error message
            });
    }
</code></pre>

<p>However, when I do this, react goes into infinite loop - I assume that when the state of <code>loading</code> changes, it also reloads the investments component route which then sets the loading state again.</p>

<p>I end up with:</p>

<blockquote>
  <p>Maximum update depth exceeded. This can happen when a component
  repeatedly calls setState inside componentWillUpdate or
  componentDidUpdate. React limits the number of nested updates to
  prevent infinite loops.</p>
</blockquote>

<p>What could be a potential solution to this conundrum?</p>
","I edited the post, however the actual culprit of the infinite loop is the setState in componentDidMount."
"48070546","Managing state for a loading bar in react with react-router","5","<p>I have an app in React which uses material-ui's responsive drawer component. Let's call it ResponsiveDrawer. In this component I have a state variable called ""loading"".</p>

<pre><code>class ResponsiveDrawer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            loading:false
        }
        this.setLoading = this.setLoading.bind(this);
    }
    setLoading(loading) {
        this.setState({loading:loading});
    }
    ...
</code></pre>

<p>I want to display a LinearProgress component at the top of the page, depending on the <code>loading</code> state variable.</p>

<pre><code>    ...
    render() {
        return (
            &lt;div className={classes.root}&gt;
                {this.state.loading ? &lt;LinearProgress/&gt; : """"} 
                ...
</code></pre>

<p>Inside ResponsiveDrawer I am also using react router to render some child components.</p>

<pre><code>                ...
                &lt;main className={classes.content}&gt;
                    &lt;div className={classes.contentWrapper}&gt;
                        &lt;Switch&gt;
                            &lt;Route
                                exact
                                path=""/investments""
                                component={InvestmentsComponent}
                            /&gt;
                            ...
                        &lt;/Switch&gt;
                     &lt;/div&gt;
               &lt;/main&gt;
          &lt;/div&gt;
</code></pre>

<p>Inside Investments component, I am doing a fetch from an API.
What I would like to do, is to set the loading state in the ResponsiveDrawer component to <code>true</code> and then set it back to <code>false</code> upon successful fetch.</p>

<p>So I passed the setLoading function of the ResponsiveDrawer into InvestmentsComponent as props:</p>

<pre><code> InvestmentsComponent = &lt;Investments setLoading={this.setLoading} /&gt;
</code></pre>

<p>And then tried to set it to true on <code>componentDidMount()</code></p>

<pre><code>    componentDidMount() {
        this.props.setLoading(true);
        fetchInvestments(); // sets loading to false upon completion
    }

     fetchInvestments() {
        fetch(""/api/investments"", {
            credentials: ""same-origin"",
            headers: {
                ""Cache-Control"": ""no-cache""
            }
        })
            .then(res =&gt; {
                if (!res.ok) throw Error(res.status);
                return res.json();
            })
            .then(responseJson =&gt; {
                this.props.setLoading(false);
                this.setState({ investments: responseJson });
            })
            .catch(err =&gt; {
                console.error(""Unable to fetch investments""); // show error message
            });
    }
</code></pre>

<p>However, when I do this, react goes into infinite loop - I assume that when the state of <code>loading</code> changes, it also reloads the investments component route which then sets the loading state again.</p>

<p>I end up with:</p>

<blockquote>
  <p>Maximum update depth exceeded. This can happen when a component
  repeatedly calls setState inside componentWillUpdate or
  componentDidUpdate. React limits the number of nested updates to
  prevent infinite loops.</p>
</blockquote>

<p>What could be a potential solution to this conundrum?</p>
","Can you show the fetchInvestments() code?"
"48070546","Managing state for a loading bar in react with react-router","5","<p>I have an app in React which uses material-ui's responsive drawer component. Let's call it ResponsiveDrawer. In this component I have a state variable called ""loading"".</p>

<pre><code>class ResponsiveDrawer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            loading:false
        }
        this.setLoading = this.setLoading.bind(this);
    }
    setLoading(loading) {
        this.setState({loading:loading});
    }
    ...
</code></pre>

<p>I want to display a LinearProgress component at the top of the page, depending on the <code>loading</code> state variable.</p>

<pre><code>    ...
    render() {
        return (
            &lt;div className={classes.root}&gt;
                {this.state.loading ? &lt;LinearProgress/&gt; : """"} 
                ...
</code></pre>

<p>Inside ResponsiveDrawer I am also using react router to render some child components.</p>

<pre><code>                ...
                &lt;main className={classes.content}&gt;
                    &lt;div className={classes.contentWrapper}&gt;
                        &lt;Switch&gt;
                            &lt;Route
                                exact
                                path=""/investments""
                                component={InvestmentsComponent}
                            /&gt;
                            ...
                        &lt;/Switch&gt;
                     &lt;/div&gt;
               &lt;/main&gt;
          &lt;/div&gt;
</code></pre>

<p>Inside Investments component, I am doing a fetch from an API.
What I would like to do, is to set the loading state in the ResponsiveDrawer component to <code>true</code> and then set it back to <code>false</code> upon successful fetch.</p>

<p>So I passed the setLoading function of the ResponsiveDrawer into InvestmentsComponent as props:</p>

<pre><code> InvestmentsComponent = &lt;Investments setLoading={this.setLoading} /&gt;
</code></pre>

<p>And then tried to set it to true on <code>componentDidMount()</code></p>

<pre><code>    componentDidMount() {
        this.props.setLoading(true);
        fetchInvestments(); // sets loading to false upon completion
    }

     fetchInvestments() {
        fetch(""/api/investments"", {
            credentials: ""same-origin"",
            headers: {
                ""Cache-Control"": ""no-cache""
            }
        })
            .then(res =&gt; {
                if (!res.ok) throw Error(res.status);
                return res.json();
            })
            .then(responseJson =&gt; {
                this.props.setLoading(false);
                this.setState({ investments: responseJson });
            })
            .catch(err =&gt; {
                console.error(""Unable to fetch investments""); // show error message
            });
    }
</code></pre>

<p>However, when I do this, react goes into infinite loop - I assume that when the state of <code>loading</code> changes, it also reloads the investments component route which then sets the loading state again.</p>

<p>I end up with:</p>

<blockquote>
  <p>Maximum update depth exceeded. This can happen when a component
  repeatedly calls setState inside componentWillUpdate or
  componentDidUpdate. React limits the number of nested updates to
  prevent infinite loops.</p>
</blockquote>

<p>What could be a potential solution to this conundrum?</p>
","If that's the case, you can simply wrap `InvestmentsComponent` in another component, let's call it `InvestmentsWrapper`. That component will be the one doing the fetching and then pass it down to `InvestmentsComponent`. Your `ResponsiveDrawer` can then just render the wrapper."
"48449116","Switch is not render react component","3","<p>I am trying check if has cookies (login) and redirect to /dashboard. I added a Switch on arround Route, but it is not render the component. If I remove Switch, the page dont load: <em>""Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.""</em></p>

<p>My code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { BrowserRouter as Router, Route, Redirect, Switch } from 'react-router-dom';
import Layout from '../../components/Layout.js';
import './Login.scss';

const Auth = () =&gt; (
  	&lt;Router&gt;
   		&lt;div id=""login"" className=""height100""&gt;
	   		&lt;Switch&gt;
	      		&lt;Route  path=""/"" component={Login}/&gt;
	      		&lt;PrivateRoute exact path=""/dashboard"" component={Protected}/&gt;
	      	&lt;/Switch&gt;
    	&lt;/div&gt;
  	&lt;/Router&gt;
)

const fakeAuth = {
  	isAuthenticated: false,
  	authenticate(cb) {
  		this.isAuthenticated = true
    	setTimeout(cb, 100) // fake async
	}
}

const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
  	&lt;Route {...rest} render={props =&gt; (
    	fakeAuth.isAuthenticated ? (
      		&lt;Component {...props}/&gt;
    ) : (
      	&lt;Redirect to={{
       		pathname: '/',
        	state: { from: props.location }
      	}}/&gt;
    )
  	)}/&gt;
)

const Protected = () =&gt; &lt;Layout /&gt;

class Login extends Component {
 	state = {
    	redirectToReferrer: false
  	}

	setCookie = (cname,cvalue,exdays) =&gt; {
	    var d = new Date();
	    d.setTime(d.getTime() + (exdays*24*60*60));
	    var expires = ""expires="" + d.toGMTString();
	    document.cookie = cname + ""="" + cvalue + "";"" + expires + "";path=/"";
	}

	getCookie = (cname) =&gt; {
 	    var name = cname + ""="";
	    var decodedCookie = decodeURIComponent(document.cookie);
	    var ca = decodedCookie.split(';');
	    for(var i = 0; i &lt; ca.length; i++) {
	        var c = ca[i];
	        while (c.charAt(0) === ' ') {
	            c = c.substring(1);
	        }
	        if (c.indexOf(name) === 0) {
	            return c.substring(name.length, c.length);
	        }
	    }
	    return """";
	}

	// checkCookie() {
	//     var redirect = this.getCookie(""redirectToReferrer"");
	//     if (redirect) {
	//     } else {
	//         this.setCookie(""redirectToReferrer"", true, 30);
	//     }
	// }

 	login = (e) =&gt; {
 		e.preventDefault();
 		const that = this;

		const data = {
			'username': this.username.value,
			'password': this.password.value
		}

		const checkLogin = function(e) {
			if(e.username === data.username &amp;&amp; e.password === data.password) {
			    fakeAuth.authenticate();
				that.setState({ redirectToReferrer: true });
				that.setCookie(""redirectToReferrer"", true, 30);
			} else {
				alert('fail');
			}
		}

		fetch('http://maiconfurtado.com.br/test.json').then(r =&gt; r.json())
			.then(e =&gt; checkLogin(e))
			.catch(e =&gt; alert(e.message));
  	}

  	render() {
	    const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };
	    const { redirectToReferrer } = this.state;
	    const redirect = this.getCookie(""redirectToReferrer"");

	    if (redirectToReferrer || redirect) {
	      	return (
	        	&lt;Redirect to={from} /&gt;
	      	)
	    }

	    return (
			&lt;div className=""box-login col-10 col-10-sm center-block""&gt;
				&lt;form className=""col-9 col-10-xs center-block"" onSubmit={this.login}&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""username""&gt;E-mail&lt;/label&gt;
						&lt;input type=""text"" className=""input"" id=""username"" name=""username"" ref={node =&gt; this.username = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""password""&gt;Password&lt;/label&gt;
						&lt;input type=""password"" className=""input"" id=""password"" name=""password"" ref={node =&gt; this.password = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;input type=""submit"" id=""submit"" value=""Log in"" /&gt;
					&lt;/div&gt;
				&lt;/form&gt;
			&lt;/div&gt;
	    )
	}
}

export default Auth</code></pre>
</div>
</div>
</p>

<p>I have another problem too: <em>Warning: You tried to redirect to the same route you're currently on: ""/dashboard""</em></p>
","Problem could come from here: const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };
Since you are not using PropTypes how are you sure Login component is receiving that?"
"48449116","Switch is not render react component","3","<p>I am trying check if has cookies (login) and redirect to /dashboard. I added a Switch on arround Route, but it is not render the component. If I remove Switch, the page dont load: <em>""Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.""</em></p>

<p>My code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { BrowserRouter as Router, Route, Redirect, Switch } from 'react-router-dom';
import Layout from '../../components/Layout.js';
import './Login.scss';

const Auth = () =&gt; (
  	&lt;Router&gt;
   		&lt;div id=""login"" className=""height100""&gt;
	   		&lt;Switch&gt;
	      		&lt;Route  path=""/"" component={Login}/&gt;
	      		&lt;PrivateRoute exact path=""/dashboard"" component={Protected}/&gt;
	      	&lt;/Switch&gt;
    	&lt;/div&gt;
  	&lt;/Router&gt;
)

const fakeAuth = {
  	isAuthenticated: false,
  	authenticate(cb) {
  		this.isAuthenticated = true
    	setTimeout(cb, 100) // fake async
	}
}

const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
  	&lt;Route {...rest} render={props =&gt; (
    	fakeAuth.isAuthenticated ? (
      		&lt;Component {...props}/&gt;
    ) : (
      	&lt;Redirect to={{
       		pathname: '/',
        	state: { from: props.location }
      	}}/&gt;
    )
  	)}/&gt;
)

const Protected = () =&gt; &lt;Layout /&gt;

class Login extends Component {
 	state = {
    	redirectToReferrer: false
  	}

	setCookie = (cname,cvalue,exdays) =&gt; {
	    var d = new Date();
	    d.setTime(d.getTime() + (exdays*24*60*60));
	    var expires = ""expires="" + d.toGMTString();
	    document.cookie = cname + ""="" + cvalue + "";"" + expires + "";path=/"";
	}

	getCookie = (cname) =&gt; {
 	    var name = cname + ""="";
	    var decodedCookie = decodeURIComponent(document.cookie);
	    var ca = decodedCookie.split(';');
	    for(var i = 0; i &lt; ca.length; i++) {
	        var c = ca[i];
	        while (c.charAt(0) === ' ') {
	            c = c.substring(1);
	        }
	        if (c.indexOf(name) === 0) {
	            return c.substring(name.length, c.length);
	        }
	    }
	    return """";
	}

	// checkCookie() {
	//     var redirect = this.getCookie(""redirectToReferrer"");
	//     if (redirect) {
	//     } else {
	//         this.setCookie(""redirectToReferrer"", true, 30);
	//     }
	// }

 	login = (e) =&gt; {
 		e.preventDefault();
 		const that = this;

		const data = {
			'username': this.username.value,
			'password': this.password.value
		}

		const checkLogin = function(e) {
			if(e.username === data.username &amp;&amp; e.password === data.password) {
			    fakeAuth.authenticate();
				that.setState({ redirectToReferrer: true });
				that.setCookie(""redirectToReferrer"", true, 30);
			} else {
				alert('fail');
			}
		}

		fetch('http://maiconfurtado.com.br/test.json').then(r =&gt; r.json())
			.then(e =&gt; checkLogin(e))
			.catch(e =&gt; alert(e.message));
  	}

  	render() {
	    const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };
	    const { redirectToReferrer } = this.state;
	    const redirect = this.getCookie(""redirectToReferrer"");

	    if (redirectToReferrer || redirect) {
	      	return (
	        	&lt;Redirect to={from} /&gt;
	      	)
	    }

	    return (
			&lt;div className=""box-login col-10 col-10-sm center-block""&gt;
				&lt;form className=""col-9 col-10-xs center-block"" onSubmit={this.login}&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""username""&gt;E-mail&lt;/label&gt;
						&lt;input type=""text"" className=""input"" id=""username"" name=""username"" ref={node =&gt; this.username = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""password""&gt;Password&lt;/label&gt;
						&lt;input type=""password"" className=""input"" id=""password"" name=""password"" ref={node =&gt; this.password = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;input type=""submit"" id=""submit"" value=""Log in"" /&gt;
					&lt;/div&gt;
				&lt;/form&gt;
			&lt;/div&gt;
	    )
	}
}

export default Auth</code></pre>
</div>
</div>
</p>

<p>I have another problem too: <em>Warning: You tried to redirect to the same route you're currently on: ""/dashboard""</em></p>
","@AdolfoOnrubia i dont know, I just copied it from her: https://reacttraining.com/react-router/web/example/auth-workflow"
"48449116","Switch is not render react component","3","<p>I am trying check if has cookies (login) and redirect to /dashboard. I added a Switch on arround Route, but it is not render the component. If I remove Switch, the page dont load: <em>""Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.""</em></p>

<p>My code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { BrowserRouter as Router, Route, Redirect, Switch } from 'react-router-dom';
import Layout from '../../components/Layout.js';
import './Login.scss';

const Auth = () =&gt; (
  	&lt;Router&gt;
   		&lt;div id=""login"" className=""height100""&gt;
	   		&lt;Switch&gt;
	      		&lt;Route  path=""/"" component={Login}/&gt;
	      		&lt;PrivateRoute exact path=""/dashboard"" component={Protected}/&gt;
	      	&lt;/Switch&gt;
    	&lt;/div&gt;
  	&lt;/Router&gt;
)

const fakeAuth = {
  	isAuthenticated: false,
  	authenticate(cb) {
  		this.isAuthenticated = true
    	setTimeout(cb, 100) // fake async
	}
}

const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
  	&lt;Route {...rest} render={props =&gt; (
    	fakeAuth.isAuthenticated ? (
      		&lt;Component {...props}/&gt;
    ) : (
      	&lt;Redirect to={{
       		pathname: '/',
        	state: { from: props.location }
      	}}/&gt;
    )
  	)}/&gt;
)

const Protected = () =&gt; &lt;Layout /&gt;

class Login extends Component {
 	state = {
    	redirectToReferrer: false
  	}

	setCookie = (cname,cvalue,exdays) =&gt; {
	    var d = new Date();
	    d.setTime(d.getTime() + (exdays*24*60*60));
	    var expires = ""expires="" + d.toGMTString();
	    document.cookie = cname + ""="" + cvalue + "";"" + expires + "";path=/"";
	}

	getCookie = (cname) =&gt; {
 	    var name = cname + ""="";
	    var decodedCookie = decodeURIComponent(document.cookie);
	    var ca = decodedCookie.split(';');
	    for(var i = 0; i &lt; ca.length; i++) {
	        var c = ca[i];
	        while (c.charAt(0) === ' ') {
	            c = c.substring(1);
	        }
	        if (c.indexOf(name) === 0) {
	            return c.substring(name.length, c.length);
	        }
	    }
	    return """";
	}

	// checkCookie() {
	//     var redirect = this.getCookie(""redirectToReferrer"");
	//     if (redirect) {
	//     } else {
	//         this.setCookie(""redirectToReferrer"", true, 30);
	//     }
	// }

 	login = (e) =&gt; {
 		e.preventDefault();
 		const that = this;

		const data = {
			'username': this.username.value,
			'password': this.password.value
		}

		const checkLogin = function(e) {
			if(e.username === data.username &amp;&amp; e.password === data.password) {
			    fakeAuth.authenticate();
				that.setState({ redirectToReferrer: true });
				that.setCookie(""redirectToReferrer"", true, 30);
			} else {
				alert('fail');
			}
		}

		fetch('http://maiconfurtado.com.br/test.json').then(r =&gt; r.json())
			.then(e =&gt; checkLogin(e))
			.catch(e =&gt; alert(e.message));
  	}

  	render() {
	    const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };
	    const { redirectToReferrer } = this.state;
	    const redirect = this.getCookie(""redirectToReferrer"");

	    if (redirectToReferrer || redirect) {
	      	return (
	        	&lt;Redirect to={from} /&gt;
	      	)
	    }

	    return (
			&lt;div className=""box-login col-10 col-10-sm center-block""&gt;
				&lt;form className=""col-9 col-10-xs center-block"" onSubmit={this.login}&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""username""&gt;E-mail&lt;/label&gt;
						&lt;input type=""text"" className=""input"" id=""username"" name=""username"" ref={node =&gt; this.username = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""password""&gt;Password&lt;/label&gt;
						&lt;input type=""password"" className=""input"" id=""password"" name=""password"" ref={node =&gt; this.password = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;input type=""submit"" id=""submit"" value=""Log in"" /&gt;
					&lt;/div&gt;
				&lt;/form&gt;
			&lt;/div&gt;
	    )
	}
}

export default Auth</code></pre>
</div>
</div>
</p>

<p>I have another problem too: <em>Warning: You tried to redirect to the same route you're currently on: ""/dashboard""</em></p>
","I suggeest to check Login component props with a console.log and see if it gets the right parameter in the right way"
"48457834","react native use navigation prop in fetch","7","<p>I am pretty new to react native. I am using react navigation in my react-native app. I am passing some props from one screen to another, and I need to use one of the props in a fetch I am trying to execute within the <code>componentDidMount</code> lifecycle method. With everything I have tried, it sends the value for the ""type"" key, but it sends nothing for the ""location"" key (see code below). Could someone help me with what am I missing or doing wrong? I have tried several things to pass the prop but nothing has worked yet.</p>

<pre><code>  componentDidMount() {
    const { params } = this.props.navigation.state;
    var data = {
      type: 'r',
      location: params.location
    }
    return fetch('http://myapisite', {
          method: 'POST',
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        }
      )
      .then((response) =&gt; response.json())
      .then((responseJson) =&gt; {
        this.setState({
          isLoading: false,
          dataSource: responseJson,
        }, function() {
          // do something with new state
        });
      })
      .catch((error) =&gt; {
        console.error(error);
      });
  }
</code></pre>
","I'd check whether react navigation is mounting the component without the param and then updates - try using `componentDidUpdate` or `componentWillReceiveProps` to see if that's the case."
"48560366","In react, will change in props in parent result in a corresponding updation in the child?","1","<p>The official documentation of react ( <a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a> ) says that an update in props results in the child being updated, but it does not happen in my code. Am I missing something?</p>

<p>I created a parent component (Y) and a child component (X). The parent passes currentTime to the child as props. Even though after the props change in the parent after 3 seconds (due to setTimeout), the value in the h2 tag in the child does not change. </p>

<p>I found on the official page of react though ( <a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a> ) that ""An update can be caused by changes to props or state."" (I'm attaching a screenshot as well of the text on the official site below) Moreover I found that there that ""These methods are called when a component is being re-rendered:""</p>

<pre><code>componentWillReceiveProps()
shouldComponentUpdate()
componentWillUpdate()
render()
componentDidUpdate()
</code></pre>

<p>But in my case the change in props does not cause the value in h2 tag in the child to change. The official documentation says that an update in props results in the child being updated, but it does not happen in my code. Am I missing something? </p>

<p>I've pasted my code here for reference.</p>

<pre><code>const Y = () =&gt; {

    let currentTime=""09:00"";
    setTimeout(()=&gt; {
            currentTime = ""10:00:""
        }, 3000);

    return (
        &lt;X time={currentTime}/&gt;
    );
};


class X extends Component {
    time = ""11:00"";

    render = () =&gt; {
        return (
            &lt;h2&gt;{this.props.time}&lt;/h2&gt;
        );
    };
}
</code></pre>

<p>Screenshot:
<a href=""https://prnt.sc/i8kvaw"" rel=""nofollow noreferrer"">https://prnt.sc/i8kvaw</a></p>

<p><strong>Update:
The comment from Shubham Khatri ""The props for the child will only change if the parent re-renders"", really helped me understand. :)</strong></p>
","props are immutable within the component, use state to achieve what you want here :)"
"48639336","check if two arrays contain identical objects - react componentDidUpdate","5","<p>I am using React's <code>componentDidUpdate</code> lifecycle method.</p>

<p>I am trying to determine whether or not two arrays are the same.</p>

<p>My <code>prevState</code> array looks like this:</p>

<pre><code>prevState.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>and the <code>this.state</code> array looks like this:</p>

<pre><code>this.state.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>As you can see if you expand the snippet below they are not equal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let playersOne = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

let playersTwo = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

console.log(playersOne == playersTwo)</code></pre>
</div>
</div>
</p>

<p>And here is my react lifecycle code.</p>

<pre><code>  componentDidUpdate(prevProps, prevState) {
    if(prevState.players != this.state.players) {
      this.updatePlayers(this.state);
    }
  }
</code></pre>

<p>can anyone advise as to the best way to determine if the arrays are equal?</p>
","check all the results [**here**](https://www.google.co.in/search?q=how+to+check+two+arrays+of+objects+are+equal+in+javascript+site:stackoverflow.com&sa=X&ved=0ahUKEwib6IXV-5DZAhVDvY8KHdswDrkQrQIIMygEMAA&biw=1440&bih=803)"
"48639336","check if two arrays contain identical objects - react componentDidUpdate","5","<p>I am using React's <code>componentDidUpdate</code> lifecycle method.</p>

<p>I am trying to determine whether or not two arrays are the same.</p>

<p>My <code>prevState</code> array looks like this:</p>

<pre><code>prevState.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>and the <code>this.state</code> array looks like this:</p>

<pre><code>this.state.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>As you can see if you expand the snippet below they are not equal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let playersOne = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

let playersTwo = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

console.log(playersOne == playersTwo)</code></pre>
</div>
</div>
</p>

<p>And here is my react lifecycle code.</p>

<pre><code>  componentDidUpdate(prevProps, prevState) {
    if(prevState.players != this.state.players) {
      this.updatePlayers(this.state);
    }
  }
</code></pre>

<p>can anyone advise as to the best way to determine if the arrays are equal?</p>
","Duplicates https://stackoverflow.com/questions/201183/how-to-determine-equality-for-two-javascript-objects and https://stackoverflow.com/questions/1068834/object-comparison-in-javascript"
"48639336","check if two arrays contain identical objects - react componentDidUpdate","5","<p>I am using React's <code>componentDidUpdate</code> lifecycle method.</p>

<p>I am trying to determine whether or not two arrays are the same.</p>

<p>My <code>prevState</code> array looks like this:</p>

<pre><code>prevState.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>and the <code>this.state</code> array looks like this:</p>

<pre><code>this.state.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>As you can see if you expand the snippet below they are not equal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let playersOne = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

let playersTwo = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

console.log(playersOne == playersTwo)</code></pre>
</div>
</div>
</p>

<p>And here is my react lifecycle code.</p>

<pre><code>  componentDidUpdate(prevProps, prevState) {
    if(prevState.players != this.state.players) {
      this.updatePlayers(this.state);
    }
  }
</code></pre>

<p>can anyone advise as to the best way to determine if the arrays are equal?</p>
","`JSON.stringify(playersOne) == JSON.stringify(playersTwo)`"
"48639336","check if two arrays contain identical objects - react componentDidUpdate","5","<p>I am using React's <code>componentDidUpdate</code> lifecycle method.</p>

<p>I am trying to determine whether or not two arrays are the same.</p>

<p>My <code>prevState</code> array looks like this:</p>

<pre><code>prevState.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>and the <code>this.state</code> array looks like this:</p>

<pre><code>this.state.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>As you can see if you expand the snippet below they are not equal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let playersOne = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

let playersTwo = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

console.log(playersOne == playersTwo)</code></pre>
</div>
</div>
</p>

<p>And here is my react lifecycle code.</p>

<pre><code>  componentDidUpdate(prevProps, prevState) {
    if(prevState.players != this.state.players) {
      this.updatePlayers(this.state);
    }
  }
</code></pre>

<p>can anyone advise as to the best way to determine if the arrays are equal?</p>
","One thing that React docs suggest is to use Immutable data since such comparisons can be expensive, but you still need to do it use _.isEqual from lodash or deep compare individual values"
"48639336","check if two arrays contain identical objects - react componentDidUpdate","5","<p>I am using React's <code>componentDidUpdate</code> lifecycle method.</p>

<p>I am trying to determine whether or not two arrays are the same.</p>

<p>My <code>prevState</code> array looks like this:</p>

<pre><code>prevState.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>and the <code>this.state</code> array looks like this:</p>

<pre><code>this.state.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>As you can see if you expand the snippet below they are not equal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let playersOne = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

let playersTwo = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

console.log(playersOne == playersTwo)</code></pre>
</div>
</div>
</p>

<p>And here is my react lifecycle code.</p>

<pre><code>  componentDidUpdate(prevProps, prevState) {
    if(prevState.players != this.state.players) {
      this.updatePlayers(this.state);
    }
  }
</code></pre>

<p>can anyone advise as to the best way to determine if the arrays are equal?</p>
","@AkashDathan looks like that one will do it"
"48641707","Event Handler (prop) passed to child component cannot be called react native","2","<p>I am passing an event handler <code>showSpinner()</code> from parent component. This method displays the activity Indicator in my app, the method when called from the parent class, works. But when I pass it down to a child component and then call it from the child as <code>this.props.showSpinner()</code>, I am getting the error </p>

<pre><code>TypeError: undefined is not an object
(evaluating 'Object.keys(this.state.data)')
</code></pre>

<p>I am also not able to <code>console.log</code> the method at the child's props
Please note, I have already bound the function at the parent.</p>

<p>Here is a part of my code.
This is the parent component.</p>

<pre><code>import React from 'react';
import { View, Button, Alert, Image, ScrollView, BackHandler, TouchableOpacity,Text, ActivityIndicator } from 'react-native';
import ProductListingItem from '../ProductCategories/ProductListingItemCategories.js';
import PusherColumnCategories from '../ProductCategories/PusherColumnCategories.js';
import NavRightButton from '../NavButton/NavRightButton.js';
import ActivitySpinner from '../ActivitySpinner.js';

const TAG = 'PRODUCTCATEGORIESPAGE';
export default class ProductCategoriesPage extends React.Component {
  constructor(props) {
    super(props);
    /*this._getResponseFromApi = this._getResponseFromApi.bind(this);*/
    this._onPressGoToCart=this._onPressGoToCart.bind(this);
    if(props){
      /*console.log(TAG,'constructor()','props available');*/
      console.log(TAG,'constructor()','props JSON stringified = '+JSON.stringify(props));
      /*this.setState({dataMain : (props.navigation.state.params.categories)});*/
    }
    this.state = {
      dataMain: props.navigation.state.params.categories,
      showIndicator: false,
    };
    console.log(TAG,'constructor','this.state.dataMain = '+this.state.dataMain );

  }
  static navigationOptions = ({navigation}) =&gt; {
    return{
      title: 'Categories',
      headerLeft: null,
      headerStyle: {
        backgroundColor: '#EE162C',
      },
      /*headerBackTitleStyle: {
        color: 'white',
      },*/
      headerTintColor: 'white',
      headerRight: &lt;NavRightButton navigation= {navigation}/&gt;,
      gesturesEnabled:false,
    };
  };
  _onPressGoToCart(){
    console.log(TAG,'_onPressGoToCart');
    console.log(TAG,'_onPressGoToCart','navigation props ='+JSON.stringify(this.props));
    const { navigate } = this.props.navigation;
    navigate('CartPage');
  }
  componentWillReceiveProps(newProps){
    console.log(TAG+'componentWillReceiveProps');
    if(newProps){
      console.log(TAG,'componentWillReceiveProps()','props available');
      console.log(TAG,'componentWillReceiveProps()','props = '+newProps.navigation.state.params.categories);
    }
  }
  _OnAlert(title,message){
    console.log(TAG,'_onAlert');
    Alert.alert(
      title,
      message,
      [
        {text:'done',onPress: () =&gt; { }}
      ]
    );
  }
  componentDidMount () {
    console.log(TAG,'componentDidMount');
    /*this._getResponseFromApi();*/
    BackHandler.addEventListener('hardwareBackPress',() =&gt; {return true});
  }
  componentWillMount () {
    console.log(TAG,'componentWillMount');
  }
  _showSpinner(){
    console.log(TAG,'_showSpinner');
    this.setState({
      showIndicator:true,
    });
  }
   _hideSpinner(){
   console.log(TAG,'_hideSpinner');
    this.setState({
      showIndicator:false,
    });
  }
  render(){
    console.log(TAG,'render');
    console.log(TAG,'render','dataMain = '+this.state.dataMain[0].id);
    // console.log(TAG,'render','showSpinner = '+JSON.stringify(this.showSpinner()));
    // var tempshowspinner = this.showSpinner.bind(this);
    // console.log(TAG,'render','tempshowspinner = '+JSON.stringify(tempshowspinner));
    return(
      &lt;View
        style={{
          flex:1,
        }}&gt;
        &lt;ScrollView style = {{flex:1,
          backgroundColor:'#F2F2F2',
          }}&gt;
          &lt;View style = {{
            flex:1,
            flexDirection:'column',
          }}&gt;
          &lt;PusherColumnCategories style = {{
            flex:1,
          }}
          data = {this.state.dataMain}
          navigate = {this.props.navigation}
          showSpinner = {this._showSpinner}
          hideSpinner = {this._hideSpinner}/&gt;
          &lt;/View&gt;
        &lt;/ScrollView&gt;
        &lt;ActivitySpinner showIndicator={this.state.showIndicator}/&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>

<p>This is the corresponding child component.</p>

<pre><code>import React from 'react';
import {View, Component, Button} from 'react-native';
import ProductListingItem from './ProductListingItemCategories';
  const TAG = ""PUSHERCOLUMNCATEGORIES"";
export default class PusherColumnCategories extends React.Component {
  constructor(props){
    super(props);
    if(props){
      console.log(TAG,'props ='+JSON.stringify(props));
      /*console.log(TAG,'props data length = '+Object.keys(props.dataMain).length);*/
      console.log(TAG,'Props = '+ JSON.stringify(props.data));
      console.log(TAG,'Navigation Props = '+JSON.stringify(props.navigate));
    }

    this.state = {
      data: props.data,
      propsAvailable: false,
      navigate: props.navigation,
    };
  };
  componentDidMount(){
    console.log(TAG,'componentDidMount');
  }
  componentWillReceiveProps(newProps){
    console.log(TAG,'componentWillReceiveProps',newProps.data);
    this.setState({
      /*data: JSON.parse(JSON.stringify(newProps.data)),*/
      data: (newProps.dataMain),
    }, function() {
      console.log(TAG,'componentWillReceiveProps','this.setState()','data = '+(Object.keys(this.state.data)));
    });
  }
  componentDidUpdate(){
    console.log(TAG,'componentDidUpdate');
  }

  render(){
    console.log(TAG,'render()');
    if(this.state.data){
      console.log(TAG,'render()','state not empty');
      console.log(TAG,'render()','data product_code = '+this.state.data[1].product_code);
      return(
        &lt;View style = {{
          flex:1,
          flexDirection: 'column',
        }}&gt;
        &lt;Button
          style = {{
            flex:1,
          }}
          title = 'presshere'
          onClick = {this.props.showSpinner}
          /&gt;
        &lt;RenderColumn style = {{
          flex:1,
        }}
         data = {this.state.data}
         navigate = {this.props.navigate}
         showSpinner = {this.props.showSpinner}
         hideSpinner = {this.props.hideSpinner}/&gt;
        &lt;/View&gt;
      );
    } else {
      console.log(TAG,'render()','state empty');
      return(
        &lt;View style = {{
          flex:1,
          flexDirection: 'column',
        }}/&gt;
      );
    }
  };
}
</code></pre>
","Please check the question now"
"48641707","Event Handler (prop) passed to child component cannot be called react native","2","<p>I am passing an event handler <code>showSpinner()</code> from parent component. This method displays the activity Indicator in my app, the method when called from the parent class, works. But when I pass it down to a child component and then call it from the child as <code>this.props.showSpinner()</code>, I am getting the error </p>

<pre><code>TypeError: undefined is not an object
(evaluating 'Object.keys(this.state.data)')
</code></pre>

<p>I am also not able to <code>console.log</code> the method at the child's props
Please note, I have already bound the function at the parent.</p>

<p>Here is a part of my code.
This is the parent component.</p>

<pre><code>import React from 'react';
import { View, Button, Alert, Image, ScrollView, BackHandler, TouchableOpacity,Text, ActivityIndicator } from 'react-native';
import ProductListingItem from '../ProductCategories/ProductListingItemCategories.js';
import PusherColumnCategories from '../ProductCategories/PusherColumnCategories.js';
import NavRightButton from '../NavButton/NavRightButton.js';
import ActivitySpinner from '../ActivitySpinner.js';

const TAG = 'PRODUCTCATEGORIESPAGE';
export default class ProductCategoriesPage extends React.Component {
  constructor(props) {
    super(props);
    /*this._getResponseFromApi = this._getResponseFromApi.bind(this);*/
    this._onPressGoToCart=this._onPressGoToCart.bind(this);
    if(props){
      /*console.log(TAG,'constructor()','props available');*/
      console.log(TAG,'constructor()','props JSON stringified = '+JSON.stringify(props));
      /*this.setState({dataMain : (props.navigation.state.params.categories)});*/
    }
    this.state = {
      dataMain: props.navigation.state.params.categories,
      showIndicator: false,
    };
    console.log(TAG,'constructor','this.state.dataMain = '+this.state.dataMain );

  }
  static navigationOptions = ({navigation}) =&gt; {
    return{
      title: 'Categories',
      headerLeft: null,
      headerStyle: {
        backgroundColor: '#EE162C',
      },
      /*headerBackTitleStyle: {
        color: 'white',
      },*/
      headerTintColor: 'white',
      headerRight: &lt;NavRightButton navigation= {navigation}/&gt;,
      gesturesEnabled:false,
    };
  };
  _onPressGoToCart(){
    console.log(TAG,'_onPressGoToCart');
    console.log(TAG,'_onPressGoToCart','navigation props ='+JSON.stringify(this.props));
    const { navigate } = this.props.navigation;
    navigate('CartPage');
  }
  componentWillReceiveProps(newProps){
    console.log(TAG+'componentWillReceiveProps');
    if(newProps){
      console.log(TAG,'componentWillReceiveProps()','props available');
      console.log(TAG,'componentWillReceiveProps()','props = '+newProps.navigation.state.params.categories);
    }
  }
  _OnAlert(title,message){
    console.log(TAG,'_onAlert');
    Alert.alert(
      title,
      message,
      [
        {text:'done',onPress: () =&gt; { }}
      ]
    );
  }
  componentDidMount () {
    console.log(TAG,'componentDidMount');
    /*this._getResponseFromApi();*/
    BackHandler.addEventListener('hardwareBackPress',() =&gt; {return true});
  }
  componentWillMount () {
    console.log(TAG,'componentWillMount');
  }
  _showSpinner(){
    console.log(TAG,'_showSpinner');
    this.setState({
      showIndicator:true,
    });
  }
   _hideSpinner(){
   console.log(TAG,'_hideSpinner');
    this.setState({
      showIndicator:false,
    });
  }
  render(){
    console.log(TAG,'render');
    console.log(TAG,'render','dataMain = '+this.state.dataMain[0].id);
    // console.log(TAG,'render','showSpinner = '+JSON.stringify(this.showSpinner()));
    // var tempshowspinner = this.showSpinner.bind(this);
    // console.log(TAG,'render','tempshowspinner = '+JSON.stringify(tempshowspinner));
    return(
      &lt;View
        style={{
          flex:1,
        }}&gt;
        &lt;ScrollView style = {{flex:1,
          backgroundColor:'#F2F2F2',
          }}&gt;
          &lt;View style = {{
            flex:1,
            flexDirection:'column',
          }}&gt;
          &lt;PusherColumnCategories style = {{
            flex:1,
          }}
          data = {this.state.dataMain}
          navigate = {this.props.navigation}
          showSpinner = {this._showSpinner}
          hideSpinner = {this._hideSpinner}/&gt;
          &lt;/View&gt;
        &lt;/ScrollView&gt;
        &lt;ActivitySpinner showIndicator={this.state.showIndicator}/&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>

<p>This is the corresponding child component.</p>

<pre><code>import React from 'react';
import {View, Component, Button} from 'react-native';
import ProductListingItem from './ProductListingItemCategories';
  const TAG = ""PUSHERCOLUMNCATEGORIES"";
export default class PusherColumnCategories extends React.Component {
  constructor(props){
    super(props);
    if(props){
      console.log(TAG,'props ='+JSON.stringify(props));
      /*console.log(TAG,'props data length = '+Object.keys(props.dataMain).length);*/
      console.log(TAG,'Props = '+ JSON.stringify(props.data));
      console.log(TAG,'Navigation Props = '+JSON.stringify(props.navigate));
    }

    this.state = {
      data: props.data,
      propsAvailable: false,
      navigate: props.navigation,
    };
  };
  componentDidMount(){
    console.log(TAG,'componentDidMount');
  }
  componentWillReceiveProps(newProps){
    console.log(TAG,'componentWillReceiveProps',newProps.data);
    this.setState({
      /*data: JSON.parse(JSON.stringify(newProps.data)),*/
      data: (newProps.dataMain),
    }, function() {
      console.log(TAG,'componentWillReceiveProps','this.setState()','data = '+(Object.keys(this.state.data)));
    });
  }
  componentDidUpdate(){
    console.log(TAG,'componentDidUpdate');
  }

  render(){
    console.log(TAG,'render()');
    if(this.state.data){
      console.log(TAG,'render()','state not empty');
      console.log(TAG,'render()','data product_code = '+this.state.data[1].product_code);
      return(
        &lt;View style = {{
          flex:1,
          flexDirection: 'column',
        }}&gt;
        &lt;Button
          style = {{
            flex:1,
          }}
          title = 'presshere'
          onClick = {this.props.showSpinner}
          /&gt;
        &lt;RenderColumn style = {{
          flex:1,
        }}
         data = {this.state.data}
         navigate = {this.props.navigate}
         showSpinner = {this.props.showSpinner}
         hideSpinner = {this.props.hideSpinner}/&gt;
        &lt;/View&gt;
      );
    } else {
      console.log(TAG,'render()','state empty');
      return(
        &lt;View style = {{
          flex:1,
          flexDirection: 'column',
        }}/&gt;
      );
    }
  };
}
</code></pre>
","Can you provide some of your code so that we can see what you are doing and where you're going wrong? But by the way you're phrasing it, it's probably something to do with function binding and `this`"
"48766539","react leaflet marker not showing when animation start","0","<p>I am trying to insert a marker when the animation start. the animation draws a polygon component along route.  i am checking when the animation start and trying to insert the marker component at first postion but it showing me this errors . ........................................................................................................................................................</p>

<pre><code> Uncaught Error: Couldn't autodetect L.Icon.Default.imagePath, set it 
 manually.

 Uncaught TypeError: Cannot set property '_leaflet_pos' of undefined
</code></pre>

<p>/// the code part<br>
........................................................................................................................................................</p>

<pre><code>import React from ""react"";
import {
  Circle,
  Mapcontrol,
  Map,
  Marker,
  Popup,
  Polyline,
  CircleMarker, 
  TileLayer,
  LayersControl,
  Tooltip
} from ""react-leaflet"";
import { alertMessage } from ""./../../helper/alert-message.js"";
import { divIcon, map, marker } from ""leaflet"";
import { GoogleLayer } from ""react-leaflet-google"";
import { observer, inject } from ""mobx-react"";
import {
  distanceTo,
  toRad,
  toDegrees,
  distVincenty,
  bearings
} from ""./../../helper/distanceCalculation.js"";
import { Button, Grid } from ""semantic-ui-react"";
import index from ""antd/lib/dropdown"";

import LandMarkPopUp from ""./LandMarkPopUp"";
import SpeedLayout from ""./SpeedLayout"";
import { platform } from ""os"";

const { BaseLayer } = LayersControl;

const key = ""AIzaSyBevgZ_HK4t08KmW23EqO-aacqqGQxnAR4"";
const road = ""ROADMAP"";
const hybrid = ""HYBRID"";
const terrain = ""TERRAIN"";
const satellite = ""SATELLITE"";

const time = new Date().toString();

@inject(""assets"")
@observer
class Maps extends React.Component {
  constructor(props) {
    super(props);
    this.index = 0;
    this.intervalId = null;
    this.intervalTimer = 400;
    this.cardata = [];
    this.polyAnim = [];
    this.state = {
      markers: [],
      position: [24.146754, 90.499477],
      zoom: 3,
      minZoom: 6,
      maxZoom: 18,
      circle: [0, 0],
      name: ""Your Asset Name"",
      time: time,
      mapBounds: [[26.273714, 87.434692], [21.912471, 94.092407]],
      polylines: [[0, 0], [0, 0]],
      bearing: 0,
      routeColor: ""#000"",
      assetLiveMode: true,
      nearLanMark: [],
      isAnimationRunning: false,
      icon: ""pause"",
      content: ""Pause"",
      mymarkers: [[23.4545, 89.264]]
    };
  }

  getChunkedPositions = markerObj =&gt; {
    let latlngs = [];
    markerObj.map((pos, idx) =&gt; {
      latlngs.push(pos.position);
    });

    var i,
      len = latlngs.length,
      distance = 1,
      chunkedLatLngs = [];

    for (i = 1; i &lt; len; i++) {
      var cur = latlngs[i - 1],
        next = latlngs[i],
        dist = distVincenty(cur, next),
        factor = distance / dist,
        dLat = factor * (next[0] - cur[0]),
        dLng = factor * (next[1] - cur[1]);

      if (dist &gt; distance) {
        while (dist &gt; distance) {
          cur = [cur[0] + dLat, cur[1] + dLng];
          (dist = distVincenty(cur, next)), chunkedLatLngs.push(cur);
        }
      } else {
        chunkedLatLngs.push(cur);
      }
    }
    chunkedLatLngs.push(latlngs[len - 1]);

    return chunkedLatLngs;
  };

  playAnimation = () =&gt; {
    if (this.intervalId !== null) {
      clearInterval(this.intervalId);
    }
    this.props.sendAnimationTime(false);
    this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
  };

  runAnimation = () =&gt; {
    const cardata = this.cardata;

    if (this.index === cardata.length) {
      console.log(""Animation Finished"");
      alertMessage(""Animation Finished"");
      this.props.sendAnimationTime(true);
      this.setState({ polylines: [], isAnimationRunning: false });
    }

    if (this.index &lt; cardata.length) {
      if (cardata[this.index].position[0] != 0) {
        this.polyAnim.push(cardata[this.index].position);
      }
      this.setState({
        markers: [cardata[this.index]],
        polylines: [this.polyAnim],
        circle: [...this.state.circle, cardata[this.index].position],
        mapBounds: [
          [
            cardata[this.index].position[0] - 0.02,
            cardata[this.index].position[1] + 0.02
          ],
          [
            cardata[this.index].position[0] + 0.02,
            cardata[this.index].position[1] - 0.02
          ]
        ],
        bearing: cardata[this.index].children[0].bearing,
        isAnimationRunning: true,
        icon: ""pause"",
        content: ""Pause""
      });
    }
    this.index += 1;
  };

  animationOnOffButton = () =&gt; {
    console.log(""Animation Buttion"", this.state.isAnimationRunning);
    if (this.state.isAnimationRunning) {
      clearInterval(this.intervalId);
      this.setState({
        isAnimationRunning: false,
        icon: ""play"",
        content: ""Play""
      });
    } else {
      console.log(""stop"");
      this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
      this.setState({
        icon: ""pause"",
        content: ""Pause""
      });
    }
  };

  animationBackwardSpeedBtn = () =&gt; {
    clearInterval(this.intervalId);
    this.intervalTimer = 100;
    this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
  };

  animationForwardSpeedBtn = () =&gt; {
    clearInterval(this.intervalId);
    this.intervalTimer = 100;
    this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
  };

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.currentAsset !== this.props.currentAsset) {
      this.circleBound(this.props.currentAsset);
    } else if (prevProps.animate !== this.props.animate) {
      var markerInfo = this.props.animate;

      var bounds = [];
      for (var i in markerInfo) {
        if (markerInfo[i].position[0] != 0 || markerInfo[i].position[1] != 0) {
          bounds.push(markerInfo[i].position);
        }
      }
      this.setState({
        mapBounds: bounds
      });

      var result = [];

      markerInfo.map((x, i) =&gt; {
        result.push({
          key: i,
          position: markerInfo[i].position,
          children: [markerInfo[i].children[3], markerInfo[i].children[2]],
          time: markerInfo[i].children[4]
        });
      });

      this.cardata = result;


      ///////////////////////////////////////////////////

      console.log(""this.cardata ----&gt;"", result);

      //////////////////////////////////////////////////////

      const first_lat = result[0].position[0] 
      const first_long = result[0].position[1] 

      const second_lat = result[result.length -1 ].position[0]
      const second_long = result[result.length - 1].position[1] 


      const f_marker = [first_long, first_lat]


      console.log(""this first point long ----&gt;"", first_long);  /// this first point long
      console.log(""this first point lat ----&gt;"", first_lat);  /// this first point lat

      console.log(""this last point long ----&gt;"", second_long); // this last point long
      console.log(""this last point lat ----&gt;"", second_lat); // this last point lat

      const l_marker = [ second_long, second_lat ]



      //////////////////////////////////////////////////////////

      this.playAnimation();
      this.props.sendAnimationTime(true);
    } else if (prevProps.route !== this.props.route) {
      var markerInfo = this.props.route;

      var bounds = [];
      for (var i in markerInfo) {
        if (markerInfo[i].position[0] != 0 || markerInfo[i].position[1] != 0) {
          bounds.push(markerInfo[i].position);
        }
      }
      this.setState({
        // markers: markerInfo,
        polylines: bounds,
        mapBounds: bounds
      });
    } else if (prevProps.data !== this.props.data) {
      const nearLm = this.props.data;

      var markerPromise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve(this.props.data);
        }, 1500);
      });

      markerPromise.then(markerInfo =&gt; {
        var bounds = [];
        var nearLanMark = [];
        for (var i in markerInfo) {
          if (
            markerInfo[i].position[0] != 0 ||
            markerInfo[i].position[1] != 0
          ) {
            bounds.push(markerInfo[i].position);
          }
        }
        if (bounds.length == 0) {
          this.setState({
            markers: markerInfo,
            polylines: [[0, 0], [0, 0]],
            mapBounds: this.state.mapBounds
          });
        } else {
          this.setState({
            markers: markerInfo,
            polylines: [[0, 0], [0, 0]],
            mapBounds: bounds
          });
        }
      });
    }
  }

  markerClick(id) {
    this.props.sendToDetails(id, true);
  }

  circleBound = value =&gt; {
    if (value !== null) {
      let Xc = value.info.position[0],
        Yc = value.info.position[1],
        R = value.radius;

      this.setState({
        mapBounds: [
          [Xc, Yc],
          [Xc, Yc + 0.03],
          [Xc, Yc - 0.03],
          [Xc - 0.03, Yc],
          [Xc + 0.03, Yc]
        ]
      });
    }
  };

  liveModeOn = () =&gt; {
    this.setState({
      assetLiveMode: false
    });

    this.props.passRouteData(this.state.assetLiveMode);
  };

  render() {
    const {
      position,
      zoom,
      minZoom,
      maxZoom,
      markers,
      time,
      mapBounds,
      polylines,    /// add marker to polyline component
      bearing,
      assetLiveMode,
      nearLanMark
    } = this.state;


    const result = markers;
    let isAnimating;
    let layoutData = {};

    if (markers.length &gt; 0 &amp;&amp; markers[0].assetId === undefined) {
      isAnimating = true;

      const animateDate = new Date(markers[0].time.time.$date);
      layoutData.speed = markers[0].children[1].speed;
      layoutData.date = `${animateDate.getDate()}-${animateDate.getMonth()}-${animateDate.getFullYear()}`;
      layoutData.time = `${animateDate.getHours()}-${animateDate.getMinutes()}-${animateDate.getSeconds()}`;
    } else {
      isAnimating = false;
    }

    const icon = (bearing, speed) =&gt; {
      return divIcon({
        className: ""my-div-icon animated-icon"",
        iconSize: [10, 10],
        iconAnchor: [12, 22],
        popupAnchor: [10, 10],
        shadowSize: [155, 150],
        html: `
            &lt;img src=""../../assets/car.png"" style=""-webkit-transform: rotate(${bearing}deg);"" width=""20""/&gt;
            &lt;div style=""z-index:-1"" class=""gps-ring""&gt;&lt;/div&gt;`
      });
    };

    const AssetIconMarker = ({ id, map, position, children, bearing }) =&gt; {
      const carbearing = !bearing ? children[0].bearing : bearing;
      const speed = children[1].speed;

      return (
        &lt;div&gt;
          &lt;Marker
            map={map}
            position={position}
            icon={icon(carbearing, speed)}
            onClick={this.markerClick.bind(this, id)}
          /&gt;
        &lt;/div&gt;
      );
    };

    const AssetIcon = ({ map, markers }) =&gt; {
      const items = markers.map(({ key, ...props }, id) =&gt; {
        return &lt;AssetIconMarker key={key} id={id} map={map} {...props} /&gt;;
      });
      return &lt;div style={{ display: ""none"" }}&gt;{items}&lt;/div&gt;;
    };

    return (
      &lt;div&gt;
        &lt;Map
          id=""map""
          ref=""leaflet""
          bounds={mapBounds}
          boundsOptions={{ padding: [10, 10] }}
          center={position}
          zoom={this.state.zoom}
          minZoom={this.state.minZoom}
          maxZoom={this.state.maxZoom}
        &gt;
          &lt;LayersControl position=""topright""&gt;
            &lt;LayersControl.BaseLayer name=""OpenStreetMap""&gt;
              &lt;TileLayer url=""http://{s}.tile.osm.org/{z}/{x}/{y}.png"" /&gt;
            &lt;/LayersControl.BaseLayer&gt;
            &lt;LayersControl.BaseLayer name=""Google Streets"" checked={true}&gt;
              &lt;GoogleLayer googlekey={key} maptype={road} /&gt;
            &lt;/LayersControl.BaseLayer&gt;
          &lt;/LayersControl&gt;




          &lt;Polyline
            color=""#111B24""
            weight=""4""
            lineCap=""round""
            positions={polylines}
            smoothFactor={1}
          /&gt;

          { this.props.currentAsset !== null ? (

            &lt;Circle
              center={this.props.currentAsset.info.position}
              radius={this.props.currentAsset.radius * 1000}
            /&gt;

          ) : null} 

          &lt;AssetIcon markers={markers} /&gt;
          &lt;LandMarkPopUp landMarkList={markers} /&gt;

          {/* {isAnimating ? (

            &lt;LandMarkPopUp landMarkList={f_markers} /&gt;


          ) : null} */}


          {this.state.mymarkers.map((position) =&gt;
            &lt;Marker 

            position={position}&gt;

            &lt;/Marker&gt;
          )}


        &lt;/Map&gt;




        {isAnimating ? (

          &lt;div className=""mapOverLay""&gt;
            &lt;Grid&gt;
              &lt;Grid.Column floated=""left"" width={5}&gt;
                &lt;div&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Speed: &lt;/strong&gt;{"" ""}
                    {layoutData.speed} km/h
                  &lt;/h3&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Date: &lt;/strong&gt;{"" ""}
                    {layoutData.date}
                  &lt;/h3&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Time: &lt;/strong&gt;{"" ""}
                    {layoutData.time}
                  &lt;/h3&gt;
                &lt;/div&gt;
              &lt;/Grid.Column&gt;
              &lt;Grid.Column width={10}&gt;
                &lt;Button.Group&gt;
                  &lt;Button
                    icon=""backward""
                    content=""Slow Speed""
                    onClick={this.animationBackwardSpeedBtn}
                  /&gt;

                  &lt;Button
                    icon={this.state.icon}
                    content={this.state.content}
                    onClick={this.animationOnOffButton}
                  /&gt;

                  &lt;Button
                    icon=""forward""
                    content=""Fast Speed""
                    onClick={this.animationForwardSpeedBtn}
                  /&gt;
                &lt;/Button.Group&gt;
              &lt;/Grid.Column&gt;
            &lt;/Grid&gt;
          &lt;/div&gt;
        ) : null}




      &lt;/div&gt;
    );
  }
}

export default Maps;
</code></pre>
",""
"48871455","Show message as sent/received in other users window with react","2","<p>I have a prototype chat app in react that I can currently show sent messages in both viewers windows (Agent and User). However, I'm having trouble figuring out how to only show a sent message as sent in one window and received in the other and vice versa. So if the Agent sends a message, it will show with their name and the message in both windows. I'm thinking I need to pass the ""author"" into each ""User messages"" and ""Agent messages"" within App.js, but this doesn't work.</p>

<p><strong>App.js</strong></p>

<pre><code>class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      messages: []
    }
    this.handleNewMessage = this.handleNewMessage.bind(this);
  }

  static propTypes = {
    messages: PropTypes.arrayOf(PropTypes.object)
  }

  handleNewMessage = (text) =&gt; {
    this.setState({
      messages: [...this.state.messages, { me: true, author: ""Me"", body: text},{ me: true, author: ""Agent"", body: text}]
    })
  }
  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;div className=""agentWindow""&gt;
          &lt;Agent messages={this.state.messages} handleNewMessage={this.handleNewMessage} /&gt;
        &lt;/div&gt;
        &lt;div className=""userWindow""&gt;
          &lt;User messages={this.state.messages} handleNewMessage={this.handleNewMessage} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Agent.js</strong>(User.js is the same)</p>

<pre><code>class Agent extends Component {
  render() {
    return (
      &lt;div className=""Agent""&gt;
        &lt;header&gt;
          &lt;p&gt;Agent&lt;/p&gt;
        &lt;/header&gt;
        &lt;MessageList messages={this.props.messages} /&gt;
        &lt;MessageForm onMessageSend={this.props.handleNewMessage} /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Message.js</strong></p>

<pre><code>class Message extends Component {
  static propTypes = {
    author: PropTypes.string,
    body: PropTypes.string.isRequired,
    me: PropTypes.bool
  }

  render() {
    const classes = classNames('Message', {
      log: !this.props.author,
      me: this.props.me
    })

    return (
      &lt;div className={classes}&gt;
        {this.props.author &amp;&amp; (
          &lt;span className=""author""&gt;{this.props.author}:&lt;/span&gt;
        )}
        {this.props.body}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p><strong>MessageList.js</strong></p>

<pre><code>class MessageList extends Component {
  static propTypes = {
    messages: PropTypes.arrayOf(PropTypes.object)
  }

  static defaultProps = {
    messages: [],
  }

  componentDidUpdate = () =&gt; {
    this.node.scrollTop = this.node.scrollHeight
  }

  render() {
    return (
      &lt;div className=""MessageList"" ref={(node) =&gt; (this.node = node)}&gt;
        {this.props.messages &amp;&amp; this.props.messages.map((message, i) =&gt; (
            &lt;Message key={i} {...message} /&gt;
        ))}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p><strong>MessageForm.js</strong></p>

<pre><code>class MessageForm extends Component {
  static propTypes = {
    onMessageSend: PropTypes.func.isRequired,
  }

  componentDidMount = () =&gt; {
    this.input.focus()
  }

  handleFormSubmit = (event) =&gt; {
    event.preventDefault()
    this.props.onMessageSend(this.input.value)
    this.input.value = """"
  }

  render() {
    return (
      &lt;form className=""MessageForm"" onSubmit={this.handleFormSubmit}&gt;
        &lt;div className=""input-container""&gt;
          &lt;input
            type=""text""
            ref={(node) =&gt; (this.input = node)}
            placeholder=""Enter Message...""
          /&gt;
        &lt;/div&gt;
        &lt;div className=""button-container""&gt;
          &lt;button type=""submit""&gt;
            Send
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
","Will you put up MessageForm.js pls?"
"48871455","Show message as sent/received in other users window with react","2","<p>I have a prototype chat app in react that I can currently show sent messages in both viewers windows (Agent and User). However, I'm having trouble figuring out how to only show a sent message as sent in one window and received in the other and vice versa. So if the Agent sends a message, it will show with their name and the message in both windows. I'm thinking I need to pass the ""author"" into each ""User messages"" and ""Agent messages"" within App.js, but this doesn't work.</p>

<p><strong>App.js</strong></p>

<pre><code>class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      messages: []
    }
    this.handleNewMessage = this.handleNewMessage.bind(this);
  }

  static propTypes = {
    messages: PropTypes.arrayOf(PropTypes.object)
  }

  handleNewMessage = (text) =&gt; {
    this.setState({
      messages: [...this.state.messages, { me: true, author: ""Me"", body: text},{ me: true, author: ""Agent"", body: text}]
    })
  }
  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;div className=""agentWindow""&gt;
          &lt;Agent messages={this.state.messages} handleNewMessage={this.handleNewMessage} /&gt;
        &lt;/div&gt;
        &lt;div className=""userWindow""&gt;
          &lt;User messages={this.state.messages} handleNewMessage={this.handleNewMessage} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Agent.js</strong>(User.js is the same)</p>

<pre><code>class Agent extends Component {
  render() {
    return (
      &lt;div className=""Agent""&gt;
        &lt;header&gt;
          &lt;p&gt;Agent&lt;/p&gt;
        &lt;/header&gt;
        &lt;MessageList messages={this.props.messages} /&gt;
        &lt;MessageForm onMessageSend={this.props.handleNewMessage} /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Message.js</strong></p>

<pre><code>class Message extends Component {
  static propTypes = {
    author: PropTypes.string,
    body: PropTypes.string.isRequired,
    me: PropTypes.bool
  }

  render() {
    const classes = classNames('Message', {
      log: !this.props.author,
      me: this.props.me
    })

    return (
      &lt;div className={classes}&gt;
        {this.props.author &amp;&amp; (
          &lt;span className=""author""&gt;{this.props.author}:&lt;/span&gt;
        )}
        {this.props.body}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p><strong>MessageList.js</strong></p>

<pre><code>class MessageList extends Component {
  static propTypes = {
    messages: PropTypes.arrayOf(PropTypes.object)
  }

  static defaultProps = {
    messages: [],
  }

  componentDidUpdate = () =&gt; {
    this.node.scrollTop = this.node.scrollHeight
  }

  render() {
    return (
      &lt;div className=""MessageList"" ref={(node) =&gt; (this.node = node)}&gt;
        {this.props.messages &amp;&amp; this.props.messages.map((message, i) =&gt; (
            &lt;Message key={i} {...message} /&gt;
        ))}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p><strong>MessageForm.js</strong></p>

<pre><code>class MessageForm extends Component {
  static propTypes = {
    onMessageSend: PropTypes.func.isRequired,
  }

  componentDidMount = () =&gt; {
    this.input.focus()
  }

  handleFormSubmit = (event) =&gt; {
    event.preventDefault()
    this.props.onMessageSend(this.input.value)
    this.input.value = """"
  }

  render() {
    return (
      &lt;form className=""MessageForm"" onSubmit={this.handleFormSubmit}&gt;
        &lt;div className=""input-container""&gt;
          &lt;input
            type=""text""
            ref={(node) =&gt; (this.input = node)}
            placeholder=""Enter Message...""
          /&gt;
        &lt;/div&gt;
        &lt;div className=""button-container""&gt;
          &lt;button type=""submit""&gt;
            Send
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
","@RandyCasburn - I've added MessageForm.js to the question."
"48871499","I have a working Chrome react web-audio app. When run in Firefox variables are listed as undefined.Why?","3","<p>This application works perfectly fine in Chrome. When it is run in Firefox the referenced global variables give an error of undefined. I do not understand why nor how to fix it.</p>

<p>If you click the play button after the song loads it plays in Chrome. In Firefox it gives the aforementioned errors. Online version: 
<a href=""http://wktdev.github.io/react_record/"" rel=""nofollow noreferrer"">http://wktdev.github.io/react_record/</a></p>

<pre><code>    let audioContext,
    song,
    mic,
    recorder,
    soundFile,
    audioRecordings = [];

    //__________________________BEGIN helpers


    function stopAllSoundFiles(arr,prop){ // @Stop all sound recordings from playing
        arr.forEach((val)=&gt;{
           val[prop].stop()
        })
    }





    //__________________________END helpers





    //__________________________BEGIN load sound via p5.js


    function preload() { // @preload is required by P5.js
        audioContext = getAudioContext();  
        soundFormats('mp3', 'ogg');
        song = loadSound('audio/song.mp3');
        console.log(song);
    }

    function setup() { // @setup is required by P5.js
        song.setVolume(0.1);

    }

   //___________________________END load sound via p5.js


 //____________________________________BEGIN Timer

    const leftPad = (width, n) =&gt; {

        if ((n + '').length &gt; width) {
            return n;
        }
        const padding = new Array(width).join('0');
        return (padding + n).slice(-width);
    };


    class TimeElapsed extends React.Component {
        getUnits() {
            const seconds = this.props.timeElapsed / 1000;
            return {
                min: Math.floor(seconds / 60).toString(),
                sec: Math.floor(seconds % 60).toString(),
                msec: (seconds % 1).toFixed(3).substring(2)
            };
        }
        render() {
            const units = this.getUnits();
            return (
                &lt;div&gt;
        &lt;span&gt;{leftPad(2, units.min)}:&lt;/span&gt;
        &lt;span&gt;{leftPad(2, units.sec)}.&lt;/span&gt;
        &lt;span&gt;{units.msec}&lt;/span&gt;
        &lt;/div&gt;
            );
        }
    }






    class TimeDisplay extends React.Component {

        constructor(props) {
            super(props)
            this.timer = undefined;
            this.startTime = undefined;


            this.state = {
                isRunning: false,
                timeElapsed: 0
            };

        }

        componentDidMount() {
            this.startCounter();

        }

        componentDidUpdate(prevProps) {
            if (prevProps.isPlaying !== this.props.isPlaying) {
                this.startCounter();
            }
        }

        startCounter() {

            if (this.props.isPlaying) {
                console.log(this.props.isPlaying);
                this.startTime = Date.now();
                this.timer = setInterval(() =&gt; { this.update() }, 10);


            } else {
                console.log(this.props.isPlaying);
                clearInterval(this.timer);
                this.setState({ timeElapsed: 0 });
            }
        }

        update() {
            const delta = Date.now() - this.startTime;
            this.setState({ timeElapsed: this.state.timeElapsed + delta });
            this.startTime = Date.now();
        }





        render() {


            return (
            &lt;div id=""time-display""&gt;   
              &lt;TimeElapsed  timeElapsed={this.state.timeElapsed} /&gt;
            &lt;/div&gt;
            )
        }

    }


    //______________________________________END Timer


    class Button extends React.Component {
        constructor(props) {
            super(props)
        }

        render() {

            let recordingButton = {

            }

            let changeColor = {
                color: ""red"",

            }

            if (this.props.isRecording) {
                recordingButton = changeColor
            } else {
                recordingButton = {}
            }


            return (&lt;button style={recordingButton} onClick={this.props.onClick}&gt;{this.props.buttonText}&lt;/button&gt;)
        }
    }




    class App extends React.Component {

        constructor(props) {
            super(props)
            this.playStartCurrentTime;
            this.recordStartCurrentTime;
            this.recordEndCurrentTime;

            this.toggleSongPlaying = this.toggleSongPlaying.bind(this);
            this.toggleRecording = this.toggleRecording.bind(this);
            this.checkedToPlay = this.checkedToPlay.bind(this);
            this.cueSelectedRecordingsToPlay = this.cueSelectedRecordingsToPlay.bind(this);


            this.state = {
                audioRecordings:[], // {timestamp: 0, sound: p5.SoundFile, checkedToPlay: false}
                isPlaying: false,
                isRecording: false,
                recordButtonText: ""Start Recording"",
                playButtonText: ""Play Song"",
            }

        }

        cueSelectedRecordingsToPlay(arr = this.state.audioRecordings){

            arr.forEach((val)=&gt;{
                console.log(""Time stamps: "" + val.timestamp);
               if(val.checkedToPlay){
                   val.sound.play(val.timestamp)
               }
            })
        }



        toggleSongPlaying() {
            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });

               this.playStartCurrentTime = audioContext.currentTime;
               console.log(this.playStartCurrentTime);
               this.cueSelectedRecordingsToPlay();
               song.play()

            } else {

                this.setState({
                    isPlaying: false,
                    playButtonText: ""Play Song""
                })

                //___________________________BEGIN if recording when playing stops... then stop recording too

                if(this.state.isRecording){
                      this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();






                //_____________________________BEGIN update state
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state



                //___________________________END if recording when playing stops... then stop recording too


                }

                stopAllSoundFiles(this.state.audioRecordings,'sound');



                song.stop();

            }

        }


        toggleRecording() {

            var isRecording = this.state.isRecording;
            if (!isRecording) {

                this.setState({
                    isRecording: true,

                    recordButtonText: ""Stop Recording"",
                });

               this.cueSelectedRecordingsToPlay();

                // audioRecorder.record();
                mic = new p5.AudioIn();
                mic.start();
                recorder = new p5.SoundRecorder();
                recorder.setInput(mic);
                soundFile = new p5.SoundFile();
                this.recordStartCurrentTime = audioContext.currentTime
                recorder.record(soundFile);




            } else {

                this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();

                console.log();
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);


                //_____________________________BEGIN update state

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state


                // save(soundFile, 'mySound.wav');
            }


            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });


                this.playStartCurrentTime = audioContext.currentTime;
                console.log(this.playStartCurrentTime);
                song.play();
            }
        }

        checkedToPlay(index){
            let arrayTemp = this.state.audioRecordings;
            if(!arrayTemp[index].checkedToPlay){
                arrayTemp[index].checkedToPlay = true;
            }else{
                arrayTemp[index].checkedToPlay = false;
            }

            this.setState({
                audioRecordings:arrayTemp
            })

            console.log(this.state.audioRecordings[index].checkedToPlay);

        }



        render() {

            console.log(this.state.audioRecordings);
            const mainContainer = {
                width: ""700px"",
                margin: ""0 auto"",
                height: ""300px"",
                outlineStyle: ""solid""
            }

           let listRecordings = this.state.audioRecordings.map((val,index)=&gt;{
                   return &lt;li key={index}&gt;recording number: {index+1} timestamp: {val.timestamp} | PLAY &lt;input type='checkbox' onChange={()=&gt;this.checkedToPlay(index)}&gt;&lt;/input&gt;&lt;/li&gt;
           })

            return (
            &lt;main style = {mainContainer}&gt; 

                 &lt;section&gt;
                    &lt;div className=""buttonContainer""&gt;
                      &lt;TimeDisplay isPlaying = {this.state.isPlaying}/&gt;
                      &lt;Button buttonText = {this.state.recordButtonText} onClick={this.toggleRecording} isRecording={this.state.isRecording}/&gt; 
                      &lt;Button buttonText = {this.state.playButtonText} onClick={this.toggleSongPlaying} /&gt;
                    &lt;/div&gt;
                 &lt;/section&gt;

                 &lt;ul&gt;
                  {listRecordings}
                 &lt;/ul&gt;

            &lt;/main&gt;

            )
        }
    }



    ReactDOM.render(
        &lt;div&gt;
        &lt;App/&gt;
    &lt;/div&gt;,
        document.getElementById(""root""))
</code></pre>
","Please post a [mcve] that demonstrates the problem."
"48871499","I have a working Chrome react web-audio app. When run in Firefox variables are listed as undefined.Why?","3","<p>This application works perfectly fine in Chrome. When it is run in Firefox the referenced global variables give an error of undefined. I do not understand why nor how to fix it.</p>

<p>If you click the play button after the song loads it plays in Chrome. In Firefox it gives the aforementioned errors. Online version: 
<a href=""http://wktdev.github.io/react_record/"" rel=""nofollow noreferrer"">http://wktdev.github.io/react_record/</a></p>

<pre><code>    let audioContext,
    song,
    mic,
    recorder,
    soundFile,
    audioRecordings = [];

    //__________________________BEGIN helpers


    function stopAllSoundFiles(arr,prop){ // @Stop all sound recordings from playing
        arr.forEach((val)=&gt;{
           val[prop].stop()
        })
    }





    //__________________________END helpers





    //__________________________BEGIN load sound via p5.js


    function preload() { // @preload is required by P5.js
        audioContext = getAudioContext();  
        soundFormats('mp3', 'ogg');
        song = loadSound('audio/song.mp3');
        console.log(song);
    }

    function setup() { // @setup is required by P5.js
        song.setVolume(0.1);

    }

   //___________________________END load sound via p5.js


 //____________________________________BEGIN Timer

    const leftPad = (width, n) =&gt; {

        if ((n + '').length &gt; width) {
            return n;
        }
        const padding = new Array(width).join('0');
        return (padding + n).slice(-width);
    };


    class TimeElapsed extends React.Component {
        getUnits() {
            const seconds = this.props.timeElapsed / 1000;
            return {
                min: Math.floor(seconds / 60).toString(),
                sec: Math.floor(seconds % 60).toString(),
                msec: (seconds % 1).toFixed(3).substring(2)
            };
        }
        render() {
            const units = this.getUnits();
            return (
                &lt;div&gt;
        &lt;span&gt;{leftPad(2, units.min)}:&lt;/span&gt;
        &lt;span&gt;{leftPad(2, units.sec)}.&lt;/span&gt;
        &lt;span&gt;{units.msec}&lt;/span&gt;
        &lt;/div&gt;
            );
        }
    }






    class TimeDisplay extends React.Component {

        constructor(props) {
            super(props)
            this.timer = undefined;
            this.startTime = undefined;


            this.state = {
                isRunning: false,
                timeElapsed: 0
            };

        }

        componentDidMount() {
            this.startCounter();

        }

        componentDidUpdate(prevProps) {
            if (prevProps.isPlaying !== this.props.isPlaying) {
                this.startCounter();
            }
        }

        startCounter() {

            if (this.props.isPlaying) {
                console.log(this.props.isPlaying);
                this.startTime = Date.now();
                this.timer = setInterval(() =&gt; { this.update() }, 10);


            } else {
                console.log(this.props.isPlaying);
                clearInterval(this.timer);
                this.setState({ timeElapsed: 0 });
            }
        }

        update() {
            const delta = Date.now() - this.startTime;
            this.setState({ timeElapsed: this.state.timeElapsed + delta });
            this.startTime = Date.now();
        }





        render() {


            return (
            &lt;div id=""time-display""&gt;   
              &lt;TimeElapsed  timeElapsed={this.state.timeElapsed} /&gt;
            &lt;/div&gt;
            )
        }

    }


    //______________________________________END Timer


    class Button extends React.Component {
        constructor(props) {
            super(props)
        }

        render() {

            let recordingButton = {

            }

            let changeColor = {
                color: ""red"",

            }

            if (this.props.isRecording) {
                recordingButton = changeColor
            } else {
                recordingButton = {}
            }


            return (&lt;button style={recordingButton} onClick={this.props.onClick}&gt;{this.props.buttonText}&lt;/button&gt;)
        }
    }




    class App extends React.Component {

        constructor(props) {
            super(props)
            this.playStartCurrentTime;
            this.recordStartCurrentTime;
            this.recordEndCurrentTime;

            this.toggleSongPlaying = this.toggleSongPlaying.bind(this);
            this.toggleRecording = this.toggleRecording.bind(this);
            this.checkedToPlay = this.checkedToPlay.bind(this);
            this.cueSelectedRecordingsToPlay = this.cueSelectedRecordingsToPlay.bind(this);


            this.state = {
                audioRecordings:[], // {timestamp: 0, sound: p5.SoundFile, checkedToPlay: false}
                isPlaying: false,
                isRecording: false,
                recordButtonText: ""Start Recording"",
                playButtonText: ""Play Song"",
            }

        }

        cueSelectedRecordingsToPlay(arr = this.state.audioRecordings){

            arr.forEach((val)=&gt;{
                console.log(""Time stamps: "" + val.timestamp);
               if(val.checkedToPlay){
                   val.sound.play(val.timestamp)
               }
            })
        }



        toggleSongPlaying() {
            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });

               this.playStartCurrentTime = audioContext.currentTime;
               console.log(this.playStartCurrentTime);
               this.cueSelectedRecordingsToPlay();
               song.play()

            } else {

                this.setState({
                    isPlaying: false,
                    playButtonText: ""Play Song""
                })

                //___________________________BEGIN if recording when playing stops... then stop recording too

                if(this.state.isRecording){
                      this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();






                //_____________________________BEGIN update state
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state



                //___________________________END if recording when playing stops... then stop recording too


                }

                stopAllSoundFiles(this.state.audioRecordings,'sound');



                song.stop();

            }

        }


        toggleRecording() {

            var isRecording = this.state.isRecording;
            if (!isRecording) {

                this.setState({
                    isRecording: true,

                    recordButtonText: ""Stop Recording"",
                });

               this.cueSelectedRecordingsToPlay();

                // audioRecorder.record();
                mic = new p5.AudioIn();
                mic.start();
                recorder = new p5.SoundRecorder();
                recorder.setInput(mic);
                soundFile = new p5.SoundFile();
                this.recordStartCurrentTime = audioContext.currentTime
                recorder.record(soundFile);




            } else {

                this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();

                console.log();
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);


                //_____________________________BEGIN update state

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state


                // save(soundFile, 'mySound.wav');
            }


            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });


                this.playStartCurrentTime = audioContext.currentTime;
                console.log(this.playStartCurrentTime);
                song.play();
            }
        }

        checkedToPlay(index){
            let arrayTemp = this.state.audioRecordings;
            if(!arrayTemp[index].checkedToPlay){
                arrayTemp[index].checkedToPlay = true;
            }else{
                arrayTemp[index].checkedToPlay = false;
            }

            this.setState({
                audioRecordings:arrayTemp
            })

            console.log(this.state.audioRecordings[index].checkedToPlay);

        }



        render() {

            console.log(this.state.audioRecordings);
            const mainContainer = {
                width: ""700px"",
                margin: ""0 auto"",
                height: ""300px"",
                outlineStyle: ""solid""
            }

           let listRecordings = this.state.audioRecordings.map((val,index)=&gt;{
                   return &lt;li key={index}&gt;recording number: {index+1} timestamp: {val.timestamp} | PLAY &lt;input type='checkbox' onChange={()=&gt;this.checkedToPlay(index)}&gt;&lt;/input&gt;&lt;/li&gt;
           })

            return (
            &lt;main style = {mainContainer}&gt; 

                 &lt;section&gt;
                    &lt;div className=""buttonContainer""&gt;
                      &lt;TimeDisplay isPlaying = {this.state.isPlaying}/&gt;
                      &lt;Button buttonText = {this.state.recordButtonText} onClick={this.toggleRecording} isRecording={this.state.isRecording}/&gt; 
                      &lt;Button buttonText = {this.state.playButtonText} onClick={this.toggleSongPlaying} /&gt;
                    &lt;/div&gt;
                 &lt;/section&gt;

                 &lt;ul&gt;
                  {listRecordings}
                 &lt;/ul&gt;

            &lt;/main&gt;

            )
        }
    }



    ReactDOM.render(
        &lt;div&gt;
        &lt;App/&gt;
    &lt;/div&gt;,
        document.getElementById(""root""))
</code></pre>
","I am not sure why that is, when I run it locally it is not an issue. When I refresh the github link it loads the file and runs."
"48871499","I have a working Chrome react web-audio app. When run in Firefox variables are listed as undefined.Why?","3","<p>This application works perfectly fine in Chrome. When it is run in Firefox the referenced global variables give an error of undefined. I do not understand why nor how to fix it.</p>

<p>If you click the play button after the song loads it plays in Chrome. In Firefox it gives the aforementioned errors. Online version: 
<a href=""http://wktdev.github.io/react_record/"" rel=""nofollow noreferrer"">http://wktdev.github.io/react_record/</a></p>

<pre><code>    let audioContext,
    song,
    mic,
    recorder,
    soundFile,
    audioRecordings = [];

    //__________________________BEGIN helpers


    function stopAllSoundFiles(arr,prop){ // @Stop all sound recordings from playing
        arr.forEach((val)=&gt;{
           val[prop].stop()
        })
    }





    //__________________________END helpers





    //__________________________BEGIN load sound via p5.js


    function preload() { // @preload is required by P5.js
        audioContext = getAudioContext();  
        soundFormats('mp3', 'ogg');
        song = loadSound('audio/song.mp3');
        console.log(song);
    }

    function setup() { // @setup is required by P5.js
        song.setVolume(0.1);

    }

   //___________________________END load sound via p5.js


 //____________________________________BEGIN Timer

    const leftPad = (width, n) =&gt; {

        if ((n + '').length &gt; width) {
            return n;
        }
        const padding = new Array(width).join('0');
        return (padding + n).slice(-width);
    };


    class TimeElapsed extends React.Component {
        getUnits() {
            const seconds = this.props.timeElapsed / 1000;
            return {
                min: Math.floor(seconds / 60).toString(),
                sec: Math.floor(seconds % 60).toString(),
                msec: (seconds % 1).toFixed(3).substring(2)
            };
        }
        render() {
            const units = this.getUnits();
            return (
                &lt;div&gt;
        &lt;span&gt;{leftPad(2, units.min)}:&lt;/span&gt;
        &lt;span&gt;{leftPad(2, units.sec)}.&lt;/span&gt;
        &lt;span&gt;{units.msec}&lt;/span&gt;
        &lt;/div&gt;
            );
        }
    }






    class TimeDisplay extends React.Component {

        constructor(props) {
            super(props)
            this.timer = undefined;
            this.startTime = undefined;


            this.state = {
                isRunning: false,
                timeElapsed: 0
            };

        }

        componentDidMount() {
            this.startCounter();

        }

        componentDidUpdate(prevProps) {
            if (prevProps.isPlaying !== this.props.isPlaying) {
                this.startCounter();
            }
        }

        startCounter() {

            if (this.props.isPlaying) {
                console.log(this.props.isPlaying);
                this.startTime = Date.now();
                this.timer = setInterval(() =&gt; { this.update() }, 10);


            } else {
                console.log(this.props.isPlaying);
                clearInterval(this.timer);
                this.setState({ timeElapsed: 0 });
            }
        }

        update() {
            const delta = Date.now() - this.startTime;
            this.setState({ timeElapsed: this.state.timeElapsed + delta });
            this.startTime = Date.now();
        }





        render() {


            return (
            &lt;div id=""time-display""&gt;   
              &lt;TimeElapsed  timeElapsed={this.state.timeElapsed} /&gt;
            &lt;/div&gt;
            )
        }

    }


    //______________________________________END Timer


    class Button extends React.Component {
        constructor(props) {
            super(props)
        }

        render() {

            let recordingButton = {

            }

            let changeColor = {
                color: ""red"",

            }

            if (this.props.isRecording) {
                recordingButton = changeColor
            } else {
                recordingButton = {}
            }


            return (&lt;button style={recordingButton} onClick={this.props.onClick}&gt;{this.props.buttonText}&lt;/button&gt;)
        }
    }




    class App extends React.Component {

        constructor(props) {
            super(props)
            this.playStartCurrentTime;
            this.recordStartCurrentTime;
            this.recordEndCurrentTime;

            this.toggleSongPlaying = this.toggleSongPlaying.bind(this);
            this.toggleRecording = this.toggleRecording.bind(this);
            this.checkedToPlay = this.checkedToPlay.bind(this);
            this.cueSelectedRecordingsToPlay = this.cueSelectedRecordingsToPlay.bind(this);


            this.state = {
                audioRecordings:[], // {timestamp: 0, sound: p5.SoundFile, checkedToPlay: false}
                isPlaying: false,
                isRecording: false,
                recordButtonText: ""Start Recording"",
                playButtonText: ""Play Song"",
            }

        }

        cueSelectedRecordingsToPlay(arr = this.state.audioRecordings){

            arr.forEach((val)=&gt;{
                console.log(""Time stamps: "" + val.timestamp);
               if(val.checkedToPlay){
                   val.sound.play(val.timestamp)
               }
            })
        }



        toggleSongPlaying() {
            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });

               this.playStartCurrentTime = audioContext.currentTime;
               console.log(this.playStartCurrentTime);
               this.cueSelectedRecordingsToPlay();
               song.play()

            } else {

                this.setState({
                    isPlaying: false,
                    playButtonText: ""Play Song""
                })

                //___________________________BEGIN if recording when playing stops... then stop recording too

                if(this.state.isRecording){
                      this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();






                //_____________________________BEGIN update state
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state



                //___________________________END if recording when playing stops... then stop recording too


                }

                stopAllSoundFiles(this.state.audioRecordings,'sound');



                song.stop();

            }

        }


        toggleRecording() {

            var isRecording = this.state.isRecording;
            if (!isRecording) {

                this.setState({
                    isRecording: true,

                    recordButtonText: ""Stop Recording"",
                });

               this.cueSelectedRecordingsToPlay();

                // audioRecorder.record();
                mic = new p5.AudioIn();
                mic.start();
                recorder = new p5.SoundRecorder();
                recorder.setInput(mic);
                soundFile = new p5.SoundFile();
                this.recordStartCurrentTime = audioContext.currentTime
                recorder.record(soundFile);




            } else {

                this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();

                console.log();
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);


                //_____________________________BEGIN update state

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state


                // save(soundFile, 'mySound.wav');
            }


            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });


                this.playStartCurrentTime = audioContext.currentTime;
                console.log(this.playStartCurrentTime);
                song.play();
            }
        }

        checkedToPlay(index){
            let arrayTemp = this.state.audioRecordings;
            if(!arrayTemp[index].checkedToPlay){
                arrayTemp[index].checkedToPlay = true;
            }else{
                arrayTemp[index].checkedToPlay = false;
            }

            this.setState({
                audioRecordings:arrayTemp
            })

            console.log(this.state.audioRecordings[index].checkedToPlay);

        }



        render() {

            console.log(this.state.audioRecordings);
            const mainContainer = {
                width: ""700px"",
                margin: ""0 auto"",
                height: ""300px"",
                outlineStyle: ""solid""
            }

           let listRecordings = this.state.audioRecordings.map((val,index)=&gt;{
                   return &lt;li key={index}&gt;recording number: {index+1} timestamp: {val.timestamp} | PLAY &lt;input type='checkbox' onChange={()=&gt;this.checkedToPlay(index)}&gt;&lt;/input&gt;&lt;/li&gt;
           })

            return (
            &lt;main style = {mainContainer}&gt; 

                 &lt;section&gt;
                    &lt;div className=""buttonContainer""&gt;
                      &lt;TimeDisplay isPlaying = {this.state.isPlaying}/&gt;
                      &lt;Button buttonText = {this.state.recordButtonText} onClick={this.toggleRecording} isRecording={this.state.isRecording}/&gt; 
                      &lt;Button buttonText = {this.state.playButtonText} onClick={this.toggleSongPlaying} /&gt;
                    &lt;/div&gt;
                 &lt;/section&gt;

                 &lt;ul&gt;
                  {listRecordings}
                 &lt;/ul&gt;

            &lt;/main&gt;

            )
        }
    }



    ReactDOM.render(
        &lt;div&gt;
        &lt;App/&gt;
    &lt;/div&gt;,
        document.getElementById(""root""))
</code></pre>
","Hmm working now. Not sure what was wrong the first time."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Sidney Unfortunately, I have tried with that and it doesn't work."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","sounds like `ConnectedReduxForm` just needs to implement [`shouldComponentUpdate`](https://reactjs.org/docs/react-component.html#shouldcomponentupdate)"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","Prehaps you need to apply the `key` to the DOM element that `ConnectedReduxForm` returns?"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","Can you post your complete code somewhere? My feeling is that the parent component was unmounted and mounted again, but I can't be sure without trying the code myself."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@leuction If returning `false` from `shouldComponentUpdate` doesn't work, the re-render is likely being caused by a class decorator (probably Redux's `connect` decorator). You should post the source for `ConnectedReduxForm`."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Hamms I have tried with set the shouldComponentUpdate function return false, and it doesn't work. Furthermore, the ConntectedReduxForm have been unmounted, I think there is nothing to do with the update."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@SimpleJ I just tried to directly import MyReduxForm instead connect the redux. shouldComponentUpdate doesn't work. it is quite wired."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@brickingup Hello, I have just uploaded all the code. But I think that the parent component has not been re-mounted."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","`shouldComponentUpdate` should only return false if the component shouldn't update. It seems like you want the component to update only when its schemaName changes, so your `shouldComponentUpdate` method should reflect that"
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","@Hamms I just return false for the test. The problem is I have no way to prevent the schemaForm to re-mount. All of three schemaForm are re-mounted. the multipleForm is not."
"49060982","How to avoid rerendering element in the array in react?","11","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","One thing I noticed is that in MultipleForm you put 'key' in SchemaForm while you should put it in Element. This may be the issue because each time MultipleForm re-renders Element will be re-mounted. So SchemaForm will also be re-mounted regardless of it's key."
"49216273","using shallow compare isEqual in componentDidUpdate","8","<p>in somewhere you did </p>

<pre><code>this.setState({ tableTH: this.state.tableTH === 'asc' ? 'desc' : 'asc' })
</code></pre>

<p>and you want to do another action, like recall the api, how would u do it? There's 2 way, the first one is to use the second argument of setState method, like this</p>

<pre><code>this.setState({ tableTH: this.state.tableTH === 'asc' ? 'desc' : 'asc' }, () =&gt; this.callAPI())
</code></pre>

<p>but this can be messy says you have many many setState, this make ur code hard to read if the logic is complicated.</p>

<p>Use componentDidUpdate</p>

<pre><code>componentDidUpdate(prevProps, prevState) {
   if(!isEqual(prevState.tableTH, this.state.tableTH)){ //let's assume tableTH state is an object
      this.callAPI() 
   }
}
</code></pre>

<p>Above code worked the same, assume tableTH is a object this will still work. But is it ok to use isEqual from lodash? Will this make the operation expensive? What about nested Object? Deep equal comparison will look like this</p>

<pre><code>_.differenceWith(prevState.tableTH, this.state.tableTH, _.isEqual);
</code></pre>
","Also, your question says `componentDidUpdate`, but that lifecycle method is called after the render. I would advise to read the [docs](https://reactjs.org/docs/react-component.html#componentdidupdate) to get a proper handle of how the lifecycle methods work."
"49248680","Flow Type complains about class property assigned via react ref","0","<p>I've started using Flow type on top of a project created with create-react-app tool. I struggle to make a simple scenario work where a class property is filled with element reference in render method but throws 2 errors. What am I doing wrong? All the checks should prevent those warnings.</p>

<pre><code>class MyComponent extends React.Component&lt;*&gt; {
  input: ?HTMLInputElement;

  componentDidUpdate = () =&gt; {
    if (this.input) {
        this.input.focus();
        if (this.input.value) {
            const valueLength = this.input.value.length;
            this.input.setSelectionRange(valueLength, valueLength);
        }
    }
  };

  render() {
    return &lt;input ref={ref =&gt; (this.input = ref)} /&gt;;
  }
}

     Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ src/todo/index.js:38:28

 Property value is missing in null or undefined [1].

  [1] 33│     input: ?HTMLInputElement;
      34│
      35│     componentDidUpdate = () =&gt; {
      36│         if (this.input) {
      37│             this.input.focus();
      38│             if (this.input.value) {
      39│                 const valueLength = this.input.value.length;
      40│                 this.input.setSelectionRange(valueLength, valueLength);
      41│             }


 Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ src/todo/index.js:40:28

 Cannot call this.input.setSelectionRange because property setSelectionRange is missing in null or undefined [1].

  [1] 33│     input: ?HTMLInputElement;
      34│
      35│     componentDidUpdate = () =&gt; {
      36│         if (this.input) {
      37│             this.input.focus();
      38│             if (this.input.value) {
      39│                 const valueLength = this.input.value.length;
      40│                 this.input.setSelectionRange(valueLength, valueLength);
      41│             }
      42│         }
      43│     };
</code></pre>
",""
"49249563","react generic component or component as attribute","0","<p>Hello I'm trying to have a generic ""component"" that toggles a class, think of it as tabs but I dont want a fixed markup on it, so I was thinking to use attributes to manage the initialization.</p>

<p>For example this code should initialize on the , clicking on it will toggle the .active class on .target.</p>

<pre><code>&lt;button data-toggle="".active"" data-target="".target""&gt;button&lt;/button&gt;
&lt;div class=""target""&gt;&lt;/div&gt;
</code></pre>

<p>The problem is that I need to initialize the data attributes with componentDidMount() and componentDidUpdate() but I can't specify it on all components, is it possible to have a global componentDidMount() for all the app? or is it possible to assign a ""generic component"" with the attribute? What's the best way to proceed?</p>

<p>I want to use attributes because I need to keep it generic, I don't want to setup a component with  etc..</p>

<p>EDIT</p>

<p>I was thinking about using componentDidMount and componentDidUpdate on the main component app, since this methods seems to fire after all chidrens have done mounting or updating, there maybe I can query the attributes.. More to come</p>

<p>EDIT2</p>

<p>Well I think the right solution is to use react components and inside them initialize the vanilla js classes imported inside the component, it should work I don't know why I didn't think about that before</p>
",""
"49261175","Uncaught TypeError: Cannot read property 'addEventListener' of null on react","0","<p>I have a problem with react. I'd create 2 files : </p>

<p>select.js :</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import reactDOM from 'react-dom';
import Select from 'react-select';
import Media from '../media/media';
import Form from '../fields/form.js';

class Select_galery extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input : ''
    }
    this.handleChange = this.handleChange.bind(this);
    this.state.selectValue = this.props.value ? this.props.value.select : 'true';
  }

  handleChange(event){
  this.setState({selectValue:event.target.value});
}



  render() {
    let url_youtube = this.props.name+'[url]';
    let id_youtube = this.props.id+'[url]';
    let value_youtube = this.props.value ? this.props.value.url : '';
    let name_select = this.props.name+'[select]';
    let name_img = this.props.name+'[image]';
    let id_img = this.props.id+'[image]';
    // let url_img = this.props.url+'[image][url]';
    if(this.state.selectValue == 'true'){
      this.state.input = &lt;Media name={name_img} id={id_img} /&gt;;
    }else{
      this.state.input = &lt;div&gt;&lt;label htmlFor={id_youtube}&gt;Url Video&lt;/label&gt;&lt;input id={id_youtube} type='text' name={url_youtube} defaultValue={value_youtube} className=""widefat""/&gt;&lt;/div&gt;;
    }
    return (
      /* NE PAS OUBLIER LE FOR !!!! */
       &lt;label htmlFor={this.props.id}&gt;{this.props.label}
          {this.state.selectValue}
         &lt;select defaultValue={this.state.selectValue}  id={this.props.id} className=""widefat"" name={name_select} onChange={this.handleChange.bind(this)}&gt;
           &lt;option value=""true""&gt;Image&lt;/option&gt;
           &lt;option value=""false""&gt;Video&lt;/option&gt;
         &lt;/select&gt;
        {this.state.input}
       &lt;/label&gt;
    );
  }
}
export default Select_galery;
</code></pre>

<p>And Media.js :</p>

<pre><code>import React from 'react';
import './media.scss';

class Media extends React.Component {
    constructor(props) {
        super(props);

        /*
         * Default state.
         * We can set the default state based on given props.
         */
        let hasMedia = false;

        if (props.value) {
            hasMedia = !!props.value.id;
        }

        this.state = {
            hasMedia: hasMedia,
            media: {
                id: props.value ? props.value.id : '',
                url: props.value ? props.value.url : '',
                name: props.value ? props.value.name : ''
            },
        };

        /*
         * Bindings.
         */
        this.addImage = this.addImage.bind(this);
        this.removeImage = this.removeImage.bind(this);
        this.select = this.select.bind(this);

        /*
         * Get a WordPress media frame.
         */
        this.wpframe = wp.media({
            // Define behaviour of the media window.
            // 'post' if related to a WordPress post.
            // 'select' if use outside WordPress post.
            frame: 'select',
            // Allow or not multiple selection.
            multiple: false,
            // The displayed title.
            title: 'Insérer Media',
            // The button behaviour
            button: {
                text: 'Insérer',
                close: true
            },
            // Type of files shown in the library.
            // 'image', 'application' (pdf, doc,...)
            /*library:{
                type: props.type ? props.type : 'image'
            }*/
        });

        // Attach an event on select. Runs when ""insert"" button is clicked.
        this.wpframe.on('select', this.select);
    }


    /**
     * Handle click on the button and open the WordPress
     * media library modal in order to fetch an image from
     * the media library. The returned ""attachment id"" value
     * is then set to the hidden input value attribute.
     *
     */
    addImage() {
        /*
         * Open the media modal.
         */
        this.wpframe.open();
    }

    /**
     * Return the selected attachment object.
     */
    select() {
        let selection = this.wpframe.state().get('selection').first(),
            type = selection.get('type'),
            id = selection.get('id'),
            thumbUrl = selection.get('icon'), // Default image url to icon.
            sizes = selection.get('sizes');

        /*
         * We receive a BackboneJs Model instance (selection).
         * Now we need to update the component in order to show the selected
         * thumbnail and populate the hidden field value with the ""id"" of the attachment.
         */
        if ('image' === type)
        {
            if (typeof sizes.thumbnail !== 'undefined') {
                thumbUrl = sizes.thumbnail.url;
            }
        }

        /*
         * We need to change the state in order
         * to force React to render the component.
         */
        this.setState({
            hasMedia: true,
            media: {
                id: id,
                url: thumbUrl,
                name: selection.get('filename')
            }
        });
    }

    /**
     * Remove the chosen image.
     * This reset the component state and force re-rendering.
     */
    removeImage() {
        this.setState({
            hasMedia: false,
            media: {
                id: '',
                url: '',
                name: ''
            }
        });
    }

    /**
     * Render a label if defined.
     *
     * @returns {*}
     */
    renderHeader() {
        if (this.props.label) {
            return (
                &lt;div className=""media-component-header""&gt;
                    &lt;h4&gt;{this.props.label}&lt;/h4&gt;
                &lt;/div&gt;
            );
        }

        return '';
    }

    /**
     * Render the media component footer.
     *
     * @returns {*}
     */
    renderFooter() {
        if (!this.props.info) {
            return '';
        }

        return (
            &lt;div className=""media-component-footer""&gt;
                &lt;p className=""description""&gt;{this.props.info}&lt;/p&gt;
            &lt;/div&gt;
        );
    }

    /**
     * Render the media component.
     * If there is a media, show the media details with a preview,
     * else only display an ""Add Image"" button.
     *
     * @returns {XML}
     */
    render() {
        if (this.state.hasMedia) {
            return (
                &lt;div ref={(domElem) =&gt; { this.domElem = domElem; }} className=""media-component""&gt;
                    {this.renderHeader()}
                    &lt;div&gt;
                        &lt;div className=""media-inner-wrapper""&gt;
                            &lt;div className=""media-preview""&gt;
                                &lt;div className=""centered""&gt;
                                    &lt;img className=""media-thumbnail"" alt=""Media Thumbnail"" src={this.state.media.url}/&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className=""media-tools""&gt;
                                &lt;div className=""media-infos""&gt;
                                    &lt;h4&gt;Nom du fichier&lt;/h4&gt;
                                    &lt;p className=""media-filename""&gt;{this.state.media.name}&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div className=""media-buttons""&gt;
                                    &lt;button type=""button""
                                            className=""button button-remove""
                                            onClick={this.removeImage}&gt;Supprimer&lt;/button&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[id]`} value={this.state.media.id}/&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[url]`} value={this.state.media.url}/&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[name]`} value={this.state.media.name}/&gt;
                    &lt;/div&gt;
                    {this.renderFooter()}
                &lt;/div&gt;
            );
        }
        return (
            &lt;div className=""media-component""&gt;
                {this.renderHeader()}
                &lt;button type=""button""
                        className=""button button-primary""
                        onClick={this.addImage}&gt;Ajouter&lt;/button&gt;
                {this.renderFooter()}
            &lt;/div&gt;
        );
    }

    /**
     * We update the DOM hidden inputs define into the parent
     * container of our media component.
     *
     * @param prevProps
     * @param prevState
     */
    componentDidUpdate(prevProps, prevState) {
        /*
         * The ""this.domElem"" property is only defined
         * when we add an image... otherwise it is null.
         *
         * We the user add/attach an image, we need to update the
         * dom hidden inputs next to our component.
         */
        if (this.domElem) {
            let parent = this.domElem.parentElement.parentElement,
                idInput = parent.querySelector('input.image-id'),
                urlInput = parent.querySelector('input.image-url'),
                nameInput = parent.querySelector('input.image-name');

            /*
             * Let's update the value attribute of each DOM hidden input.
             */
            if (idInput || urlInput || nameInput) {
                idInput.setAttribute('value', this.state.media.id);
                urlInput.setAttribute('value', this.state.media.url);
                nameInput.setAttribute('value', this.state.media.name);
            }
        }
    }
}

export default Media;
</code></pre>

<p>When I select an image in Worpdress and save it, i've got the error message : </p>

<p>Uncaught TypeError: Cannot read property 'addEventListener' of null</p>

<p><a href=""https://i.stack.imgur.com/TyaSU.png"" rel=""nofollow noreferrer"">When I select the image</a></p>

<p><a href=""https://i.stack.imgur.com/LSDHd.png"" rel=""nofollow noreferrer"">When I updated my post</a></p>

<p><a href=""https://i.stack.imgur.com/6TfoV.png"" rel=""nofollow noreferrer"">In the Database</a></p>

<p>If you need more informations, ask me ;)</p>
",""
"49410221","google-maps-react and how to transform javascript code in react Components","0","<p>I have a small app using google-maps-react, I have added a rightclick event on map, but I m stuck now and I do not think I am in the right direction. My addNewMarker method has a InfoWindow with a button, which I want to use to call web api with a POST request. Is there a way to refactor the code in a pure react? </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';


export default class MapContainer extends Component {

    state = {
        locations: [
            { name: ""New York County Supreme Court"", location: { lat: 40.7143033, lng: -74.0036919 } },
            { name: ""Queens County Supreme Court"", location: { lat: 40.7046946, lng: -73.8091145 } },
            { name: ""Kings County Supreme Court"", location: { lat: 40.6940226, lng: -73.9890967 } },
            { name: ""Richmond County Supreme Court"", location: { lat: 40.6412336, lng: -74.0768597 } },
            { name: ""Bronx Supreme Court"", location: { lat: 40.8262388, lng: -73.9235238 } }
        ]
    }

    componentDidUpdate() {
        this.loadMap(); // call loadMap function to load the google map
    }



    loadMap() {
        if (this.props &amp;&amp; this.props.google) { // checks to make sure that props have been passed
            const { google } = this.props; // sets props equal to google
            const maps = google.maps; // sets maps to google maps props

            const mapRef = this.refs.map; // looks for HTML div ref 'map'. Returned in render below.
            const node = ReactDOM.findDOMNode(mapRef); // finds the 'map' div in the React DOM, names it node

            const mapConfig = Object.assign({}, {
                center: { lat: 40.7485722, lng: -74.0068633 }, // sets center of google map to NYC.
                zoom: 11, // sets zoom. Lower numbers are zoomed further out.
                mapTypeId: 'roadmap' // optional main map layer. Terrain, satellite, hybrid or roadmap--if unspecified, defaults to roadmap.
            })

            this.map = new maps.Map(node, mapConfig); // creates a new Google map on the specified node (ref='map') with the specified configuration set above.
            this.map.addListener('rightclick', (evt) =&gt; {
                this.addNewMarker(this.map, maps, evt);
            })

            // ==================
            // ADD MARKERS TO MAP
            // ==================
            this.state.locations.forEach(location =&gt; { // iterate through locations saved in state
                const marker = new maps.Marker({ // creates a new Google maps Marker object.
                    position: { lat: location.location.lat, lng: location.location.lng }, // sets position of marker to specified location
                    map: this.map, // sets markers to appear on the map we just created on line 35
                    title: location.name // the title of the marker is set to the name of the location
                });
            })

        }
    }

    addNewMarker(map, maps, e) {
        const latitude = e.latLng.lat();
        const longitude = e.latLng.lng();
        console.log(latitude + ', ' + longitude);
        var marker = new maps.Marker({
            position: e.latLng,
            map: map
        });
        var infowindow = new maps.InfoWindow({
            content: `&lt;div class=""btn-group btn-group-toggle"" data-toggle=""buttons""&gt;
            &lt;label class=""btn btn-primary active""&gt;&lt;input type=""radio"" name=""options"" id=""option1"" autocomplete=""off"" checked&gt;Патрул&lt;/label&gt;
            &lt;label class=""btn btn-primary active""&gt;&lt;input type=""radio"" name=""options"" id=""option2"" autocomplete=""off""&gt;Камера&lt;/label&gt;
            &lt;label class=""btn btn-primary active""&gt;&lt;input type=""radio"" name=""options"" id=""option3"" autocomplete=""off""&gt;Пешак&lt;/label&gt;
          &lt;/div&gt;
            &lt;h4&gt;${(new Date()).toString()}&lt;/h4&gt;
            &lt;div&gt;&lt;a class=""btn btn-large btn-success"" onclick=""postInfo();""&gt;Share&lt;/a&gt;
            &lt;/div&gt;`
        });
        infowindow.addListener('closeclick', function(){
            marker.setMap(null);
        });
        marker.addListener('click', function() {
            infowindow.open(this.map, marker);
        });
        infowindow.open(this.map, marker);
        }

    render() {
        const style = { // MUST specify dimensions of the Google map or it will not work. Also works best when style is specified inside the render function and created as an object
            width: '100vw', // 90vw basically means take up 90% of the width screen. px also works.
            height: '75vh' // 75vh similarly will take up roughly 75% of the height of the screen. px also works.
        }

        return ( // in our return function you must return a div with ref='map' and style.
            &lt;div ref=""map"" style={style}&gt;
                loading map...
      &lt;/div&gt;
        )
    }
}</code></pre>
</div>
</div>
</p>

<p>Thanks in advance!</p>
",""
"49450876","How to make a Stopwatch app in reactjs?","0","<p>[1]How to make a stopwatch app like this <a href=""https://www.online-stopwatch.com/countdown/"" rel=""nofollow noreferrer"">https://www.online-stopwatch.com/countdown/</a> in reactjs...?</p>

<pre><code>import React,{Component} from 'react';

export default class StopWatch extends Component{
  constructor(props){
    super(props);
    this.state={
      time2: ''
    }
  }
  timeCount(){
    this.time= setInterval(() =&gt; {
      this.setState({ time2:this.state.time2 - 1});
    },1000);
  }
  stopTimer() {
    clearInterval(this.time);
  }
  componentDidUpdate(){
    console.log(this.state.time2);
    if(this.state.count===0){
      clearInterval(this.time);
    }
  }
  componentWillUnmount(){
    clearInterval(this.time);
  }

  toggle(key){
    if(this.state.time2.length &lt; 6) {
      this.setState({ time2: `${this.state.time2}` + `${key}` });
    }
  }
</code></pre>

<p>[2]:Value of timer is not changing after trigger buttons.Provide me the 
     best method to achieve this.</p>

<p>Reference Link: <a href=""https://www.online-stopwatch.com/countdown/"" rel=""nofollow noreferrer"">https://www.online-stopwatch.com/countdown/</a></p>
",""
"49825323","react navigation header for StackNavigator screen doesn't render if screen wrapped in HOC","0","<h1>Summary</h1>

<ol>
<li>I created a custom HOC that checks for a user being authenticated by checking if the redux store has a user.id property</li>
<li>I am using react navigation and react native</li>
<li>When I wrap my screen component in my HOC, the navigation header appears but is blanked out (and conversely if I DON'T wrap my screen component in my HOC, the navigation header appears properly)</li>
<li>There is also react-redux connect in the mix in both the HOC and the wrapped component and I'm wondering if that is making things break</li>
</ol>

<p>Why is my react navigation header not showing properly when I wrap the screen component in my custom HOC?</p>

<p>I wonder if I'm wrapping things in the wrong order--these are the possibly offending lines of code from the screen component (one or the other is commented out when I'm testing):</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// export default connect(mapStateToProps, mapDispatchToProps)(EntityPage); &lt;--this renders the header fine

  export default connect(mapStateToProps, mapDispatchToProps)(withAuthentication(EntityPage)); &lt;--this renders the header blank</code></pre>
</div>
</div>
</p>

<h1>Code</h1>

<h2>Custom HOC I made that checks for authentication</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {
  Component
} from 'react';
import PropTypes from 'prop-types';
import {
  Alert
} from 'react-native';
import {
  connect
} from 'react-redux';

function withAuthentication(Comp) {
  class AuthenticatedScreen extends Component {
    componentDidUpdate(prevProps) {
      if (this.props.user &amp;&amp; !this.props.user.id) {
        Alert.alert('you\'re not logged in anymore');
      }
    }

    render() {
      return &lt;Comp { ...this.props
      }
      /&gt;;
    }
  }

  function mapStateToProps(state) {
    return {
      user: state.user,
    };
  }

  AuthenticatedScreen.propTypes = {
    user: PropTypes.object,
    component: PropTypes.object,
  };

  return connect(mapStateToProps)(AuthenticatedScreen);
}

export default withAuthentication;</code></pre>
</div>
</div>
</p>

<h2>Screen component I am wrapping with custom authentication HOC</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import withAuthentication from '../User/AuthorizedHOC'; &lt;--my custom HOC import

class EntityPage extends Component {
    static navigationOptions = ({navigation}) =&gt; {
      return {
        title: 'My Entities',
        headerRight: (
&gt;&gt;        &lt;Button type='action' title='Add New Entity' onPress={()=&gt;navigation.navigate('EntityCreate')}&gt;
          &lt;/Button&gt;),
        headerStyle: {paddingRight: (Platform.OS === 'ios') ? 0 : 8},
      };
    };

    componentDidMount() {
      this.props.loadEntities();
    }

    render() {
      const {
        entities,
      } = this.props;

      return (
        &lt;FullscreenView&gt;
          &lt;EntityList entities={entities}/&gt;
        &lt;/FullscreenView&gt;
      );
    }
  }

  function mapStateToProps(state) {
    return {
      entities: getSortedEntityList(state),
        };
  }

  function mapDispatchToProps(dispatch) {
    return {
      loadEntities: () =&gt; dispatch(loadEntities()),
      deleteEntity: (entity) =&gt; dispatch(deleteEntity(entity)),
    };
  }

  // export default connect(mapStateToProps, mapDispatchToProps)(EntityPage); &lt;--this renders the header fine

  export default connect(mapStateToProps, mapDispatchToProps)(withAuthentication(EntityPage)); &lt;--this renders the header blank</code></pre>
</div>
</div>
</p>
",""
"49895162","window.print() not working in IE 11 using react.js with react-pdf library","2","<p>window.print() doesn't seem to work in IE. I am using react.js with react-pdf library being used.</p>

<p>Below is my sample code:</p>

<pre><code>import { Document, Page } from ""react-pdf/build/entry.noworker"";

class PrintFile extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidUpdate() {
    window.print();
  }

  render() {
    const {
      pdfFile,
    } = this.props;
    return (
      &lt;DocumentTitle title={pdfFile.name}&gt;
        &lt;div id=""printable""&gt;
          &lt;Document
            file={pdfFile}
          &gt;
            ...
          &lt;/Document&gt;
        &lt;/div&gt;
      &lt;/DocumentTitle&gt;
    );
  }
}

PrintFile.propTypes = {
    pdfFile: PropTypes.object,
};

export default PrintFile;
</code></pre>

<p>I have removed the logic and just put the basic stuff required here..</p>

<p><a href=""https://www.npmjs.com/package/react-pdf"" rel=""nofollow noreferrer"">PDF Library Link</a></p>
","Calling print in componentDidUpdate? Please dont use libs that override native functions like window.print()."
"49895162","window.print() not working in IE 11 using react.js with react-pdf library","2","<p>window.print() doesn't seem to work in IE. I am using react.js with react-pdf library being used.</p>

<p>Below is my sample code:</p>

<pre><code>import { Document, Page } from ""react-pdf/build/entry.noworker"";

class PrintFile extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidUpdate() {
    window.print();
  }

  render() {
    const {
      pdfFile,
    } = this.props;
    return (
      &lt;DocumentTitle title={pdfFile.name}&gt;
        &lt;div id=""printable""&gt;
          &lt;Document
            file={pdfFile}
          &gt;
            ...
          &lt;/Document&gt;
        &lt;/div&gt;
      &lt;/DocumentTitle&gt;
    );
  }
}

PrintFile.propTypes = {
    pdfFile: PropTypes.object,
};

export default PrintFile;
</code></pre>

<p>I have removed the logic and just put the basic stuff required here..</p>

<p><a href=""https://www.npmjs.com/package/react-pdf"" rel=""nofollow noreferrer"">PDF Library Link</a></p>
","@Sulthan whats the alternate ?"
"50087326","When the ref callback argument is NULL in react?","9","<p>In some component when I use ref callback to receive component's ref, the argument of callback is null. When and in what situations the argument will be null?</p>
","> React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts. ref callbacks are invoked before componentDidMount or componentDidUpdate lifecycle hooks. From: https://reactjs.org/docs/refs-and-the-dom.html"
"50185157","How to update Highchart from inside react a component?","3","<p>I am working with react 16.3 where <code>componentWillUpdate</code> is deprecated (strict mode). We have a react wrapper around <code>Highcharts</code> and used to update the <code>highchart</code> in <code>componentWillUpdate</code> that runs just before render. </p>

<p>But now in react 16.3 when the input <code>highchartoptions</code> prop updates, there seems to be no way to call <code>Highchart.update</code> before <code>render()</code> is called. Its suggested to use <code>componentDidUpdate</code> but its called only after <code>render()</code> and it doesn't seem to work at all.Any suggestions will help.</p>

<p>Code snippet here:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class HighchartReactWrapper extends React.Component {
  constructor(props) {
    super(props);

    // We maintain the user provided options being used by highchart as state
    // inorder to check if chart update is needed.
    this.state = { highChartOptions: this.props.options };
    this.onChartRendered = this.onChartRendered.bind(this);
  }

  componentDidMount() {
    // Create chart
    this.chart = new Highcharts.Chart(this.container, this.state.highChartOptions, this.onChartRendered);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.options !== prevState.options) {
      return { highChartOptions: nextProps.options };
    }
  }

  componentDidUpdate() {
    this.chart.update(this.state.highChartOptions, false, true); &lt;---- Doesn't work
  }

  onChartRendered() {
    // Callbacks..
    if (this.props.onChartRenderedCallback !== undefined) {
      this.props.onChartRenderedCallback();
    }
  }

  componentWillUnmount() {
    // Destroy chart
    this.chart.destroy()
  }

  render() {
    return (
      &lt;div className=""react-highchart-wrapper""&gt;
        &lt;div id={container =&gt; this.container = container} /&gt;
      &lt;/div&gt;
    );
  }
}

HighchartReactWrapper.propTypes = {
  /**
   * Chart options to be used in Highcharts library.
   */
  options: PropTypes.object.isRequired,
  onChartRenderedCallback: PropTypes.func
};

HighchartReactWrapper.defaultProps = {
  options: undefined,
  onChartRenderedCallback: undefined
};</code></pre>
</div>
</div>
</p>
","What happens if you put `this.chart.update(this.state.highChartOptions, false, true);` as the last line in `componentDidMount`?"
"50185157","How to update Highchart from inside react a component?","3","<p>I am working with react 16.3 where <code>componentWillUpdate</code> is deprecated (strict mode). We have a react wrapper around <code>Highcharts</code> and used to update the <code>highchart</code> in <code>componentWillUpdate</code> that runs just before render. </p>

<p>But now in react 16.3 when the input <code>highchartoptions</code> prop updates, there seems to be no way to call <code>Highchart.update</code> before <code>render()</code> is called. Its suggested to use <code>componentDidUpdate</code> but its called only after <code>render()</code> and it doesn't seem to work at all.Any suggestions will help.</p>

<p>Code snippet here:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class HighchartReactWrapper extends React.Component {
  constructor(props) {
    super(props);

    // We maintain the user provided options being used by highchart as state
    // inorder to check if chart update is needed.
    this.state = { highChartOptions: this.props.options };
    this.onChartRendered = this.onChartRendered.bind(this);
  }

  componentDidMount() {
    // Create chart
    this.chart = new Highcharts.Chart(this.container, this.state.highChartOptions, this.onChartRendered);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.options !== prevState.options) {
      return { highChartOptions: nextProps.options };
    }
  }

  componentDidUpdate() {
    this.chart.update(this.state.highChartOptions, false, true); &lt;---- Doesn't work
  }

  onChartRendered() {
    // Callbacks..
    if (this.props.onChartRenderedCallback !== undefined) {
      this.props.onChartRenderedCallback();
    }
  }

  componentWillUnmount() {
    // Destroy chart
    this.chart.destroy()
  }

  render() {
    return (
      &lt;div className=""react-highchart-wrapper""&gt;
        &lt;div id={container =&gt; this.container = container} /&gt;
      &lt;/div&gt;
    );
  }
}

HighchartReactWrapper.propTypes = {
  /**
   * Chart options to be used in Highcharts library.
   */
  options: PropTypes.object.isRequired,
  onChartRenderedCallback: PropTypes.func
};

HighchartReactWrapper.defaultProps = {
  options: undefined,
  onChartRenderedCallback: undefined
};</code></pre>
</div>
</div>
</p>
","component didMount is only called once during initialization/creation phase. So subsequent update to option props doesn't update the chart."
"50185157","How to update Highchart from inside react a component?","3","<p>I am working with react 16.3 where <code>componentWillUpdate</code> is deprecated (strict mode). We have a react wrapper around <code>Highcharts</code> and used to update the <code>highchart</code> in <code>componentWillUpdate</code> that runs just before render. </p>

<p>But now in react 16.3 when the input <code>highchartoptions</code> prop updates, there seems to be no way to call <code>Highchart.update</code> before <code>render()</code> is called. Its suggested to use <code>componentDidUpdate</code> but its called only after <code>render()</code> and it doesn't seem to work at all.Any suggestions will help.</p>

<p>Code snippet here:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class HighchartReactWrapper extends React.Component {
  constructor(props) {
    super(props);

    // We maintain the user provided options being used by highchart as state
    // inorder to check if chart update is needed.
    this.state = { highChartOptions: this.props.options };
    this.onChartRendered = this.onChartRendered.bind(this);
  }

  componentDidMount() {
    // Create chart
    this.chart = new Highcharts.Chart(this.container, this.state.highChartOptions, this.onChartRendered);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.options !== prevState.options) {
      return { highChartOptions: nextProps.options };
    }
  }

  componentDidUpdate() {
    this.chart.update(this.state.highChartOptions, false, true); &lt;---- Doesn't work
  }

  onChartRendered() {
    // Callbacks..
    if (this.props.onChartRenderedCallback !== undefined) {
      this.props.onChartRenderedCallback();
    }
  }

  componentWillUnmount() {
    // Destroy chart
    this.chart.destroy()
  }

  render() {
    return (
      &lt;div className=""react-highchart-wrapper""&gt;
        &lt;div id={container =&gt; this.container = container} /&gt;
      &lt;/div&gt;
    );
  }
}

HighchartReactWrapper.propTypes = {
  /**
   * Chart options to be used in Highcharts library.
   */
  options: PropTypes.object.isRequired,
  onChartRenderedCallback: PropTypes.func
};

HighchartReactWrapper.defaultProps = {
  options: undefined,
  onChartRenderedCallback: undefined
};</code></pre>
</div>
</div>
</p>
","Ashb, could you upload your work codes for this and how you use it?"
"50228991","How to unit test a react component that uses inheritance instead of composition using jest and enzyme?","3","<p>I have a component that extends a generic component (custom react component). How do I unit-test using enzyme's mount? Here's the code:</p>

<p>Container.js</p>

<pre><code>import React from 'react';
import request from 'API/request';

export default class Container extends React.Component {
  componentDidMount() {
    this.populateData();
  }

  componentDidUpdate() {
    if (this.isDataStale()) {
      return this.populateData();
    }
  }

  populateData() {
    const url = this.getUrl();
    const params = this.getParams();

return request(this.props.dispatch, {
  url,
  params,
  method: 'GET'
})
  .then(response =&gt; {
    this.dispatchData(response.data);
  })
  .catch(error =&gt; {
    this.dispatchError(error);
  });


}
render() {
    if (this.getData() &amp;&amp; !this.isDataStale()) {
      return this.renderChildren();
    } else {
      return null;
    }
  }

  getError() {}
  getParams() {}
  isDataStale() {
    return false;
  }
}
</code></pre>

<p>Here's the functional component:</p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import { Route, withRouter } from 'react-router-dom';
import CustomPage from 'Client/customPage';
import Container from 'Client/container';
import TestPanel from 'Client/testPanel/TestPanel';
import Greeting from 'Client/greeting';
import Button from '../Button';

export class Test extends Container {
  constructor({ match }) {
    super();
    this.state = {
      match: match,
      id: match.params.id,
      location: ''
    };
  }

  isDataStale() {
    return (
      this.props.data.id !== this.props.match.params.id
    );
  }

  getData() {
    return this.props.data.values;
  }

  dispatchData(data) {
    this.props.dispatch({
      type: 'DATA_FOUND',
      data: data,
      id: this.state.id
    });
  }

  dispatchError(error) {
    this.props.dispatch({ type: 'CUSTOM_ERROR', data: error });
  }

  showDetails(url) {
    this.props.history.push(url);
  }

  renderChildren() {
    const match = this.state.match;
    const testUrl = `/test/values/${this.state.id}`;
    const verifyUrl = `${testUrl}/verify`;

    return (
      &lt;div className=""test-plan""&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;Greeting show={true} /&gt;
        )} /&gt;
        &lt;TestPanel
          data={this.props.data}
          id={this.props.match.params.id}
        /&gt;
        &lt;Route exact path={testUrl} render={() =&gt; (
          &lt;CustomPage id={this.state.id} /&gt;
        )} /&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;div className=""next-button"" &gt;&lt;Button label = {' NEXT '} onButtonClick = { this.showDetails.bind(this, loanUrl) } /&gt; &lt;/div&gt;
        )} /&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = state =&gt; {
  return {
    data: state.data
  };
};

export default withRouter(connect(mapStateToProps)(Test));
</code></pre>

<p>How do I test this Test (functional) component using Enzyme? Am not sure how this mock works since the render method is inside the container which in turn invokes the renderChildren method in our functional component. Lot of functional components extends this container so we can't change this to composition pattern as of now.</p>

<p>Here's the test case (Not working)</p>

<pre><code>import jsdomWindow from '../../test.setup';
import React from 'react';
import {BrowserRouter} from 'react-router-dom';
import { Test } from 'Client/containers/test';
import { createStore } from 'redux';
import { Provider } from 'react-redux';
import Enzyme, {mount} from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
import sinon from 'sinon';
import * as api from 'API/request';
import { populateData, isDataStale } from '../../../../src/client/app/container';

Enzyme.configure({ adapter: new Adapter() });
const sandbox = sinon.sandbox.create();

describe('&lt;Test /&gt;',() =&gt; {
  beforeEach(function() {
    sandbox.stub(api, 'default').returns(Promise.resolve({data: { saySomething: 'Yay Tests!'}}));
  });

  afterEach(function() {
    sandbox.restore();
  });
  const match = {
    params: {
      id: 100
    }
  };
  const testState = {
    data : {
      test: {
        id:'100',
        email:'someone@something.com',
        first_name:'John',
        home_phone:'325-555-6564',
        last_name:'Doe'
      }
    }
  };
  const wrapper = mount(
    &lt;BrowserRouter&gt;
      &lt;Provider store={createStore(state =&gt; state, { data: testState.data })}&gt;
        &lt;Test data={testState.data} dispatch={ sinon.spy() }
          match={match} /&gt;
      &lt;/Provider&gt;
    &lt;/BrowserRouter&gt;
  );
  jest.mock('../../../../src/client/app/container', () =&gt; ({
    populateData: jest.fn(),
    isDataStale: jest.fn(),
    getError: jest.fn(),
    getParams: jest.fn(),

  }));

  it('should render', () =&gt; {
    console.log(wrapper.debug());
    populateData.mockReturnValueOnce({});
    isDataStale.mockReturnValueOnce(false);
    const greetingContainer = wrapper.find('.greeting-container').find('.quick-info').find('.quick-info-heading');
    expect(greetingContainer.text()).toContain('PROPER RESPONSE');
  });

  // it('should render greeting component by default', () =&gt; {
  //   expect(wrapper.find('div.greeting-container')).toBeDefined();
  //   expect(wrapper.find('div.info-container')).toBeDefined();
  //   expect(wrapper.find('div.next-button')).toBeDefined();
  // });

  // it('should not render greeting and next-button components on clicking next', () =&gt; {
  //   console.log(`Test**** ${JSON.stringify(wrapper.find('div.plan'))}`);
  // });
});
</code></pre>

<p>Could anyone help me to unit test this using mount method of enzyme. Don't want to use shallow here as i have to test nested components' properties.</p>

<p>Thank you.</p>
","If you mock out `request` and all the other props correctly it should be pretty straight forward. You mount `Test`, change it's props or state, and make assertions about spies having been called."
"50228991","How to unit test a react component that uses inheritance instead of composition using jest and enzyme?","3","<p>I have a component that extends a generic component (custom react component). How do I unit-test using enzyme's mount? Here's the code:</p>

<p>Container.js</p>

<pre><code>import React from 'react';
import request from 'API/request';

export default class Container extends React.Component {
  componentDidMount() {
    this.populateData();
  }

  componentDidUpdate() {
    if (this.isDataStale()) {
      return this.populateData();
    }
  }

  populateData() {
    const url = this.getUrl();
    const params = this.getParams();

return request(this.props.dispatch, {
  url,
  params,
  method: 'GET'
})
  .then(response =&gt; {
    this.dispatchData(response.data);
  })
  .catch(error =&gt; {
    this.dispatchError(error);
  });


}
render() {
    if (this.getData() &amp;&amp; !this.isDataStale()) {
      return this.renderChildren();
    } else {
      return null;
    }
  }

  getError() {}
  getParams() {}
  isDataStale() {
    return false;
  }
}
</code></pre>

<p>Here's the functional component:</p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import { Route, withRouter } from 'react-router-dom';
import CustomPage from 'Client/customPage';
import Container from 'Client/container';
import TestPanel from 'Client/testPanel/TestPanel';
import Greeting from 'Client/greeting';
import Button from '../Button';

export class Test extends Container {
  constructor({ match }) {
    super();
    this.state = {
      match: match,
      id: match.params.id,
      location: ''
    };
  }

  isDataStale() {
    return (
      this.props.data.id !== this.props.match.params.id
    );
  }

  getData() {
    return this.props.data.values;
  }

  dispatchData(data) {
    this.props.dispatch({
      type: 'DATA_FOUND',
      data: data,
      id: this.state.id
    });
  }

  dispatchError(error) {
    this.props.dispatch({ type: 'CUSTOM_ERROR', data: error });
  }

  showDetails(url) {
    this.props.history.push(url);
  }

  renderChildren() {
    const match = this.state.match;
    const testUrl = `/test/values/${this.state.id}`;
    const verifyUrl = `${testUrl}/verify`;

    return (
      &lt;div className=""test-plan""&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;Greeting show={true} /&gt;
        )} /&gt;
        &lt;TestPanel
          data={this.props.data}
          id={this.props.match.params.id}
        /&gt;
        &lt;Route exact path={testUrl} render={() =&gt; (
          &lt;CustomPage id={this.state.id} /&gt;
        )} /&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;div className=""next-button"" &gt;&lt;Button label = {' NEXT '} onButtonClick = { this.showDetails.bind(this, loanUrl) } /&gt; &lt;/div&gt;
        )} /&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = state =&gt; {
  return {
    data: state.data
  };
};

export default withRouter(connect(mapStateToProps)(Test));
</code></pre>

<p>How do I test this Test (functional) component using Enzyme? Am not sure how this mock works since the render method is inside the container which in turn invokes the renderChildren method in our functional component. Lot of functional components extends this container so we can't change this to composition pattern as of now.</p>

<p>Here's the test case (Not working)</p>

<pre><code>import jsdomWindow from '../../test.setup';
import React from 'react';
import {BrowserRouter} from 'react-router-dom';
import { Test } from 'Client/containers/test';
import { createStore } from 'redux';
import { Provider } from 'react-redux';
import Enzyme, {mount} from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
import sinon from 'sinon';
import * as api from 'API/request';
import { populateData, isDataStale } from '../../../../src/client/app/container';

Enzyme.configure({ adapter: new Adapter() });
const sandbox = sinon.sandbox.create();

describe('&lt;Test /&gt;',() =&gt; {
  beforeEach(function() {
    sandbox.stub(api, 'default').returns(Promise.resolve({data: { saySomething: 'Yay Tests!'}}));
  });

  afterEach(function() {
    sandbox.restore();
  });
  const match = {
    params: {
      id: 100
    }
  };
  const testState = {
    data : {
      test: {
        id:'100',
        email:'someone@something.com',
        first_name:'John',
        home_phone:'325-555-6564',
        last_name:'Doe'
      }
    }
  };
  const wrapper = mount(
    &lt;BrowserRouter&gt;
      &lt;Provider store={createStore(state =&gt; state, { data: testState.data })}&gt;
        &lt;Test data={testState.data} dispatch={ sinon.spy() }
          match={match} /&gt;
      &lt;/Provider&gt;
    &lt;/BrowserRouter&gt;
  );
  jest.mock('../../../../src/client/app/container', () =&gt; ({
    populateData: jest.fn(),
    isDataStale: jest.fn(),
    getError: jest.fn(),
    getParams: jest.fn(),

  }));

  it('should render', () =&gt; {
    console.log(wrapper.debug());
    populateData.mockReturnValueOnce({});
    isDataStale.mockReturnValueOnce(false);
    const greetingContainer = wrapper.find('.greeting-container').find('.quick-info').find('.quick-info-heading');
    expect(greetingContainer.text()).toContain('PROPER RESPONSE');
  });

  // it('should render greeting component by default', () =&gt; {
  //   expect(wrapper.find('div.greeting-container')).toBeDefined();
  //   expect(wrapper.find('div.info-container')).toBeDefined();
  //   expect(wrapper.find('div.next-button')).toBeDefined();
  // });

  // it('should not render greeting and next-button components on clicking next', () =&gt; {
  //   console.log(`Test**** ${JSON.stringify(wrapper.find('div.plan'))}`);
  // });
});
</code></pre>

<p>Could anyone help me to unit test this using mount method of enzyme. Don't want to use shallow here as i have to test nested components' properties.</p>

<p>Thank you.</p>
","I mocked the component. But, it doesn't work. I have updated the test file as well. Please have a look."
"50228991","How to unit test a react component that uses inheritance instead of composition using jest and enzyme?","3","<p>I have a component that extends a generic component (custom react component). How do I unit-test using enzyme's mount? Here's the code:</p>

<p>Container.js</p>

<pre><code>import React from 'react';
import request from 'API/request';

export default class Container extends React.Component {
  componentDidMount() {
    this.populateData();
  }

  componentDidUpdate() {
    if (this.isDataStale()) {
      return this.populateData();
    }
  }

  populateData() {
    const url = this.getUrl();
    const params = this.getParams();

return request(this.props.dispatch, {
  url,
  params,
  method: 'GET'
})
  .then(response =&gt; {
    this.dispatchData(response.data);
  })
  .catch(error =&gt; {
    this.dispatchError(error);
  });


}
render() {
    if (this.getData() &amp;&amp; !this.isDataStale()) {
      return this.renderChildren();
    } else {
      return null;
    }
  }

  getError() {}
  getParams() {}
  isDataStale() {
    return false;
  }
}
</code></pre>

<p>Here's the functional component:</p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import { Route, withRouter } from 'react-router-dom';
import CustomPage from 'Client/customPage';
import Container from 'Client/container';
import TestPanel from 'Client/testPanel/TestPanel';
import Greeting from 'Client/greeting';
import Button from '../Button';

export class Test extends Container {
  constructor({ match }) {
    super();
    this.state = {
      match: match,
      id: match.params.id,
      location: ''
    };
  }

  isDataStale() {
    return (
      this.props.data.id !== this.props.match.params.id
    );
  }

  getData() {
    return this.props.data.values;
  }

  dispatchData(data) {
    this.props.dispatch({
      type: 'DATA_FOUND',
      data: data,
      id: this.state.id
    });
  }

  dispatchError(error) {
    this.props.dispatch({ type: 'CUSTOM_ERROR', data: error });
  }

  showDetails(url) {
    this.props.history.push(url);
  }

  renderChildren() {
    const match = this.state.match;
    const testUrl = `/test/values/${this.state.id}`;
    const verifyUrl = `${testUrl}/verify`;

    return (
      &lt;div className=""test-plan""&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;Greeting show={true} /&gt;
        )} /&gt;
        &lt;TestPanel
          data={this.props.data}
          id={this.props.match.params.id}
        /&gt;
        &lt;Route exact path={testUrl} render={() =&gt; (
          &lt;CustomPage id={this.state.id} /&gt;
        )} /&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;div className=""next-button"" &gt;&lt;Button label = {' NEXT '} onButtonClick = { this.showDetails.bind(this, loanUrl) } /&gt; &lt;/div&gt;
        )} /&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = state =&gt; {
  return {
    data: state.data
  };
};

export default withRouter(connect(mapStateToProps)(Test));
</code></pre>

<p>How do I test this Test (functional) component using Enzyme? Am not sure how this mock works since the render method is inside the container which in turn invokes the renderChildren method in our functional component. Lot of functional components extends this container so we can't change this to composition pattern as of now.</p>

<p>Here's the test case (Not working)</p>

<pre><code>import jsdomWindow from '../../test.setup';
import React from 'react';
import {BrowserRouter} from 'react-router-dom';
import { Test } from 'Client/containers/test';
import { createStore } from 'redux';
import { Provider } from 'react-redux';
import Enzyme, {mount} from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
import sinon from 'sinon';
import * as api from 'API/request';
import { populateData, isDataStale } from '../../../../src/client/app/container';

Enzyme.configure({ adapter: new Adapter() });
const sandbox = sinon.sandbox.create();

describe('&lt;Test /&gt;',() =&gt; {
  beforeEach(function() {
    sandbox.stub(api, 'default').returns(Promise.resolve({data: { saySomething: 'Yay Tests!'}}));
  });

  afterEach(function() {
    sandbox.restore();
  });
  const match = {
    params: {
      id: 100
    }
  };
  const testState = {
    data : {
      test: {
        id:'100',
        email:'someone@something.com',
        first_name:'John',
        home_phone:'325-555-6564',
        last_name:'Doe'
      }
    }
  };
  const wrapper = mount(
    &lt;BrowserRouter&gt;
      &lt;Provider store={createStore(state =&gt; state, { data: testState.data })}&gt;
        &lt;Test data={testState.data} dispatch={ sinon.spy() }
          match={match} /&gt;
      &lt;/Provider&gt;
    &lt;/BrowserRouter&gt;
  );
  jest.mock('../../../../src/client/app/container', () =&gt; ({
    populateData: jest.fn(),
    isDataStale: jest.fn(),
    getError: jest.fn(),
    getParams: jest.fn(),

  }));

  it('should render', () =&gt; {
    console.log(wrapper.debug());
    populateData.mockReturnValueOnce({});
    isDataStale.mockReturnValueOnce(false);
    const greetingContainer = wrapper.find('.greeting-container').find('.quick-info').find('.quick-info-heading');
    expect(greetingContainer.text()).toContain('PROPER RESPONSE');
  });

  // it('should render greeting component by default', () =&gt; {
  //   expect(wrapper.find('div.greeting-container')).toBeDefined();
  //   expect(wrapper.find('div.info-container')).toBeDefined();
  //   expect(wrapper.find('div.next-button')).toBeDefined();
  // });

  // it('should not render greeting and next-button components on clicking next', () =&gt; {
  //   console.log(`Test**** ${JSON.stringify(wrapper.find('div.plan'))}`);
  // });
});
</code></pre>

<p>Could anyone help me to unit test this using mount method of enzyme. Don't want to use shallow here as i have to test nested components' properties.</p>

<p>Thank you.</p>
","What exactly doesn't work? Some remarks: I wouldn't test `BrowserRouter` and `Provider` if all you care about is the `Test` component. This makes your test setup unnecessarily complicated. Why do you need both sinon and jest mocking? Jest should be enough here, it restores automatically when the test is over."
"50344466","can't call ref(also others like state, props, function, etc) on react quill custom handler","0","<p>I got a problem with quill editor on react.<br/><br/>
<code>imageHandler()</code> works well.<br/>But In <code>imageHandler()</code>, It can't call others like state, props, function, etc as well.<br/>
I wanna call quillRef in <code>imageHandler()</code> that is called by module.toolbar.handlers </p>

<p>Below is my simple code. <br/></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import ReactQuill from 'react-quill'; // ES6

const formats = [
  'header', 'font', 'size',
  'bold', 'italic', 'underline', 'strike', 'blockquote',
  'list', 'bullet', 'indent',
  'link', 'image', 'video'
]

class App extends Component {
  
  constructor(props) {
    super(props)
    this.state = { text: ''}
    this.handleChange = this.handleChange.bind(this)

    this.reactQuillRef = null; // ReactQuill component
    this.quillRef = null;      // Quill instance
  }
  
  modules = {
    toolbar: {
      container:  [['bold', 'italic', 'underline', 'blockquote'],
            [{'list': 'ordered'}, {'list': 'bullet'}],
            ['image'],
      ],
      handlers: {
         'image': this.imageHandler
      }
    }
  }

  componentDidMount() {
    this.attachQuillRefs()
  }
  
  componentDidUpdate() {
    this.attachQuillRefs()
  }
  
  attachQuillRefs = () =&gt; {
    if (typeof this.reactQuillRef.getEditor !== 'function') return;
    this.quillRef = this.reactQuillRef.getEditor();
  }

  imageHandler() {
    const input = document.createElement('input');
    input.setAttribute('type', 'file');
    input.setAttribute('accept', 'image/*');
    input.click();
    
    input.onchange = () =&gt; {
    
      const file = input.files[0];
      console.log(file); // works well
      
      // problems : can't call ref, props, function... etc
      console.log(""ref : "", this.reactQuillRef, this.quillRef); // undefine
      
      // this.insertImg(); // not work (insertImg is not a function)

      console.log(this.props); // undefine
      
    };
  }

  handleChange(value) {
    this.setState({ text: value });
    this.refs.test.innerHTML = this.state.text;
  }
  
  insertImg = () =&gt; {
    console.log(""insertImg"",prototype);
    var range = this.quillRef.getSelection();
    let position = range ? range.index : 0;
    console.log(this.quillRef); // works well!!!!!!!!! why diffrent with imgHandler() 
    this.quillRef.insertEmbed(position, 'image','https://images.pexels.com/photos/47480/pexels-photo-47480.jpeg?auto=compress&amp;cs=tinysrgb&amp;h=350');
  }

  render() {
    return (
      &lt;div className=""App""&gt;
      &lt;button onClick={this.insertImg}&gt;Insert Img&lt;/button&gt;
        &lt;ReactQuill value={this.state.text}
                  onChange={this.handleChange} 
                  modules={this.modules}
                  formats={formats} 
                  ref={(el) =&gt; {this.reactQuillRef = el}}
        /&gt;

      &lt;br/&gt;&lt;br/&gt;
      &lt;div contentEditable='true' ref='test'&gt;&lt;/div&gt;
      {this.state.text}
      &lt;/div&gt;

    );
  }
}

export default App;</code></pre>
</div>
</div>
</p>

<p>I tried many ways(all failed) and this case, not work</p>

<p><code>imageHandler() {...}</code> to <code>imageHandler = () =&gt; {...}</code></p>

<p><br/><br/><br/>
And my package.json here
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>{
  ""name"": ""quill"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""dependencies"": {
    ""fine-uploader"": ""^5.16.2"",
    ""react"": ""^16.3.2"",
    ""react-dom"": ""^16.3.2"",
    ""react-quill"": ""^1.2.7"",
    ""react-scripts"": ""1.1.4""
  },
  ""scripts"": {
    ""start"": ""react-scripts start"",
    ""build"": ""react-scripts build"",
    ""test"": ""react-scripts test --env=jsdom"",
    ""eject"": ""react-scripts eject""
  }
}</code></pre>
</div>
</div>
</p>

<p>Any Idea why?
Does anyone give hands for me?
Thank you!</p>
",""
"50530634","semantic-ui-react Menu returns TypeError: instance.render is not a function","0","<p>I am somewhat new to React. I've been working on a React project for some time but never messed with packages and dependencies. And I think this is what my issue is related to.</p>

<p>I have a project where I use Semantic-UI-React Menu + Router for navigation. Up until last night it worked fine. Then I ran <code>npm install</code> and everything started failing. I was digging into the specifics to find the root cause and identified that <code>&lt;Menu /&gt;</code> was causing the issue. So I created a new fresh app using the <strong>create-new-app</strong> package and confirmed that the newly created app worked. Then I added the <strong>semantic-ui-react</strong> package to it and confirmed that it worked properly. After that I tried to render <code>&lt;Menu /&gt;</code> again and saw the same issue that I was seeing in my project. I'm suspicious that something is up with the versions of the packages but I cannot figure out what it is.</p>

<p>The Node.js version is 10.0.0.</p>

<p>The npm version is 5.6.0.</p>

<p>Here is my package.json:</p>

<pre><code>{
    ""name"": ""my-app"",
    ""version"": ""0.1.0"",
    ""private"": true,
    ""dependencies"": {
        ""react"": ""^16.4.0"",
        ""react-dom"": ""^16.4.0"",
        ""react-scripts"": ""1.1.4"",
        ""semantic-ui-react"": ""^0.80.1""
    },
    ""scripts"": {
        ""start"": ""react-scripts start"",
        ""build"": ""react-scripts build"",
        ""test"": ""react-scripts test --env=jsdom"",
        ""eject"": ""react-scripts eject""
    }
}
</code></pre>

<p>Here is my App.js (the menu example is copied from semantic-ui-react reference as is):</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import { Menu } from 'semantic-ui-react';
import './App.css';

const items = [
    { key: 'editorials', active: true, name: 'Editorials' },
    { key: 'review', name: 'Reviews' },
    { key: 'events', name: 'Upcoming Events' },
]

const MenuExampleProps = () =&gt; (
    &lt;Menu items={items} /&gt;
)

export default MenuExampleProps
</code></pre>

<p>When I run <code>yarn start</code>, I see this:</p>

<pre><code>1 of 2 errors on the page
TypeError: instance.render is not a function
finishClassComponent
node_modules/react-dom/cjs/react-dom.development.js:13085

  13082 | } else {
  13083 |   {
  13084 |     ReactDebugCurrentFiber.setCurrentPhase('render');
&gt; 13085 |     nextChildren = instance.render();
  13086 |     if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode &amp;&amp; workInProgress.mode &amp; StrictMode) {
  13087 |       instance.render();
  13088 |     }

updateClassComponent
node_modules/react-dom/cjs/react-dom.development.js:13047

  13044 |   } else {
  13045 |     shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
  13046 |   }
&gt; 13047 |   return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);
  13048 | }
  13049 | 
  13050 | function finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime) {

beginWork
node_modules/react-dom/cjs/react-dom.development.js:13715

  13712 | case FunctionalComponent:
  13713 |   return updateFunctionalComponent(current, workInProgress);
  13714 | case ClassComponent:
&gt; 13715 |   return updateClassComponent(current, workInProgress, renderExpirationTime);
  13716 | case HostRoot:
  13717 |   return updateHostRoot(current, workInProgress, renderExpirationTime);
  13718 | case HostComponent:

performUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js:15741

  15738 |   startBaseRenderTimer();
  15739 | }
  15740 | 
&gt; 15741 | next = beginWork(current, workInProgress, nextRenderExpirationTime);
  15742 | 
  15743 | if (workInProgress.mode &amp; ProfileMode) {
  15744 |   // Update ""base"" time if the render wasn't bailed out on.

workLoop
node_modules/react-dom/cjs/react-dom.development.js:15780

  15777 | if (!isAsync) {
  15778 |   // Flush all expired work.
  15779 |   while (nextUnitOfWork !== null) {
&gt; 15780 |     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  15781 |   }
  15782 | } else {
  15783 |   // Flush asynchronous work until the deadline runs out of time.

callCallback
node_modules/react-dom/cjs/react-dom.development.js:100

   97 |   // nested call would trigger the fake event handlers of any call higher
   98 |   // in the stack.
   99 |   fakeNode.removeEventListener(evtType, callCallback, false);
&gt; 100 |   func.apply(context, funcArgs);
  101 |   didError = false;
  102 | }
  103 | 

invokeGuardedCallbackDev
node_modules/react-dom/cjs/react-dom.development.js:138

  135 | // Synchronously dispatch our fake event. If the user-provided function
  136 | // errors, it will trigger our global error handler.
  137 | evt.initEvent(evtType, false, false);
&gt; 138 | fakeNode.dispatchEvent(evt);
  139 | 
  140 | if (didError) {
  141 |   if (!didSetError) {

invokeGuardedCallback
node_modules/react-dom/cjs/react-dom.development.js:187

  184 |  * @param {...*} args Arguments for function
  185 |  */
  186 | invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
&gt; 187 |   invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);
  188 | },
  189 | 
  190 | /**

replayUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js:15194

  15191 | // Replay the begin phase.
  15192 | isReplayingFailedUnitOfWork = true;
  15193 | originalReplayError = thrownValue;
&gt; 15194 | invokeGuardedCallback$2(null, workLoop, null, isAsync);
  15195 | isReplayingFailedUnitOfWork = false;
  15196 | originalReplayError = null;
  15197 | if (hasCaughtError()) {

renderRoot
node_modules/react-dom/cjs/react-dom.development.js:15840

  15837 | 
  15838 | var failedUnitOfWork = nextUnitOfWork;
  15839 | if (true &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) {
&gt; 15840 |   replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);
  15841 | }
  15842 | 
  15843 | // TODO: we already know this isn't true in some cases.

performWorkOnRoot
node_modules/react-dom/cjs/react-dom.development.js:16437

  16434 |   completeRoot(root, finishedWork, expirationTime);
  16435 | } else {
  16436 |   root.finishedWork = null;
&gt; 16437 |   finishedWork = renderRoot(root, expirationTime, false);
  16438 |   if (finishedWork !== null) {
  16439 |     // We've completed the root. Commit it.
  16440 |     completeRoot(root, finishedWork, expirationTime);

performWork
node_modules/react-dom/cjs/react-dom.development.js:16358

  16355 |   }
  16356 | } else {
  16357 |   while (nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime)) {
&gt; 16358 |     performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
  16359 |     findHighestPriorityRoot();
  16360 |   }
  16361 | }

performSyncWork
node_modules/react-dom/cjs/react-dom.development.js:16330

  16327 | }
  16328 | 
  16329 | function performSyncWork() {
&gt; 16330 |   performWork(Sync, false, null);
  16331 | }
  16332 | 
  16333 | function performWork(minExpirationTime, isAsync, dl) {

requestWork
node_modules/react-dom/cjs/react-dom.development.js:16230

  16227 | 
  16228 | // TODO: Get rid of Sync and use current time?
  16229 | if (expirationTime === Sync) {
&gt; 16230 |   performSyncWork();
  16231 | } else {
  16232 |   scheduleCallbackWithExpiration(expirationTime);
  16233 | }

scheduleWork$1
node_modules/react-dom/cjs/react-dom.development.js:16096

  16093 | !isWorking || isCommitting$1 ||
  16094 | // ...unless this is a different root than the one we're rendering.
  16095 | nextRoot !== root) {
&gt; 16096 |   requestWork(root, nextExpirationTimeToWorkOn);
  16097 | }
  16098 | if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {
  16099 |   invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');

scheduleRootUpdate
node_modules/react-dom/cjs/react-dom.development.js:16663

  16660 |   }
  16661 |   enqueueUpdate(current, update, expirationTime);
  16662 | 
&gt; 16663 |   scheduleWork$1(current, expirationTime);
  16664 |   return expirationTime;
  16665 | }
  16666 | 

updateContainerAtExpirationTime
node_modules/react-dom/cjs/react-dom.development.js:16690

  16687 |     container.pendingContext = context;
  16688 |   }
  16689 | 
&gt; 16690 |   return scheduleRootUpdate(current, element, expirationTime, callback);
  16691 | }
  16692 | 
  16693 | function findHostInstance(component) {

updateContainer
node_modules/react-dom/cjs/react-dom.development.js:16717

  16714 |   var current = container.current;
  16715 |   var currentTime = recalculateCurrentTime();
  16716 |   var expirationTime = computeExpirationForFiber(currentTime, current);
&gt; 16717 |   return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
  16718 | }
  16719 | 
  16720 | function getPublicRootInstance(container) {

./node_modules/react-dom/cjs/react-dom.development.js/ReactRoot.prototype.render
node_modules/react-dom/cjs/react-dom.development.js:17000

  16997 |   if (callback !== null) {
  16998 |     work.then(callback);
  16999 |   }
&gt; 17000 |   updateContainer(children, root, null, work._onCommit);
  17001 |   return work;
  17002 | };
  17003 | ReactRoot.prototype.unmount = function (callback) {

legacyRenderSubtreeIntoContainer/&lt;
node_modules/react-dom/cjs/react-dom.development.js:17140

  17137 |     if (parentComponent != null) {
  17138 |       root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
  17139 |     } else {
&gt; 17140 |       root.render(children, callback);
  17141 |     }
  17142 |   });
  17143 | } else {

unbatchedUpdates
node_modules/react-dom/cjs/react-dom.development.js:16557

  16554 |       isUnbatchingUpdates = false;
  16555 |     }
  16556 |   }
&gt; 16557 |   return fn(a);
  16558 | }
  16559 | 
  16560 | // TODO: Batching should be implemented at the renderer level, not within

legacyRenderSubtreeIntoContainer
node_modules/react-dom/cjs/react-dom.development.js:17136

  17133 |   };
  17134 | }
  17135 | // Initial mount should not be batched.
&gt; 17136 | unbatchedUpdates(function () {
  17137 |   if (parentComponent != null) {
  17138 |     root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
  17139 |   } else {

render
node_modules/react-dom/cjs/react-dom.development.js:17195

  17192 |   return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
  17193 | },
  17194 | render: function (element, container, callback) {
&gt; 17195 |   return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
  17196 | },
  17197 | unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
  17198 |   !(parentComponent != null &amp;&amp; has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;

./src/index.js
src/index.js:7

   4 | import App from './App';
   5 | import registerServiceWorker from './registerServiceWorker';
   6 | 
&gt;  7 | ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
   8 | registerServiceWorker();
   9 | 
  10 | 

This screen is visible only in development. It will not appear if the app crashes in production.
Open your browser’s developer console to further inspect this error
</code></pre>
",""
"50665943","Use tab key not working on Prime-react editable Data table","0","<p>I used an editable data Table of prime-react , and it worked mouse click. But Problem is tab key not work.I want to enable editable mode one cell to another cell using tab key. I use Prime react version 1.4.0</p>

<p>A full code are given below:-</p>

<p><strong>index.js</strong> 
 <em>where my editable table code contains</em></p>

<pre><code>import React from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { FormattedMessage } from 'react-intl';
import { createStructuredSelector } from 'reselect';
import { compose } from 'redux';
import injectSaga from 'utils/injectSaga';
import injectReducer from 'utils/injectReducer';
import reducer from './reducer';
import saga from './saga';
import messages from './messages';
import { Messages } from 'primereact/components/messages/Messages';
import { Growl } from 'primereact/components/growl/Growl';
import { Panel } from 'primereact/components/panel/Panel';
import { Button } from 'primereact/components/button/Button';
import { DataTable } from 'primereact/components/datatable/DataTable';
import { Column } from 'primereact/components/column/Column';
import { InputText } from 'primereact/components/inputtext/InputText';
import { Dropdown } from 'primereact/components/dropdown/Dropdown';
import CustomDataTable from 'components/CustomDataTable';
import { makeSelectSelectedStudent, makeSelectSectionName, makeSelectStudentUpdateBasicInformation, makeSelectSectionList, makeSelectStdBasicInfo, makeSelectEditorStudent, makeSelectSetMessage, makeSelectSetErrMessage, makeSelectLoaderOff, makeSelectLoaderOn } from './selectors';
import { selectStudent, setEditorData, submitUpdate, getMessage, getErrMessage, submitForm, changeSectionName, getLoaderOn, getLoaderOff } from './actions';
import AppPrivateLayout from '../AppPrivateLayout';

export class StudentUpdateBasicInformation extends React.Component {
  componentDidUpdate() {
    this.props.changeMessage('');
  }

  rollBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.studentRoll} /&gt;;
  }

  nameBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.studentName} /&gt;;
  }

  fatherNameBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.fatherName} /&gt;;
  }

  motherNameBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.motherName} /&gt;;
  }

  contactBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.guardianMobile} /&gt;;
  }

  genderBody(rowData) {
    let gender = [
      { label: 'Male', value: 'Male' },
      { label: 'Female', value: 'Female' },
      { label: 'Others', value: 'Others' }
    ];

    return &lt;Dropdown value={rowData.studentGender} options={gender} style={{ width: '100%' }} placeholder=""Select"" /&gt;
  }

  religionBody(rowData) {
    let religion = [
      { label: 'Islam', value: 'Islam' },
      { label: 'Hindu', value: 'Hindu' },
      { label: 'Buddhist', value: 'Buddhist' },
      { label: 'Christian', value: 'Christian' },
      { label: 'Others', value: 'Others' }
    ];
    return &lt;Dropdown value={rowData.studentReligion} options={religion} style={{ width: '100%' }} placeholder=""Select"" /&gt;
  }

  bloodBody(rowData) {
    let blood = [
      { label: 'A+', value: 'A+' },
      { label: 'A-', value: 'A-' },
      { label: 'B+', value: 'B+' },
      { label: 'B-', value: 'B-' },
      { label: 'O+', value: 'O+' },
      { label: 'O-', value: 'O-' }

    ];
    return &lt;Dropdown value={rowData.bloodGroup} options={blood} style={{ width: '100%' }} placeholder=""Select"" /&gt;
  }

  render() {
    let rollEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Roll"" value={row.rowData.studentRoll} /&gt;
    }

    let nameEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Student name"" value={row.rowData.studentName} /&gt;
    }

    let fatherNameEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Father name"" value={row.rowData.fatherName} /&gt;
    }

    let motherNameEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Mother name"" value={row.rowData.motherName} /&gt;
    }

    let contactEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Contact Number"" value={row.rowData.guardianMobile} /&gt;
    }

    let genderEditor = (row) =&gt; {
      let gender = [
        { label: 'Male', value: 'Male' },
        { label: 'Female', value: 'Female' },
        { label: 'Others', value: 'Others' }
      ];

      return &lt;Dropdown value={row.rowData.gender} options={gender} onChange={(evt) =&gt; this.props.onEditorValueChange(row, evt.value)} style={{ width: '100%' }} placeholder=""Select"" /&gt;
    }

    let religionEditor = (row) =&gt; {
      let religion = [
        { label: 'Islam', value: 'Islam' },
        { label: 'Hindu', value: 'Hindu' },
        { label: 'Buddhist', value: 'Buddhist' },
        { label: 'Christian', value: 'Christian' },
        { label: 'Others', value: 'Others' }
      ];
      return &lt;Dropdown value={row.rowData.religion} options={religion} onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.value); }} style={{ width: '100%' }} placeholder=""Select"" /&gt;
    }

    let bloodEditor = (row) =&gt; {
      let blood = [
        { label: 'A+', value: 'A+' },
        { label: 'A-', value: 'A-' },
        { label: 'B+', value: 'B+' },
        { label: 'B-', value: 'B-' },
        { label: 'O+', value: 'O+' },
        { label: 'O-', value: 'O-' }

      ];
      return &lt;Dropdown value={row.rowData.blood} options={blood} onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.value); }} style={{ width: '100%' }} placeholder=""Select"" /&gt;
    }

    let msg = """";
    if (this.props.setMessage) {
      msg = { severity: 'success', detail: this.props.setMessage.message };
      this.growl.show(msg);
    }
    else if (this.props.setErrMessage) {
      msg = { severity: 'error', summary: 'Failed', detail: this.props.setErrMessage };
      this.growl.show(msg);
    }
    if(this.props.loaderOn){
      if(this.props.loaderOn === 'On') {
      $('.loaderDiv').show();
    } else if(this.props.loaderOn === 'Off'){
      $('.loaderDiv').hide();
    }
  }
    let content = '';
    if (this.props.stdBasicInfo &amp;&amp; this.props.stdBasicInfo.length) {
      $('#UpdateBtnID').show();
      let selectedStudentArr = [];
      if (this.props.selectedStudent.length) {
        Array.prototype.push.apply(selectedStudentArr, this.props.selectedStudent);
      }
      let columnData = [
        &lt;Column selectionMode=""multiple"" header=""Mark"" style={{ width: '3em' }} /&gt;,
        &lt;Column field=""studentRoll"" header=""Roll No."" editor={rollEditor} body={this.rollBody} style={{ width: '55px' }} /&gt;,
        &lt;Column field=""studentName"" header=""Name"" editor={nameEditor} body={this.nameBody} style={{ width: '170px' }} /&gt;,
        &lt;Column field=""fatherName"" header=""Father Name"" editor={fatherNameEditor} body={this.fatherNameBody} style={{ width: '145px' }} /&gt;,
        &lt;Column field=""motherName"" header=""Mother Name"" editor={motherNameEditor} body={this.motherNameBody} style={{ width: '145px' }} /&gt;,
        &lt;Column field=""guardianMobile"" header=""Contact No."" editor={contactEditor} style={{ width: '100px' }} body={this.contactBody} /&gt;,
        &lt;Column field=""studentGender"" header=""Gender"" editor={genderEditor} body={this.genderBody} style={{ width: '85px' }} /&gt;,
        &lt;Column field=""studentReligion"" header=""Religion"" editor={religionEditor} body={this.religionBody} style={{ width: '85px' }} /&gt;,
        &lt;Column field=""bloodGroup"" header=""Blood Group"" editor={bloodEditor} style={{ width: '80px' }} body={this.bloodBody} /&gt;
      ];
      content = &lt;CustomDataTable
        info={this.props.stdBasicInfo}
        onSelectionChange={this.props.onSelectionChange}
        selectedData={selectedStudentArr}
        columnData={columnData}
        isSelectionOn={true}
        editable={true}
        header={'Student List'}
        rows={10}
      /&gt;
    }

    //FOR SECTION LIST
    let sectionListOptions = [];
    if (this.props.sectionList &amp;&amp; this.props.sectionList.length) {
      sectionListOptions = this.props.sectionList.map((item) =&gt; ({
        value: item.classConfigId,
        label: item.classShiftSection,
      }))
    }

    return (
      &lt;div&gt;
        &lt;AppPrivateLayout&gt;
        &lt;Panel header=""Student Information Update""&gt;
          &lt;form method=""post"" onSubmit={this.props.onSubmitForm} &gt;
            &lt;div className='ui-g form-group'&gt;

              &lt;div className='ui-g-2 ui-lg-2 ui-md-2'&gt;&lt;/div&gt;
              &lt;div className='ui-g-2 ui-lg-2 ui-md-2 ui-sm-12 netiLabel'&gt;
                &lt;label&gt; Section &lt;span className=""required""&gt; * &lt;/span&gt;&lt;/label&gt;
              &lt;/div&gt;
              &lt;div className='ui-g-3 ui-lg-3 ui-md-4 ui-sm-12 ui-fluid'&gt;
                &lt;Dropdown value={this.props.sectionname} onChange={this.props.onChangeSectionList} options={sectionListOptions} placeholder=""Select Section"" autoWidth={false} /&gt;
              &lt;/div&gt;
              &lt;div className='ui-g-2 ui-lg-2 ui-md-3 ui-sm-12 ui-fluid'&gt;
                &lt;Button icon=""ui-icon-search"" title=""Search"" label='Search'&gt;&lt;/Button&gt;
              &lt;/div&gt;
              &lt;div className='ui-g-2 ui-lg-2 ui-fluid'&gt;&lt;/div&gt;
            &lt;/div&gt;
          &lt;/form&gt;
          {content}
          &lt;div className='ui-g'&gt;
            &lt;Growl ref={(el) =&gt; this.growl = el} /&gt;
            &lt;div className='ui-g-4 ui-lg-4 ui-md-4 ui-sm-12 ui-fluid'&gt;

            &lt;/div&gt;
            &lt;div className='ui-g-6 ui-lg-6 ui-md-5 ui-sm-12 ui-fluid'&gt;&lt;/div&gt;
            &lt;div className='ui-g-2 ui-lg-2 ui-md-3 ui-sm-12 ui-fluid'&gt;
              &lt;Button id=""UpdateBtnID"" style={{ display: 'none' }} onClick={this.props.onUpdate} icon='ui-icon-autorenew' label='Update'&gt;&lt;/Button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Panel&gt;
        &lt;div class=""loaderDiv"" style={{display: 'none'}}&gt;
            &lt;img className=""sticky"" src=""https://loading.io/spinners/harmony/lg.harmony-taiji-spinner.gif"" /&gt;
          &lt;/div&gt;
        &lt;/AppPrivateLayout&gt;
      &lt;/div&gt;
    );
  }
}

StudentUpdateBasicInformation.propTypes = {
  stdBasicInfo: PropTypes.any,
  onSubmitForm: PropTypes.func,
  onEditorValueChange: PropTypes.func,
  value: PropTypes.any,
  onUpdate: PropTypes.func,
  setMessage: PropTypes.any,
  setErrMessage: PropTypes.any,
  changeMessage: PropTypes.func,
  sectionList: PropTypes.any,
  onChangeSectionList: PropTypes.func,
  sectionname: PropTypes.any,
  loaderOn: PropTypes.any,
};

const mapStateToProps = createStructuredSelector({
  stdBasicInfo: makeSelectStdBasicInfo(),
  selectedStudent: makeSelectSelectedStudent(),
  value: makeSelectEditorStudent(),
  setMessage: makeSelectSetMessage(),
  setErrMessage: makeSelectSetErrMessage(),
  sectionList: makeSelectSectionList(),
  sectionname: makeSelectSectionName(),
  loaderOn: makeSelectLoaderOn(),
});

function mapDispatchToProps(dispatch) {
  return {
    changeMessage: (evt) =&gt; {
      dispatch(getMessage());
      dispatch(getErrMessage());
      dispatch(getLoaderOn(evt));
    },

    onSubmitForm: (evt) =&gt; {
      if (evt !== undefined &amp;&amp; evt.preventDefault)
        evt.preventDefault();
      dispatch(submitForm());
    },
    onSelectionChange: (evt) =&gt; dispatch(selectStudent(evt.data)),
    onEditorValueChange: (row, value) =&gt; {
      dispatch(setEditorData(row, value));
    },
    onUpdate: (evt) =&gt; dispatch(submitUpdate()),
    onChangeSectionList: (evt) =&gt; dispatch(changeSectionName(evt.value)),
  };
}

const withConnect = connect(mapStateToProps, mapDispatchToProps);
const withReducer = injectReducer({ key: 'studentUpdateBasicInformation', reducer });
const withSaga = injectSaga({ key: 'studentUpdateBasicInformation', saga });

export default compose(
  withReducer,
  withSaga,
  withConnect,
)(StudentUpdateBasicInformation);
</code></pre>

<p><strong>constants.js</strong></p>

<pre><code>export const DEFAULT_ACTION = 'app/StudentUpdateBasicInformation/DEFAULT_ACTION';

export const SUBMIT_FORM = 'app/StudentUpdateBasicInformation/SUBMIT_FORM';
export const SET_STD_BASIC_INFO = 'app/StudentUpdateBasicInformation/SET_STD_BASIC_INFO';
export const SELECT_STUDENT = 'app/StudentUpdateBasicInformation/SELECT_STUDENT';
export const SET_EDITOR_DATA = 'app/StudentUpdateBasicInformation/SET_EDITOR_DATA';
export const GET_MESSAGE = 'app/StudentUpdateStudentId/GET_MESSAGE';
export const GET_ERR_MESSAGE = 'app/StudentUpdateStudentId/GET_ERR_MESSAGE';
export const SUBMIT_UPDATE = 'app/StudentUpdateBasicInformation/SUBMIT_UPDATE';
export const SET_SECTION_LIST = 'app/StudentUpdateBasicInformation/SET_SECTION_LIST';
export const CHANGE_SECTIONNAME = 'app/StudentUpdateBasicInformation/CHANGE_SECTIONNAME';
export const GET_LOADER_ON = 'app/StudentUpdateBasicInformation/GET_LOADER_ON';
</code></pre>

<p><strong>actions.js</strong></p>

<pre><code>import {
  DEFAULT_ACTION, SUBMIT_FORM, SET_STD_BASIC_INFO, SELECT_STUDENT, SET_EDITOR_DATA, SUBMIT_UPDATE, GET_MESSAGE, GET_ERR_MESSAGE, CHANGE_SECTIONNAME, SET_SECTION_LIST, GET_LOADER_OFF, GET_LOADER_ON
} from './constants';

export function defaultAction() {
  return {
    type: DEFAULT_ACTION,
  };
}

export function setStdBasicInfo(item) {
  return {
    type: SET_STD_BASIC_INFO,
    item,
  }
}

export function selectStudent(data) {
  return {
    type: SELECT_STUDENT,
    data,
  };
}

export function setEditorData(row, value) {
  return {
    type: SET_EDITOR_DATA,
    row, 
    value,
  };
}


export function submitForm() {
  return {
    type: SUBMIT_FORM,
  };
}

export function submitUpdate() {
  return {
    type: SUBMIT_UPDATE,
  };
}

export function getMessage(message) {
  return {
    type: GET_MESSAGE,
    message,
  }
}

export function getErrMessage(errmessage) {
  return {
    type: GET_ERR_MESSAGE,
    errmessage,
  }
}

export function setSectionList(sectionList) {
  return {
    type: SET_SECTION_LIST,
    sectionList,
  };
}
export function changeSectionName(sectionname) {
  return {
    type: CHANGE_SECTIONNAME,
    sectionname,
  };
}


export function getLoaderOn(loaderOn){
  return{
    type: GET_LOADER_ON,
    loaderOn,
  }
}
</code></pre>

<p><strong>reducer.js</strong></p>

<pre><code>import { fromJS } from 'immutable';
import {
  DEFAULT_ACTION, SET_STD_BASIC_INFO, SELECT_STUDENT, SET_EDITOR_DATA, GET_MESSAGE, GET_ERR_MESSAGE, SET_SECTION_LIST, CHANGE_SECTIONNAME, GET_LOADER_ON, GET_LOADER_OFF
} from './constants';

const initialState = fromJS({
  selectedStudent: [],
  value: [],
  sectionList: {},
  sectionname: '',
});

function studentUpdateBasicInformationReducer(state = initialState, action) {
  switch (action.type) {
    case DEFAULT_ACTION:
      return state;
    case SET_STD_BASIC_INFO:
      return state.set('stdBasicInfo', action.item);
    case SELECT_STUDENT:
      return state.set('selectedStudent', action.data);
    case SET_EDITOR_DATA:
      let updatedInfost = [...action.row.value];
      updatedInfost = [...action.row.value];
      updatedInfost[action.row.rowIndex][action.row.field] = action.value;
      return state.set('stdBasicInfo', updatedInfost);
    case GET_MESSAGE:
      return state.set('setMessage', action.message);
    case GET_ERR_MESSAGE:
      return state.set('setErrMessage', action.errmessage);
    case SET_SECTION_LIST:
      return state.set('sectionList', action.sectionList);
    case CHANGE_SECTIONNAME:
      return state.set('sectionname', action.sectionname);
      case GET_LOADER_ON:
      return state.set('loaderOn', action.loaderOn);
      // case GET_LOADER_OFF:
      // return state.set('loaderOff', action.loaderOff);
    default:
      return state;
  }
}

export default studentUpdateBasicInformationReducer;
</code></pre>

<p><strong>selectors.js</strong></p>

<pre><code>import { createSelector } from 'reselect';

const selectStudentUpdateBasicInformationDomain = (state) =&gt; state.get('studentUpdateBasicInformation');

const makeSelectStudentUpdateBasicInformation = () =&gt; createSelector(
  selectStudentUpdateBasicInformationDomain,
  (substate) =&gt; substate.toJS()
);

const makeSelectStdBasicInfo = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('stdBasicInfo'));
const makeSelectSelectedStudent = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (substate) =&gt; substate.get('selectedStudent'));
const makeSelectEditorStudent = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (substate) =&gt; substate.get('value'));
const makeSelectSetMessage = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('setMessage'));
const makeSelectSetErrMessage = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('setErrMessage'));
const makeSelectSectionName = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('sectionname'));
const makeSelectSectionList = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain,(substate) =&gt; substate.get('sectionList'));
const makeSelectLoaderOn = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (substate) =&gt; substate.get('loaderOn'));

export {
  selectStudentUpdateBasicInformationDomain,
  makeSelectStdBasicInfo,
  makeSelectSelectedStudent,
  makeSelectEditorStudent,
  makeSelectSetMessage,
  makeSelectSetErrMessage, makeSelectSectionName, makeSelectSectionList, makeSelectLoaderOn, 
  //makeSelectLoaderOff
};
</code></pre>

<p><strong>saga.js</strong></p>

<pre><code>import { take, call, put, select, takeLatest } from 'redux-saga/effects';
import { BASE_URL, FETCH_BASIC_INFO_LIST, UPDATE_ID, GET_CLASS_CONFIGURATION_URL, STUDENT_CONFIG_LIST } from '../../utils/serviceUrl';
import { setStdBasicInfo, getMessage, getErrMessage, selectStudent, setSectionList, changeSectionName, getLoaderOn } from './actions';
import request from '../../utils/request';
import { SUBMIT_FORM, SUBMIT_UPDATE } from './constants';
import { makeSelectEditorStudent, makeSelectSelectedStudent, makeSelectSectionList, makeSelectSectionName  } from './selectors';
import { getTokenData } from '../../utils/authHelper';

//FOR SECTION LIST
export function* fetchSectionList() {
  const tokenData = JSON.parse(getTokenData());
  const requestUrl = BASE_URL.concat(GET_CLASS_CONFIGURATION_URL);
  const options = {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': tokenData.token_type+"" ""+tokenData.access_token,
    },
  };
  try {
    const response = yield call(request, requestUrl, options);
    if (response.item) {
      yield put(setSectionList(response.item));
    }
  } catch (err) {
    console.dir(err);
  }
}

//FOR STUDENT BASIC INFO LIST
export function* fetchStudentBasicInfoList() {
  const tokenData = JSON.parse(getTokenData());
  const classConfigId = yield select(makeSelectSectionName());
  let msgg;
  if (classConfigId == '') {
    let msg = ""An error has occured. Please fill up all required fields"";
    yield put(getErrMessage(msg));

  }
  else {
    msgg = 'On';
    yield put(getLoaderOn(msgg));
  const requestURL = BASE_URL.concat(STUDENT_CONFIG_LIST).concat('?classConfigId=').concat(classConfigId);
  const options = {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': tokenData.token_type+"" ""+tokenData.access_token,
    },
  };
  const info = yield call(request, requestURL,options);
  yield put(setStdBasicInfo(info.item));
  msgg = 'Off';
  yield put(getLoaderOn(msgg));
  }
}


//FOR UPDATE STUDENT INFORMATION
export function* updateStdBasicInfo() {
  const tokenData = JSON.parse(getTokenData());
  const selectedCheckData = yield select(makeSelectSelectedStudent());
  let selectedData = [];
  if (selectedCheckData.length === undefined || selectedCheckData.length === 0) {
    const errresult = ""An error has occured. Please fill up all required fields"";
    yield put(getErrMessage(errresult));
  } else {

    for (const i in selectedCheckData) {
      const DataList = selectedCheckData[i];
      selectedData.push(DataList);
    }

    const requestURL = BASE_URL.concat(UPDATE_ID);
    const options = {
      method: 'PUT',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        'Authorization': tokenData.token_type+"" ""+tokenData.access_token,
      },

      body: JSON.stringify(selectedData),
    }

    try {
      const result = yield call(request, requestURL, options);
      yield put(selectStudent([]));
      yield fetchStudentBasicInfoList();
      yield put(getMessage(result));

    } catch (err) {
      const errresult = ""Something went wrong. Please try again."";
      yield put(setStdBasicInfo(info.item));
      yield put(getErrMessage(errresult));

    }
  }
}


export default function* defaultSaga() {
  yield fetchSectionList();
  yield takeLatest(SUBMIT_FORM, fetchStudentBasicInfoList);
  yield takeLatest(SUBMIT_UPDATE, updateStdBasicInfo);

}
</code></pre>
",""
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","sorry, pardon me?"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Let us [continue this discussion in chat](https://chat.stackoverflow.com/rooms/172377/discussion-between-akhila-hegde-and-brandnew)."
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Yeah, I haven't named as Component."
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Also, I'd suggest that you dont call your component `Component` as this might and mostly prolly will collide with React's named export `Component`"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","I tried that. But again it renders, nothing. Can I make use of ```loader``` state ?"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Instead of `{this.props.userList}`, have you tried `{this.props.userList.length > 0 && this.props.userList}`"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Sure.. edited the question. Please have a look. Thank you."
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Oh well, you have to call the loadUserDetails as soon as the component is mounted (componentDidMount). How? The way you did it. Is the way you've done it not working? If so, are there any errors?"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","No..no, My problem is not in redux, but in react. I have set the thunk, and store everything. Where I need to call the ```loadUserDetails``` to get the ```userList```  ? In ```compoentDidMount```? Or ```componentDidUpdate``` ?  If so, how?"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Have a look at this https://stackoverflow.com/a/49878448/6219957"
"50674295","How to get data from async functions in react components, react-redux?","11","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","Possible duplicate of [How to wait until all of the properties of received synchronous array are set in React-Redux?](https://stackoverflow.com/questions/49877971/how-to-wait-until-all-of-the-properties-of-received-synchronous-array-are-set-in)"
"50690351","componentDidUpdate() working mostly, but not rendering new data","1","<p>I am using the componentDidUpdate() method and for the most part, it is doing what it should. It runs the function to get the data from the API as well as logs it to the console. The problem is that it does not render the new data on the front end. The only time it renders the new data is if the component actually mounts (if the page is refreshed). I feel like I'm very close, but have hit a dead end. Here is my code:</p>

<pre><code>import React from 'react';
import Nav from './Nav';

class List extends React.Component {
constructor(props) {
super(props);
this.state = {
  APIData: []
}
}

getAPIData() {
const url = `http://localhost:3001${this.props.location.pathname}`;
return fetch(url, {
  method: 'GET',
  mode: 'CORS',
  headers: {
    'Accept': 'application/json'
  }
})
  .then(response =&gt; response.json())
  .then(data =&gt; {
    console.log(data);
    return data;
  }).catch(err =&gt; { console.log('Error: ', err) });
};

dataList() {
return (
  &lt;div&gt;
  {this.state.APIData.map((APIData) =&gt; (
    &lt;p&gt; And the data returned is -&gt; {APIData.firstName} 
{APIData.lastName} !&lt;/p&gt;
  )
  )}
  &lt;/div&gt;
) 
}

componentDidMount() {
console.log(this.props.location.pathname);

this.getAPIData()
  .then(data =&gt; {
    console.log('in List.js ', data);
    this.setState({
      APIData: data
    });
  });
}

componentDidUpdate(prevProps, prevState) {
console.log(this.props.location.pathname);
// only update if the data has changed
this.getAPIData()
.then(data =&gt; {
  if (prevProps.data !== this.props.data) {
    this.setState({
      APIData: data
    });
  }
  console.log(data);
});
}

render() {
return (
  &lt;div&gt;
    &lt;Nav /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;div&gt;
      {/* {this.state.APIData.map((APIData) =&gt; (
        &lt;p&gt; And the data returned is -&gt; {APIData.firstName} 
 {APIData.lastName} !&lt;/p&gt;
      )
      )} */}
      {this.dataList()}

    &lt;/div&gt;

  &lt;/div&gt;
 );
 }
 }



 export default List;
</code></pre>
","most APIs have an update-function for those cases. As I don't use your frameworks I can't help more here."
"50703141","How to troubleshoot row height adjustment with expandable rows with react virtualized list?","1","<p>I'm using expandable panels (Material-UI) in rows with a react virtualized list and have been having issues with the heights auto-adjusting. I've read several SO posts and some issues on dynamic row heights on the react-virtualized site, but I have a specific problem where it seems like there's an 'off by one' issue with when the row height is adjusted after panel is expanded/collapsed.</p>

<p>Here's the expected behavior:</p>

<ol>
<li>Row panel expanded by default.</li>
<li>User clicks expandable panel row.</li>
<li>Row panel collapses.</li>
<li>Row height adjusts to panel collapse.</li>
</ol>

<p>Here's the actual behavior <em>FOR THE FIRST CLICK</em>:</p>

<ol>
<li>Row panel expanded by default.</li>
<li>User clicks expandable panel row.</li>
<li>Row panel collapses.</li>
<li>Row height does NOT adjust to panel collapse.</li>
<li>HOWEVER, on subsequent clicks the row height DOES adjust, but to the 'opposite' state, which leads to an inconsistency - i.e when the the row panel is clicked to expand again, the row height is adjusted to the row height as if it were collapsed, and vice versa. So when the panel is collapsed there's a bunch of white space after it, and when it's technically expanded the row height is too small to see the content.</li>
</ol>

<p>I'm not sure what other info to include besides posting code and noting that the onRowClick() IS firing when the panels are collapsed/expanded.</p>

<p>Here's the parent component:</p>

<pre><code>import React, { Component } from 'react';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import List from 'react-virtualized/dist/commonjs/List';
import { CellMeasurer, CellMeasurerCache } from 'react-virtualized/dist/commonjs/CellMeasurer';
import EquipSummaryRow from './EquipSummaryRow';
import './EquipSummary.css';

class EquipSummary extends Component {
  constructor(props) {
    super(props);

    this.cache = new CellMeasurerCache({
      fixedWidth: true,
    });

    this.rowRenderer = this.rowRenderer.bind(this);
    this.getDatum = this.getDatum.bind(this);
    this.onRowClick = this.onRowClick.bind(this);
  }

  getDatum(index) {
    const list = this.props.equipData;

    return list[index];
  }

  saveRef = (ref) =&gt; this.containerNode = ref;

  saveListRef = (ref) =&gt; {
    this.list = ref;
  }

  componentDidUpdate() {
    console.log('component updated');
    this.cache.clearAll();
    this.list.recomputeRowHeights();
  }

  onRowClick(e, index) {
    e.preventDefault();
    this.cache.clear(index);
    this.list.recomputeRowHeights();
    this.list.forceUpdateGrid();
  }

  rowRenderer({ index, key, parent, style }) {
    const datum = this.getDatum(index);
    return (
      &lt;div key={key} style={style}&gt;
        &lt;CellMeasurer
          cache={this.cache}
          columnIndex={0}
          key={key}
          rowIndex={index}
          parent={parent}
        &gt;
          {({ measure }) =&gt; (
            &lt;EquipSummaryRow
              onClick={(e, idx) =&gt; this.onRowClick(e, idx)}
              measure={measure}
              datum={datum}
              index={index}
            /&gt;
          )}
        &lt;/CellMeasurer&gt;
      &lt;/div&gt;
    );
  }

  render() {
    console.log('rendering..');
    return (
      &lt;div className=""EquipSummary-AutoSizer"" ref={this.saveRef}&gt;
        &lt;AutoSizer&gt;
          {({ width, height }) =&gt; (
            &lt;List
              ref={this.saveListRef}
              width={width}
              height={height}
              rowHeight={this.cache.rowHeight}
              rowCount={this.props.equipData.length}
              rowRenderer={this.rowRenderer}
              deferredMeasurementCache={this.cache}
              equipData={this.props.equipData}
            /&gt;
          )}
        &lt;/AutoSizer&gt;
      &lt;/div&gt;
    );
  }
}

export default EquipSummary;
</code></pre>

<p>And here's the component that represents a row:</p>

<pre><code>import React, { Component } from 'react';
import {
  Table,
  TableBody,
  TableHeader,
  TableHeaderColumn,
  TableRow,
  TableRowColumn,
} from 'material-ui/Table';
import { MuiThemeProvider } from 'material-ui/styles';
import ExpansionPanel from '@material-ui/core/ExpansionPanel';
import ExpansionPanelSummary from '@material-ui/core/ExpansionPanelSummary';
import ExpansionPanelDetails from '@material-ui/core/ExpansionPanelDetails';
import Typography from '@material-ui/core/Typography';


class EquipSummaryRow extends Component {
  render() {
    const { datum } = this.props;

    return (
      &lt;div&gt;
        &lt;ExpansionPanel
          defaultExpanded
          onChange={e =&gt; this.props.onClick(e, this.props.index)}
        &gt;
          &lt;ExpansionPanelSummary expandIcon={&lt;div&gt;|&lt;/div&gt;}&gt;
            &lt;Typography&gt;{`${datum.type}      (id: ${datum.instance}, points: ${datum.points.length})`}&lt;/Typography&gt;
          &lt;/ExpansionPanelSummary&gt;
          &lt;ExpansionPanelDetails&gt;
            &lt;Table&gt;
              &lt;TableHeader
                displaySelectAll={false}
                adjustForCheckbox={false}
              &gt;
                &lt;TableRow&gt;
                  &lt;TableHeaderColumn&gt;Device&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Object ID&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Type&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Name&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Description&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Units&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Value&lt;/TableHeaderColumn&gt;
                &lt;/TableRow&gt;
              &lt;/TableHeader&gt;
              &lt;TableBody
                displayRowCheckbox={false}
              &gt;
                {datum.points.map((row, index) =&gt; (
                  &lt;TableRow key={row.id}&gt;
                    &lt;TableRowColumn&gt;{row.device}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.objectID}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.type}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.name}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.description}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.units}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.value}&lt;/TableRowColumn&gt;
                  &lt;/TableRow&gt;
                  ))}
              &lt;/TableBody&gt;
            &lt;/Table&gt;
          &lt;/ExpansionPanelDetails&gt;
        &lt;/ExpansionPanel&gt;
      &lt;/div&gt;
    );
  }
}

export default EquipSummaryRow;
</code></pre>

<p>Could this be an issue with how I'm using the cache? I've been beating my head with this so any suggestions appreciated!</p>
","Don't you give `recomputeRowHeights()` index? Also `recomputeRowHeights(index)` already include a `forceUpdate()` as I read react-virtualized's codes, so I guess `this.list.forceUpdateGrid();` can be omitted?"
"50876815","react.js google maps not shwoing up","0","<p>hi all im trying to use google-maps-react to display a simple map with markers ,but am getting a blank screen with no map for some reason. ALso am getting no errors in the console.
 I provided api key in the index.html file. Any my other google maps librarires are working fine.   ANy help is greatly appreciated ! 
 Rating.js </p>

<pre><code>import React, { Component } from 'react';
import styles from './App.css';
import Map from './Map.js';

import { GoogleApiWrapper } from 'google-maps-react'

import MapContainer from './Map.js'
export default class Rating extends React.Component {
    render(){
        return(


&lt;section classname=""feature""&gt;
          &lt;div id=""banner"" &gt;
            &lt;div classname=""banner__text""&gt;
              &lt;div classname=""l-container""&gt;
                &lt;h2 classname=""heading-1""&gt;
                  &lt;span id=""li""&gt;Take the uncertainty out of planning&lt;/span&gt;

                &lt;/h2&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;
                 &lt;h3 id=""fish""&gt; Never get lost finding the trail. With just one click, get the link right to the trail head. Access has never been so easy.&lt;/h3&gt;
                                  &lt;h3 id=""fish""&gt; Search for trails in any place you like ! Or use your current location to search!!!&lt;/h3&gt;
              &lt;/div&gt;

              &lt;div&gt;
            &lt;MapContainer google={this.props.google} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div classname=""feature__main feature__main--centered l-container""&gt;
            &lt;div classname=""feature__device feature__device--laptop""&gt;
            &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt; &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;   &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt; &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt; 
              &lt;div id=""device""&gt;
                &lt;img src=""http://www.downloadmaps.org/wp-content/uploads/2016/03/maps-laptop.jpg"" alt=""Trail Details Page""/&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div classname=""l-inner-container""&gt;
              &lt;h2 classname=""feature__heading heading-3""&gt;Know the details before you go.&lt;/h2&gt;
              &lt;p&gt;Browse hand-curated trail maps as well as trail reviews, photos and activity recordings &lt;br&gt;&lt;/br&gt; contributed by a
                community of hikers, mountain bikers, trail runners and more.&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;


        );

   }
}
</code></pre>

<p>Map.js </p>

<pre><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom'


export default class MapContainer extends Component {

  // ======================
  // ADD LOCATIONS TO STATE
  // ======================
  state = {
    locations: [
      { name: ""New York County Supreme Court"", location: {lat: 40.7143033, lng: -74.0036919} },
      { name: ""Queens County Supreme Court"", location: {lat: 40.7046946, lng: -73.8091145} },
      { name: ""Kings County Supreme Court"", location: {lat: 40.6940226, lng: -73.9890967} },
      { name: ""Richmond County Supreme Court"", location: {lat: 40.6412336, lng: -74.0768597} },
      { name: ""Bronx Supreme Court"", location: {lat: 40.8262388, lng: -73.9235238} }
    ]
  }

  componentDidUpdate() {
    this.loadMap(); // call loadMap function to load the google map
  }

  loadMap() {
    if (this.props &amp;&amp; this.props.google) { // checks to make sure that props have been passed
      const {google} = this.props; // sets props equal to google
      const maps = google.maps; // sets maps to google maps props

      const mapRef = this.refs.map; // looks for HTML div ref 'map'. Returned in render below.
      const node = ReactDOM.findDOMNode(mapRef); // finds the 'map' div in the React DOM, names it node

      const mapConfig = Object.assign({}, {
        center: {lat: 40.7485722, lng: -74.0068633}, // sets center of google map to NYC.
        zoom: 11, // sets zoom. Lower numbers are zoomed further out.
        mapTypeId: 'roadmap' // optional main map layer. Terrain, satellite, hybrid or roadmap--if unspecified, defaults to roadmap.
      })

      this.map = new maps.Map(node, mapConfig); // creates a new Google map on the specified node (ref='map') with the specified configuration set above.

  // ==================
  // ADD MARKERS TO MAP
  // ==================
      this.state.locations.forEach( location =&gt; { // iterate through locations saved in state
        const marker = new google.maps.Marker({ // creates a new Google maps Marker object.
          position: {lat: location.location.lat, lng: location.location.lng}, // sets position of marker to specified location
          map: this.map, // sets markers to appear on the map we just created on line 35
          title: location.name // the title of the marker is set to the name of the location
        });
      })

    }
  }

  render() {
    const style = { // 
      width: '100%', // 9h screen. px also works.
      height: '100%' // 
    }

    return ( // in our return function h ref='map' and style.

      &lt;div ref=""map"" style={style}&gt;

        loading map...
      &lt;/div&gt;
    )
  }
}
</code></pre>
",""
"50894897","react-leaflet keep opening popup on click instead of opening only once","0","<p>I'm trying to show a popup on the place I clicked every time I click on the map (only one popup needs to show).</p>

<p>The first time it works but any time I click after that it won't:</p>

<pre><code>import React, { Component, createRef } from 'react';
import { Map as LeafletMap, TileLayer, Marker,Popup } from 'react-leaflet';


const newPopup = props =&gt; (
  &lt;Popup position={props.newCoords}&gt;
    &lt;h1&gt;You clicked here&lt;/h1&gt;
  &lt;/Popup&gt;
);

export default class Map extends Component {
  mapRef = createRef()

  handleClick (e) {
    const coords = this.mapRef.current.leafletElement.mouseEventToLatLng(e.originalEvent);
    console.log(coords);
    this.setState({
      ...this.state,
      showNewPopup:true,
      newName:"""",
      newCoords:coords
    })
  }
  constructor() {
    super()
    this.state = {
      lat: 52.369730195560706,
      lng: 4.901275634765625,
      zoom: 10,
      showNewPopup:false,
      newName:"""",
      newCoords:{lat:0,lng:0}
    }
  }

  render() {
    const position = [this.state.lat, this.state.lng];
    return (
      &lt;LeafletMap 
        center={position}
        zoom={this.state.zoom}
        style={{width:""100%"",height:""100%""}}
        onClick={(e)=&gt;this.handleClick(e)}
        ref={this.mapRef}
      &gt;
        &lt;TileLayer
          attribution='&amp;copy; &lt;a href=""http://osm.org/copyright""&gt;OpenStreetMap&lt;/a&gt; contributors'
          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'
        /&gt;
        {
          (this.state.showNewPopup)
            ? newPopup(this.state)
            : """"
        }
      &lt;/LeafletMap&gt;
    );
  }
}
</code></pre>

<p>Popup cannot be extended, when you try there is an error:</p>

<blockquote>
  <blockquote>
    <p>TypeError: Super expression must either be null or a function, not object</p>
  </blockquote>
</blockquote>

<pre><code>class MyPopup extends Popup {

}

const newPopup = props =&gt; (
  &lt;MyPopup position={props.newCoords}&gt;
    &lt;h1&gt;You clicked here&lt;/h1&gt;
  &lt;/MyPopup&gt;
);
</code></pre>

<p>Probably because of <a href=""https://github.com/PaulLeCam/react-leaflet/blob/master/src/Popup.js#L99"" rel=""nofollow noreferrer"">this</a></p>

<pre><code>export default withLeaflet(Popup)
</code></pre>

<p>Tried to wrap the component and get a ref to the leaflet popup</p>

<pre><code>class NewPopup extends Component {
  popRef = createRef()
  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log(""lll"",prevProps.position,this.props.position);
    this.popRef.current.leafletElement.openPopup(this.props.position);
    // this.popRef.current.leafletElement.update();
    // this.popRef.current.leafletElement.bringToFront();
    // debugger;
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Popup position={this.props.position} ref={this.popRef}&gt;
          &lt;h1&gt;You clicked here&lt;/h1&gt;
        &lt;/Popup&gt;
      &lt;/div&gt;
    );
  }
};
</code></pre>

<p>No error but same behavior, never opens a popup after the first click.</p>

<p>Dependencies in package.json:</p>

<pre><code>""dependencies"": {
  ""leaflet"": ""^1.3.0"",
  ""react"": ""^16.4.1"",
  ""react-dom"": ""^16.4.1"",
  ""react-leaflet"": ""^2.0.0-rc.1"",
  ""react-scripts"": ""1.1.4""
},
</code></pre>
",""
"50996256","Re rendering points when resizing map (mapbox + react + d3)","1","<p>I'm trying to put React, Mapbox and d3 together. React for DOM manipulation, Mapbox for map rendering and d3 for drawing on the map. While I have gotten to the stage where I am able to draw a line on the map, I wanted to redraw the line when the user decides to zoom or move in the map. I am quite stuck, as I don't know exactly how to implement this event listener. Here is my code so far:</p>

<pre><code>import React, { Component } from 'react';
import MapboxGl from 'mapbox-gl/dist/mapbox-gl.js';
import MapPoints from './MapPoints.jsx';
import { geoMercator, geoPath, geoTransform, geoProjection } from 'd3-geo';
import './App.css';
import 'mapbox-gl/dist/mapbox-gl.css';

export default class Map extends Component {
    constructor(props) {
        super(props);
        this.d3Draw = [];
        this.box_measures = {
            bottom: 244,
            height: 220,
            left: 0,
            right: 1321,
            top: 24,
            width: 1321,
            x: 0,
            y: 24
        };
    }
    componentDidMount() {
        MapboxGl.accessToken =
            'pk.eyJ1Ijoiam9zZWNvdG8iLCJhIjoiY2l2OGZxZWNuMDAxODJ6cGdhcGFuN2IyaCJ9.7szLs0lc_2EjX6g21HI_Kg';

        this.map = new MapboxGl.Map({
            container: this.mapContainer,
            style: 'mapbox://styles/mapbox/streets-v9'
        });

        this.map.jumpTo({ center: [13.29, 52.51], zoom: 10 });
        this.map.addControl(new MapboxGl.NavigationControl());
        this.box_measures = document.getElementsByClassName('mapboxgl-canvas')[0].getBoundingClientRect();
    }

    componentWillUnmount() {
        this.map.remove();
    }

    componentDidUpdate() {
        this.d3Draw = this.props.dataPoints.map(x =&gt;
            this.map.project(new MapboxGl.LngLat(x.geometry.coordinates[0], x.geometry.coordinates[1]))
        );
    }

    render() {
        const style = {
            position: 'absolute',
            top: 100,
            bottom: 0,
            width: '80%'
        };

        return (
            &lt;div&gt;
                &lt;div className=""map"" style={style} ref={el =&gt; (this.mapContainer = el)} /&gt;
                &lt;MapPoints drawPoints={this.d3Draw} measures={this.box_measures} /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>Your help will be greatly appreciated!</p>
","Have you seen [this Stack thread](https://stackoverflow.com/questions/41612091/get-current-position-on-zoomstart) on handling the ""zoomStart"" event? [Here is a link to the general ""zoom"" event dc page](https://www.mapbox.com/mapbox-gl-js/api/#map.event:zoomstart). But maybe better to handle on ""zoomStart""/""zoomEnd"" to reduce handler calls."
"51066954","fullcalendar react wrapper scheduler passing events","0","<p>I'm trying to use fullcalendar-react-wrapper-scheduler in my project.</p>

<p>The documentation shows an example of passing events into the FullCalendar component, however it does not show how to pass in resources.</p>

<p>I'm attempting to pass in ""resources"" by mimicking how ""events"" are being passed in. But that does not display any resources on the DOM. </p>

<p>Has anyone successfully used this package that can provide guidance for passing in resources?</p>

<p>Documentation:
<a href=""https://www.npmjs.com/package/fullcalendar-reactwrapper-scheduler#examples"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/fullcalendar-reactwrapper-scheduler#examples</a></p>

<p>Here's a code snippet showing how I am passing in events (successfully) and resources (not successfully):
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';

import { connect } from 'react-redux';

import Nav from '../../components/Nav/Nav';



import { USER_ACTIONS } from '../../redux/actions/userActions';

import { LOGIN_ACTIONS } from '../../redux/actions/loginActions';



//START CALENDAR LIBRARY IMPORTS//
import FullCalendar from 'fullcalendar-reactwrapper-scheduler';
import 'fullcalendar-reactwrapper-scheduler/dist/css/fullcalendar.min.css';
//END CALENDAR LIBRARY IMPORTS//



const mapStateToProps = state =&gt; ({
    user: state.user,
});

class ExampleComponent extends Component {
    constructor(props) {
        super(props);
        this.state = {
            events: [
                {
                    resourceId: 'a',
                    id: 1,
                    title: 'Shoot 1',
                    start: '2017-06-27T08:00:00',
                    end: '2017-06-27T09:00:00'
                },
                {
                    resourceId: 'b',
                    id: 2,
                    title: 'Shoot 2',
                    start: '2017-06-27T10:00:00',
                    end: '2017-06-27T11:00:00'
                },
                {
                    resourceId: 'a',
                    id: 3,
                    title: 'Shoot 3',
                    start: '2017-06-27T13:00:00',
                    end: '2017-06-27T14:00:00'
                },
                {
                    resourceId: 'c',
                    id: 4,
                    title: 'Shoot 4',
                    start: '2017-06-27T08:00:00',
                    end: '2017-06-27T09:00:00'
                },
                {
                    resourceId: 'd',
                    id: 5,
                    title: 'Shoot 5',
                    start: '2017-06-27T012:00:00',
                    end: '2017-06-27T13:00:00'
                },
            ],
            resources: [
                { id: 'a', title: 'Room A' },
                { id: 'b', title: 'Room B' },
                { id: 'c', title: 'Room C' },
                { id: 'd', title: 'Room D' },
            ]
        }
    }

    componentDidMount() {
        this.props.dispatch({
            type: USER_ACTIONS.FETCH_USER
        });
    }

    componentDidUpdate() {
        if (!this.props.user.isLoading &amp;&amp; this.props.user.userName === null) {
            this.props.history.push('home');
        }
    }

    logout = () =&gt; {
        this.props.dispatch({
            type: LOGIN_ACTIONS.LOGOUT
        });
        // this.props.history.push('home');
    }

    render() {
        let content = null;

        if (this.props.user.userName) {
            content = (
                &lt;div id=""example-component""&gt;
                    &lt;FullCalendar
                        id=""your-custom-ID""
                        header={{
                            left: 'prev,next today myCustomButton',
                            center: 'title',
                            right: 'month,basicWeek,basicDay'
                        }}
                        defaultDate={'2017-06-27'}
                        navLinks={true} // can click day/week names to navigate views
                        editable={true}
                        eventLimit={true} // allow ""more"" link when too many events
                        events={this.state.events}
                        resources={this.state.resources}
                        defaultView='agendaDay'

                    /&gt;
                &lt;/div&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;Nav /&gt;
                {content}
            &lt;/div&gt;
        );
    }
}

// this allows us to use &lt;App /&gt; in index.js
export default connect(mapStateToProps)(ExampleComponent);</code></pre>
</div>
</div>
</p>
",""
"51174738","react-quill How to properly add attribute to a specific html tag","0","<p>Here is what I want to achieve. My user is typing a text in a react-quill component and each time the user type a hashtag like ""<strong>#S1</strong> "" (the space is important, it allow to detect when the user has finished to type his tag) I want to replace the tag #S1 by a specific text containing some value.</p>

<p>I <strong>don't use delta</strong>, but HTML string for the value of the reat-quill component. So far I have succeed to replace the hastag bug the proper value I need, and add a color to the span inserted. What I want to also add is a title attribute that will allow to show the corresponding tag name (i.e. #S1) and an id that will identify uniquely identify the content of the tag. But when I tried to add these attribute in my span, it's systematically strip.</p>

<p>I understood that I have to create my own parchment, but I' didn't succeed to get it work. Here is my code.</p>

<pre><code>const modules = {
  toolbar: [
    [{header: [1, 2, false]}],
    ['bold', 'italic', 'underline', 'strike', 'blockquote'],
    [{'script': 'sub'}, {'script': 'super'}],
    [{'list': 'ordered'}, {'list': 'bullet'}, {'indent': '-1'}, {'indent': '+1'}],
    ['link', 'image'],
    ['clean'],
    [{color: []}, {background: []}],
  ],
};
const formats = [
  'header',
  'bold', 'italic', 'underline', 'strike', 'blockquote',
  'script', 'sub', 'super',
  'list', 'bullet', 'indent',
  'link', 'image',
  'color', 'background',

];
/**
 * Inline Em Tag from Quill Docs:
 * https://quilljs.com/guides/cloning-medium-with-parchment/
 */
let Inline = ReactQuill.Quill.import('blots/inline');
class EmphBlot extends Inline {
  static create(value) {
    console.log(value);
    let node = super.create();
    node.setAttribute('style', 'color: rgb(230, 0, 0)');
    node.setAttribute('title', value.title);

    return node;
  }

  static value(node) {
    return {
      title: node.getAttribute('title'),
      style: node.getAttribute('style')
    };
  }
}

EmphBlot.blotName = 'tag';
EmphBlot.tagName = 'span';
ReactQuill.Quill.register('formats/em', EmphBlot);

class Editor extends React.Component {
  constructor (props) {
    super(props)
    this.state = { editorHtml: '&lt;p&gt;Start here by typing a hashtag&lt;/p&gt;' }
    this.quillRef = null;
    this.reactQuillRef = null;
    this.handleChange = this.handleChange.bind(this)
    this.handleClickEmbed = this.handleClickEmbed.bind(this)
    this.handleClickFormat = this.handleClickFormat.bind(this)
    this.registerFormats = this.registerFormats.bind(this)
  }

  componentDidMount () {
    this.registerFormats()
    this.setState({
      editorHtml: '' // trigger update
    })
  }

  componentDidUpdate () {
    this.registerFormats()
  }

  registerFormats () {
    // Ensure React-Quill references is available:
    if (typeof this.reactQuillRef.getEditor !== 'function') return;
    // Skip if Quill reference is defined:
    if (this.quillRef != null) return;

    console.log('Registering formats...', this.reactQuillRef)
    const quillRef = this.reactQuillRef.getEditor() // could still be null

    if (quillRef != null) {
      this.quillRef = quillRef;
      // console.log(Quill.imports)
    }
  }

  handleClickFormat () {
    var range = this.quillRef.getSelection();
    if (range) {      
      this.quillRef.format('em', true);
    }
  }

  handleClickEmbed () {
    var range = this.quillRef.getSelection();
    if (range) {      
      this.quillRef.insertEmbed(range.index,""hr"",""null"")
    }
  }

  checkForTag(content, indexPosition){
  let tag = /#(\w+)\s/;
  let find = content.match(tag);
  let indexAfterInsertion = indexPosition;
  let updated = false;
  let comment;
  if (find !== null) {
    indexAfterInsertion = indexPosition - find[0].length;
    let replace = ""My new data (1, 5, 3)""
    indexAfterInsertion += replace.length + 1;
    updated = true;
    if (replace !== '#' + find[1]) {
      let toReplacer = '&lt;span style=""color:red"" title=""tag-' + find[1].toUpperCase() + '""&gt;' + replace + '&lt;/span&gt;&amp;nbsp;';
      // console.log(toReplacer);
      comment = content.replace(/#(\w+)\s/, toReplacer);
    } else {
      comment = content.replace(/#(\w+)\s/, find[1] + ""&amp;nbsp;"");
    }
  }
  // console.log(comment);
  return {content: comment, updated, indexAfterInsertion}
  }

  handleChange (content, delta, source, editor) {
    let editorHtml = content
    let newHtml = this.checkForTag(content);
    if(newHtml.updated === true){
      console.log(newHtml);
      editorHtml = newHtml.content
    }
    console.log(editorHtml)
    this.setState({editorHtml});
  }

  render () {
    return (
      &lt;div&gt;
        &lt;p&gt;Enter a text containing #S1 (or any other tag, the space must be placed after the tag). It sould be replaced by an other data, but missing the attribute title.&lt;/p&gt;

        &lt;ReactQuill 
          ref={(el) =&gt; { this.reactQuillRef = el }}
          value={this.state.editorHtml}
          onChange={this.handleChange.bind(this)}
          modules={modules}
          formats={formats}
          /&gt;
       &lt;/div&gt;
     )
  }
}

Editor.propTypes = {
  placeholder: React.PropTypes.string,
}

ReactDOM.render(
  &lt;div&gt;
    &lt;Editor/&gt;
   &lt;/div&gt;, 
  document.querySelector('.app')
)
</code></pre>

<p>Here is a codepen showing how it work so far <a href=""https://codepen.io/FLCcrakers/pen/JZVeZE?editors=0111"" rel=""nofollow noreferrer"">https://codepen.io/FLCcrakers/pen/JZVeZE?editors=0111</a></p>

<p>I surely miss something, but don't understand what. </p>
",""
"51214269","How to access a form inside InfoWindow content in React using Google maps api and google-maps-react V2.0.2","0","<p>I am trying to view an InfoWindow everytime the maps is clicked, it will show an input field and a button to add the named location to list. For now, I am just trying to get the text out of the form, the problem that I am having is how to access the form when the button is clicked???!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import ReactDOM from 'react-dom';
import PopUpForm from './PopUpForm';
import ReactDOMServer from 'react-dom/server'

class Map extends React.Component {
  
  state = {
      infowindow: new google.maps.InfoWindow({}),
  }

  componentDidUpdate(prevProps, prevState) {
    console.log('componentDidUpdate');
    if (prevProps.google !== this.props.google) {
      this.loadMap();
    }
  }

  componentDidMount() {
    console.log('componentDidMount');
    this.loadMap();
  }

  loadMap() {
    console.log('loadMap');
    if (this.props &amp;&amp; this.props.google) {
      // google is available
      const {google} = this.props;
      const maps = google.maps;

      const mapRef = this.refs.map;
      const node = ReactDOM.findDOMNode(mapRef);

      const {initialCenter, zoom} = this.props;
      const {lat, lng} = initialCenter;
      const center = new maps.LatLng(lat, lng);
      const mapConfig = Object.assign({}, {
        center,
        zoom
      })
      this.map = new maps.Map(node, mapConfig);

      // adding markers for corresponding saved places
      const pos = {lat: 59.329113196988345 , lng: 17.966015144369067};
      const marker = new google.maps.Marker({
        position: pos,
        map: this.map,
        title: 'first marker',
      });
      const infowindow = new google.maps.InfoWindow({
        content: `&lt;h3&gt;${marker.title}&lt;/h3&gt;`
      });
      marker.addListener('click', () =&gt; {
        infowindow.open(this.map, marker);
      });

      // pop up  infoWindoW on map
      this.map.addListener('click', (e) =&gt; {
        this.state.infowindow.close();
        const popUp = &lt;PopUpForm onSubmit={this.onSubmit}/&gt;;
        this.showPopupOnMap(e.latLng, popUp);
        google.maps.event.addListener(this.state.infowindow, 'domready', () =&gt; {
          // HOW TO ACCESS THE FORM HERE
        });
      })
      this.forceUpdate();
    }      
}

onSubmit = () =&gt; {
  e.preventDefault();
  window.alert('onSubmit form')
}

showPopupOnMap = (latLng, popUp) =&gt; {
  const contentString = ReactDOMServer.renderToString(popUp)

  const pos = { lat: latLng.lat(), lng: latLng.lng() };

  this.state.infowindow = new google.maps.InfoWindow({
    content: contentString,
    position: pos
  });
  this.state.infowindow.open(this.map)
}

renderChildren() {
  console.log('renderChildren');
  const {children} = this.props;
  if (!children) return;
  return React.Children.map(children, c =&gt; {
    return React.cloneElement(c, {
      map: this.map,
      google: this.props.google,
    });
  })
}

render() {
  console.log('render');
    const style = {
      width: '70vw',
      height: '70vh'
    }

    return (
      &lt;div  ref=""map"" style={style}&gt;
        loading map...
        {this.renderChildren()}
      &lt;/div&gt;
    )
  }
};

Map.defaultProps = {
  zoom: 11,
  initialCenter: {
    lat: 59.3293,
    lng: 18.0686
  }
}

export default Map;</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';

class PopUpForm extends React.Component {
    render() {
        return (
            &lt;div id='iwc' ref='iwc' &gt;
                &lt;b&gt;Add this location&lt;/b&gt;&lt;br /&gt;
                &lt;form ref='mapform' className='map-form' onSubmit={this.onSubmit}&gt;
                    &lt;input type='text' /&gt;
                    &lt;button id='btn'&gt;Add&lt;/button&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        );
    }
}

export default PopUpForm;</code></pre>
</div>
</div>
</p>

<p>inside of this.map.addListner(this.state.infoWindow, 'domready', someFunctionToBeCalled) I do not know how to acces the form in React, I searched about it all I could found is this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>google.maps.event.addListener(info, 'domready', function() {
    document.id(""map-form"").addEvent(""submit"", function(e) {
        e.stop();
        console.log(""hi!"");
    });
});</code></pre>
</div>
</div>
</p>

<p>is this even possible? Am I missing something??</p>
",""