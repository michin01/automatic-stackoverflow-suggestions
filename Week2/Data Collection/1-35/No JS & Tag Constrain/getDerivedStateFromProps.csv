Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate
"50185157","1","50185682","","2018-05-05 02:33:33","","3","149","<p>I am working with react 16.3 where <code>componentWillUpdate</code> is deprecated (strict mode). We have a react wrapper around <code>Highcharts</code> and used to update the <code>highchart</code> in <code>componentWillUpdate</code> that runs just before render. </p>

<p>But now in react 16.3 when the input <code>highchartoptions</code> prop updates, there seems to be no way to call <code>Highchart.update</code> before <code>render()</code> is called. Its suggested to use <code>componentDidUpdate</code> but its called only after <code>render()</code> and it doesn't seem to work at all.Any suggestions will help.</p>

<p>Code snippet here:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class HighchartReactWrapper extends React.Component {
  constructor(props) {
    super(props);

    // We maintain the user provided options being used by highchart as state
    // inorder to check if chart update is needed.
    this.state = { highChartOptions: this.props.options };
    this.onChartRendered = this.onChartRendered.bind(this);
  }

  componentDidMount() {
    // Create chart
    this.chart = new Highcharts.Chart(this.container, this.state.highChartOptions, this.onChartRendered);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.options !== prevState.options) {
      return { highChartOptions: nextProps.options };
    }
  }

  componentDidUpdate() {
    this.chart.update(this.state.highChartOptions, false, true); &lt;---- Doesn't work
  }

  onChartRendered() {
    // Callbacks..
    if (this.props.onChartRenderedCallback !== undefined) {
      this.props.onChartRenderedCallback();
    }
  }

  componentWillUnmount() {
    // Destroy chart
    this.chart.destroy()
  }

  render() {
    return (
      &lt;div className=""react-highchart-wrapper""&gt;
        &lt;div id={container =&gt; this.container = container} /&gt;
      &lt;/div&gt;
    );
  }
}

HighchartReactWrapper.propTypes = {
  /**
   * Chart options to be used in Highcharts library.
   */
  options: PropTypes.object.isRequired,
  onChartRenderedCallback: PropTypes.func
};

HighchartReactWrapper.defaultProps = {
  options: undefined,
  onChartRenderedCallback: undefined
};</code></pre>
</div>
</div>
</p>
","9743947","","6622817","","2018-05-05 02:38:16","2018-05-05 04:23:13","How to update Highchart from inside react a component?","<reactjs><highcharts>","1","3","1","",""
"51392633","1","","","2018-07-18 02:18:56","","0","22","<p>I had successfully configured the <code>StackNavigator</code> in react-navigation v1.5.x to track navigation events in order to render contextually informative components as part of a screen's <code>navigationOptions</code>. Unfortunately, this no longer works with react-navigation v2.2.3.</p>

<p>In short, in v2.2.3 a navigation event results in the invocation of the screen's <code>navigationOptions</code> BEFORE the <code>StackNavigator</code> invokes its <code>onNavigationStateChange</code> listener. This means that the <code>navigationOptions</code> are always being invoked with stale <code>screenProps</code>.</p>

<p>What is the recommended way of implementing this functionality in react-navigation v2.</p>

<blockquote>
  <p>&lt;&lt; GORY DETAILS BELOW >></p>
</blockquote>

<p>I spent way too much time digging into this to see why this was occurring.</p>

<p>In v2.2.3 <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/createNavigationContainer.js#L313"" rel=""nofollow noreferrer""><code>NavigationContainer.dispatch</code></a> processes the navigation event in question.</p>

<ul>
<li>The navigation event causes a new route to be added to the navigation state <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/createNavigationContainer.js#L322"" rel=""nofollow noreferrer"">[code reference]</a></li>
<li>The navigator stores the navigation state as component state, so <code>dispatch()</code> now calls <code>setState</code> with the new <code>navState</code> <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/createNavigationContainer.js#L349"" rel=""nofollow noreferrer"">[code reference]</a></li>
<li>Now we pop out of <code>dispatch()</code>. The change in <code>navState</code> means that the <code>StackNavigator</code>'s <code>navigation</code> prop is updated which causes react to invoke <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/navigators/createNavigator.js#L16"" rel=""nofollow noreferrer""><code>Navigator.getDerivedStateFromProps</code></a></li>
<li>The <code>navigationOptions</code>, among several navigation relation options, will be invoked on the screen associated to the new route <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/navigators/createNavigator.js#L64"" rel=""nofollow noreferrer"">[code reference]</a> </li>
<li>The <code>dispatch()</code> invokes <code>onNavigationStateChange</code> via a call back passed to the prior <code>setState</code> call. This means that <code>onNavigationStateChange</code> will be invoked only AFTER the state update has taken effect. <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/createNavigationContainer.js#L350"" rel=""nofollow noreferrer"">code reference</a></li>
<li>In my case, the invocation of my navigator's <code>_onNavigationStateChange</code> results in updates to <code>screenState</code> which is then passed to the <code>StackNavigator</code>. While he does result in an invocation of <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/navigators/createNavigator.js#L16"" rel=""nofollow noreferrer""><code>Navigator.getDerivedStateFromProps</code></a> with up to date screen titles, that 2nd invocation doesn't result in a call to the Screen's <code>navigationOptions</code>. <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/navigators/createNavigator.js#L16"" rel=""nofollow noreferrer""><code>Navigator.getDerivedStateFromProps</code></a> only ends up calling <code>navigationOptions</code> the first time the route is placed on the navigation stack array <a href=""https://github.com/react-navigation/react-navigation/blob/2.2.3/src/navigators/createNavigator.js#L24"" rel=""nofollow noreferrer"">code reference</a></li>
</ul>

<p>My navigator code looks similar to this:</p>

<pre><code>_onNavigationStateChange = (previousState, currentState) =&gt; {
  const currentRoute = getRouteTitle(currentState);
  const previousRoute = getRouteTitle(previousState);
  // this only processes the initial ""before nav"" events.
  if (currentRoute === previousRoute) return;

  const updatedScreenState = {
    ...this.state.screenState,
    currentTitle: currentRoute,
    previousTitle: previousRoute
  };
  this.setState({ screenState: updatedScreenState });
};

render(): Element&lt;*&gt; {
  return (
    &lt;StackNavigator
      screenProps={this.state.screenState}
      onNavigationStateChange={this._onNavigationStateChange}
    /&gt;
  );
}
</code></pre>

<p>This is how one of my screens tries to use the <code>screenProps</code> title:</p>

<pre><code>class MyScreenIso extends React.Component {
  // Provides the navbar header to AppNavigator's Stack Navigation
  static navigationOptions =
    ({ navigation, screenProps }) =&gt; {
      // refining the screenProps type to one we expect
      const typedScreenProps = screenProps;

      const backBtnLabel = typedScreenProps.previousTitle ? `Go back to ${typedScreenProps.previousTitle}` : 'Go back';
      return {
        headerLeft: (
          &lt;McIcon
            style={Styles.headerIcon}
            size={30}
            accessibilityLabel={backBtnLabel}
            accessibilityRole=""link""
            name=""arrow-left""
            onPress={() =&gt; {
              navigation.goBack();
            }}
          /&gt;
        )
      };
    };
</code></pre>
","1284852","","9206753","","2018-07-18 08:52:00","2018-07-18 08:52:00","react-navigation v2 screen's navigationOptions invoked before navigator's onNavigationStateChange","<reactjs><react-navigation>","0","0","","",""
"50056137","1","50056187","","2018-04-27 05:59:42","","1","147","<p>I cannot understand, why when I try to start the function <code>getTodosList</code> inside the <code>getDerivedStateFromProps</code> the method - it always retrun to me the <code>TypeError - Cannot read property 'getTodosList' of null</code>. </p>

<p>Also after I start use the <code>getDerivedStateFromProps</code> - my function does not start in <code>componentDidMount</code> too...</p>

<p>What is I'm doing wrong? (</p>

<pre><code>import React, { Component } from 'react';
import {Doughnut} from 'react-chartjs-2';

class Chart extends Component {
    constructor(props) {
        super(props);

        this.state = {
            // some state...
    }

    getTodosList = (todos) =&gt; {
        console.log(todos);
        const all = [];
        const done = [];

        // some logic...

    }

    componentDidMount() {
        const { todos } = this.props.state.iteams;
        console.log('componentDidMount', todos);

        this.getTodosList(todos);
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        const { todos } = nextProps.state.iteams;
        console.log(this.getTodosList, prevState.datasets, 'componentWillReceiveProps', todos);

        this.getTodosList(todos); // TypeError: Cannot read property 'getTodosList' of null

    }
</code></pre>
","9433929","","","","","2018-04-27 06:26:38","React. Cannot start function inside the getDerivedStateFromProps","<javascript><reactjs>","2","0","1","",""
"50185726","1","","","2018-05-05 04:33:23","","-1","169","<p>I've a problem using <code>getDerivedStateFromProps</code> with redux. I want to replace <code>componentWillReceiveProps</code> to upgrade to react 16, but somehow it won't fire. Below is my container component code</p>

<pre><code>@connect(state=&gt;({user: state.user, global: state.global}), {loginUser})
class LoginFormContainer extends React.Component {

  constructor() {
    super()
    this.state = {
      email: '',
      password: '',
      isAuthenticated: false
    }
  }

  //but this worked?
  componentWillReceiveProps(nextProps) {
    if(nextProps.user.isAuthenticated !== this.props.user.isAuthenticated &amp;&amp; nextProps.user.isAuthenticated) {
        this.props.history.location.replace('/dashboard')
    }
  }

  /*static getDerivedStateFromProps(nextProps, prevState) {
    console.log('not even fired?')
    if (nextProps.user.isAuthenticated !== prevState.isAuthenticated) {
      return {
        isAuthenticated: '/dashboard'
      }
    }

    return null
  }*/

  handleSubmit() {
    const { email, password } = this.state
    this.props.loginUser(email, password)
  }

  render(){

    this.state.isAuthenticated &amp;&amp; &lt;Redirect to={'/dashboard'} /&gt;

    return(
      &lt;LoginForm /&gt;
    )
  }
}

export default LoginFormContainer
</code></pre>
","8221187","","","","","2018-05-05 05:47:59","replace componentWillReceiveProps in redux with getDerivedStateFromProps but not firing","<javascript><reactjs><redux>","1","2","","",""
"50098764","1","","","2018-04-30 10:37:19","","0","563","<p>I'm trying to use the new <a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""nofollow noreferrer"">getDerivedStateFromProps</a> lifecycle method in my React Native component but the method never gets called. I've tried looking it up but found <a href=""https://github.com/facebook/react-native/issues?utf8=%E2%9C%93&amp;q=getDerivedStateFromProps"" rel=""nofollow noreferrer"">no issues</a> in the react-native repo. No results on StackOverflow or Google either.</p>

<p>What I did find are a <a href=""https://www.reddit.com/r/reactjs/comments/8abmdl/getderivedstatefromprops_not_working/"" rel=""nofollow noreferrer"">reddit thread</a> and a <a href=""https://stackoverflow.com/a/50010498/2634633"">StackOverflow issue</a> which both cite updating <code>react-dom</code> as a solution, which would not work in this case since there's no dom in React Native.</p>

<p><strong>Can anyone confirm if this method is supposed to work in React Native?</strong> If it can be used, any help with solving this issue will be much appreciated.</p>

<p>Below is a simplified version of my component:</p>

<pre><code>import React from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';

import { Auth } from '../redux';
import ChillaAPI from '../api';

const withUserData = WrappedComponent =&gt; {
  class UserDataLoader extends React.Component {

    static getDerivedStateFromProps(props, state) {

      console.log('getDerivedStateFromProps');

      if (props.uid !== state.uid) {
        return {
          uid: props.uid,
        };
      }

      return state;
    }

    state = { uid: null };

    render() {
      console.log({ propsUid: this.props.uid });
      console.log({ stateUid: this.state.uid });
      return &lt;WrappedComponent /&gt;;
    }
  }

  UserDataLoader.propTypes = {
    uid: PropTypes.bool.isRequired,
  };

  return connect(mapStateToProps)(UserDataLoader);

};

function mapStateToProps(state) {
  return {
    uid: Auth.selectors.getUid(state),
  };
}

export default withUserData;
</code></pre>

<p>The log output from the component is as follows:</p>

<pre><code>{ propsUid: null }
{ stateUid: null }
{ propsUid: 'jW78ej3JDgPpheadAlcrkG8UIZB2' }
{ stateUid: null }
</code></pre>

<p>Here is my package.json for good measure:</p>

<pre><code>{
  ""name"": ""Chilla"",
  ""version"": ""0.0.1"",
  ""private"": true,
  ""scripts"": {
    ""start"": ""node node_modules/react-native/local-cli/cli.js start"",
    ""start:reset"": ""node node_modules/react-native/local-cli/cli.js start --reset-cache"",
    ""watch:lint"": ""node node_modules/eslint-watch/bin/esw -w"",
    ""test"": ""jest"",
    ""precommit"": ""lint-staged""
  },
  ""lint-staged"": {
    ""*.js"": [
      ""node_modules/.bin/prettier --single-quote --trailing-comma es5 --write"",
      ""eslint"",
      ""git add""
    ]
  },
  ""dependencies"": {
    ""axios"": ""^0.18.0"",
    ""firebase"": ""^4.13.1"",
    ""husky"": ""^0.14.3"",
    ""lint-staged"": ""^7.0.4"",
    ""prop-types"": ""^15.6.1"",
    ""react"": ""16.3.1"",
    ""react-native"": ""^0.52.2"",
    ""react-native-fetch-blob"": ""^0.10.8"",
    ""react-native-image-picker"": ""^0.26.7"",
    ""react-navigation"": ""^1.5.11"",
    ""react-redux"": ""^5.0.7"",
    ""recompose"": ""^0.27.0"",
    ""redux"": ""^4.0.0"",
    ""redux-logger"": ""^3.0.6""
  },
  ""devDependencies"": {
    ""babel-eslint"": ""^8.2.3"",
    ""babel-jest"": ""22.4.3"",
    ""babel-preset-react-native"": ""4.0.0"",
    ""eslint"": ""^4.19.1"",
    ""eslint-config-airbnb"": ""^16.1.0"",
    ""eslint-config-prettier"": ""^2.9.0"",
    ""eslint-plugin-import"": ""^2.11.0"",
    ""eslint-plugin-jsx-a11y"": ""^6.0.3"",
    ""eslint-plugin-react"": ""^7.7.0"",
    ""eslint-plugin-react-native"": ""^3.2.1"",
    ""eslint-watch"": ""^3.1.4"",
    ""jest"": ""22.4.3"",
    ""prettier"": ""^1.12.1"",
    ""react-test-renderer"": ""16.3.1""
  },
  ""jest"": {
    ""preset"": ""react-native""
  }
}
</code></pre>
","2634633","","2634633","","2018-04-30 10:47:47","2018-04-30 20:14:26","getDerivedStateFromProps not called in React Native","<javascript><reactjs><react-native>","1","2","","",""
"49673143","1","49677858","","2018-04-05 13:04:30","","11","3485","<p>I use <strong>React 16.3.1</strong> and <strong>next.js</strong>.<br />
And I put <strong>getDerivedStateFromProps</strong> inside the class extending <strong>PureComponent</strong>.</p>

<p>Here is the code:</p>

<blockquote>
  <p>Header.js</p>
</blockquote>

<pre><code>import { PureComponent } from 'react'
...

export default class Header extends PureComponent {
  constructor (props) {
    super(props)

    this.colorAnimationProps = {
      animationDuration: '0.4s',
      animationFillMode: 'forwards'
    }

    this.colorAnimationStyle = {
      toColor: {
        animationName: 'toColor',
        ...this.colorAnimationProps
      },
      toTransparent: {
        animationName: 'toTransparent',
        ...this.colorAnimationProps
      }
    }

    this.state = {
      colorAnimation: {},
      headerModal: null
    }
  }

  componentDidMount () {
    if (this.props.isColor) {
      this.setState({colorAnimation: this.colorAnimationStyle.toColor})
    }
  }

  static getDerivedStateFromProps (nextProps, prevState) {
    console.log('should go here')
    if (nextProps.isColor) {
      return {colorAnimation: this.colorAnimationStyle.toColor}
    }
    return {colorAnimation: this.colorAnimationStyle.toTransparent}
  }

  render () {
    ...
  }
}
</code></pre>

<p>And here is the parent that modifies the prop:</p>

<blockquote>
  <p>index.js</p>
</blockquote>

<pre><code>import { PureComponent } from 'react'

...
import Header from '../components/Header'
import Layout from '../components/Layout'
import { withReduxSaga } from '../redux/store'

class Index extends PureComponent {
  constructor (props) {
    super(props)

    this.state = {
      isHeaderColor: false
    }
  }

  componentDidMount () {
    if (window.pageYOffset &gt; 50) {
      this.setState({isHeaderColor: true})
    }

    window.addEventListener('scroll', (e) =&gt; {
      if (window.pageYOffset &gt; 50) {
        this.setState({isHeaderColor: true})
      } else {
        this.setState({isHeaderColor: false})
      }
    })
  }

  render () {
    return (
      &lt;Layout url={this.props.url}&gt;
        &lt;Header isColor={this.state.isHeaderColor} /&gt;
        ...
      &lt;/Layout&gt;
    )
  }
}

export default withReduxSaga(Index)
</code></pre>

<p>My problem is: getDerivedStateFromProps is not called when the prop changes. At least, it should do console.log, but it doesn't.</p>

<p>Can anybody here help me?</p>
","1333432","","1333432","","2018-04-05 16:06:29","2018-06-09 09:03:29","getDerivedStateFromProps is not called","<reactjs><next.js><react-16>","2","5","","",""
"49684141","1","","","2018-04-06 02:05:03","","0","363","<p>I am waiting for the redux store to be populated so that I can reload a React Native screen but am having issues refreshing the page upon this redux state being updated.</p>

<p>Specifically, I am working with wix's react-native-navigation library and have started a tab based app. I push the login screen from the first screen of the tabs and don't pop it back until successful login/signup. Because of this set up, all default tab screens load before the login flow is complete and I can obtain a user authorization token. When I receive this authorization token I want to refresh one of the screens because I can now make requests with this token.</p>

<p>Here is currently what I have:</p>

<p>AuthActions.js:</p>

<pre><code>export const facebookLogin = (id, token) =&gt; { 
//""token"" here isn't the token i need -  i know, confusing
    return dispatch =&gt; {
        fetch('https://somethingsomething.com/auth/facebook/'+id+'/'+token)
        .then((response) =&gt; response.json())
        .then((responseJson) =&gt; {
            console.log(responseJson.token); // &lt; - This is the token I need 
            return facebookSuccess(dispatch, responseJson);
        })
        .catch((error) =&gt; {
            console.log(error);
            return facebookFail(dispatch);
        });
    };
};


const facebookSuccess = (dispatch, data) =&gt; {
    dispatch({
        type: FACEBOOK_LOGIN_SUCCESS,
        payload: data
    });
};
</code></pre>

<p>AuthReducer.js </p>

<pre><code>export default (state = INITIAL_STATE, action) =&gt; {
    switch (action.type) {
        case FACEBOOK_LOGIN_SUCCESS:
        console.log(action.payload.token); //Successfully logged here
            return {
                ...state,
                ...INITIAL_STATE,
                firstName: action.payload.user.firstName,
                lastName: action.payload.user.lastName,
                user: action.payload.user.id,
                profilePicture: action.payload.user.profilePic,
                authorization: action.payload.token
                };
        default:
                ...
     }
}
</code></pre>

<p>In ComponentIWantToReRender.js:</p>

<pre><code>getDerivedStateFromProps(nextProps, prevState) {
    console.log(""Hello is anyone there?"");
    console.log(nextProps);
    console.log(prevState);
    //Never called - supposed to update when new props received
}


const mapStateToProps = state =&gt; {
        const { ha, foo, bar } = state.groove;
        const { user, authorization } = state.auth;
        return {
            ha,
            foo,
            bar,
            user,
            authorization, //this is the ever so special token i need
        };
};

export default connect(mapStateToProps, { unrelatedFunctionName })(ComponentIWantToReRender);
</code></pre>

<p>In ComponentIWantToReRender.js if I log this.props.authorization during the render process it comes up undefined. This is because it hasn't been set up yet through the login process/redux. I need to wait until it's ready but am unsure how to do that. Does anyone have any advice or insight?</p>
","8464291","","8464291","","2018-04-06 04:31:06","2018-04-06 04:31:06","How to wait for redux to change prop - getDerivedStateFromProps","<javascript><react-native><redux>","0","6","","",""
"50115373","1","50115534","","2018-05-01 11:04:44","","1","353","<p>I want to create a Modal-like component that receives an open/closed boolean as a prop, then stores that value in the component state. When closing the Modal, I want to update the close boolean prop, but wait a few seconds before updating the component state so that I can add transition classes and animate the exit.</p>

<p>With <code>componentWillReceiveProps</code>, I could accomplish this by wrapping <code>this.setState</code> in a timeout and add the classes in the meantime. With the new React 16.3 API, I see that <a href=""https://reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops"" rel=""nofollow noreferrer"">is is recommended</a> to use the <code>getDerivedStateFromProps</code> instead.</p>

<p>Since <code>getDerivedStateFromProps</code> ""should return an object to update state, or null to indicate that the new props do not require any state updates,"" (<a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""nofollow noreferrer"">React docs</a>) I want the method to look something like this:</p>

<pre><code>static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.menuIsOpen === false &amp;&amp; prevState.menuIsOpen === true) {
        return setTimeout(() =&gt; { menuIsOpen: false}, 1000);
    }
    return null;
}
</code></pre>

<p>But that doesn't work. <a href=""https://stackoverflow.com/questions/24928846/get-return-value-from-settimeout"">I've read</a> that <code>setTimeout</code> does not return a value but am wondering if there is a more elegant solution to the problem than returning a promise.</p>
","8486161","","","","","2018-05-01 17:24:00","How to use React's getDerivedStateFromProps with a setTimeout?","<javascript><reactjs><settimeout>","1","1","","",""
"49578114","1","","","2018-03-30 16:42:43","","0","108","<p>In <a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""nofollow noreferrer"">react docs</a> they write:</p>

<blockquote>
  <p>getDerivedStateFromProps is invoked after a component is instantiated
  as well as when it receives new props.</p>
</blockquote>

<p>Does <strong>instantiated</strong> means the same as mounted?</p>

<p>So I'm asking if</p>

<p><code>import { renderToString } from 'react-dom/server';</code></p>

<p>will call this hook.</p>
","4443323","","","","","2018-03-30 16:42:43","is getDerivedStateFromProps called during Server-side rendering?","<reactjs>","0","2","","",""
"49724015","1","","","2018-04-09 00:06:58","","0","88","<p>How to initialize state with dynamic key based on props? The props is a data fetched from external source (async). So the props will change when the data is succesfully downloaded. Consider a component like this. </p>

<p>edit: I want to make the state dynamic because I want to generate a dialog (pop up) based on the item that is clicked. the <code>DialogContainer</code> is basically that. <code>visible</code> prop will make that dialog visible, while <code>onHide</code> prop will hide that dialog. I use <a href=""https://react-md.mlaursen.com/components/dialogs"" rel=""nofollow noreferrer"">react-md library</a>.</p>

<pre><code>class SomeComponent extends React.Component {
  constructor() {
    super();
    this.state = {};
    // the key and value will be dynamically generated, with a loop on the props
    // something like:
    for (const item of this.props.data) {
      this.state[`dialog-visible-${this.props.item.id}`] = false}
    }
  }

  show(id) {
    this.setState({ [`dialog-visible-${id}`]: true });
  }

  hide(id) {
    this.setState({ [`dialog-visible-${id}`]: false });
  }

  render() {
    return (
      &lt;div&gt;
        {this.props.data.map((item) =&gt; {
          return (
            &lt;div&gt;
              &lt;div key={item.id} onClick={this.show(item.id)}&gt;
                &lt;h2&gt; Show Dialog on item-{item.id}&lt;/h2&gt;
              &lt;/div&gt;
              &lt;DialogContainer
                visible={this.state[`dialog-visible-${item.id}`]}
                onHide={this.hide(item.id)}
              &gt;
                &lt;div&gt;
                  &lt;h1&gt; A Dialog that will pop up &lt;/h1&gt;
                &lt;/div&gt;
              &lt;/DialogContainer&gt;
            &lt;/div&gt;
          );
        })}
      &lt;/div&gt;
    )
  }
}

// the data is fetched by other component.
class OtherComponent extends React.Component {
  componentDidMount() {
    // fetchData come from redux container (mapDispatchToProps)
    this.props.fetchData('https://someUrlToFetchJSONData/')
  }
}
</code></pre>

<p>The data then is shared via Redux.</p>

<p>However, based on my understanding so far, state can be updated based on props with <code>componentWillReceiveProps</code> or the new <code>getDerivedStateFromProps</code> (not on the constructor as above). But, how to do that on either method? </p>

<p>The example <a href=""https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props"" rel=""nofollow noreferrer"">here</a> only explains when the state is initialized on the constructor, and call <code>setState</code> on either cWRP or gDSFP. But, I want the key value pair to be initialized dynamically.</p>

<p>Any help/hint will be greatly appreciated. Please do tell if my question is not clear enough.</p>
","5835100","","5835100","","2018-04-09 01:33:14","2018-04-09 01:33:14","Initialize state with dynamic key based on props in reactJS","<javascript><reactjs><javascript-objects><computed-properties>","1","6","","",""
"50246826","1","","","2018-05-09 06:29:54","","0","17","<p>I'm using react.js v 16.3 and I'm confused by <code>getDerivedStateFromProps</code> a little bit.</p>

<p>I want to have <code>state</code> updated but I want <strong>particular</strong> changes to the state on the initial rendering only. How could I determine - is it first rendering or not?</p>
","2926641","","","","","2018-05-09 06:29:54","How could I know it's initial rendering in `getDerivedStateFromProps` react.js lifecycle?","<javascript><reactjs>","1","0","1","",""
"50054411","1","50055431","","2018-04-27 02:37:41","","0","776","<p>I'm confused about the new lifecycle of react 16, getDerivedStateFromProps use case. Take below code for example, getDerivedStateFromProps is not needed at all since I can achieve what I want with componentDidUpdate.</p>

<pre><code>export class ComponentName extends Component {
  //what is this for?
  static getDerivedStateFromProps(nextProps, prevState) {

    if (nextProps.filtered !== prevState.filtered &amp;&amp; nextProps.filtered === 'updated') {
      return {
        updated: true //set state updated to true, can't do anything more?
      };
    }

    return null;

  }

  componentDidUpdate(prevProps, prevState) {
    if(prevProps.filtered !== this.state.filtered &amp;&amp; this.state.filtered === 'updated'){
      console.log('do something like fetch api call, redirect, etc..')
    }
  }

  render() {
    return (
      &lt;div&gt;&lt;/div&gt;
    );
  }
}
</code></pre>
","9472172","","","","","2018-04-27 04:49:44","Why use getDerivedStateFromProps when you have componentDidUpdate?","<javascript><reactjs><ecmascript-6>","2","0","","",""
"50066974","1","","","2018-04-27 16:48:43","","1","83","<p>I would like to trigger some redux action to store some state into the redux(cache some state) after the props have changed. With the releasing of react 16.3, a lot of life cycle functions in the React have changed. Previously, I put this into the <code>componentWillReceiveNextProps()</code>. However, it seems that there is no good way to do that. Currently, I do something like this:</p>

<pre><code>const MyComponent extends React.Component {
  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.name !== prevState.name) {
      nextProps.cacheState(prevState.someState) // this function will dispatch a redux action
      return {
        someState: nextProps.someState // the someState will changed after this function
      }
    }
    return {
      ...
    }
  }
}
</code></pre>

<p>It seems that this is not a good way to dispatch an action in the <code>getDerivedStateFromProps()</code> since it cause some side effect. So what is the best practice to solve this problem?</p>
","4812854","","","","","2018-04-28 01:29:12","What is the best way to trigger an redux action if the props changed after the react 16.3?","<javascript><reactjs>","1","3","0","",""
"48863450","1","48863781","","2018-02-19 09:52:44","","0","6189","<p>According to this post about <a href=""https://medium.com/@baphemot/whats-new-in-react-16-3-d2c9b7b6193b"" rel=""nofollow noreferrer"">what's news in React 16.3</a>, in the next update <code>componentWillReceiveProps</code> will have a replacement and that is <code>getDerivedStateFromProps</code> (the replacement will only happens in 17.0).</p>

<p>The interesting part is that this brand new, static lifecycle method </p>

<blockquote>
  <p>is called both on initial mounting and on re-rendering of the
  component, so you can use it instead of creating state based on props
  in constructor.</p>
</blockquote>

<p>I'm getting confused. So from now on should I need to split my constructor and put the create state logic to this new function instead? I mean the logic when you create state first time your component is created and the logic when you create state from API props is not the same. Putting them together in one method seems not very ideal.</p>

<p>And one more thing is that if I choose to create my state from constructor, this new method will still be called anyway. What a jerk!</p>

<p>What do you think?</p>
","7070779","","","","","2018-07-09 12:53:05","A thought about getDerivedStateFromProps","<javascript><reactjs><react-native>","2","3","1","",""
"49747217","1","","","2018-04-10 06:54:23","","0","41","<p>Versions</p>

<p>webpack 4.1.1, react 16.3.1, apollo-boost 0.1.4 (apollo-client 2.2.8)</p>

<p>See below for code. Essentially what I have found is that whenever I try to load my component in the render function, componentDidMount is being called forever. removing the reference to <code>.default</code> and just rendering null resolves the issue, moving the reference to <code>.default</code> to the render method does not. How can I use the dynamic imports here alongside react correctly? Note that before I had the react-apollo query component for managing state this worked fine. What do I need to do to combine these 3 tools to actually cooperate? After 4-5 hours on the same issue I've made no progress.</p>

<pre><code>const RouterContainer = () =&gt; (
  &lt;Query
    query={gql`
      {
        currentRoute @client
        routeArgs @client
      }
    `}
  &gt;{({ data }) =&gt; &lt;Router {...data} /&gt;}&lt;/Query&gt;
);

class Router extends React.Component {
  state = {
    component: null,
    page: '',
  }
  fetchComponent = () =&gt; {
    import('./MyComponent).then(Component =&gt; {
      this.setState({ Component: Component.default });
    });
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.page !== nextProps.currentRoute) {
      return { page: nextProps.currentRoute };
    }
    return null;
  }
  componentDidMount() {
    // Being run infinitely. Why???
    // this.fetchComponent();
  }
  render() {
    return this.state.Component ? &lt;this.state.Component /&gt; : null;
  }
}
</code></pre>
","9623208","","","","","2018-04-10 06:54:23","Webpack dynamic import causing react remount","<reactjs><webpack><react-apollo>","0","0","","",""
"49757177","1","49757734","","2018-04-10 15:10:08","","0","48","<p>I have a React component with 4 different state values:</p>

<pre><code>class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            value: '',
            intents: [],
            selected_tags: [],
            unselected_tags: []};

        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.checkIntersection = this.checkIntersection.bind(this);
        this.setTags = this.setTags.bind(this);
}
</code></pre>

<p>the <code>value</code> updates as the user types a message, a server response populates <code>intents</code>, and the other two follow a logic according to the items in <code>intents</code>:</p>

<pre><code>this.setState({
    intent: ['a','b','c'...n],
    selected_tags: data.filter(tag =&gt; this.checkIntersection(['b','c','d'], this.state.intent).size !== 0), 
    unselected_tags: data.filter(tag =&gt; !this.state.selected_tags.includes(tag))
)}
</code></pre>

<p>The problem is that I can't seem to update the latter three synchronously (<code>intents</code>, <code>selected_tags</code> and <code>unselected_tags</code>). This is crucial since the content of <code>selected_tags</code> depend on <code>intents</code>, and the content of <code>unselected_tags</code> depends on <code>selected_tags</code>. </p>

<p>I did manage to force <code>selected_tags</code> to wait for <code>intents</code> to populate using Promises <code>.then()</code> and <code>unselected_tags</code> to wait for <code>selected_tags</code> using <code>setTimeout()</code>.</p>

<pre><code>axios.get('http://localhost:3001', {
    params: {
      text: this.state.value
    }
  })
.then(response =&gt; this.setState({
    intent: [....])
}))
.then(setTags)

setTags() {
    if (this.state.intent !== []) {
      this.setState( {
        selected_tags: data.filter(tag =&gt; this.checkIntersection(tag.intents, this.state.intent).size !== 0)
  });
  setTimeout(this.setState({ 
    unselected_tags: data.filter(tag =&gt; !this.state.selected_tags.includes(tag))}), 0)
   }
}
</code></pre>

<p>However, I'm pretty sure this is not the 'React' way of doing this, mainly because I don't know how long the server will take to respond in realtime, so using <code>setTimeout</code> could be a bad practice. On the other hand, I didn't manage to use <code>ComponentDidUpdate()</code> either, since <code>value</code> updates instantly as I type so it doesn't wait for <code>intents</code> to populate. </p>

<p>I suspect <code>getDerivedStateFromProps()</code> might be helpful in these kind of situations, but I didn't find any <em>real</em> use of this function online (with a context and all).
Is there an equivalent to <code>ComponentDidUpdate()</code> where I can choose what specific kind of update in the state to wait for?</p>

<p>Generally speaking, I am not sure  how to reconcile my flow with the react lifecycle the react way.</p>
","8205650","","","","","2018-04-10 15:36:51","how to synchronously setState of multiple values in react?","<reactjs><synchronization>","2","0","","",""
"49578614","1","","","2018-03-30 17:19:19","","0","93","<p>I have an array of strings which I would like to render as a list, with a colored text. The user can change the color with a button.</p>

<p>For that I have built a component called  which receives an array and renders a list with the array's values and a button to change the color:</p>

<pre><code>import React, { Component } from ""react"";

const renderArray = arr =&gt; (arr.map(value =&gt; (
    &lt;li&gt;
      {value}
    &lt;/li&gt;
  )))


class List extends Component {
  constructor(props) {
    super(props);
    this.state = {
      color: 'red'
    }
  }
  toggleColor = () =&gt; {
    if (this.state.color === ""red"") {
      this.setState({color: ""blue""});
    } else {
      this.setState({color: ""red""});
    }
  }
  render() {
    const style = {
      color: this.state.color
    };
    return (
      &lt;div style={style}&gt;
        &lt;ul&gt;
          {renderArray(this.props.array)}
        &lt;/ul&gt;
        &lt;button onClick={this.toggleColor}&gt;Change color&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
export default List;
</code></pre>

<p>The List is called with:</p>

<pre><code>&lt;List array={arr} /&gt;
</code></pre>

<p>And arr:</p>

<pre><code>const arr = ['one', 'two', 'three'];
</code></pre>

<p>Fiddle here: <a href=""https://codesandbox.io/s/3y09yr01mm"" rel=""nofollow noreferrer"">Fiddle</a></p>

<p>But this seems incorrect to me. I rerender the whole array by calling <code>renderArray()</code> each time the color changes. In this case it is not too bad but what if the <code>renderArray()</code> is much more complex?</p>

<p>To my understanding, I need to create a new list only if the array prop changes and this could do in getDerivedStateFromProps (or in componentWillReceiveProps which will be deprecated...):</p>

<pre><code>  componentWillReceiveProps(nextProps)
  {
    const renderedArray = renderArray(nextProps.array);
    this.setState({ renderedArray });
  }
</code></pre>

<p>And then, on render, use <code>this.state.renderedArray</code> to show the list.</p>

<p>But this seems strange, to store a rendered object in the state...
Any suggestions?</p>

<p>Thanks!</p>
","9479647","","","","","2018-03-30 21:22:04","Rendering in react with array.map","<reactjs>","2","0","","",""
"49723019","1","49723067","","2018-04-08 21:37:40","","2","935","<p>Think of a component that has a prop 'name' and state 'elapse'.</p>

<pre><code>new Component(name) =&gt; ""Hi {name}. It's been {elapse} seconds""
</code></pre>

<p><code>{elapse}</code> should be reset to 0 when the prop <code>{name}</code> changes.</p>

<p>If the prop changes from 'Alice' to 'Bob' at 10 seconds,
the message should change from</p>

<blockquote>
  <p>Hi Alice. It's been 10 seconds</p>
</blockquote>

<p>to</p>

<blockquote>
  <p>Hi Bob. It's been 0 seconds</p>
</blockquote>

<ul>
<li><p><code>getDerivedStateFromProps</code> cannot be used because <code>{elapse}</code> is not a pure function of <code>{name}</code>, and I cannot return 0 because it may be called on re-render.</p></li>
<li><p><code>componentDidUpdate</code> will eventually update <code>{elapse}</code> to 0, but before that, the invalid state <em>""Hi Bob. It's been 0 seconds""</em> is shown to the user.</p></li>
</ul>

<p>Can <code>getDerivedStateFromProps</code> or <code>componentDidUpdate</code> implement this scenario?</p>

<ol>
<li><p>In many cases the state is not a pure function of props. Is <code>getDerivedStateFromProps</code> only for stateless functional components? Does react encourage the use of stateless components?</p></li>
<li><p>How can <code>getDerivedStateFromProps</code> replace <code>componentWillReceiveProps</code> in stateful components?</p></li>
</ol>
","2547570","","3098651","","2018-04-10 00:39:18","2018-04-10 00:39:18","Compare with previous props in getDerivedStateFromProps","<reactjs>","3","0","","",""
"49156717","1","49209181","","2018-03-07 16:23:25","","6","2872","<p>I have just updated to react native 0.54.0 that also includes alpha 1 of react 16.3, naturally I get a lot of warnings regarding depreciation of <code>componentWillMount</code> and <code>componentWillReceiveProps</code>.</p>

<p>I have an animated route component that was relying on <code>componentWillReceiveProps</code> at its core it receives new path, compares it to previous one, if they are sets old children, animates them out, sets new children and animates them in.</p>

<p>Here is code in question:</p>

<pre><code>componentWillReceiveProps(nextProps: Props) {
    if (nextProps.pathname !== this.props.pathname) {
      this.setState({ previousChildren: this.props.children, pointerEvents: false }, () =&gt;
        this.animate(0)
      );
    }
  }
</code></pre>

<p>Now for the questions I have regarding porting this to <code>static getDerivedStateFromProps</code></p>

<p>1) I no longer have access to <code>this.props</code>, hence no access to previous pathname, I guess I can store these props in state, is this correct approach now? Seems like repetition of data.</p>

<p>2) As I have no access to <code>this</code> I can't call my animation function, that relies on a state. How can I bypass this?</p>

<p>3) I need to first set state and then call the animation, as <code>getDerivedStateFromProps</code> sets state by returning the values, I can't do much afterwards, so is there a way to set state and after thats done execute a callback?</p>

<p>4) <code>pathname</code> bit is only used in <code>componentWillreceiveProps</code> right now, if I move it to state and never use <code>this.state</code> inside <code>getDerivedStateFromProps</code> (because I can't) <code>this.state.pathname</code> errors as being defined but never used. Is the best approach here to make it static as well?</p>

<p>My first instinct was to change it to <code>componentDidUpdate</code>, but we are not supposed to use <code>setState</code> inside of it correct? (this does work in my scenario though).</p>

<pre><code>  componentDidUpdate(prevProps: Props) {
    if (this.props.pathname !== prevProps.pathname) {
      this.setState({ previousChildren: prevProps.children, pointerEvents: false }, () =&gt;
        this.animate(0)
      );
    }
  }
</code></pre>

<p><strong>NOTE:</strong> As far as I heard I think there is a feature coming in ""suspense"" that will allow us to keep views mounted on component unmount event? I wasn't able to find any reference to this, but it sounds like something I could potentially utilise for this animation</p>

<p>For anyone interested, this is snippet for a full component in question</p>

<pre><code>// @flow
import React, { Component, type Node } from ""react"";
import { Animated } from ""react-native"";

type Props = {
  pathname: string,
  children: Node
};

type State = {
  animation: Animated.Value,
  previousChildren: Node,
  pointerEvents: boolean
};

class OnboardingRouteAnomation extends Component&lt;Props, State&gt; {
  state = {
    animation: new Animated.Value(1),
    previousChildren: null,
    pointerEvents: true
  };

  componentWillReceiveProps(nextProps: Props) {
    if (nextProps.pathname !== this.props.pathname) {
      this.setState({ previousChildren: this.props.children, pointerEvents: false }, () =&gt;
        this.animate(0)
      );
    }
  }

  animate = (value: 0 | 1) =&gt; {
    Animated.timing(this.state.animation, {
      toValue: value,
      duration: 150
    }).start(() =&gt; this.animationLogic(value));
  };

  animationLogic = (value: 0 | 1) =&gt; {
    if (value === 0) {
      this.setState({ previousChildren: null, pointerEvents: true }, () =&gt; this.animate(1));
    }
  };

  render() {
    const { animation, previousChildren, pointerEvents } = this.state;
    const { children } = this.props;
    return (
      &lt;Animated.View
        pointerEvents={pointerEvents ? ""auto"" : ""none""}
        style={{
          alignItems: ""center"",
          opacity: animation.interpolate({ inputRange: [0, 1], outputRange: [0, 1] }),
          transform: [
            {
              scale: animation.interpolate({ inputRange: [0, 1], outputRange: [0.94, 1] })
            }
          ]
        }}
      &gt;
        {previousChildren || children}
      &lt;/Animated.View&gt;
    );
  }
}

export default OnboardingRouteAnomation;
</code></pre>
","911930","","911930","","2018-03-08 06:46:39","2018-03-10 12:43:04","static getDerivedStateFromProps that requires previous props and state callback?","<javascript><reactjs><react-native>","1","2","2","",""
"49803661","1","","","2018-04-12 18:31:27","","-1","65","<p>I have the following react native script.  It's not quite right yet but getting there.  In the console I'm getting the following messages that I don't understand what to do with:</p>

<pre><code>Warning: componentWillMount is deprecated and will be removed in the next 
major version. Use componentDidMount instead. As a temporary workaround, you 
can rename to UNSAFE_componentWillMount.

Please update the following components: ExpoRootComponent, 
RootErrorBoundary, Text, TextInput, View

Learn more about this warning here:
react-async-component-lifecycle-hooks
- node_modules\react-native\Libraries\ReactNative\YellowBox.js:82:15 in warn
- node_modules\react-native\Libraries\Renderer\ReactNativeRenderer- 
dev.js:5706:19 in printWarning
- ... 21 more stack frames from framework internals
14:17:34: Warning: componentWillReceiveProps is deprecated and will be 
removed in the next major version. Use static getDerivedStateFromProps 
instead.

Please update the following components: Text, TextInput, View

Learn more about this warning here:
react-async-component-lifecycle-hooks
- node_modules\react-native\Libraries\ReactNative\YellowBox.js:82:15 in warn
- node_modules\react-native\Libraries\Renderer\ReactNativeRenderer- 
dev.js:5706:19 in printWarning
- ... 21 more stack frames from framework internals
</code></pre>

<p>I'm not explicitly calling componentWillMount.  How do I use componentDidMount to get rid of the warning?</p>

<p>How do I update the components it's asking me to update?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { TextInput,Button, StyleSheet, View,Text, ScrollView } from 'react-native';
import {Constants} from 'expo'

  let id=0
  const Todo = (props) =&gt; (
    &lt;Text&gt;
      {/* &lt;input type='checkbox'
              checked={props.todo.checked}
              onClick={props.onToggle}
        /&gt; */}
       &lt;Button title='delete' button onPress={props.onDelete}&gt;&lt;/Button&gt;
       &lt;Text&gt;{props.todo.text}&lt;/Text&gt;
    &lt;/Text&gt;
  )
  export default class App extends React.Component {
    constructor(){
      super()
      this.state={
        todos:[],
      }
    }



  addTodo(e){
   console.log('hello')
    console.log(e.target)
    this.setState({todos: [...this.state.todos,
                              { id:id++,
                                text: e.value,
                                checked:false
                              }
                          ]
                  })
    e.value=''
  }
  toggle(id){
    this.setState({todos: this.state.todos.map(todo=&gt;{
                          if(id!==todo.id)return todo
                          return{
                              id:todo.id,
                              text:todo.text,
                              checked: !todo.checked}})})
  }
  removeTodo(id){
    this.setState({todos: this.state.todos.filter(todo=&gt;(todo.id!==id))})
  }

  render(){
     return(

       &lt;View style={styles.container}&gt;
          &lt;Text &gt;Count of Todos: &amp;nbsp;{this.state.todos.length}&lt;/Text&gt;
          &lt;Text &gt;{""Todo's checked:""}&amp;nbsp;
               {this.state.todos.filter(todo =&gt;(todo.checked===true)).length}&lt;/Text&gt;
          &lt;TextInput
                 style={{height:25,borderColor:'red',borderWidth:1,textAlign:'center'}}
                  placeholder={'add ToDo'}
                  onSubmitEditing={(e)=&gt;(this.addTodo(e.target))}/&gt;

          &lt;ScrollView&gt;
           {this.state.todos.map(todo=&gt;(
                 &lt;Todo
                    onToggle={()=&gt;(this.toggle(todo.id))}
                    onDelete={()=&gt;(this.removeTodo(todo.id))}
                    todo={todo}
                    key={todo.id}
                 /&gt;))}
          &lt;/ScrollView&gt;
       &lt;/View&gt;
     )
    }
  }
const styles = StyleSheet.create({
  container:{
    flex:1,
    flexDirection:'column',
    height:50,

    paddingTop:3*Constants.statusBarHeight,

  }
})</code></pre>
</div>
</div>
</p>
","4398966","","","","","2018-04-12 18:42:30","react native error messages not understood","<react-native>","1","0","","",""
"49449527","1","","","2018-03-23 12:20:23","","6","1820","<p>As read in <a href=""https://github.com/facebook/react/issues/12310"" rel=""noreferrer"">this React Github issue</a> I see more and more that</p>

<blockquote>
  <p>the cost of <code>render()</code> is relatively small</p>
</blockquote>

<p><strong>In React 16.3</strong>, I'm wondering why one would use the new getDerivedStateFromProps instead of componentDidUpdate?</p>

<p>Imagine this example:</p>

<pre><code>getDerivedStateFromProps(nextProps, prevState) {
  if (!prevState.isModalOpen &amp;&amp; nextProps.isReady) {
       return { isModalOpen: true };
  }
}
</code></pre>

<p>versus</p>

<pre><code>componentDidUpdate(prevProps, prevState) {
  if (!prevState.isModalOpen &amp;&amp; this.props.isReady) {
        this.setState({ isModalOpen: true });
  }
}
</code></pre>

<p>The later seems simpler just because it's using only existing API and looks just like what we used to do in componentWillReceiveProps so I don't see why users would go for getDerivedStateFromProps? What's the benefit?</p>

<p>Thanks!</p>
","757461","","","","","2018-03-23 14:17:00","Why use getDerivedStateFromProps instead of componentDidUpdate?","<reactjs>","2","2","","",""
"49501625","1","49848089","","2018-03-26 22:27:24","","1","65","<p>I'm trying to move through screens using React Navigation, the problem lies in the nested return that i use to dynamically render a set of items and doesn't let me use an arrow function to directly navigate, so i have to implement this on a function. My question here is, how do i do that? As far as my internet research went you can only push a new screen after a dialog alert shows up, i don't want that.   </p>

<p>I'm attaching the code:</p>

<pre><code>var Dimensions = require('Dimensions');
var {width,height} = Dimensions.get('window');

import React, {Component} from 'react';
import {
    View,
    Text,
    StyleSheet,
    TouchableOpacity,
    Image
} from 'react-native';
import Pie from 'react-native-pie';
import { connect } from 'react-redux';
import { bindActionCreators } from 'redux';

import NaviBarView from './../Commons/NaviBar'
import actions from '../../Redux/actions'

class Main extends Component {
constructor(props){
    super(props);
    this.state={
        cargando:true,
        cryptoCurrencyValues:{}
    }

    this.onNextPress = this.onNextPress.bind(this);
    this.renderItems = this.renderItems.bind(this);
}

static getDerivedStateFromProps(nextProps,prevState){
    console.warn('Positivo', Object.keys(nextProps.cryptoCurrencyValues).length)
    if (Object.keys(nextProps.cryptoCurrencyValues).length !== 0){

    }else{
        console.warn('Negativo')
    }
    return null;
}

onNextPress(){

    **//HERE I WANT TO CALL NAVIGATE TO MOVE TO ANOTHER SCREEN**

}

componentDidMount(){
    console.warn('esto una vez')
    this.props.actions.getCryptoValues();
    this.setState({cargando:true})
}

renderItems(){
    var self = this;
    return listData.map(function(cryptoValue,i){
    return(
                &lt;View style={styles.itemContainer} key={i}&gt;
                    &lt;View style={{alignSelf:'center',backgroundColor:'transparent', marginLeft:10}}&gt;
                        &lt;Image source={cryptoValue.img} style={{width:width*0.095, height:height*0.050}} resizeMode={'stretch'}/&gt;
                    &lt;/View&gt;
                    &lt;View style={{marginLeft:10}}&gt;
                        &lt;View style={{alignSelf:'flex-start',marginTop:15}}&gt;
                            &lt;Text style={{color:'#ffffff',fontSize:18,fontWeight: 'bold'}}&gt;{cryptoValue.name}&lt;/Text&gt;
                        &lt;/View&gt;
                        &lt;View style={{alignSelf:'flex-start',marginBottom:10}}&gt;
                            &lt;Text style={{color:'#6e6e6e',fontSize:18}}&gt;{cryptoValue.desc}&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/View&gt;
                    &lt;View style={{marginLeft:40}}&gt;
                        &lt;View style={{alignSelf:'flex-start',marginTop:15}}&gt;
                            &lt;Text style={{color:'#ffffff',fontSize:18}}&gt;{cryptoValue.price}&lt;/Text&gt;
                        &lt;/View&gt;
                        &lt;View style={{alignSelf:'flex-start',marginBottom:10}}&gt;
                            &lt;Text style={{color:'#6e6e6e',fontSize:18}}&gt;{cryptoValue.currency}&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/View&gt;
                    &lt;View style={{alignSelf:'center',backgroundColor:'transparent', marginLeft:50}}&gt;
                        &lt;TouchableOpacity onPress={() =&gt; self.onNextPress()} style={{alignSelf:'center',backgroundColor:'transparent'}}&gt;
                            &lt;Image source={require('./../../img/next.png')} style={{width:width*0.035, height:height*0.032}} resizeMode={'stretch'}/&gt;
                        &lt;/TouchableOpacity&gt;
                    &lt;/View&gt; 
                &lt;/View&gt;         
                );
            });
}

render(){
    return(
        &lt;View style={styles.container}&gt;
            &lt;View&gt;
                &lt;NaviBarView/&gt;
            &lt;/View&gt;
            &lt;View style={styles.cardContainer}&gt;
                &lt;View style={{marginTop:10,flexDirection: 'row',marginTop:10,marginLeft:10,alignItems:'stretch'}}&gt;
                        &lt;Image source={require('./../../img/pie-chart.png')} resizeMode={'stretch'} style={{width:width*0.095, height:height*0.055}}/&gt;
                        &lt;Text style={{fontSize:20,color:'#ffffff',fontWeight:'bold',marginLeft:15,alignSelf:'center'}}&gt;STATUS&lt;/Text&gt;
                        &lt;TouchableOpacity style={{marginLeft:230,alignSelf:'center'}}&gt;
                            &lt;Image source={require('./../../img/reload.png')} resizeMode={'stretch'} style={{width:width*0.065, height:height*0.035}}/&gt;
                        &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
                    &lt;View style={{alignSelf:'flex-start',marginTop:50}}&gt;
                        &lt;Pie
                          radius={100}
                          innerRadius={97}
                          series={[10, 20, 30, 40]}
                          colors={['#f00', '#0f0', '#00f', '#ff0']} 
                        /&gt;
                    &lt;/View&gt;
            &lt;/View&gt;

            {this.renderItems()}

        &lt;/View&gt;

        );
    }
}

const listData = [
{_id:1,name:'Bitcoin',desc:'Billetera BTC',price:'$141,403.22',currency:'BTC: $11.673,50',img:require('./../../img/bitcoin.png')},
{_id:2,name:'Ethereum',desc:'Billetera ETH',price:'$20200,50',currency:'ETH: $863,40',img:require('./../../img/ethereum.png')},
{_id:3,name:'NEO',desc:'Billetera NEO',price:'$40.401',currency:'NEO: $118,02',img:require('./../../img/neo.png')},
];

const styles = new StyleSheet.create({
    container:{
        flex:1,
        backgroundColor: '#0d0d0d',
        flexDirection: 'column',
        position:'relative',
    },
    cardContainer:{
        backgroundColor:'#1a1a1a',
        marginTop: 7,
        marginBottom:7,
        marginLeft:7,
        marginRight:7,
        height:height*0.50,
        width:width,
        justifyContent: 'flex-start'
    },
    itemContainer:{
        flexDirection: 'row',
        backgroundColor:'#1a1a1a',
        width:width,
        height:height*0.115,
        marginLeft:7,
        marginRight:7,
        marginBottom:7,
        justifyContent: 'flex-start'
    },
})

function mapStateToProps (state,props) {
    return {cryptoCurrencyValues: state.cryptocurrencyValues,
    }
}

function mapDispatchToProps (dispatch) {
    return {
        actions: bindActionCreators(actions, dispatch)
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(Main);
</code></pre>
","9555088","","","","","2018-04-16 00:22:32","react native navigate to screen from function","<android><reactjs><react-native><react-navigation>","2","0","","",""
"49823294","1","","","2018-04-13 18:38:29","","3","173","<p>Creating a new app with create-react-native-app is now generating new warnings.  Is there anything I need to do to correct the warnings?  For instance, how would I update the components listed:</p>

<pre><code> ExpoRootComponent, RootErrorBoundary, Text, View
</code></pre>

<p>here are the new warnings:  (can all this be ignored? will create-react-native-app be updated to use 0.55.x?)</p>

<pre><code>14:30:04: Warning: componentWillMount is deprecated and will be removed in 
the next major version. Use componentDidMount instead. As a temporary 
workaround, you can rename to UNSAFE_componentWillMount.

Please update the following components: ExpoRootComponent, 
RootErrorBoundary, Text, View

Learn more about this warning here:
xxx:/fb.me/react-async-component-lifecycle-hooks
- node_modules\react-native\Libraries\ReactNative\YellowBox.js:82:15 in warn
- node_modules\react-native\Libraries\Renderer\ReactNativeRenderer- 
dev.js:5706:19 in printWarning
- ... 21 more stack frames from framework internals
14:30:06: Warning: componentWillReceiveProps is deprecated and will be 
removed in the next major version. Use static getDerivedStateFromProps 
instead.

Please update the following components: Text, View

Learn more about this warning here:
xxx:/fb.me/react-async-component-lifecycle-hooks
- node_modules\react-native\Libraries\ReactNative\YellowBox.js:82:15 in warn
- node_modules\react-native\Libraries\Renderer\ReactNativeRenderer- 
dev.js:5706:19 in printWarning
- ... 21 more stack frames from framework internals
</code></pre>
","4398966","","","","","2018-04-16 07:24:21","create-react-native-app displays new warnings","<react-native><create-react-native-app>","2","0","","",""
"49885018","1","","","2018-04-17 18:24:10","","0","935","<p>Recently it has come out that soon React will be deprecating <code>componentWillReceiveProps</code> and in it's place is the new static function <code>getDerivedStateFromProps</code>. <a href=""https://medium.com/@baphemot/whats-new-in-react-16-3-d2c9b7b6193b"" rel=""nofollow noreferrer"">See more here</a></p>

<p>I am currently migrating my apps to this new API, but am having an issue with<code>getDerivedStateFromProps</code>, due to the fact that I am using the recompose library for higher order components. We make the use of <code>componentWillReceive</code> props through the library's lifecycle object.</p>

<p>So before moving to the new API, I had this:</p>

<pre><code>export function someHoC () {
  return compose(
    lifecycle({
      componentWillReceiveProps (nextProps) {
        const { fetch } = nextProps
          if (shouldFetch(this.props, nextProps)) {
             fetch()
          }
      }
    })
  )
}
</code></pre>

<p>This has now changed to the following:</p>

<pre><code>export function someHoC () {
  return compose(
    lifecycle({
      getDerivedStateFromProps (nextProps) {
          const { fetch } = nextProps
          if (shouldFetch(this.props, nextProps)) {
             fetch()
          }
      }
    })
  )
}
</code></pre>

<p>However, <code>getDerivedStateFromProps</code> needs to be static, so I am getting the warning regarding that and don't know how to handle it.</p>

<blockquote>
  <p>warning.js?7f205b4:33 Warning: lifecycle(MyComponent): getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.</p>
</blockquote>

<p>What can I do to pass it in as a static lifecycle method into my component?</p>
","1676032","","1676032","","2018-04-17 18:45:19","2018-04-19 10:11:50","How to create React's new static function getDerivedStateFromProps as a lifecycle method using an HoC in the recompose library?","<reactjs><higher-order-components><recompose><react-lifecycle>","2","4","","",""
"50632573","1","50632609","","2018-05-31 20:49:41","","0","180","<p>So just learned that <code>componentWillReceiveProps</code> is deprecated and we need to use <code>getDerivedStateFromProps</code> lifecycle method now.
<a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops</a></p>

<p>I'm using it as such below:</p>

<pre><code>class Main extends Component {
  static getDerivedStateFromProps(props) {
    console.log('getDerivedStateFromProps', props);
    const { modal } = props;
    this.setState({ modal });
  }

  constructor(props) {
    super(props);

    this.state = {
      modal: {}
    };
  }
</code></pre>

<p>However it errors out on the <code>setState</code></p>

<p><a href=""https://i.stack.imgur.com/nQOVi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nQOVi.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>main.js:30 Uncaught TypeError: Cannot read property 'setState' of null
      at getDerivedStateFromProps (main.js:30)</p>
</blockquote>

<p>What am I missing here?</p>
","168738","","","","","2018-06-10 14:48:55","When using getDerivedStateFromProps (React) getting error: Cannot read property 'setState' of null","<javascript><reactjs><getderivedstatefromprops>","3","1","","",""
"50632949","1","50646445","","2018-05-31 21:20:19","","3","291","<p>I'm using the new <code>getDerivedStateFromProps</code> since <code>componentWillReceiveProps</code> was deprecated. However it does not seem to work as expected, as nothing happens after I update the Redux state.</p>

<p><strong>Expected</strong></p>

<ul>
<li>Action / Reducer is updated</li>
<li>Component Main's <code>props.modal</code> is updated and the component re-renders</li>
</ul>

<p><strong>Results</strong></p>

<ul>
<li>Action / Reducer is updated</li>
<li>Nothing happens in the Main Component</li>
</ul>

<hr>

<pre><code>""react"": ""^16.3.2"",
""react-dom"": ""^16.3.2"",
</code></pre>

<p>Note here in this screenshot, I'm able to update the Redux state, <code>modal</code> has been updated, yet my component does not update and re-render.</p>

<p><a href=""https://i.stack.imgur.com/bm9Ns.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bm9Ns.png"" alt=""enter image description here""></a></p>

<p>I expect this code to be called a 2nd time:</p>

<pre><code>static getDerivedStateFromProps(nextProps, nextState) {
  const { modal } = nextProps;
  console.log('getDerivedStateFromProps', nextProps);
  console.log(' nextState', nextState);
  return { modal };
}
</code></pre>

<p>Or at least the console.log's in my render method to be called a twice time, this never happens. Any ideas why?</p>

<h3>Component code:</h3>

<pre><code>import React, { Component } from 'react';
import { connect } from 'react-redux';

// MUI
import { withStyles } from '@material-ui/core/styles';

// Components
import TopNav from 'components/Common/topNav';
// import ProductModal from 'components/Common/productModal';

// Utils
import {
  findNotification,
  showNotification
} from 'utils/notifications';

const styles = {
  root: {
    flexGrow: 1,
    display: 'flex',
    flexDirection: 'column',
    height: '100%'
  }
};

class Main extends Component {
  static getDerivedStateFromProps(nextProps, nextState) {
    const { modal } = nextProps;
    console.log('getDerivedStateFromProps', nextProps);
    console.log(' nextState', nextState);
    return { modal };
  }

  constructor(props) {
    super(props);

    this.state = {
      modal: {}
    };
  }

  componentDidUpdate(props) {
    console.log('componentDidUpdate', props);
  }

  render() {
    const {
      classes,
      children,
      notifications,
      currentNotification
    } = this.props;


    console.log('this.props', this.props);
    console.log('this.state', this.state);

    const notificationObj = findNotification(currentNotification, notifications);

    return (
      &lt;div className={classes.root}&gt;
        {/* &lt;ProductModal /&gt; */}
        &lt;TopNav /&gt;
        { showNotification(notificationObj)}
        {children}
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = ({ modal }) =&gt; ({
  modal
});

export const MainJest = Main;

export default connect(mapStateToProps, null)(withStyles(styles)(Main));
</code></pre>

<h3>Reducer:</h3>

<pre><code>import {
  MODAL_CLOSE_MODAL,
  MODAL_SET_MODAL
} from 'actions/types';

export const initialState = {
  modal: {
    name: '',
    props: {}
  }
};

const modalsReducer = (state = initialState, { type, payload }) =&gt; {
  switch (type) {
    case MODAL_SET_MODAL:
      return {
        ...state,
        modal: {
          name: payload.modalName,
          props: payload.modalProps
        }
      };
    case MODAL_CLOSE_MODAL:
      return {
        ...state,
        modal: {
          name: '',
          props: {}
        }
      };
    default:
      return state;
  }
};

export default modalsReducer;
</code></pre>
","168738","","168738","","2018-06-01 14:56:34","2018-06-01 15:10:51","getDerivedStateFromProps Does not re-render after Redux Reducer state is updated","<javascript><reactjs><redux>","1","7","","",""
"49617486","1","49618535","","2018-04-02 19:24:33","","25","12707","<p>It looks like <code>componentWillReceiveProps</code> is going to be completely phased out in coming releases, in favor of a new lifecycle method <code>getDerivedStateFromProps</code>.</p>

<p><a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""noreferrer"">https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops</a></p>

<p>Upon inspection, it looks like you are now unable to make a direct comparison between <code>this.props</code> and <code>nextProps</code>, like you can in <code>componentWillReceiveProps</code>. Is there any way around this?</p>

<p>Also, it now returns an object. Am I correct to assume that the return value is essentially <code>this.setState</code>?</p>

<p>Below is an example I found online
<a href=""https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md#state-derived-from-propsstate"" rel=""noreferrer"">https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md#state-derived-from-propsstate</a></p>

<p><strong>Before</strong></p>

<pre><code>class ExampleComponent extends React.Component {
  state = {
    derivedData: computeDerivedState(this.props)
  };

  componentWillReceiveProps(nextProps) {
    if (this.props.someValue !== nextProps.someValue) {
      this.setState({
        derivedData: computeDerivedState(nextProps)
      });
    }
  }
}
</code></pre>

<p><strong>After</strong></p>

<pre><code>class ExampleComponent extends React.Component {
  // Initialize state in constructor,
  // Or with a property initializer.
  state = {};

  static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.someMirroredValue !== nextProps.someValue) {
      return {
        derivedData: computeDerivedState(nextProps),
        someMirroredValue: nextProps.someValue
      };
    }

    // Return null to indicate no change to state.
    return null;
  }
}
</code></pre>
","4385889","","458193","","2018-06-10 13:33:19","2018-06-21 09:44:40","How to use lifecycle method getDerivedStateFromProps as opposed to componentWillReceiveProps","<javascript><reactjs><lifecycle>","3","0","4","",""
"50539639","1","50539696","","2018-05-26 05:34:38","","0","53","<p>I have Three components like below</p>

<p><code>A.js</code></p>

<pre><code>import React, { Component } from 'react';
import B from './B';
export class A extends Component {
    ajaxmethod = () =&gt; {
        //fetching data through ajax method.

    }
    render() {
        return (
            &lt;div&gt;
                &lt;B/&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p><code>B.js</code></p>

<pre><code>import React, { Component } from 'react';
import C from './C';

//this is a Modal container
export class B extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;C/&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p><code>C.js</code></p>

<pre><code>import React, { Component } from 'react';

//this is Modal elements
export class C extends Component {
    render() {
        return (
            &lt;div&gt;
                I need to display data here from A Component
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>There is button in <code>A.js</code> component. Which button displays a modal (<code>B.js</code>) when clicked. <code>B.js</code> is modal container component. <code>C.js</code> is modal element component. I have a AJAX method in <code>A.js</code> component. I would like to display data in <code>C.js</code> from <code>A.js</code>.</p>

<p>How can I do that ?</p>

<p><strong>UPDATE</strong></p>

<p>I used below code in <code>B.js</code> component.</p>

<pre><code>static getDerivedStateFromProps(nextProps) {
    return {
      modalchildOpen: nextProps.modelStatus
    };
  }
</code></pre>
","5043301","","5043301","","2018-05-26 09:16:29","2018-05-26 16:39:06","Pass data to nested component in react.js","<reactjs>","3","0","","",""
"50703224","1","50733941","","2018-06-05 15:00:48","","0","89","<p>I am trying to follow the design pattern in <a href=""https://github.com/reactjs/rfcs/issues/26"" rel=""nofollow noreferrer"">https://github.com/reactjs/rfcs/issues/26</a> (see replies by bvaughn) and create ReactJS editable form, that reads data from the server, show then in the form fields, allows the use to edit values and then save those data back in database. </p>

<p>I have some essential code:</p>

<pre><code>const mapStateToProps = state =&gt; {
    return {
        invoice: state.invoice,
        invoiceReady: state.invoiceReady,
    };
};

 static getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.match.params.id !== prevState.id) {
            return update(
                prevState, {
                    ['id']: {$set: nextProps.match.params.id},
                    ['invoiceReady']: {$set: false}
                });
        } else {
            return update(
                prevState, {
                    ['invoice']: {$set: nextProps.invoice},
                    ['invoiceReady']: {$set: nextProps.invoiceReady}
                });
        }
    }

 handleChange(event) {
        const state = update(
            this.state, {
                invoice: {
                    [event.target.id]: {$set: event.target.value}
                }
            }
        );
        this.setState(state);
    }

componentDidMount() {
        this.requestInvoice();
    }

componentDidUpdate(prevProps, prevState) {
        if (!this.state.invoiceReady) {
            this.requestInvoice();
        }
    }
</code></pre>

<p>and my JSX code contains editable fields like:</p>

<pre><code>                        &lt;input
                            type=""text""
                            className=""form-control""
                            id=""invoiceDate""
                            value={this.state.invoice.invoiceDate}
                            onChange={this.handleChange}
                        /&gt;
</code></pre>

<p>So - according to the mentioned pattern I am initiating the request to the server by <code>requestInvoice</code>, some other components handle this action and receives and saves the invoice into the Redux store and that is why those data are automatically written into the <code>props.invoice</code> variable and I am further writing <code>props.invoice</code> into <code>this.state.invoice</code> by <code>getDerivedStateFromProps</code> for further local processing of the invoice data. During the work with the form the <code>handleChange</code> events are raised and with the help of immutability-helper (update function) the updated fields are written into new state and <code>setState</code> is called. </p>

<p>My problem is that during the <code>setState</code> call the React is calling <code>getDerivedStateFromProps</code> and so the <code>props.invoice</code> overwrites any changes that are coming from the user and that ar processed into <code>handleChange:setState</code> function.</p>

<p>So - <strong>how to solve this problem: the conflict between <code>setState</code> and <code>getDerivedStateFromProps</code>?</strong></p>

<p>Several options may be:</p>

<ul>
<li>my design can be flawed. E.g. maybe I should not try to move <code>props.invoice</code> into <code>this.state.invoice</code> (why not?)? But from the other side it would be nice to save invoice into this.state and be sure that all the changes are applied to the <code>this.state.invoice</code> during the editing of the invoice.</li>
<li>mybe I should prevent execution of <code>getDerivedStateFromProps</code> during <code>setState</code>?</li>
</ul>

<p>Maybe some other design pattern or code is more suitable for my ReactJS form?</p>

<p>I am using ReactJ 16.x</p>
","1375882","","","","","2018-06-07 06:03:30","ReactJS setState conflicts with getDerivedStateFromProps","<reactjs><react-redux>","2","0","","",""
"50728797","1","","","2018-06-06 20:12:44","","0","28","<p>I have observed that the <code>getDerivedStateFromProps</code> of the React Component is called in at least 2 cases: </p>

<ol>
<li>when the props are changed, e.g. the component imports Redux store data via component's props when the Redux store have received new data from the external API (either as a result from the request initiated by the component or as a push from external event)</li>
<li>when the component's <code>setState</code> is called, e.g. user can update data in some element of the component and this update is handled by the procedure that calls <code>setState</code>.</li>
<li>it is also called during the navigation, when props.match.params.... are changed.</li>
</ol>

<p>So - I would like determine the cause (1. or 2.) of the <code>getDerivedStateFromProps</code> and make distinct actions in each case. How it is possible to make such distinction. Maybe this is not possible to do. Or maybe my architecture is flawed if I wish to do this?</p>

<p><em>The main problem for me is - how to pass business object from the redux store (to which the <code>props</code> of component points to) into <code>this.state</code> of some component for further local manipulation?</em></p>

<p>My previous attempt is documented in the question <a href=""https://stackoverflow.com/questions/50703224/reactjs-setstate-conflicts-with-getderivedstatefromprops"">ReactJS setState conflicts with getDerivedStateFromProps</a> in which the more concrete code examples are available.</p>
","1375882","","1375882","","2018-06-06 21:04:28","2018-06-06 21:04:28","Is it possible to detect the cause of getDerivedStateFromProps in React-Redux?","<javascript><reactjs><redux><react-redux>","0","3","","",""
"50752055","1","","","2018-06-08 01:12:15","","1","163","<p>I am not sure if current behavior is correct or not.</p>

<p>In 16.3 I was successfully using getDerivedStateFromProps when I had a component that had received its state via props, checking between props and state (or is it more succinct to say prevState and nextProps) using said function was just fine. It updated the state when new props came in,  and changes to state functioned as normal.</p>

<p>Now in 16.4 because calls to setState also trigger getDerivedStateFromProps,  I'm seeing an unexpected result. The state to which it compares is already updated to the new state (logically?) but since props or nextProps remain unchanged my comparison updates to the current set props. These are logically unchanged as I only changed the state. So, my calls to set state now fail. Maybe I'm doing it wrong? Maybe it should compare to the state as is was before setState was called? This is what I would expect, and would solve the problem because the real previous state will match the props and no change will occur.</p>

<p>here is an example:
<a href=""https://jsfiddle.net/rjacks24/1yupwngv/"" rel=""nofollow noreferrer"">https://jsfiddle.net/rjacks24/1yupwngv/</a></p>

<pre><code>class Example extends React.Component {
constructor(props) {
super(props);
this.state = {
  stopped: this.props.stopped || false,
};

  this.wasToggled = false;
  this.toggleStop = this.toggleStop.bind(this);
}

static getDerivedStateFromProps(nextProps, prevState) {
  if (prevState.stopped !== nextProps.stopped) {
   return ({ stopped: nextProps.stopped });
  } 
  return null;
}

/**
   * function to handle the stop of the antenna
   * @returns {void}
   */
toggleStop() {
    this.wasToggled  = !this.wasToggled;
    this.setState({
      stopped: !this.state.stopped,
    });
  }

render() {
   return (
     &lt;div&gt;
        &lt;button type=""button"" onClick={this.toggleStop} className={this.state.stopped ? ""done"" : """"} &gt;Toggle&lt;/button&gt;
           State Toggled? {this.state.stopped ? 'yes' : 'no'}
         &lt;div&gt;But Actually... wasToggled: {this.wasToggled ? 'yes' :'no'} &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>The expected behavior is that which you get by removing the codeblock for getDerivedStateFromProps(), however, updates from heigher up to props aren't then handled,the way they should be.</p>

<p>I apologize if I am just doing it wrong, but since I was good in 16.3, if figured it's at least worth bringing up for discussion.
This person seems to be experiencing the same thing, but my example is a bit easier: <a href=""https://stackoverflow.com/questions/50532606/proper-use-of-react-getderivedstatefromprops"">Proper use of React getDerivedStateFromProps</a></p>

<p>My guess is that the correct way in these cases is to always handle the state on the HOC, then calling gdsfp is not a problem.</p>

<p>tldr; 16.3 let me change state while using getderivedStateFromProps,  16.4 does not. </p>
","2811781","","","","","2018-06-08 04:13:27","getDerivedStatefromProps in react 16.4 results in no state changes","<reactjs>","1","0","1","",""
"50709453","1","","","2018-06-05 21:50:52","","0","155","<p>Recently i've refactored my Checkbox component to use the new <strong>getDerivedStateFromProps</strong> static method instead of the deprecated <strong>componentWillReceiveProps</strong>.</p>

<p><strong>Now i'm experiencing some issues:</strong></p>

<p><strong>1.</strong> I had to save another previousValue in the component state and compare it each time with the new values, coming from state or props - (otherwise it won't work, since getDerivedStateFromProps is invoked upon each update, also state change).</p>

<p><strong>2.</strong> getDerivedStateFromProps is called 4 times per checkbox change which seems like a waste...</p>

<p>What am i missing here?</p>

<p><a href=""https://stackblitz.com/edit/react-ts-yucxwd"" rel=""nofollow noreferrer"">code example</a></p>
","3318226","","","","","2018-06-06 11:24:35","React 16.4 getDerivedStateFromProps and controlled components","<reactjs><react-dom>","1","1","","",""
"50864547","1","50865039","","2018-06-14 19:26:35","","0","32","<p>For example, say i have a child component (the row of a table) which has in its state a 'rating' key, with the value set to '0' in the constructor. </p>

<p>In getDerivedStateFromProps and ComponentDidMount, the rating is set to this.props.rating. so far so good.</p>

<p>Now the user sets a new rating, state is updated, the query to mysql is dispatched, and everything is good. But then the user clicks a Link (react-router-dom) to the same page they are already on. React updates all the components, but since the higher level component has not changed, it does not query the database again for the songs, and therefore the same set of songs is passed down as props, along with the old rating.</p>

<p>my question is simple: should the higher level component query the database each time the user redirects to the component? if so, is there a lifecycle method for this, since props aren't changing? or should the query for the new set of songs be sent each time the user selects a rating? the latter seems like the correct approach, but also inefficient.</p>
","7229669","","","","","2018-06-14 20:01:02","How to manage state in react during react-router redirects","<reactjs><react-router>","1","0","","",""
"51193657","1","51246326","","2018-07-05 14:18:48","","0","61","<p>I am unable to use <code>static</code> method inside Class Component which is Connected to Redux. TypeScript reports </p>

<pre><code>Argument of type 'typeof SAI' is not assignable to parameter of type 'ComponentType&lt;IStateProps &amp; IDispatchProps&gt;'.
  Type 'typeof SAI' is not assignable to type 'StatelessComponent&lt;IStateProps &amp; IDispatchProps&gt;'.
    Type 'typeof SAI' provides no match for the signature '(props: IStateProps &amp; IDispatchProps &amp; { children?: ReactNode; }, context?: any): ReactElement&lt;any&gt; | null'.
</code></pre>

<p>Container:</p>

<pre><code>export interface IStateProps {
  saiList: ISaiList
}

const mapStateToProps = (state: IRootState) =&gt; ({
  saiList: SaiListSelector(state)
});

export interface IDispatchProps {
  getSai: () =&gt; Dispatch&lt;AnyAction&gt;;
  postSai: (saiList: ISaiList) =&gt; Dispatch&lt;AnyAction&gt;;
}

const mapDispatchToProps = (dispatch: Dispatch) =&gt; ({
  getSai: () =&gt; dispatch&lt;any&gt;(getSaiList()),
  postSai: (saiList: ISaiList) =&gt; dispatch&lt;any&gt;(postSaiList(saiList))
});

export default connect(mapStateToProps, mapDispatchToProps)(SAI);
</code></pre>

<p>Component part:</p>

<pre><code>interface ISAIState {
  editActive: boolean;
  localSai: ISaiList;
  sortBy: string;
}

type ISaiProps = IStateProps &amp; IDispatchProps;

export default class SAI extends React.Component&lt;ISaiProps&gt; {

  public state: ISAIState = {
    editActive: false,
    localSai: [...this.props.saiList],
    sortBy: 'default'
  };

  static getDerivedStateFromProps(props: ISaiProps, state: ISAIState) {
    window.console.log(props, state);
  }
</code></pre>

<p>Is this an issue with <code>@types/react-redux</code> being not up-to-date or is it something from my side? When I comment out</p>

<pre><code>static getDerivedStateFromProps(props: ISaiProps, state: ISAIState) {
    window.console.log(props, state);
}
</code></pre>

<p>method, all works ok...</p>
","3987916","","","","","2018-07-09 13:06:49","Unable to use static getDerivedStateFromProps inside Redux + Typescript Connected Component","<typescript><redux><react-redux><getderivedstatefromprops>","1","0","","",""
"50706523","1","","","2018-06-05 18:16:11","","0","73","<p>I am trying to understand the new React lifecycle methods and have trouble figuring out some details. In React docs for <a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""nofollow noreferrer"">getDerivedStateFromProps</a> it says:</p>

<blockquote>
  <p>getDerivedStateFromProps is invoked right before calling the render
  method, both on the initial mount and on subsequent updates. It should
  return an object to update the state, or null to update nothing.</p>
  
  <p>Note that this method is <strong>fired on every render, regardless of the
  cause</strong>. This is in contrast to UNSAFE_componentWillReceiveProps, which
  only fires when the parent causes a re-render and not as a result of a
  local setState.</p>
</blockquote>

<p>(emphasis mine)</p>

<p>If I understand correctly, if I just derive state from props and return it (as the name suggests we should do), I will trigger an endless loop, because <code>this.state</code> will update, which will trigger re-render, which will call <code>getDerivedStateFromProps</code>, which will return new state update,... </p>

<p>Do we need to make sure that we only return state update if the changes differ from the old state, or am I missing something?</p>
","593487","","","","","2018-06-08 12:03:04","Do we need to make sure getDerivedStateFromProps is not recursive?","<reactjs>","1","0","","",""
"50909833","1","","","2018-06-18 12:44:31","","4","90","<p>So 16.4 ""fixes"" a bug in getDerivedStateFromProps and now it gets fired both on props change and on state change. Obviously this is intended, coming from this post: <a href=""https://github.com/facebook/react/issues/12898"" rel=""nofollow noreferrer"">https://github.com/facebook/react/issues/12898</a>. However for me, saving previous props in the state is a major overkill, so I am asking if someone has made a procedure in coping with a case like this:</p>

<pre><code>class Componentche extends React.Component {
  state = {
    valuesForInput: {
      input1: ''
    }
  }
  static getDerivedStateFromProps(props, state) {
    if (props.someInitialValuesForInput.input1 !== state.valuesForInput.input1) {
      return {
       valuesForInput: {
         ...state,
         input1: props.someInitialValuesForInput.input1
       }
      }
    }
   return state;

   render () {
      &lt;Input value='valuesForInput.input1' onChange='(e) =&gt; setState({valuesForInput: {...this.state, input1: e.target.value }})'
   }
}
</code></pre>

<p>So in this above case, I will never ever have change in the input, because getDerivedStateFromProps will execute both on new props received and on the setState trigger, and my condition will never even be false.</p>

<p>So what is the correct way to handle this situation? Do I need to really keep the old props in the state and use them for conditions as well?</p>

<p>I just saw this <a href=""https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state"" rel=""nofollow noreferrer"">post from React</a> but they do not offer a working alternative. </p>

<p>Thanks for your help!</p>
","2299417","","2299417","","2018-06-18 13:06:22","2018-06-18 13:06:22","React 16.4 enables getDerivedStateFromProps to be called from state change. How to cope with that?","<javascript><reactjs><react-16>","0","0","","",""
"49664867","1","49666440","","2018-04-05 05:38:19","","3","1666","<p>Before upgrading react to version <code>16.3</code> for calling action based on changes in props I use something like this code :</p>

<pre><code>componentWillReceiveProps(nextProps){
   if(this.props.country.length !== nextProps.country){
    doSomething(); //example calling redux action
    }
}
</code></pre>

<p>but in version <code>16.3</code> of react <code>componentWillReceiveProps</code> is unsafe and we must use <a href=""https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops"" rel=""nofollow noreferrer""><code>getDerivedStateFromProps</code></a> but it said this methods must return object and I don't know how I can simulate what I do before with <code>componentWillReceiveProps</code> do with <code>getDerivedStateFrompProps</code></p>
","1262045","","","","","2018-06-04 18:59:15","Calling Method in getDerivedStateFromProps in ReactJS","<reactjs>","2","4","","",""
"50854314","1","","","2018-06-14 09:39:20","","1","50","<p>I cannot figure out what is the problem with my component lyfecicle. I need to start my timer <code>_startTimer</code> in case when the component will receive new props. But istead of it I always got <code>null</code> for my both local methods <code>_startTimer</code> and <code>_clearTimer</code> in getDerivedStateFromProps react lifecicle method. why?</p>

<p>My problem is about how to use the local methods inside the getDerivedStateFromProps! please, read ceafully before mark my question as dublicated!</p>

<p>Thank you!  </p>

<pre><code>  _startTimer = timeLeftForNextCD =&gt; {
     setInterval(() =&gt; {'hey'}, 5000)
  }

  _clearTimer = timerId =&gt; {
    clearInterval(timerId)
  }

  componentDidMount() {
    const { timeLeftForNextCD } = this.props.copyProgress
    console.log('componentDidMount', timeLeftForNextCD)
    if (timeLeftForNextCD) {
      this._runTimer(timeLeftForNextCD)
    }
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    const { timeLeftForNextCD } = nextProps.copyProgress
    const { timerId } = prevState
    console.log(this._clearTimer, this._runTimer) // error - null for both
    if (timeLeftForNextCD) {
      this._clearTimer(timerId)
      this._runTimer(timeLeftForNextCD)
    }

    return null
  }
</code></pre>
","9929306","","9929306","","2018-06-18 09:51:08","2018-06-18 09:51:08","Why static getDerivedStateFromProps does not see local component methods?","<javascript><reactjs>","0","5","1","",""
"50855594","1","50856338","","2018-06-14 10:42:43","","1","171","<p>I have this simple code that is using the new <code>getDerivedStateFromProps</code> lifecycle:</p>

<pre><code>static getDerivedStateFromProps(nextProps: Props, prevState: State) {
  if (nextProps.value !== prevState.value) {
    console.log('hello');
    return {
      value: nextProps.value
    };
  }

  return null;
}
</code></pre>

<p>And this is the test:</p>

<pre><code>it('should call getDerivedStateFromProps', () =&gt; {
  const instance = shallow(mockComponent());

  instance.setProps({ value: 'test2' });

  expect(instance.state.value).toEqual('test2');
});
</code></pre>

<p>But I have this error but I know that is calling because of the console.log().</p>

<pre><code>Expected value to equal:
  ""test2""
Received:
  undefined
</code></pre>

<p>How do I test properly <code>getDerivedStateFromProps</code>?</p>

<p>I'm using:</p>

<pre><code>react: 16.4
react-Dom: 16.4
enzyme-adapter-react-16: 1.1.1
react-test-renderer: 16.4.1
</code></pre>
","3507464","","","","","2018-06-16 09:37:06","How to test getDerivedStateFromProps with Jest and Enzyme","<javascript><reactjs><unit-testing><jestjs><enzyme>","2","2","","",""