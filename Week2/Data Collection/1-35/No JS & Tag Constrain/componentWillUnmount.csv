Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate
"30100403","1","","","2015-05-07 11:58:05","","0","638","<p>Im using a data array to create a menu in react, the menu work fine but it has some submenu on determinated items. </p>

<p>I use the classnames to show the submenu, this is made in 2 separated components of react and the problem is the following, when I click on one menu item which has submenu all the submenus are open at the same time. </p>

<p>Not sure how to fix it and just open the corresponded submenu.</p>

<p>This is the menu:</p>

<pre><code>export default class MainNavBarView_Profit extends React.Component {
    constructor (props){
        super(props);

        this.state = {active: false, activetest:false}
        this.handleClick = this.handleClick.bind(this)
    }

    handleClick() {
        this.setState({ active: !this.state.active, activetest: !this.state.activetest });
    }

    render() {
        var me = this;
        var cx = require('classnames');
        var button = cx ({
            'aui-profit-main-navbar-dropdown-closed-li' : true,
            'selected' : this.state.active
        });
        var menu_data = [
            { text: 'Inicio' },
            { text: 'Ventas' },
            { text: 'Gastos' },
            { text: 'Bancos' },
            { text: 'Invitar a mis amigos' },
            { text: 'Mi gestor', submenu: [
                { text: 'Conectar con mi gestor' },
                { text: 'Buscar un gestor' },
                { text: 'Ver ofertas de expertos' },
                { text: 'Buscar un experto' },
                ]
            },
            { text: 'Aplicaciones', submenu: [
                { text: 'Facturación' },
                { text: 'Contabilidad' },
                { text: 'Proyectos' },
                { text: 'Stock' },
                { text: '+ Añadir más aplicaciones' },
                ]
            }
        ];

        var menu_options = [];
        menu_data.map(function(menu_option, index) {
            if (menu_option.submenu) {
                menu_options.push(&lt;li key={index} className={button}&gt;&lt;a href=""#"" className=""aui-profit-main-navbar-dropdown-closed-a"" onClick={me.handleClick}&gt;{menu_option.text}&lt;/a&gt; &lt;MainNavBarDropdownView options={menu_option.submenu} activetest={me.state.activetest} /&gt;&lt;/li&gt;);
            } else {
                menu_options.push(&lt;li key={index} className=""aui-profit-main-navbar-li""&gt;&lt;a href=""#"" className=""aui-profit-main-navbar-a""&gt;{menu_option.text}&lt;/a&gt;&lt;/li&gt;);
            }
        });

        return (
            &lt;div className=""aui-profit-main-navbar-container""&gt;
                &lt;nav&gt;
                    &lt;ul className=""aui-profit-main-navbar-ul""&gt;
                        {menu_options}
                    &lt;/ul&gt;
                &lt;/nav&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>This is the submenu: </p>

<pre><code>export default class MainNavBarDropdownView_Profit extends React.Component {

    constructor(props) {
        super(props);   
    }

    componentWillMount() {
        if (process.env.BROWSER) {
            document.addEventListener(""click"", (e) =&gt; this._handleOnClickDocument(e), true);
        }
    }

    componentWillUnmount() {
        if (process.env.BROWSER) {
            document.removeEventListener(""click"", (e) =&gt; this._handleOnClickDocument(e), true);
        }
    }

    _handleOnClickDocument(e) {
        e.preventDefault();

        if (this.refs.dropdownContainer.getDOMNode().contains(e.target)) return;

        if(this.state.active == true){
            this.setState({ 
                active: false
            });
        }
    }

    render() {

        var submenu_options = [];
        this.props.options.map(function(submenu_option, index) {
            submenu_options.push(&lt;li key={index} className=""aui-profit-main-navbar-dropdown-li""&gt;&lt;a href=""#"" className=""aui-profit-main-navbar-dropdown-a""&gt;{submenu_option.text}&lt;/a&gt;&lt;/li&gt;);
        });
        var cx = require('classnames');
        var dropdown = cx ({
            'aui-profit-main-navbar-dropdown-ul' : true,
            'block' : this.props.activetest
        });

        return (
            &lt;ul className={dropdown} ref=""dropdownContainer""&gt;
                {submenu_options}
            &lt;/ul&gt;                   
        );
    }
}
</code></pre>

<p>I was wondering if I can do it just with css, adding a class to the items with submenu which displays or changes the ul class to block?</p>
","2923808","","1048572","","2015-05-07 13:40:49","2015-05-07 13:40:49","how to show the submenu of each clicked menu item and not all in a react array","<css><reactjs>","0","2","","",""
"30135351","1","","","2015-05-09 02:37:44","","5","7142","<p>I have the following code for a simple dropdown menu on my navbar: <a href=""https://jsfiddle.net/jL3yyk98/10/"" rel=""nofollow"">https://jsfiddle.net/jL3yyk98/10/</a></p>

<p>index.html</p>

<pre><code>&lt;div id=""menu-button""&gt;&lt;/div&gt;
</code></pre>

<p>NavMenu.js</p>

<pre><code>var NavMenu = React.createClass({
    getDefaultProps: function()
    {
        return {
            isOpen: false
        };
    },

    render: function()
    {
        if (this.props.isOpen)
        {
            return (
                &lt;div className=""dropdown""&gt;
                    &lt;ul&gt;
                        &lt;li&gt;&lt;a href=""#""&gt;News&lt;/a&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;a href=""#""&gt;About&lt;/a&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;a href=""#""&gt;Guidelines&lt;/a&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;a href=""#""&gt;Exchange&lt;/a&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;a href=""#""&gt;Forum&lt;/a&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            );
        }
        return null;
    }
});
</code></pre>

<p>NavMenuButton.js</p>

<pre><code>var NavMenuButton = React.createClass({

    getInitialState: function()
    {
        return {
            isOpen: false
        };
    },

    toggleMenu: function(e)
    {
        e.stopPropagation();
        this.setState({isOpen: !this.state.isOpen});
    },

    onClose: function()
    {
        this.setState({isOpen: false});
    },

    componentDidMount: function ()
    {
        document.body.addEventListener('click', this.onClose);
    },

    componentWillUnmount: function ()
    {
        document.body.removeEventListener('click', this.onClose);
    },

    render: function()
    {
        return (
            &lt;div&gt;
                &lt;a onClick={this.toggleMenu} href=""#""&gt;Menu&lt;/a&gt;
                &lt;NavMenu isOpen={this.state.isOpen} /&gt;
            &lt;/div&gt;
        );
    }

});

React.render(&lt;NavMenuButton /&gt;, document.getElementById('menu-button'));
</code></pre>

<p>I understand with my current code that both the toggleMenu method and onClose method are called when the user clicks the menu button to close the menu (since they are also effectively clicking the body); and that the onClose method is called first, meaning that the state is set to false, but then the toggleMenu method is called and it's set back to true. Why is this, and how can I fix it so that clicking the menu button toggles the menu <em>and</em> clicking the body hides the menu?</p>

<p>If this approach seems wrong what approach should I be using? I'm fairly new to react so I'm still learning what goes where and why.</p>

<p>Also, I cannot use a full body div as the solution to this, it needs to be a typical dropdown; so if users want to interact with another part of the page (maybe clicking a link), then they can do that.</p>
","2442241","","2442241","","2015-05-23 14:55:55","2015-09-25 06:47:54","Toggle dropdown menu in reactjs","<javascript><drop-down-menu><toggle><reactjs>","2","5","1","",""
"40652380","1","","","2016-11-17 10:27:24","","1","752","<p>I am trying to shorten the screen when the keyboard is active. But it always adjust it weirdly in android, it works fine in iOS.
Before keyboard is active:</p>

<p><img src=""https://cloud.githubusercontent.com/assets/15681219/20385368/1d91da1c-acf2-11e6-8699-104471899c37.jpeg"" width=""230"" /></p>

<p>After keyboard is active:  </p>

<p><img src=""https://cloud.githubusercontent.com/assets/15681219/20385376/24f2e3fa-acf2-11e6-8c28-087c66c86002.jpeg"" width=""230"" /></p>

<p>I am using RN 0.37, this also happens when i am starting from scratch: </p>

<p>This is my code:</p>

<pre><code>import React from 'react';

import {
  Keyboard,
  Dimensions,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  AppRegistry
} from 'react-native';

var {height, width} = Dimensions.get('window');
var _keyboardWillShowSubscription;
var _keyboardWillHideSubscription;
height = height - 20;

class awesomeproject extends React.Component {
  constructor(props) {
        super(props);
        this.state = {
            height: height,
        };
    }
    componentDidMount() {
        _keyboardWillShowSubscription = Keyboard.addListener('keyboardDidShow', (e) =&gt; this._keyboardWillShow(e));
        _keyboardWillHideSubscription = Keyboard.addListener('keyboardDidHide', (e) =&gt; this._keyboardWillHide(e));
    }
    componentWillUnmount() {
        _keyboardWillShowSubscription.remove();
        _keyboardWillHideSubscription.remove();
    }
    _keyboardWillShow(e) {
        this.setState({height: height - e.endCoordinates.height});
    }
    _keyboardWillHide(e) {
        this.setState({height: height});
    }
  render() {
    return (
        &lt;View style={{height: this.state.height}}&gt;  
            &lt;View style={{backgroundColor: 'blue', flex: 1}} /&gt;
            &lt;View style={styles.fieldBox}&gt;
                &lt;TextInput 
                    style={styles.field}
                    placeholder={'hello'}
                    autoCapitalize={'none'}
                    placeholderTextColor={'#afbccc'}
                    blurOnSubmit={false}
                    autoCorrect={false}
                    ref={'textinput'}
                    onChangeText={(data) =&gt; this.setState({message: data})} /&gt;
            &lt;/View&gt;
        &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  field: {
        color:'black',
        fontWeight:'bold',
        fontSize:18,
        flex: 1,
        marginHorizontal: 10
    },
});

AppRegistry.registerComponent('awesomeproject', () =&gt; awesomeproject);
</code></pre>
","2870004","","2668136","","2016-12-22 06:23:46","2016-12-22 06:23:46","Height adjustment when keyboard appears is wrong in react-native android","<android><keyboard><react-native>","1","1","","",""
"50185157","1","50185682","","2018-05-05 02:33:33","","3","149","<p>I am working with react 16.3 where <code>componentWillUpdate</code> is deprecated (strict mode). We have a react wrapper around <code>Highcharts</code> and used to update the <code>highchart</code> in <code>componentWillUpdate</code> that runs just before render. </p>

<p>But now in react 16.3 when the input <code>highchartoptions</code> prop updates, there seems to be no way to call <code>Highchart.update</code> before <code>render()</code> is called. Its suggested to use <code>componentDidUpdate</code> but its called only after <code>render()</code> and it doesn't seem to work at all.Any suggestions will help.</p>

<p>Code snippet here:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class HighchartReactWrapper extends React.Component {
  constructor(props) {
    super(props);

    // We maintain the user provided options being used by highchart as state
    // inorder to check if chart update is needed.
    this.state = { highChartOptions: this.props.options };
    this.onChartRendered = this.onChartRendered.bind(this);
  }

  componentDidMount() {
    // Create chart
    this.chart = new Highcharts.Chart(this.container, this.state.highChartOptions, this.onChartRendered);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.options !== prevState.options) {
      return { highChartOptions: nextProps.options };
    }
  }

  componentDidUpdate() {
    this.chart.update(this.state.highChartOptions, false, true); &lt;---- Doesn't work
  }

  onChartRendered() {
    // Callbacks..
    if (this.props.onChartRenderedCallback !== undefined) {
      this.props.onChartRenderedCallback();
    }
  }

  componentWillUnmount() {
    // Destroy chart
    this.chart.destroy()
  }

  render() {
    return (
      &lt;div className=""react-highchart-wrapper""&gt;
        &lt;div id={container =&gt; this.container = container} /&gt;
      &lt;/div&gt;
    );
  }
}

HighchartReactWrapper.propTypes = {
  /**
   * Chart options to be used in Highcharts library.
   */
  options: PropTypes.object.isRequired,
  onChartRenderedCallback: PropTypes.func
};

HighchartReactWrapper.defaultProps = {
  options: undefined,
  onChartRenderedCallback: undefined
};</code></pre>
</div>
</div>
</p>
","9743947","","6622817","","2018-05-05 02:38:16","2018-05-05 04:23:13","How to update Highchart from inside react a component?","<reactjs><highcharts>","1","3","1","",""
"50196555","1","50197160","","2018-05-06 05:32:48","","0","54","<p>I want to change the dafault locale of this component to <code>fr</code>. Here is the component:</p>

<pre><code>import EventEmitter from 'events';
import pt from 'prop-types';
import React from 'react';
import moment from 'moment';

moment.locale(""fr"");

class Ticker extends EventEmitter {
  tick = () =&gt; this.emit('tick');

  constructor(interval) {
    super();
    this.setMaxListeners(0);
    this.once('newListener', () =&gt; setInterval(this.tick, interval));
  }
}

const ticker = new Ticker(30000); // 30 sec

export default class TimeDisplay extends React.Component {
  static propTypes = {
    timeStamp: pt.oneOfType([pt.number.isRequired, pt.string.isRequired]),
    className: pt.string,
    timeAgoInTitle: pt.bool,
  };

  refresh = () =&gt; this.forceUpdate();

  componentDidMount() {
    ticker.addListener('tick', this.refresh);
  }

  componentWillUnmount() {
    ticker.removeListener('tick', this.refresh);
  }

  render() {
    moment.locale(""fr"");
    const time = moment(this.props.timeStamp);
    const timeAgo = Math.abs(moment().diff(time)) &lt; 1000 ? 'maintenant' : time.fromNow();
    const timeISO = time.format();

    const title = this.props.timeAgoInTitle ? timeAgo : time.format('lll');
    const contents = this.props.children ? this.props.children : timeAgo;

    return (
      &lt;time className={this.props.className} dateTime={timeISO} title={title}&gt;{contents}&lt;/time&gt;
    );
  }
}
</code></pre>

<p>As you can see I've set <code>moment.locale(""fr"");</code> both after imports and at render but the moment strings are still shown in English. How can I fix it?</p>
","5774375","","631803","","2018-05-07 00:22:19","2018-05-07 00:22:19","Can not change default locale of moment.js in react component","<reactjs><momentjs>","1","0","","",""
"49335127","1","","","2018-03-17 10:52:45","","1","196","<p>enter image description hereI got the problem with an npm package that is rn-apple-healthkit.
And my problem is as a below
<a href=""https://github.com/terrillo/rn-apple-healthkit/issues/16"" rel=""nofollow noreferrer"">https://github.com/terrillo/rn-apple-healthkit/issues/16</a></p>

<h2>I have imported AppleHealthkit, however Eslint still alert me AppleHealthkit is not defined in ""<strong><em>AppleHealthkit.initStepCountObserver({}, () => {});</em></strong>""</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import {
  ScrollView,
  Navigator,
  View,
  NativeAppEventEmitter,
} from 'react-native';
import axios from 'axios';
import AppleHealthKit from 'rn-apple-healthkit';

import AlbumDetail from './AlbumDetail';

// Healthkit API part
const d = new Date();

const PERMS = AppleHealthKit.Constants.Permissions;

const HKOPTIONS = {
  permissions: {
    read: [
        PERMS.StepCount,
        PERMS.Height,
        PERMS.Weight,
        PERMS.DateOfBirth,
        PERMS.BodyMassIndex,
    ],
    write: [
        PERMS.StepCount,
        PERMS.Weight,
        PERMS.BodyMassIndex,
    ],
  },
  date: d.toISOString()
};

AppleHealthKit.initHealthKit(HKOPTIONS, (err, res) =&gt; {
  if (err) {
    console.log('HealthkitInitError: ', err);
    return;
  }
  console.log('HealthkitInitSucess');

  AppleHealthkit.initStepCountObserver({}, () =&gt; {});

  this.sub = NativeAppEventEmitter.addListener(
    'change:steps',
    (event) =&gt; {
    //'change:steps' event has been received. step
    //count data should be re-fetched from Healthkit.
      this._fetchStepCountData();
      console.log(event);
    }
  );
  this._fetchStepCountData();
  this._fetchOtherRelevantHealthkitData();
});

// StepCounter Example
AppleHealthKit.getStepCount(HKOPTIONS, (error, results) =&gt; {
  if (error) {
    console.log('getStepCountError: ', error);
    return;
  }
  console.log(results);
});

// React-Native part
class albumList extends Component {
  state = { albums: [] };
  
  componentWillMount() {
    axios.get('https://rallycoding.herokuapp.com/api/music_albums')
      .then(response =&gt; this.setState({ albums: response.data }))
      .then(response =&gt; console.log(response));
  }

  componentDidMount() {
    console.log(this.state.albums);
  }

// when the component where the listener was added unmounts, call the 'remove' method of the subscription object.
  componentWillUnmount() {
    this.sub.remove();
  };

  renderAlbums() {
    return this.state.albums.map(album =&gt; 
      &lt;AlbumDetail key={album.title} data={album} /&gt;
    );
  }
  render() {
    return (
      &lt;ScrollView&gt; 
        {this.renderAlbums()}
      &lt;/ScrollView&gt;
    );
  }
}

export default albumList;</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><a href=""https://i.stack.imgur.com/SXZzD.jpg"" rel=""nofollow noreferrer"">enter image description here</a></p>
","9501255","","9501255","","2018-03-17 11:11:20","2018-03-17 11:11:20","react-native with healthkit api","<react-native><health-kit>","0","2","0","",""
"42540397","1","","","2017-03-01 19:31:51","","0","269","<p>I am using react-router with a route structure like so:</p>

<pre><code>const routes = (
  &lt;Router history={browserHistory}&gt;
    &lt;Route path=""/main"" component={MainPage}&gt;&lt;/Route&gt;
    &lt;Route path=""/charts/:chartID"" component={App}&gt;&lt;/Route&gt;
  &lt;/Router&gt;
)
</code></pre>

<p>I am trying to do a call to a meteor method when a user switches away from ""/charts/:chartID"" to ""/main"". I only want the method to be called once if possible</p>

<p>In App.js, I used the life cycle methods:</p>

<pre><code>  componentDidUpdate(){
    Meteor.call('test',""update"");   
  } // prints ""update""

  componentWillUnmount(){
    Meteor.call('test',""unmount"");
  } // nothing happens when url changes
</code></pre>

<p>Main.js (server):</p>

<pre><code>Meteor.methods({
    'test'(obj){
        console.log(obj)
    }
})
</code></pre>

<p>I read from this <a href=""https://github.com/ReactTraining/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow noreferrer"">source</a> that components should unmount when the url changes in my situation, but seems like I may have missed out something. How should I be resolving this?</p>

<p>Any help is greatly appreciated!</p>
","6150999","","","","","2017-03-01 22:55:19","react-router: Calling componentWillUnmount across different non-nested routes","<javascript><reactjs><meteor><react-router>","1","0","1","",""
"47463048","1","47486941","","2017-11-23 20:45:41","","2","647","<p>This is the code... how would you abort such ajax call?</p>

<p>Or, how to prevent react from giving me an error ""setState called on unmounted component""?</p>

<p>(httpGet is just a wrapper for XMLHttpRequest and a promise)</p>

<pre><code>async componentDidMount() {
    const response = await httpGet(""/ajaxRequest"");
    if(response) {
        //the component has already been unmounted
        this.setState(() =&gt; ({success: true}));
    }
}

componentWillUnmount() {
    //should abort possible running ajax
}
</code></pre>

<p><strong>EDIT:</strong>
Here's the wrapper:</p>

<pre><code>const httpGet = function (url) {


    const request = new XMLHttpRequest;
    request.open(""GET"", url, true);

    return new Promise((resolve, reject) =&gt;  {
        request.onload(response =&gt; {
            resolve(response);
        });

        request.onerror(() =&gt; {
            reject(""Network error"");
        });

        request.send();
    });
};
</code></pre>
","2880184","","218196","","2017-11-27 16:32:29","2017-11-27 16:32:29","How to abort running async/await xmlHttpRequest within componentWillUnmount?","<javascript><ajax><reactjs><async-await><ecmascript-2017>","1","4","","",""
"42534069","1","","","2017-03-01 14:16:13","","0","76","<p>Trying to pause or remove GSAP animation within the <code>else</code> part of this conditional.. </p>

<p>Container code - </p>

<pre><code>     renderNews = () =&gt; {
  /**
   * Renders news snippets, no filtering at this time
   */
    let max = 2
    let count = 0
    let posts = this.props.posts.map((article) =&gt; {
      count++
      console.log('count' + count)
      console.log('renderNews article =&gt; ', article)
      if (count &lt;= max) {
        return (
          &lt;Grid md={0.5} sm={1} key={article.id} &gt;
            &lt;SnippetNewsEvents
              image={article.featured_media}
              event={false}
              title={article.title.rendered}
              date={moment(article.date_gmt).format('Do MMMM YYYY')}
              excerpt={article.excerpt.rendered}
              buttonText='Read More'
              link={'/posts/' + article.slug}
            /&gt;
          &lt;/Grid&gt;
        )
      } else {
        return ( // or whatever the right grid thing is
          &lt;Grid md={1 / 3} sm={1 / 2} xs={1} key={article.id} &gt;
            &lt;SnippetNewsEvents
              //innerRef={null}
              image={article.featured_media}
              title={article.title.rendered}
              date={moment(article.date_gmt).format('Do MMMM YYYY')}
              //  excerpt={article.excerpt.rendered}
              buttonText='Read More'
              link={'/posts/' + article.slug}
            /&gt;
          &lt;/Grid&gt;
      )
      }
    })
    return posts
  }
</code></pre>

<p>Component Code - </p>

<pre><code>export default class SnippetNewsEvents extends React.Component { // eslint-disable-line react/prefer-stateless-function
  constructor () {
    super()
    this.state = {
      image: null
    }
  }
  componentDidMount = () =&gt; {
    this.getImage(this.props.image)
    this.contentTween = new TimelineMax().add([
      TweenMax.fromTo(this.wrapper, 1, {
        scale: '0.95'
      }, {
        scale: '1'
      })])

    this.scene = new ScrollMagic.Scene({triggerElement: this.wrapper, triggerHook: 0.8, duration: window.innerHeight/2})
                  .setTween(this.contentTween)
                  .addIndicators({name: 'snippets'})
                  .addTo(scrollController)
  }
  getImage (image) {
    if (typeof image === 'string') {
      this.setState({image: image})
    } else if (typeof image === 'number' &amp;&amp; image !== 0) {
      fetch('http://hkserverdev.weruinit.com/wp-json/wp/v2/media/' + image)
      .then(response =&gt; response.json())
      .then(data =&gt; {
        this.setState({image: data.source_url})
      }).catch(error =&gt; {
        if (dev) console.error('Error:', error)
      })
    }
  }
  showImage (image) {
    if (this.state.image == null) {
      return null
    } else {
      return (
        &lt;SnippetImage src={this.state.image} data-rjs='2' /&gt;
      )
    }
  }
  showLocation = () =&gt; {
    if (this.props.event) {
      return (
        &lt;EventsDetailWrapper&gt;
          &lt;H3c title={this.props.title}&gt;{this.props.title}&lt;/H3c&gt;
          &lt;EventsTimeLocation&gt;
            &lt;Combo&gt;
              &lt;Icon className='buttonIcon' src={require('../../images/time_icon.png')} data-rjs='2' /&gt;
              &lt;Detail copy={this.props.date} news /&gt;
            &lt;/Combo&gt;
            &lt;Combo&gt;
              &lt;Icon className='buttonIcon' src={require('../../images/location_icon.png')} /&gt;
              &lt;Detail copy={this.props.location} /&gt;
            &lt;/Combo&gt;
          &lt;/EventsTimeLocation&gt;
        &lt;/EventsDetailWrapper&gt;
      )
    } else {
      return (
        &lt;NewsDetailWrapper&gt;
          &lt;Detail uppercase={this.props.event} copy={this.props.date} /&gt;
          &lt;H3c&gt;{this.props.title}&lt;/H3c&gt;
          &lt;Detail excerpt copy={this.props.excerpt} /&gt;
        &lt;/NewsDetailWrapper&gt;
      )
    }
  }
  componentWillUnmount () {
    this.scene = this.scene.destroy()
  }
  render (props) {
    if (dev) console.log('SnippetNewsEvents =&gt; ', this.props)
    return (
      &lt;EventsItemWrapper innerRef={c =&gt; (this.wrapper = c)} className='snippet' small={this.props.compressed}&gt;
        {this.showImage(this.props.image)}
        {this.showLocation(this.props.event)}
        &lt;Button className='hvr-trim hvr-trim-alt' black snippet link={this.props.link} content='Read More'&gt;{this.props.content}&lt;/Button&gt;
      &lt;/EventsItemWrapper&gt;
    )
  }
}
</code></pre>

<p>I'm new to both react and GSAP and js :(( </p>
","5236915","","","","","2017-03-01 16:20:14","Pause GSAP animation after 2nd react component rendered","<javascript><reactjs><animation><gsap>","1","0","","",""
"44361293","1","44361492","","2017-06-05 03:31:12","","1","74","<p>uI have react component, i use <code>componentDidMount</code> lifecycle hook to bind <code>mousedown</code> event to <strong>document</strong>. When mouse down event triggering I bind two more events <code>mousemove</code> and <code>mouseup</code> to <strong>document</strong> also I remove those events at <code>mouseup</code> event. </p>

<p>My problem is when <code>mouseup</code> event triggering it suppose to remove <code>mousemove</code> and <code>mouseup</code> but its not working. Instead each time i click the page <code>mouseup</code> triggering multiple times like: 1, 3, 6, 10, 15... it`s multiplying. </p>

<p>When <code>componentWillUnmount</code> also not removing event from <strong>document</strong>. </p>

<pre><code>import React, { Component } from 'react'

class SandBox extends Component{
    componentDidMount(){
        document.addEventListener('mousedown', this.mouseDown.bind(this))
    }

    //mouseDown
    mouseDown(){
        document.addEventListener('mouseup', this.mouseUp.bind(this))
        document.addEventListener('mousemove', this.mouseMove.bind(this))
    }

    //mouseUp
    mouseUp(){
        // this is not removing the events from document
        document.removeEventListener('mouseup', this.mouseUp, false)
        document.removeEventListener('mousemove', this.mouseMove, false)
        // this triggers 1,3,6,10,15 times
        console.log('mose up')
    }

    moseMove(){
        // mosemoveCodes
    }

}
</code></pre>
","5485491","","5485491","","2017-06-05 03:46:55","2017-06-05 04:00:36","document.removeEventListner not removing event in reactjs","<javascript><reactjs><javascript-events><mouseevent>","1","4","","",""
"42936406","1","42936794","","2017-03-21 19:25:07","","1","940","<p>I am beginning with react at the moment coming from pure front end development with HTML, CSS and a bit of jquery. So I got no experience with package installation. I wanted to install axios using npm.</p>

<p>I started with <code>npm install</code> axios and it seemed to work. But I still get the error message ""axios is not defined"". What I missing? Do I have to right a dependency in my package.json? And if yes how do I right it?</p>

<p>Package.json</p>

<pre><code>{
  ""name"": ""first-webapp-react"",
  ""version"": ""1.0.0"",
  ""description"": """",
  ""main"": ""main.js"",
  ""private"": true,
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1"",
    ""watch"": ""watchify -v -d -t [ reactify --es6 ] main.js -o compiled.js"",
    ""build"": ""NODE_ENV=production browserify -t [ reactify --es6 ] main.js | uglifyjs &gt; compiled.js""
  },
  ""author"": ""BAGGID"",
  ""license"": ""MIT"",
  ""dependencies"": {
    ""moment"": ""^2.10.2"",
    ""react"": ""^0.13.2"",
    ""axios"": ""^0.15.3""
  },
  ""devDependencies"": {
    ""browserify"": ""^9.0.8"",
    ""reactify"": ""^1.1.0"",
    ""uglify-js"": ""^2.4.20"",
    ""watchify"": ""^3.1.2""
  }
}
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var React = require('react');

var TopBar = require('./Top-bar');
var ProductPage = require('./Product-page');
var Test = require('./test');


var App = React.createClass({

  getInitialState: function() {
    return {
      page: 'SearchResult',
      jobs: []
    };    
  },

  componentDidMount: function() {
    var _this = this;
    this.serverRequest = 
      axios.get(""http://codepen.io/jobs.json"")
        .then(function(result) {    
          _this.setState({
            jobs: result.data.jobs
          });
        })
  },

  componentWillUnmount: function() {
    this.serverRequest.abort();
  },

	render(){
    console.log('Person: ' + this.state.person);
		return (
			&lt;div&gt;
				&lt;TopBar /&gt;		
        &lt;ProductPage /&gt;
        &lt;Test /&gt;
			&lt;/div&gt;
		);
	}
});

module.exports = App;</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=""en""&gt;
	&lt;meta charset=""UTF-8""&gt;
	&lt;title&gt;React Test&lt;/title&gt;
	&lt;link href=""http://maxcdn.bootstrapcdn.com/bootswatch/3.3.4/flatly/bootstrap.min.css"" type=""text/css"" rel=""stylesheet"" /&gt;
	&lt;link href=""assets/css/styles.css"" type=""text/css"" rel=""stylesheet"" /&gt;
	&lt;link href=""assets/css/baggid-standart.css"" type=""text/css"" rel=""stylesheet"" /&gt;
	&lt;link href=""assets/css/login.css"" type=""text/css"" rel=""stylesheet"" /&gt;
	&lt;link href=""assets/css/button-stacking.css"" type=""text/css"" rel=""stylesheet"" /&gt;
&lt;/head&gt;
&lt;body&gt;

	&lt;div id=""main""&gt;	
	&lt;/div&gt;

	
	&lt;script src=""./compiled.js""&gt;&lt;/script&gt;
	&lt;script src=""https://unpkg.com/axios/dist/axios.min.js""&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","7096798","","7096798","","2017-03-21 19:58:13","2017-03-21 19:58:13","installing package for react using npm","<reactjs><npm><npm-install><axios>","4","1","","",""
"44258218","1","","","2017-05-30 09:18:23","","0","127","<p>I've made an app using react-native, however I need to trigger a react event from an android widget. This is currently my setup:</p>

<pre><code>public class IsHetAlBierTijdWidget extends AppWidgetProvider {

    static void updateAppWidget(Context context, AppWidgetManager appWidgetManager,
                                int appWidgetId) {

        CharSequence widgetText = context.getString(R.string.app_name);
        // Construct the RemoteViews object
        RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.is_het_al_bier_tijd_widget);

        // Instruct the widget manager to update the widget
        appWidgetManager.updateAppWidget(appWidgetId, views);
    }

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        // There may be multiple widgets active, so update all of them
        for (int appWidgetId : appWidgetIds) {
            updateAppWidget(context, appWidgetManager, appWidgetId);
            sendEventToReactApp(context);
        }
    }

    @Override
    public void onEnabled(Context context) {
        // Enter relevant functionality for when the first widget is created
    }

    @Override
    public void onDisabled(Context context) {
        // Enter relevant functionality for when the last widget is disabled
    }

    public void sendEventToReactApp(Context context) {
        WritableMap event = Arguments.createMap();
        event.putString(""message"", ""MyMessage"");
        ReactApplicationContext reactApplicationContext = new ReactApplicationContext(context);
        MSREventBridgeModule msrEventBridgeModule = new MSREventBridgeModule(reactApplicationContext);
        msrEventBridgeModule.emitEvent(""Widget_Update"",event);
    }
}
</code></pre>

<p>react code:</p>

<pre><code>class Home extends Component {

    constructor(){
        super();
        this.onWidgetUpdate.bind(this);
    }

    onWidgetUpdate(){
        console.log(""widget update..."");
    }

    componentWillMount() {
        this.props.fetchBierTijd()
        DeviceEventEmitter.addListener('Widget_Update', this.onWidgetUpdate);
    }

    componentWillUnmount() {
        DeviceEventEmitter.removeListener('Widget_Update', this.onWidgetUpdate);
    }

    render() {
        return (
            &lt;View style={{flex: 1, justifyContent:'center', alignItems:'center'}}&gt;
                &lt;Countdown
                    style={{marginTop: 80}} fontSize=""40""
                    isBiertijd={this.props.isBierTijd}
                    timeLeft={this.props.timeLeft}
                /&gt;
            &lt;/View&gt;
        )
    }
}

const mapStateToPros = state =&gt; ({
    fetching: state.bierTijd.fetching,
    isBierTijd: state.bierTijd.isBierTijd,
    nextBierTijd: state.bierTijd.next,
    timeLeft: moment(state.bierTijd.next).diff(moment())
})


const mapDispatchToProps = dispatch =&gt; {
    return bindActionCreators({...bierTijdActions,}, dispatch)
}

export default connect(mapStateToPros, mapDispatchToProps)(Home)
</code></pre>

<p>Is it possible to do this, or does the event need to be triggered from the main activity? a good explanation of communication from native to react native would also be appreciated.</p>
","8085205","","","","","2017-10-31 00:00:33","Triggering react-native events from widget - android","<javascript><android><events><react-native><native>","1","0","","",""
"34511849","1","","","2015-12-29 13:13:05","","0","85","<p>I try to interact with data on route changes(I use react-router 1.0.0) but inherited components are not fetching data from API</p>

<p>basically I have my base route which is interacting with the store but the inherited route like <code>/:slug</code> does not updates the component with new data</p>

<p>it seems like the <code>_onChange</code> will not fire up!
the component</p>

<pre><code>import React from 'react';
import PropertyStore from '../stores/PropertyStore';
import AppActions from '../actions/AppActions'



class Property extends React.Component{

    constructor(){
        super();
        this.state = {
            property: []
        }

        this._onChange = this._onChange.bind(this);
        this.handleChange = this.handleChange.bind(this);

    }

    componentWillMount(){
        PropertyStore.addChangeListener(this._onChange);
    }

    componentWillUnmount() {
        PropertyStore.removeChangeListener(this._onChange);
    }

    componentDidMount () {
        AppActions.getProperty( this.props.params.slug );
    }

    handleChange(e) {}

    _onChange() {
        this.setState({
            property: PropertyStore.getProperty( this.props.params.slug )
        });
    }

    render() {
        var property;
        if (this.state.property) {
            console.log(this.state.property) //empty!!

            property = this.state.property.map(function (detail, i) {
        return (
            &lt;div&gt;{detail.description}&lt;/div&gt;)
            });
        }

        return(
            &lt;div className=""Property""&gt; {property} &lt;/div&gt;
        )
    }
}


module.exports = Property;
</code></pre>

<p>AppActions</p>

<pre><code>'use strict';

var AppDispatcher = require('../dispatchers/AppDispatcher');
var AppConstants = require('../constants/AppConstants');
var PropertiesStore = require('../stores/PropertiesStore');
var PropertyStore = require('../stores/PropertyStore');
var Promise = require('es6-promise').Promise; // jshint ignore:line
var Api = require('../services/Api');

var AppActions = {

    getProperties: function () {
        Api
            .get('/api/v2/properties')
            .then(function (properties) {
                AppDispatcher.handleViewAction({
                    actionType: AppConstants.RECEIVE_PROPERTIES,
                    properties: properties.data.properties
                });
            })
            .catch(function () {
                AppDispatcher.handleViewAction({
                    actionType: AppConstants.RECEIVE_ERROR,
                    error: 'There was a problem getting the workshops'
                });
            });
    },

    getProperty: function (slug) {

        Api
            .get('/api/v2/properties/'+ slug)
            .then(function (property) {

                AppDispatcher.handleViewAction({
                    actionType: AppConstants.RECEIVE_PROPERTY,
                    property: property.data.property
                });
            })
            .catch(function () {
                AppDispatcher.handleViewAction({
                    actionType: AppConstants.RECEIVE_ERROR,
                    error: 'There was a problem getting the Voucher'
                });
            });

    },

    getMedia: function () {
        Api
            .get('/wp-json/wp/v2/workshops')
            .then(function (workshops) {
                AppDispatcher.handleViewAction({
                    actionType: WorkshopConstants.RECEIVE_MEDIA,
                    workshops: workshops
                });
            })
            .catch(function () {
                AppDispatcher.handleViewAction({
                    actionType: WorkshopConstants.RECEIVE_ERROR,
                    error: 'There was a problem getting the categories'
                });
            });
    }

};

module.exports = AppActions;
</code></pre>
","1831740","","1831740","","2015-12-30 14:44:14","2015-12-30 14:44:14","react-router and flux how to?","<reactjs><react-router><reactjs-flux>","0","2","","",""
"45188689","1","","","2017-07-19 11:04:57","","3","88","<p>I am trying to implement infinite scroll in react js by repeating the same set of data a certain number of times and adding an event listener scroll to the window.</p>

<p>The code that I have is like this </p>

<pre><code>import React from 'react';
import ReactDom from 'react-dom' ;
import $ from 'jquery' ;
import { Router, Route, Link, IndexRoute, hashHistory, browserHistory } from 'react-router';
import {Author} from './Author.js'


class ExpenseApp extends React.Component{
  constructor(props){
    super(props);
    this.state={
      data:this.props.data,
      list:[],
      repeat:[],
      requestSent:false
    }
    this.handleOnScroll=this.handleOnScroll.bind(this);
  }
  componentDidMount(){
    window.addEventListener('scroll',this.handleOnScroll);
    this.initFakeData();
  }
  componentWillUnmount(){
    window.removeEventListener('scroll',this.handleOnScroll);
  }

  initFakeData(){
    var data=this.createData(this.state.data,100);
    this.setState({data:data});
  }

  createData(data,counter){
    var i=0;

    var fakeData=[];
    var len=Object.keys(data).length;
    for(i=0;i&lt;counter;i++){
      for(var j=0;j&lt;len;j++){

        fakeData.push(data[j]);
      }
    }
    return fakeData;
  }

  querySearchResult(){
    if(this.state.requestSent){
      return;
    }
    setTimeout(this.doQuery,2000);
    this.setState({
      requestSent:true
    })
  }

  doQuery(){
    var that=this;
    $.ajax({

      url:'#',
      data:null,
      method:'GET',
      success:function(data,textStatus,jqXHR){
        var fakeData=that.createData(that.state.data,20);
        var newData=that.state.data.concat(fakeData);
        that.setState({data:newData,requestSent:false});
      },
      error: function(jqXHR, textStatus, errorThrown) {
        that.setState({requestSent: false});
      }
    });

  }

  handleOnScroll() {
    var that=this;
    var scrollTop = (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
    var scrollHeight = (document.documentElement &amp;&amp; document.documentElement.scrollHeight) || document.body.scrollHeight;
    var clientHeight = document.documentElement.clientHeight || window.innerHeight;
    var scrolledToBottom = Math.ceil(scrollTop + clientHeight) &gt;= scrollHeight;
    if (scrolledToBottom) {
      that.querySearchResult();
    }
  }

  render(){
    var data=this.state.data;
    var list=this.state.list;
     var len= Object.keys(data).length;
     console.log(data);
    for(var i=0;i&lt;len;i++){
      list.push(&lt;Author key={i} i={i} data={data[i]}/&gt;);
    }

    return(
    &lt;div&gt;
      &lt;div className=""row""&gt;
        {list}
      &lt;/div&gt;
      {(() =&gt; {
        &lt;span&gt;still loading&lt;/span&gt;
          if (this.state.requestSent) {
            return(
              &lt;div className=""data-loading""&gt;
                &lt;i className=""fa fa-refresh fa-spin""&gt;&lt;/i&gt;
              &lt;/div&gt;
            );
          } else {
            return(
              &lt;div className=""data-loading""&gt;&lt;/div&gt;
            );
          }
        })()}
        &lt;/div&gt;
      )
  }
}
</code></pre>

<p>But when I scroll after the data gets repeated over 100 times, then I get errors.<a href=""https://i.stack.imgur.com/wG6Qp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wG6Qp.png"" alt=""error""></a>
In the ajax call, I am getting the error.
<a href=""https://i.stack.imgur.com/SuSDr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SuSDr.png"" alt=""error""></a></p>

<p>What am I doing wrong in here?</p>
","7816606","","7816606","","2017-07-19 17:08:30","2017-07-19 17:08:30","error in ajax(can't read property of undefined) while implementing react infinite scroll","<javascript><jquery><ajax><reactjs><reactive-programming>","0","6","","",""
"43356080","1","44390924","","2017-04-11 20:58:16","","0","729","<p>I am manually hooking a React component up to a Redux store. Yes, I realize Dan Abramov of Redux <a href=""https://stackoverflow.com/questions/32372646/#comments-32428568"">recommends against this</a>. I will be getting around to looking at react-redux eventually, but for now I want to understand what's going on.</p>

<pre><code>componentDidMount() {
    this.unsubscribe = store.subscribe(() =&gt; {
        const storeState = store.getState();
        this.setState({
            someData: storeState.someData
        });
    }.bind(this));
}
componentWillUnmount () {
    this.unsubscribe();
}
</code></pre>

<p>This is some code I have in a tab  page component. These tab pages get swapped in and out in a parent component as the user changes tabs to display different data. I have stepped through the debugger and confirmed that as a user changes tabs, the following occurs in order:</p>

<ol>
<li>The previous tab is unmounted (<code>componentWillUnmount</code> fires and <code>this.unsubscribe()</code> is called. <code>this</code> is the previous tab component, as expected)</li>
<li>The new tab is mounted. (<code>componentDidMount</code> fires and <code>this</code> is the new tab component, as expected)</li>
<li><code>setState</code> gets called in the subscribe callback with <code>this</code> being the PREVIOUS TAB, and react complains with an error:</li>
</ol>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Tab component.</p>
</blockquote>

<p>This seems strange to me. Shouldn't calling <code>unsubscribe</code> as I have prevent this callback from being called on the unmounted component? The <a href=""https://stackoverflow.com/questions/32372646"">post that I'm following along with</a> seems to suggest that doing what I've done should make this warning go away, and is simply questioning if this is a good idea. But in my case, it persists.</p>

<p>I don't think it matters, but I am using the ES6 ""class"" syntax whereas the original appears not to be.</p>
","1756625","","-1","","2017-05-23 11:54:06","2017-06-06 13:10:23","Redux unsubscribe within componentWillUnmount still calls subscribe callback","<reactjs><redux><react-redux>","1","0","1","",""
"47463163","1","","","2017-11-23 20:57:16","","0","75","<p><strong>EDIT: I found the answer myself - and it was stupid easy. I just had to call the player terminator function within componentWillUnmount. If anyone else is as clueless as me, there you go!</strong></p>

<p>I've by now searched the web quite thoroughly and while I found some cases which had similar elements, I'm not sure how I would go about solving this (I've tried).</p>

<pre><code>const NestedStackNav = StackNavigator({
    ExerciseList: {screen: ExerciseList},
    Exercise: {screen: ExerciseScreen},
    SoundScreen: {screen: SoundScreen}
});

const SimpleApp = TabNavigator({
    ExerciseTab: {screen: NestedStackNav},
    Settings: {screen: Settings},
}, {
    animationEnabled: true,
    tabBarOptions: {
        inactiveBackgroundColor: 'rgb(133,180,217)',
        inactiveTintColor: 'rgb(133,150,217)',
        style: {
            backgroundColor: 'rgb(133,212,217)',
            height: GLOBAL.SCREEN.WIDTH * 0.12,
        }
    },
});

export default class App extends Component {
    render() {
        return &lt;SimpleApp/&gt;;
    }
}

class SoundScreen extends Component {

/* Stops audio (this is in  */
    _stop() {
        this.player.stop(() =&gt; {
            this._updateState();
        });
    }
</code></pre>

<p>}</p>

<p>So I'm building a mobile app in React Native where I have a TabNavigator, within it nested a StackNavigator and the StackNavigator has 3 screens, the last of which is a player for audio. I used react-native-audio-toolkit for audio, and react-navigation for navigation.</p>

<p>The problem is, if I leave the sound playing when going back in the stack(navigator) a step, the sound won't stop. I'm a bit of a beginner with React Native as well, but I want to basically call a method of class SoundScreen I've implemented, which is the audio player view, to stop the audio when HeaderBackButton is pressed. I tried dumping the method call into the onPress attribute for HeaderBackButton but it didn't work. Surely there's an easier way?</p>

<p>I found the onNavigationStateChange-function of react-navigation but I don't know how to use it. <a href=""https://reactnavigation.org/docs/navigators#onNavigationStateChange-prevState-newState-action"" rel=""nofollow noreferrer"">https://reactnavigation.org/docs/navigators#onNavigationStateChange-prevState-newState-action</a></p>

<p>Thank you.</p>
","8765913","","8765913","","2017-11-25 19:59:33","2017-11-25 19:59:33","Close audioplayer (react-native-audio-toolkit) when going back with StackNavigator","<android><reactjs><audio><react-native><react-navigation>","0","0","","",""
"35167297","1","","","2016-02-03 02:08:42","","0","152","<p>I have a ""dumb"" component that displays the approx. distance between two locations.</p>

<pre><code>import React from ""react""

const cos = Math.cos
const p = Math.PI / 180
function getDistance(lat1, lon1, lat2, lon2) {
  var a = 0.5 - c((lat2 - lat1) * p)/2 +
          c(lat1 * p) * c(lat2 * p) *
          (1 - c((lon2 - lon1) * p))/2
  return 12742 * Math.asin(Math.sqrt(a)) // 2 * R; R = 6371 km
}

let Distance = ({from,to}) =&gt; {
    let distance = getDistance(
      from.latitude,
      from.longitude,
      to.latitude,
      to.longitude)
    if (distance &lt; 1.0) {
      distance = (distance * 100) + ""m""
    } else {
      distance = distance + ""km""
    }
    return &lt;span&gt;{distance}&lt;/span&gt;
  }
}
Distance.displayName = ""Distance""
</code></pre>

<p>I want to enhance this component by updating the component whenever the browsers geo-location changes. So I created another component</p>

<pre><code>class TrackingDistance extends React.Component {
  constructor(props) {
    super(props)
    this.updatePosition = this.updatePosition.bind(this)
    if (TrackingDistance.lastPosition) {
      this.updatePosition(TrackingDistance.lastPosition)
    } else {
      navigator.geolocation.getCurrentPosition(this.updatePosition)
    }
  }

  updatePosition(position) {
    this.setState({from: position.coords})
  }

  componentDidMount() {
    if (TrackingDistance.instances.length === 0) {
      TrackingDistance.watchId = navigator.geolocation.watchPosition(position =&gt; {
        TrackingDistance.instances.map(instance =&gt; instance.updatePosition(position))
      })
    }
    TrackingDistance.instances.push(this)
  }

  componentWillUnmount() {
    TrackingDistance.instances.remove(this)
    if (TrackingDistance.instances.length === 0) {
      navigator.geolocation.clearWatch(TrackingDistance.watchId)
    }
  }

  render() {
    return this.state.from ? &lt;Distance to={this.props.to} from={this.state.from}/&gt; : null
  }
}
TrackingDistance.instances = []
TrackingDistance.watchId = 0
TrackingDistance.lastPosition = null
</code></pre>

<p>My goal was to register the event listener for the geo-location updates only once in my app and not one listener for every component. I worry I create a circular reference when I save the component instances in a static array <code>TrackingDistance.instances</code>.</p>

<p>Also is it allowed to call the <code>setState</code> method of other components from outside the component itself (like I do in my location listener?)</p>

<p>Is there any other react pattern to solve such problem better? I can't use Mixins, cause I am using ES6 React component classes.</p>
","299209","","","","","2016-02-03 02:08:42","Location tracking react component - How to to handle listeners/updates","<design-patterns><reactjs><geolocation>","0","4","","",""
"43053561","1","43054846","","2017-03-27 18:09:57","","0","363","<p>I am trying to implement react-virtualized into my project. I have a side panel with a list of subdivisions. I would like to have an accordion-like functionality when the user selects an item. When the page first loads it looks like it is working correctly.</p>

<p><a href=""https://i.stack.imgur.com/8wTKk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8wTKk.png"" alt=""screenshot""></a></p>

<p>However when I start to scroll down the list looks like this</p>

<p><a href=""https://i.stack.imgur.com/AJ5m5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AJ5m5.png"" alt=""screenshot2""></a></p>

<p>and here is code</p>

<pre><code>const mapStateToProps = state =&gt; ({
  windowHeight: state.dimensions.windowHeight,
  sbds: new Immutable.List(state.sbds.data),
  sbd: state.sbd.data
})

@connect(mapStateToProps)
export default class SBD extends Component {
  static propTypes = {
    windowHeight: PropTypes.number,
    sbds: PropTypes.instanceOf(Immutable.List),
    sbd: PropTypes.object
  }

  constructor(props) {
    super(props)
    this.state = {
      listHeight: props.windowHeight - 250,
      listRowHeight: 60,
      overscanRowCount: 10,
      rowCount: props.sbds.size,
      scrollToIndex: undefined,
      collapse: true
    }
  }

  componentWillUnmount() {
  }

  shouldComponentUpdate(nextProps, nextState) {
    const {sbds} = this.props
    if (shallowCompare(this, nextProps, nextState))
      return true
    else return stringify(sbds) !== stringify(nextProps.sbds)
  }

  _handleSelectRow = selected =&gt; {
    sbdRequest(selected)
    const obj = {[selected.id]: true}
    this.setState(obj)
  }

  render() {
    const {
      listHeight,
      listRowHeight,
      overscanRowCount,
      rowCount,
      scrollToIndex
    } = this.state

    return (
      &lt;div&gt;
        &lt;SearchGroup /&gt;
        &lt;Card className='border-0 mt-10 mb-0'&gt;
          &lt;CardBlock className='p-0'&gt;
            &lt;AutoSizer disableHeight&gt;
              {({width}) =&gt; (
                &lt;List
                  ref='List'
                  className=''
                  height={listHeight}
                  overscanRowCount={overscanRowCount}
                  rowCount={rowCount}
                  rowHeight={listRowHeight}
                  rowRenderer={this._rowRenderer}
                  scrollToIndex={scrollToIndex}
                  width={width}
                /&gt;
              )}
            &lt;/AutoSizer&gt;
          &lt;/CardBlock&gt;
        &lt;/Card&gt;
      &lt;/div&gt;
    )
  }

  _getDatum = index =&gt; {
    const {sbds} = this.props
    return sbds.get(index % sbds.size)
  }

  _rowRenderer = ({index}) =&gt; {
    const {sbd} = this.props
    const datum = this._getDatum(index)
    return (
      &lt;span key={datum.id}&gt;
        &lt;Button
          type='button'
          color='link'
          block
          onClick={() =&gt; this._handleSelectRow(datum)}&gt;
          {datum.name}
        &lt;/Button&gt;
        &lt;Collapse isOpen={this.state[datum.id]}&gt;
          &lt;Card&gt;
            &lt;CardBlock&gt;
            FOO BAR
            &lt;/CardBlock&gt;
          &lt;/Card&gt;
        &lt;/Collapse&gt;
      &lt;/span&gt;
    )
  }
}
</code></pre>
","3919120","","","","","2017-03-27 19:27:05","How to use react-virtualized with dynamic list height","<reactjs><react-virtualized>","1","0","","",""
"34621442","1","","","2016-01-05 21:21:20","","4","7142","<p>I am trying to do a clock component, simply to give the date and time in local format in a webpage. I imported MomentJS using the command line npm i moment --save in my webpack environment. Next I wrote this in my Clock.jsx component (mostly based on the React example on the website).</p>

<pre><code>import React from 'react';
import Moment from 'moment';

export default class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      dateTimestamp : Date.now()
    };
  }
  tick = () =&gt; {
    this.setState({dateTimestamp: this.state.dateTimestamp + 1});
    console.log('tick');
  }
  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }
  componentWillUnmount() {
    clearInterval(this.interval);
  }
  render() {
    const date = this.state.dateTimestamp;
    return(
      &lt;div className=""clock""&gt; Heure locale : {date}&lt;/div&gt;
    );
}

}
</code></pre>

<p>Doing this the timestamp incremented correctly. However, when passing a new state element in the object, the first value (based on Date.now() ) is calculated in the constructor but for each tick, only the timestamp is incrementing the formatted date is stuck on its first value. Here is the code.</p>

<pre><code>import React from 'react';
import Moment from 'moment';

export default class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      dateTimestamp : Date.now(),
      dateFormatted : Moment(Date.now()).toString()
    };
  }
  tick = () =&gt; {
    this.setState({dateTimestamp: this.state.dateTimestamp + 1});
    console.log(this.state.dateTimestamp);
    this.setState({dateFormatted: Moment(this.state.dateTimestamp).toString()});
    console.log(this.state.dateFormatted);
  }
  ...
  render() {
    const date = this.state.dateFormatted;
    return(
      &lt;div className=""clock""&gt; Heure locale : {date}&lt;/div&gt;
    );
}

}
</code></pre>

<p>Does anyone could explain help me solving this issue but above all tell me what is going wrong with my piece of code?</p>

<p>Thanks </p>

<p>UPDATE: In the end my use of moment was not appropriate, even if I cannot figure out why it would not work this way. Find below my correct implementation to have the date and time refreshed every seconds.</p>

<pre><code>import React from 'react';
import Moment from 'moment';

export default class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      dateFormatted : Moment().locale('fr').format('dddd Do MMMM YYYY HH:mm:ss').toString()
    };
  }
  tick = () =&gt; {
    this.setState({
      dateFormatted : Moment().locale('fr').format('dddd Do MMMM YYYY HH:mm:ss').toString()
    });
  }
  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }
  componentWillUnmount() {
    clearInterval(this.interval);
  }
  render() {
    const date = this.state.dateFormatted;
    return(
      &lt;div className=""clock""&gt; Date (locale) : {date}&lt;/div&gt;
    );
  }
}
</code></pre>

<p>This also ""solves"" the anti pattern issue exposed below (different cross-dependant setState() call). I would need the timestamp for any other reason but I will find a workaround.</p>
","4175361","","4175361","","2016-01-10 12:58:27","2016-01-10 12:58:27","Where to apply my moment() function in a react component?","<javascript><reactjs><momentjs><react-jsx>","2","1","1","",""
"44252903","1","45088061","","2017-05-30 03:23:54","","-1","749","<p>I am currently attempting to implement the  <strong>react-native-sqlite-storage</strong> plugin for a react-native project, the original repo which this code is based up on is located at </p>

<p><a href=""https://github.com/andpor/react-native-sqlite-storage"" rel=""nofollow noreferrer"">https://github.com/andpor/react-native-sqlite-storage</a> [2]</p>

<p>I rewrote the example script located in the repository's <em>src</em> folder that utilizes the plugin via JS Promises. The class I re-created is almost completely working, and can be executed in the iOS simulator. However, I get an error when closing the database with the close() function - the error returned while debugging is </p>

<blockquote>
  <p>that.db.close() is not a function.</p>
</blockquote>

<p>The line causing the error is below (apparantly)</p>

<pre><code>that.db.close().then(onDbCloseSuccess).catch(onDbCloseError);
</code></pre>

<p>The complete code for the class is listed below. Any help in resolving this issue is much appreciated. (note, I kept the original author's reference to using 'that' as 'this' for now, with the intention to refactor 'that' back into 'this' later).</p>

<pre><code>'use strict';

import React, { Component } from 'react';
import {
    AppRegistry,
    StyleSheet,
    Text,
    View,
    ListView
} from 'react-native';


import SQLite from 'react-native-sqlite-storage';
SQLite.DEBUG(true);
SQLite.enablePromise(true);

export default class ExampleClass extends Component {

    database_name = ""Test.db"";
    database_version = ""1.0"";
    database_displayname = ""SQLite Test Database"";
    database_size = 200000;
    db: Promise;
    state = { progress:[] };

  constructor(){
    super();
  }

  getInitialState(){
    return {
        progress: [],
        dataSource: new ListView.DataSource({
            rowHasChanged: (row1, row2) =&gt; any = (row1, row2) =&gt; { return row1 !== row2 ; },
        })
    };
  }

  componentWillUnmount(){
        this.closeDatabase();
  }

  setAppState(msg: string){
      this.state.progress.push(msg);
      this.setState(this.state);
  }

  errorCB(err) {
    console.log(""(errorCB) ERROR: "", err);
    this.setAppState(""ERROR: "" + (err.message || err));
  }

  closeDatabase(){
        let that = this;
        if (that.db) {
            console.log(""CLOSING DATABASE"");
            that.setAppState(""CLOSING DATABASE"");

            const onDbCloseSuccess: (status: any) =&gt; void = (status: any) =&gt; {
                console.log(""DATABASE CLOSED"");
                that.setAppState(""DATABASE CLOSED"");
            };

            const onDbCloseError: (error: string) =&gt; void = (error: string) =&gt; {
                that.errorCB(error);
            };

            // error closing database? no close method()?
            that.db.close().then(onDbCloseSuccess).catch(onDbCloseError);

        } else {
            that.setAppState(""DATABASE WAS NOT OPENED"");
        }
  }

  deleteDatabase(){
    let that = this;

    that.setAppState(""DELETING DATABASE"");

    const onDeleteDBSuccess: () =&gt; void = () =&gt; {
        console.log(""DATABASE DELETED"");
        that.setAppState(""DATABASE DELETED"");
    };

    const onDeleteDBError: (error: string) =&gt; void = (error: string) =&gt; {
        console.log(""ERROR DELETING DATABASE"");
        that.errorCB(error);
    };

    SQLite.deleteDatabase(that.database_name).then(onDeleteDBSuccess).catch(onDeleteDBError);

  }

  queryEmployees(tx) {
        let that = this;
        console.log(""Executing employee query"");
        const q: string = `SELECT a.name, b.name as deptName FROM Employees a, Departments b WHERE a.department = b.department_id`;

        const executeSqlSuccess: Function = ([tx,results]) =&gt; {

            that.state.progress.push(""QUERY COMPLETED"");
            that.setState(that.state);

            const numRows: number = results.rows.length;
            for (let i = 0; i &lt; numRows; i++) {
                let row = results.rows.item(i);
                that.state.progress.push(`Empl Name: ${row.name}, Dept Name: ${row.deptName}`);
            }
            that.setState(that.state);
        };

        const executeSqlFailure: (error: string) =&gt; void = (error: string) =&gt; {
            console.log(error);
        };

        tx.executeSql(q).then(executeSqlSuccess).catch(executeSqlFailure);
    }

    populateDB(tx) {
      console.log(`populateDB`);

        let that = this;
        that.setAppState(""EXECUTING DROP STATEMENTS"");

        tx.executeSql('DROP TABLE IF EXISTS Employees;');
        tx.executeSql('DROP TABLE IF EXISTS Offices;');
        tx.executeSql('DROP TABLE IF EXISTS Departments;');

        that.setAppState(""EXECUTING CREATE STATEMENTS"");

        const onCreateTableError: (error: string) =&gt; void = (error) =&gt; {
            that.errorCB(error);
        };

        tx.executeSql('CREATE TABLE IF NOT EXISTS Version( '
            + 'version_id INTEGER PRIMARY KEY NOT NULL); ').catch(onCreateTableError);

        tx.executeSql('CREATE TABLE IF NOT EXISTS Departments( '
            + 'department_id INTEGER PRIMARY KEY NOT NULL, '
            + 'name VARCHAR(30) ); ').catch(onCreateTableError);

        tx.executeSql('CREATE TABLE IF NOT EXISTS Offices( '
            + 'office_id INTEGER PRIMARY KEY NOT NULL, '
            + 'name VARCHAR(20), '
            + 'longtitude FLOAT, '
            + 'latitude FLOAT ) ; ').catch(onCreateTableError);

        tx.executeSql('CREATE TABLE IF NOT EXISTS Employees( '
            + 'employee_id INTEGER PRIMARY KEY NOT NULL, '
            + 'name VARCHAR(55), '
            + 'office INTEGER, '
            + 'department INTEGER, '
            + 'FOREIGN KEY ( office ) REFERENCES Offices ( office_id ) '
            + 'FOREIGN KEY ( department ) REFERENCES Departments ( department_id ));').catch(onCreateTableError);

        that.setAppState(""EXECUTING INSERT STATEMENTS"");

        tx.executeSql('INSERT INTO Departments (name) VALUES (""Client Services"");');
        tx.executeSql('INSERT INTO Departments (name) VALUES (""Investor Services"");');
        tx.executeSql('INSERT INTO Departments (name) VALUES (""Shipping"");');
        tx.executeSql('INSERT INTO Departments (name) VALUES (""Direct Sales"");');

        tx.executeSql('INSERT INTO Offices (name, longtitude, latitude) VALUES (""Denver"", 59.8,  34.1);');
        tx.executeSql('INSERT INTO Offices (name, longtitude, latitude) VALUES (""Warsaw"", 15.7, 54.1);');
        tx.executeSql('INSERT INTO Offices (name, longtitude, latitude) VALUES (""Berlin"", 35.3, 12.1);');
        tx.executeSql('INSERT INTO Offices (name, longtitude, latitude) VALUES (""Paris"", 10.7, 14.1);');

        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Sylvester Stallone"", 2,  4);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Elvis Presley"", 2, 4);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Leslie Nelson"", 3,  4);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Fidel Castro"", 3, 3);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Bill Clinton"", 1, 3);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Margaret Thatcher"", 1, 3);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Donald Trump"", 1, 3);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Dr DRE"", 2, 2);');
        tx.executeSql('INSERT INTO Employees (name, office, department) VALUES (""Samantha Fox"", 2, 1);');

        console.log(""ALL CONFIG SQL DONE"");
    }

  populateDatabase(dbResult){
    let that = this;

    that.state.progress.push(""Database integrity check"");
    that.setState(that.state);

    const q: string = 'SELECT 1 FROM Version LIMIT 1';
    const executeSqlSuccess: () =&gt; void = () =&gt;{
        that.state.progress.push(""Database is ready ... executing query ..."");
        that.setState(that.state);

        const transactionSuccess: () =&gt; void = () =&gt; {
            that.state.progress.push(""Processing completed"");
            that.setState(that.state);
        };

        const transactionFailure: (error: string) =&gt; void = (error: string) =&gt; {
            console.log(`*** transactionFailure error. details ***`, error);
        };

        dbResult.transaction(that.queryEmployees.bind(that)).then(transactionSuccess).catch(transactionFailure);
    };

    const executeSqlFailure: (error: string) =&gt; void = (error: string) =&gt;{
        console.log(""Received error: "", error);
        that.state.progress.push(""DATABASE NOT READY ... POPULATING DATA"");
        that.setState(that.state);

        const onPopulateDBSuccess: () =&gt; void = () =&gt;{
            that.state.progress.push(""Database populated ... executing query ..."");
            that.setState(that.state);

            const onTransactionComplete = (result) =&gt; {
                console.log(""Transaction is now finished"");
                that.state.progress.push(""Processing completed"");
                that.setState(that.state);
                that.closeDatabase()
            };

            const onTransactionFailure: (error: string) =&gt; void = (error: string) =&gt; {
                console.log(`*** populateDatabase: transactionFailure error *** \n`,error);
            };


            dbResult.transaction(that.queryEmployees.bind(that)).then(onTransactionComplete).catch(onTransactionFailure);
        };

        const onPopulateDBFailure: Function = (error: string) =&gt; {
            console.log(error);
        };

        dbResult.transaction(that.populateDB.bind(that)).then(onPopulateDBSuccess).catch(onPopulateDBFailure);
    };

    dbResult.executeSql(q).then(executeSqlSuccess).catch(executeSqlFailure);
  }

  loadAndQueryDB(){
      const that = this;
      that.setAppState(""PLUGIN INTEGRITY CHECK"");

      const onOpenDBSuccess: (dbResult: any) =&gt; any = (dbResult: any) =&gt; {
          console.log('*** onOpenDBSuccess ***');
          console.log('DATABASE OPENED');
          that.state.progress.push('DATABASE OPENED');
          that.setState(that.state);
          console.log(dbResult);

          that.populateDatabase(dbResult);
      };

      const onOpenDBFailure: (error: string ) =&gt; void = (error: string) =&gt; {
          console.log('*** onOpenDBFailure ***');
          console.log(error);
      };

      const onEchoTestComplete: () =&gt; void = () =&gt; {
          console.log('*** onEchoTestComplete ***');
          that.state.progress.push(""Integrity check passed ..."");
          that.setState(that.state);

          that.state.progress.push(""Opening database ..."");
          that.setState(that.state);

          // create a database
          that.db = SQLite.openDatabase(this.database_name, this.database_version, this.database_displayname, this.database_size).then(onOpenDBSuccess).catch(onOpenDBFailure);
      };

      const onEchoTestFailure: () =&gt; void = () =&gt; {
          console.log('*** onEchoTestFailure ***');
          that.state.progress.push(""echoTest failed - plugin not functional"");
          that.setState(that.state);
      };

      SQLite.echoTest().then(onEchoTestComplete).catch(onEchoTestFailure);
  }

  runDemo(){
      this.state.progress = [""Starting SQLite Promise Demo""];
      this.setState(this.state);
      this.loadAndQueryDB();
  }

  render(){
      let ds = new ListView.DataSource({rowHasChanged: (row1, row2) =&gt; { return row1 !== row2;}});
      return (&lt;View style={styles.mainContainer}&gt;
        &lt;View style={styles.toolbar}&gt;
          &lt;Text style={styles.toolbarButton} onPress={this.runDemo.bind(this)}&gt;
            Run Demo
          &lt;/Text&gt;
          &lt;Text style={styles.toolbarButton} onPress={this.closeDatabase.bind(this)}&gt;
            Close DB
          &lt;/Text&gt;
          &lt;Text style={styles.toolbarButton} onPress={this.deleteDatabase.bind(this)}&gt;
            Delete DB
          &lt;/Text&gt;
        &lt;/View&gt;
        &lt;ListView
            enableEmptySections={true}
            dataSource={ds.cloneWithRows(this.state.progress)}
            renderRow={this.renderProgressEntry}
            style={listStyles.liContainer}/&gt;
      &lt;/View&gt;);
  }

  renderProgressEntry(entry){
    return (&lt;View style={listStyles.li}&gt;
        &lt;View&gt;
            &lt;Text style={listStyles.liText}&gt;{entry}&lt;/Text&gt;
        &lt;/View&gt;
    &lt;/View&gt;)
  }

}

const listStyles = StyleSheet.create({
    li: {
        borderBottomColor: '#c8c7cc',
        borderBottomWidth: 0.5,
        paddingTop: 15,
        paddingRight: 15,
        paddingBottom: 15,
    },
    liContainer: {
        backgroundColor: '#fff',
        flex: 1,
        paddingLeft: 15,
    },
    liIndent: {
        flex: 1,
    },
    liText: {
        color: '#333',
        fontSize: 17,
        fontWeight: '400',
        marginBottom: -3.5,
        marginTop: -3.5,
    },
});

const styles = StyleSheet.create({
    container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#F5FCFF',
    },
    welcome: {
        fontSize: 20,
        textAlign: 'center',
        margin: 10,
    },
    instructions: {
        textAlign: 'center',
        color: '#333333',
        marginBottom: 5,
    },
    toolbar: {
        backgroundColor: '#51c04d',
        paddingTop: 30,
        paddingBottom: 10,
        flexDirection: 'row'
    },
    toolbarButton: {
        color: 'blue',
        textAlign: 'center',
        flex: 1
    },
    mainContainer: {
        flex: 1
    }
});

AppRegistry.registerComponent('ExampleClass', () =&gt; ExampleClass);
</code></pre>

<p>Here is the detailed error message from the iOS simulator running the react-native app (I blanked out the project name):</p>

<p><a href=""https://i.stack.imgur.com/1RfSd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1RfSd.png"" alt=""enter image description here""></a></p>
","482254","","482254","","2017-05-31 14:21:45","2017-07-13 18:06:08","react-native-sqlite-storage close is not a function in iOS","<javascript><sqlite><react-native><ecmascript-6><react-native-ios>","1","0","","",""
"43726814","1","43766651","","2017-05-01 21:30:32","","3","262","<p>I'm getting a warning on the following line on my react component</p>

<pre><code>handleToggle: Function;
</code></pre>

<p>I'm using <a href=""https://github.com/yannickcr/eslint-plugin-react"" rel=""nofollow noreferrer"">eslint-plugin-react</a> and <a href=""https://flow.org/"" rel=""nofollow noreferrer"">Flow</a> and I'm getting a warning ""handleToggle should be placed after constructor"". This is related to rule react/sort-comp. I tried with the following on my .eslintrc.json</p>

<pre><code> ""react/sort-comp"": [1, {
  ""order"": [
    ""static-methods"",
    ""lifecycle"",
    ""everything-else"",
    ""render""
  ],
  ""groups"": {
    ""lifecycle"": [
      ""displayName"",
      ""propTypes"",
      ""contextTypes"",
      ""childContextTypes"",
      ""/^.*: Function$/"",
      ""mixins"",
      ""statics"",
      ""defaultProps"",
      ""state"",
      ""constructor"",
      ""getDefaultProps"",
      ""getInitialState"",
      ""getChildContext"",
      ""componentWillMount"",
      ""componentDidMount"",
      ""componentWillReceiveProps"",
      ""shouldComponentUpdate"",
      ""componentWillUpdate"",
      ""componentDidUpdate"",
      ""componentWillUnmount""
    ]
  }
}]
</code></pre>

<p>But I'm unable to fix the warning. I want the Function Types before constructor the same as the other Type Definition. How can I achieve this?</p>
","5623087","","4076315","","2017-05-03 02:09:47","2017-05-03 17:44:15","How to fix warning caused by Flow Function Types using eslint-plugin-react?","<reactjs><eslint><flowtype>","1","1","","",""
"44082014","1","44082330","","2017-05-20 04:46:38","","1","3715","<p>I've always used react-redux <code>connect</code> to configure props but I need to use a react <code>Component</code> to use lifecycle methods. I'm noticing that my props that I'm grabbing from the store seem to be static and they do not update as the store updates.</p>

<p>Code:</p>

<pre class=""lang-js prettyprint-override""><code>class AlertModal extends Component {

  title
  isOpen
  message

  componentDidMount() {
    const { store } = this.context
    const state = store.getState()
    console.log('state', state)
    console.log('store', store)
    this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate())
    this.title = state.get('alertModal').get('alertModalTitle')
    this.isOpen = state.get('alertModal').get('isAlertModalOpen')
    this.message = state.get('alertModal').get('alertModalMessage')
    this.forceUpdate()
  }

  componentWillUnmount() {
    this.unsubscribe()
  }

  updateAlertModalMessage(message) {
    this.context.store.dispatch(updateAlertModalMessage(message))
  }
  updateAlertModalTitle(title) {
    this.context.store.dispatch(updateAlertModalTitle(title))
  }

  updateAlertModalIsOpen(isOpen) {
    this.context.store.dispatch(updateAlertModalIsOpen(isOpen))
  }

  render() {

    console.log('AlertModal rendered')
    console.log('AlertModal open', this.isOpen) &lt;======= stays true when in store it is false

    return (
      &lt;View
</code></pre>

<p>How do I set up <code>title</code>, <code>isOpen</code>, and <code>message</code> so they reflect the store values at all times?</p>
","3935156","","2054072","","2017-05-20 16:12:47","2018-07-20 18:46:16","react props not updating with redux store","<reactjs><react-native><redux><react-redux>","3","3","","",""
"43687031","1","","","2017-04-28 18:48:44","","0","247","<p>i am building a react app for my client and i am having some compatibility issues with IE. My side bar works fine with chrome and all other browsers but with IE11, the scroll bar is interfering with the sidebar like this.
<a href=""https://i.stack.imgur.com/PRvMY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PRvMY.png"" alt=""Wrong sidebar""></a></p>

<p>in chrome, it works fine. it looks like this
<a href=""https://i.stack.imgur.com/Wpq3j.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Wpq3j.png"" alt=""working sidebar""></a></p>

<p>any idea what i can do to solve this problem?
I am new to front end development so i haven't tried anything yet.</p>

<p>i will include the code sidebar if that helps.. here it is</p>

<pre><code>    class SideCharmMenu extends React.Component {
    constructor(props) {
        super(props);
    }
    componentDidMount(){
        document.body.classList.toggle('has-charm', true);
    }
    componentWillUnmount(){
        document.body.classList.remove('has-charm');
    }

    render() {
        return (
            &lt;div className=""charm""&gt;
                &lt;button type=""button"" className=""toggle-charm"" onClick={this.props.onClick}&gt;
                    &lt;span className=""sr-only""&gt;Toggle Menu&lt;/span&gt;
                    &lt;span className=""glyphicon glyphicon-menu-hamburger""&gt;&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>css for the menu:</p>

<pre><code> body.has-charm {
  overflow-x: visible;
  padding-right:25px;
}
</code></pre>
","6276976","","6276976","","2017-04-28 18:56:42","2017-04-28 19:18:22","IE compatability issues in react app. scroll bar problems","<javascript><reactjs><browser><internet-explorer-11><polyfills>","1","0","","",""
"44349518","1","","","2017-06-03 23:44:49","","0","663","<p>I have a <code>&lt;MapView&gt;</code> and the region never updates when I scroll the map. The map is essentially stuck on one region. When I scroll it seems to pass the exact same region to <code>this.props.onRegionChange</code> which prevents the map from scrolling. How do I make it pass in a scrolled to region?</p>

<pre><code>&lt;MapView
          style={styles.map}
          region={this.props.region}
          onRegionChange={this.props.onRegionChange}
        &gt;
          {
            this.props.markers.map(marker =&gt; {
              return (
                &lt;MapView.Marker
                  coordinate={{ latitude: marker.latitude, longitude: marker.longitude }}
                  title={marker.name}
                /&gt;
              )
            })}
        &lt;/MapView&gt;
</code></pre>

<p>full code:</p>

<p><strong>Map.js</strong></p>

<pre><code>import { StyleSheet } from 'react-native'
import React, { Component } from 'react'
import MapView from 'react-native-maps'
import { connect } from 'react-redux'
import {
  Button,
  Container
} from 'native-base'

import selectMarkers from './markers.selector'

import { updateRegion } from './map.action'
import Icon from 'react-native-vector-icons/FontAwesome'
import { toggleMenu } from '../search-page/searchPage.action'
import mapStyle from './style'

const mapStateToProps = (state) =&gt; ({
  region: state.get('map').get('region'),
  markers: selectMarkers(state)
})

const mapDispatchToProps = (dispatch) =&gt; ({
  onRegionChange: (region) =&gt; {
    dispatch(updateRegion(region))
  },
  onToggleMenuClick: () =&gt; {
    dispatch(toggleMenu())
  }
})

class Map extends Component {

  componentDidMount() {
    const { store } = this.context
    this.unsubscribe = store.subscribe(() =&gt; { })
  }

  componentWillUnmount() {
    this.unsubscribe()
  }

  render() {
  console.log('map')
  console.log('markers', this.props.markers)
    return (
      &lt;Container&gt;
        &lt;MapView
          style={styles.map}
          region={this.props.region}
          onRegionChange={this.props.onRegionChange}
        &gt;
          {
            this.props.markers.map(marker =&gt; {
              return (
                &lt;MapView.Marker
                  coordinate={{ latitude: marker.latitude, longitude: marker.longitude }}
                  title={marker.name}
                /&gt;
              )
            })}
        &lt;/MapView&gt;
        &lt;Button
          small
          icon
          style={mapStyle.toggleMenuButton}
          onPress={() =&gt; this.props.onToggleMenuClick()}&gt;
          &lt;Icon name=""sliders"" size={20} color=""#FFFFFF"" /&gt;
        &lt;/Button&gt;
      &lt;/Container&gt;
    )
  }
}

Map.contextTypes = {
  store: React.PropTypes.object
}

Map.propTypes = {
  region: React.PropTypes.shape({
    latitude: React.PropTypes.number,
    longitude: React.PropTypes.number,
    latitudeDelta: React.PropTypes.number,
    longitudeDelta: React.PropTypes.number
  }).isRequired,
  onRegionChange: React.PropTypes.func.isRequired,
  onToggleMenuClick: React.PropTypes.func.isRequired,
  markers: React.PropTypes.array
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Map)

const styles = StyleSheet.create({
  map: {
    ...StyleSheet.absoluteFillObject,
    zIndex: -1
  }
})
</code></pre>

<p><strong>map.reducer</strong></p>

<pre><code>// @flow
import initialState from '../../config/config'
import { UPDATE_REGION } from './map.action'

const map = (
  initialMapState: [] = initialState.get('map'),
  action: Object): string =&gt; {
  switch (action.type) {
    case UPDATE_REGION: {
      if (action.payload) {
        return initialMapState.set('region', {
          latitudeDelta: 0.0922,
          longitudeDelta: 0.0421,
          latitude: action.payload.region.latitude,
          longitude: action.payload.region.longitude
        })
      } else {
        return initialMapState
      }
    }
    default:
      return initialMapState
  }
}

export default map
</code></pre>
","3935156","","","","","2017-06-04 00:03:35","react-native-maps region not updating - map stuck on one region","<javascript><reactjs><react-native><redux><react-native-maps>","1","0","","",""
"33808808","1","33808975","","2015-11-19 16:05:15","","2","231","<p>I’ve added a listener to the window to detect an <code>onClickOutside</code> type of scenario (specifically, to collapse a menu when clicking outside of the menu). This is the component with the code in question:</p>

<pre><code>import React, { Component, PropTypes } from 'react';
import ReactDOM from 'react-dom';
import LinkedStateMixin from 'react-addons-linked-state-mixin';
import styles from './DescriptiveSelect.css';
import classNames from 'classnames';
import _ from 'underscore';

export default class DescriptiveSelect extends Component {

    static propTypes = {
        attrForOptionLabel: PropTypes.string,
        attrForOptionValue: PropTypes.string,
        children: PropTypes.string,
        className: PropTypes.string,
        disabled: PropTypes.bool,
        nullLabel: PropTypes.string,
        onUpdate: PropTypes.func,
        options: PropTypes.array,
        selectedLabel: PropTypes.string,
        selectedOption: PropTypes.number,
        valueLink: PropTypes.object
    }

    mixins: [LinkedStateMixin]

    static defaultProps = {
        attrForOptionLabel: 'name',
        attrForOptionValue: 'id',
        disabled: false,
        selectedOption: 0,
        selectedLabel: 'Select one…'
    }

    state = {
        isOpen: false,
        options: []
    }

    componentDidMount() {
        this.buildOptions(this.props.options);
        window.addEventListener('click', this.onDocumentClick.bind(this));
    }

    componentWillUnmount() {
        window.removeEventListener('click', this.onDocumentClick);
    }

    onDocumentClick(event) {
        const theLabel = ReactDOM.findDOMNode(this);

        if (theLabel &amp;&amp; theLabel.contains(event.target)) {
            this.setState({isOpen: !this.state.isOpen});
        } else {
            this.setState({isOpen: false});
        }
        event.preventDefault();
    }

    handleSelection(option) {
        if (this.props.onUpdate) {
            this.props.onUpdate(option.id);
        }
        this.setState({'isOpen': false});
    }

    /**
     * Build out &lt;select&gt; menu options
     * Data must be formatted with the following attributes:
     *     const theData = [
     *         {
     *             id: 1,
     *             sequence: 0,
     *             short_name: 'App'
     *         }
     *     ];
     * @param  {array} data The data to convert, either from an endpoint
     *                      response or passed in via the `options` prop.
     */
    buildOptions(data) {
        const _this = this;
        const results = data;
        const resultLength = results.length;
        const {
            attrForOptionValue,
            attrForOptionLabel
        } = this.props;

        // Sort data by sequence attribute
        _.sortBy(results, 'sequence');

        // Cycle through JSON results and create &lt;option&gt; elements
        for (let i = 0; i &lt; resultLength; i++) {
            const option = results[i];
            _this.state.options.push(
                &lt;option key={option.id} value={option[attrForOptionValue]}&gt;{option[attrForOptionLabel]}&lt;/option&gt;
            );
            _this.forceUpdate();
        }
    }

    render() {
        const {
            className,
            nullLabel,
            options
        } = this.props;

        // Classes for select menu
        const selectClasses = classNames({
            [styles.LabelWrapper]: true,
            [className]: className
        });

        /**
         * Contents of the custom select.
         * Taken from the `options` prop that should be passed in.
         */
        const optionNodes = options.map((option) =&gt; {
            return (
                &lt;li className={styles.Option} key={option.id} onClick={this.handleSelection.bind(this, option)}&gt;
                    &lt;div className={styles.OptionLabel}&gt;a &lt;strong&gt;{option.name}&lt;/strong&gt;&lt;/div&gt;
                    &lt;div className={styles.OptionDetail}&gt;{option.description}&lt;/div&gt;
                &lt;/li&gt;
            );
        });

        return (
            &lt;label className={selectClasses} ref=""theLabel""&gt;
                &lt;select
                    className={styles.Select}
                    nullLabel={nullLabel}
                    options={options}
                    ref=""theSelect""
                    valueLink={this.props.valueLink}
                &gt;
                    { nullLabel ? &lt;option value=""""&gt;{nullLabel}&lt;/option&gt; : null }
                    { this.state.options }
                &lt;/select&gt;
                { this.state.isOpen ? &lt;div className={styles.Menu}&gt;
                    &lt;ul className={styles.OptionsWrapper}&gt;
                        {optionNodes}
                    &lt;/ul&gt;
                    &lt;footer className={styles.Footer}&gt;
                        &lt;p&gt;&lt;a href=""#""&gt;Learn more&lt;/a&gt; about App.typography titles.&lt;/p&gt;
                    &lt;/footer&gt;
                &lt;/div&gt; : null }
            &lt;/label&gt;
        );
    }
}
</code></pre>

<p>I'm not sure why, but it doesn't ever actually remove the listener, so I end up with several of these in the console:</p>

<blockquote>
  <p>Uncaught Error: Invariant Violation: findDOMNode was called on an
  unmounted component.</p>
</blockquote>

<p>Anything glaring in this code that might be causing the issue?</p>
","347884","","","","","2015-11-19 16:12:23","I can’t seem to reliably remove a listener using componentWillUnmount","<javascript><reactjs>","1","0","1","",""
"44372612","1","","","2017-06-05 15:43:54","","0","163","<p>When moving my app's navigation handling from react-native-router-flux to react-router-native, I seem to have uncovered an issue in how my app's native UI omponents are handled.</p>

<p>My app has several animated data plots that I've implemented in Java and imported into React Native as <a href=""https://facebook.github.io/react-native/docs/native-components-android.html"" rel=""nofollow noreferrer"">Native UI Components</a>. The visualizations are powered by some resource-hungry runnables on background threads that get started when the ui component is loaded. Previously, I stopped these threads by changing a prop of the native ui component (isVisible) to false.</p>

<p>However, when navigating away from a screen containing one of these native ui components with react-router-native (which unmounts components upon transition), even though componentWillUnmount is called in the react component, the native threads powering my plots keep running. </p>

<p>I tried to shut them down by changing the native ui component prop isVisible to false in componentWillUnmount, but even that doesn't fix the problem. Perhaps because there isn't another render of that component after componentWillUnmount?</p>

<p>Does anyone have any ideas on how to force a native UI component and all of its processes to shut down when it's parent is unmounted?</p>
","5507626","","","","","2017-07-31 16:16:37","Android UI Components still running when React component is unmounted with react-router-native","<react-native><react-router><react-native-android>","1","0","","",""
"43859785","1","","","2017-05-09 01:53:42","","1","3033","<p>I'm trying to display multiple markers using an npm package called react-google-maps and I'm having a difficult time. I'm following the demo here on how to display one map marker (<a href=""https://tomchentw.github.io/react-google-maps/events/simple-click-event"" rel=""nofollow noreferrer"">https://tomchentw.github.io/react-google-maps/events/simple-click-event</a>), however when I do the trivially understood thing of adding a second marker element to the the GoogleMap component I can't get that marker to display (I've also changed the coordinates). It's really bothering me and if anyone could point out what's going wrong I would really appreciate it.</p>

<p>Thanks.</p>

<p>Here is the code as I've fiddled with it.
The only thing I've changed is added the second marker, with a new coordinate.</p>

<pre><code>/* global google */
import {
  default as React,
  Component,
} from ""react"";


import withGoogleMap from './assets/withGoogleMap';
import GoogleMap from './assets/GoogleMap';
import Marker from './assets/Marker';

const SimpleClickEventExampleGoogleMap = withGoogleMap(props =&gt; (
  &lt;GoogleMap
    ref={props.onMapMounted}
    zoom={props.zoom}
    center={props.center}
    onCenterChanged={props.onCenterChanged}
  &gt;
    &lt;Marker
      defaultPosition={props.center}
      title=""Click to zoom""
      onClick={props.onMarkerClick}
    /&gt;

    &lt;Marker
      defaultPosition={props.marker2center}
      title=""Click to zoom""
      onClick={props.onMarkerClick}
    /&gt;



  &lt;/GoogleMap&gt;
));

const INITIAL_CENTER = { lat: -25.363882, lng: 131.044922 };
const MARKER1_CENTER = { lat: -25.363882, lng: 131.044922 };
const MARKER2_CENTER = { lat: -25.44, lng: 131.55 };

/*
 * https://developers.google.com/maps/documentation/javascript/examples/event-simple
 *
 * Add &lt;script src=""https://maps.googleapis.com/maps/api/js""&gt;&lt;/script&gt; to your HTML to provide google.maps reference
 */
export default class SimpleClickEventExample extends Component {



  state = {
    zoom: 4,
    center: INITIAL_CENTER,
    marker2center: MARKER2_CENTER
  };

  handleMapMounted = this.handleMapMounted.bind(this);
  handleCenterChanged = this.handleCenterChanged.bind(this);
  handleMarkerClick = this.handleMarkerClick.bind(this);

  handleMapMounted(map) {
    this._map = map;
  }

  handleMarkerClick() {
    this.setState({
      zoom: 8,
    });
  }

  handleCenterChanged() {
    const nextCenter = this._map.getCenter();
    if (nextCenter.equals(new google.maps.LatLng(INITIAL_CENTER))) {
      // Notice: Check nextCenter equality here,
      // or it will fire center_changed event infinitely
      return;
    }
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
    this._timeoutId = setTimeout(() =&gt; {
      this.setState({ center: INITIAL_CENTER });
      this._timeoutId = null;
    }, 3000);

    this.setState({
      // Because center now is a controlled variable, we need to set it to new
      // value when ""center_changed"". Or in the next render it will use out-dated
      // state.center and reset the center of the map to the old location.
      // We can never drag the map.
      center: nextCenter,
    });
  }

  componentWillUnmount() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }

  render() {
    return (
      &lt;div className='googleMap' style={{width: ""500px"", height: ""500px"", margin: ""0 auto""}}&gt;
        &lt;SimpleClickEventExampleGoogleMap
          containerElement={
            &lt;div style={{ height: `100%` }} /&gt;
          }
          mapElement={
            &lt;div style={{ height: `100%` }} /&gt;
          }
          zoom={this.state.zoom}
          center={this.state.center}
          onMapMounted={this.handleMapMounted}
          onCenterChanged={this.handleCenterChanged}
          onMarkerClick={this.handleMarkerClick}
        /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
","7268968","","","","","2018-07-09 16:03:28","How do I display multiple markers with react-google-maps","<javascript><google-maps><reactjs><google-maps-api-3><maps>","4","0","3","",""
"42848885","1","42850645","","2017-03-17 03:47:51","","1","1417","<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
var axios = require('axios');
class Application extends React.Component {        
  constructor() {
    super();
    this.handleClick = this.handleClick.bind(this);        
    this.state = {
      dropdownItems: []
    };
  }        
  deleteDd(index) {
    let dropdownItems =  this.state.dropdownItems.filter(item =&gt; item!==index);
    this.setState({dropdownItems: dropdownItems});
  }        
  handleClick() {
    let dropdownItems = [...this.state.dropdownItems];
    dropdownItems.push(dropdownItems.length);
    this.setState({dropdownItems: dropdownItems});
  }        
getInitialState() {
    return {
      company: []
    }
  }
//trying to get json data into dropdown by passing the json object into the url         
  componentDidMount(){var _this = this;
    this.serverRequest = axios

        .get(""myurl"")
        .then(function(result) {    
          _this.setState({
            company: result.data.company        
          });
          //console.log(jobs);
        })
  }        
  componentWillUnmount(){
    this.serverRequest.abort();
  }
  render() {
    let dropdowns = this.state.dropdownItems.map(item =&gt;
      (&lt;MyDropdown key = {item} num = {item} onDeleteMe ={this.deleteDd.bind(this, item)} /&gt;));        
    return (
    &lt;div&gt;
    &lt;h1 className=""text-left page-title""&gt;Higher&lt;/h1&gt;
    &lt;h2 className=""text-left""&gt;CTR&lt;/h2&gt;
    &lt;h3 className=""text-left""&gt;ABC&lt;/h3&gt;            
    &lt;div&gt;       
            &lt;form&gt;
    &lt;select className=""dropdown menu dropdown-style"" data-dropdown-menu&gt;
                        &lt;option defaultValue&gt;Choose one&lt;/option&gt;
                        &lt;option value=""test""&gt;test&lt;/option&gt;
                        &lt;option value=""test1""&gt;test1&lt;/option&gt;               
                    &lt;/select&gt;
      //here is where all my json data resides in company              
        &lt;h1&gt;Companies!&lt;/h1&gt;
        {this.state.company.map(function(company) {
          return (
            &lt;div key={company.id} className=""company""&gt;                      
                {company.Company}      
                                 &lt;/div&gt;);})}
            &lt;/form&gt;
</code></pre>

<p>I am getting this error ""Uncaught TypeError: Cannot read property 'map' of undefined"" I am trying to load json data into a dropdown please help. I have tried all the possible ways i can but still not able to figure what the problem is, any help is very much appreciated thanks.</p>
","7712988","","","","","2017-03-17 06:27:49","Uncaught TypeError: Cannot read property 'map' of undefined in reactjs","<reactjs>","1","2","","",""
"34113100","1","34168145","","2015-12-06 01:56:15","","6","4814","<p>I am using React's <code>TestUtil.renderIntoDocument</code> to test a React component class, <a href=""https://facebook.github.io/jest/docs/tutorial-react.html#content"" rel=""noreferrer"">like this</a> (only I am using TypeScript instead of Babel):</p>

<pre><code>describe(""MyComponent"", () =&gt; {
  it(""will test something after being mounted"", () =&gt; {
    var component = TestUtils.renderIntoDocument(&lt;MyComponent /&gt;);
    // some test...
  })
})
</code></pre>

<p>This works, but I want to write a test that verifies that <code>componentWillUnmount</code> behaves as expected. However, it seems that the test runner never unmounts the component, which is not surprising. So my question is: how do I unmount the component from within a test? The <code>TestUtil</code> doesn't have anything that looks like what I want, something along the lines of <code>removeFromDocument</code> I would imagine. </p>
","2225281","","","","","2018-04-09 11:51:04","Testing React componentWillUnmount using Jest","<reactjs><jestjs>","4","1","","",""
"51274389","1","","","2018-07-10 21:51:26","","0","9","<p>Similar to my prior question: <a href=""https://stackoverflow.com/questions/51047924/firefox-extension-onpopupclose-event/"">Firefox Extension - onPopupClose event?</a> I have a simple popup component that subscribes and unsubscribes to a timer. I'm using React and am unable to get <code>componentWillUnmount</code> to be called without explicitly calling it on a window <code>unload</code> event in conjunction with <code>ReactDOM.unmountComponentAtNode</code>.</p>

<ul>
<li>Is there a React method that can be used to handle web extension popup close events?</li>
<li>If not why is componentWillUnmount not called on popup close? The React documentation states:</li>
</ul>

<blockquote>
  <p>componentWillUnmount() is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount().</p>
</blockquote>

<p>thus I would assume the event should be called since the component would be destroyed on window unloading.</p>

<ul>
<li>Lastly is this the idiomatic way to handle such an event in React?</li>
</ul>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import ReactDOM from 'react-dom';

// Due to how web-extensions seperate different web-extension components
// (popups, content scripts, and background scripts) you must use methods
// like getBackgroundPage to share the namespace of variables in other
// contexts.
const BG = browser.extension.getBackgroundPage();

class DashBoard extends React.Component {
    constructor(props) {
        super(props);

        this.timer = BG.timer;
        this.Store = BG.Store;

        this.state = { secondsElapsed: 0 };

        this.setSecondsElapsed = this.setSecondsElapsed.bind(this);
    }

    setSecondsElapsed(seconds) {
        this.setState({ secondsElapsed: seconds });
    }

    componentDidMount() {
        console.log(""Component Mounting"");
        this.timer.subscribe(this.setSecondsElapsed);
    }

    componentWillUnmount() {
        console.log(""Unmounting"");
        this.timer.unsubscribe(this.setSecondsElapsed);
    }

    render() {
        return (
            &lt;React.Fragment&gt;
                &lt;p&gt;Current Session Time Spent: {this.state.secondsElapsed}&lt;/p&gt;
            &lt;/React.Fragment&gt;
        );
    }
}

ReactDOM.render(&lt;DashBoard/&gt;, document.getElementById(""content""));

window.addEventListener(""unload"", function () {
    ReactDOM.unmountComponentAtNode(document.getElementById(""content""));
});</code></pre>
</div>
</div>
</p>
","8665598","","","","","2018-07-10 21:51:26","Web Extension popup -- componentWillUnmount not called","<javascript><reactjs><events><dom><firefox-webextensions>","0","0","","",""
"35320536","1","35320820","","2016-02-10 16:23:58","","2","2196","<p>I'm creating a small application with react, redux and react-router.</p>

<p>I have a list of items wrapped in <code>&lt;Link /&gt;</code>, and when I click one of them, I want the item to be set as the <code>currentItem</code> in the state before triggering the link action. There's an action to do that - <code>selectItem(item)</code> - but I don't know how to trigger it.</p>

<p>Should I trigger it on <code>componentWillUnmount</code>? In that case - how do I figure out what item was clicked? Should I create an <code>&lt;Link onClick={}/&gt;</code> handler that dispatches the action?</p>

<p>The item page will then check whether or not the currentItem is set, and potentially fetch it from the back end if not.</p>
","1064572","","","","","2017-05-11 10:59:38","Triggering action on route change with react-router","<reactjs><react-router><redux>","2","0","1","",""
"43287443","1","","","2017-04-07 21:37:54","","0","37","<p>I have an app with Meteor React using TinyMce through react-tinymce (as per instructions at <a href=""https://www.tinymce.com/docs/integrations/react/"" rel=""nofollow noreferrer"">https://www.tinymce.com/docs/integrations/react/</a></p>

<p>I have a form component with TinyMCE which is called from an orderedlist to allow users to add comments. It works as expected except in the following situation:</p>

<ol>
<li>When using either an iPad or iPhone (works fine on desktops and Android mobile).</li>
<li>The first instance of the form works as expected, however with subsequent attempts to add comments the cursor does not show up in TinyMCE and the user cannot enter their comments.</li>
<li>Without an external keyboard, when the form is opened the keyboard pops up - I have found that by manually closing the keyboard, then tapping in the textarea again it works.</li>
<li>With an external keyboard (on iPad), clinking the link in the menubar (I am using the link plugin) and then closing it and tapping in the textarea again it works.</li>
</ol>

<p>I have attached code to show how TinyMCE is initiated (and removed), as well as how it is called in the form.</p>

<p>Any suggestions as to what I can try to get this to work properly on an iPad/iPhone would be greatly appreciated.</p>

<pre><code>componentDidMount() {
tinymce.remove();
tinymce.init({
selector: '.addComments,
    plugins: ""autoresize link paste"",
    paste_as_text: true,
    autoresize_bottom_margin: 10,
    relative_urls: false,
    link_title: false,
    default_link_target: ""_blank"",
    height: 200,
    autoresize_max_height: 200,
    toolbar: 'underline italic numlist link',
    menubar: '',
    skin: ""lightgray"",
    statusbar: false,
    content_css : '/css/content.css'
 });
}

componentWillUnmount() {
    tinymce.remove();
}
</code></pre>

<p>And it is rendered as follows:</p>

<pre><code>&lt;div className=""AddComments"" id={`background${this.props.meetingId}`} onChange={this.handleEditorChange}&gt;&lt;/div&gt;
</code></pre>
","1720150","","","","","2017-04-09 20:57:56","Meteor React using TinyMce with react-tinymce problems with iPad","<iphone><reactjs><ipad><meteor><tinymce-4>","1","0","","",""
"51300499","1","","","2018-07-12 08:14:41","","0","20","<p>In my react app I have a conditionally imported component like this:</p>

<pre><code>componentDidMount() {
    if (this.props.client === 'abcdf') {
        import('../clients/abcdf/abcdfMenu').then(comp =&gt; {
            this.setState({ sideMenu: comp.default });
        });
    }
}
</code></pre>

<p>Under some circumstances the parent component may be unmounted before the import completes which triggers the warning: <code>Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.</code></p>

<p>The only suggestions I have found are either don't use async in components or use a <code>isMounted</code> property in state (anti-pattern?) or cancel the promise with experimental code not suitable for production. </p>

<p>Do you have any suggestion specifically about dynamic imports? Any idea would be highly appreciated.</p>
","3549949","","","","","2018-07-12 08:14:41","Cancel component import in react componentWillUnmount","<reactjs>","0","2","","",""
"43508744","1","43508810","","2017-04-20 01:37:48","","0","1233","<p>Why do they use <code>componentWillUnmount</code> to <code>clearInterval</code> here ?</p>

<pre><code>componentWillUnmount() {
   clearInterval(this.timerID);
   console.log(""here"");  //nothing happens
}
</code></pre>

<p><a href=""https://facebook.github.io/react/docs/state-and-lifecycle.html"" rel=""nofollow noreferrer"">in this example at the official docs</a></p>

<p>Why do they use it since this method doesn't get called in this cycle and thus the clearInterval won't execute every second ? Isn't the idea behind this to clear the interval every second since every second there is a new interval happening ? or I am misunderstanding ?</p>
","7185785","","","","","2017-04-20 01:46:01","How do ""componentWillUnmount"" work with clearinterval?","<reactjs>","1","1","2","",""
"43796577","1","","","2017-05-05 04:33:29","","2","247","<p>its possible to open drawer layout with onPress in another scene?</p>

<p>this is my App.js, i will open my drawer from this screen</p>

<pre><code>/**
 * Sample React Native App
* https://github.com/facebook/react-native
* @flow
*/

import React, { Component } from 'react';
import {
AppRegistry, Button,
StyleSheet,
Text,
View
} from 'react-native';
import { Router, Scene, Actions } from 'react-native-router-flux';
import Home from './Scene/Home';
import Login from './Scene/Login';
import Register from './Scene/Register';
import DrawerLayout from './Component/DrawerLayout';
export default class Flux extends Component {
    constructor() {
    super();
    this.openDrawer = this.openDrawer.bind(this);
    }
    openDrawer(){
    this.drawer.openDrawer()
    }
//componentWillUnmount(){Actions.refresh({key: 'drawer', open: false })}
    render() {
    var createRightButton = function() {
        return (
            &lt;View&gt;
                &lt;Button style={{color: 'green'}} title={""Drawer""}    onPress={()=&gt;this.openDrawer()}&gt;
                    +
                &lt;/Button&gt;
            &lt;/View&gt;
        )};
    return (
        &lt;Router renderRightButton={createRightButton}&gt;
            &lt;Scene key=""root""&gt;
            &lt;Scene key=""drawer"" component={DrawerLayout}&gt;
                &lt;Scene key=""Main"" tabs={true}&gt;
                    &lt;Scene key=""home"" ref={(_drawer) =&gt; this.drawer = _drawer} component={Home} title=""Home"" initial={true}/&gt;
                    &lt;Scene key=""login"" component={Login} title=""Login"" /&gt;
                    &lt;Scene key=""register"" component={Register} title=""Register"" /&gt;
                &lt;/Scene&gt;
            &lt;/Scene&gt;
            &lt;/Scene&gt;
        &lt;/Router&gt;
        );
    }

}

const styles = StyleSheet.create({
    container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
    },
    welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
    },
    instructions: {
        textAlign: 'center',
        color: '#333333',
        marginBottom: 5,
    },
});

AppRegistry.registerComponent('Flux', () =&gt; Flux);
</code></pre>

<p>and this is my drawerlayout.js, and i will open this layout from other screen. its possible?</p>

<pre><code>import React, { Component } from 'react';
import Drawer from 'react-native-drawer';
import SideMenu from './SideMenu';
import {Actions, DefaultRenderer} from 'react-native-router-flux';
import {Button, DrawerLayoutAndroid, TouchableOpacity, View} from ""react- native"";

export default class NavigationDrawer extends Component {
   constructor() {
    super();
    this.openDrawer = this.openDrawer.bind(this);
    this.closeDrawer = this.closeDrawer.bind(this);
    }
   openDrawer(){
    this.refs['DRAWER'].openDrawer()
   }
   closeDrawer(){
    this.refs['DRAWER'].closeDrawer()
   }
    // state={
    //     drawerOpen: false,
    //     drawerDisabled: false,
    // };
    // closeDrawer = () =&gt; {
    //     this._drawer.close()
    // };
    // openDrawer = () =&gt; {
    //     this._drawer.open()
    // };

    render(){
    const state = this.props.navigationState;
    const children = state.children;
    var navigationView = (&lt;View&gt;
        &lt;Button onPress={()=&gt;{this.closeDrawer();Actions.home()}} title={""Home""}&gt;
            Home
        &lt;/Button&gt;
        &lt;Button onPress={()=&gt;{this.closeDrawer();Actions.login()}} title={""Login""}&gt;
            Login
        &lt;/Button&gt;
        &lt;Button onPress={()=&gt;{this.closeDrawer();Actions.register()}} title={""Register""}&gt;
            Register
        &lt;/Button&gt;
    &lt;/View&gt;);
    return (
        &lt;DrawerLayoutAndroid
            drawerWidth={300}
            ref={'DRAWER'}
            drawerPosition={DrawerLayoutAndroid.positions.Left}
            renderNavigationView={() =&gt; navigationView}&gt;
            &lt;DefaultRenderer navigationState={children[0]} onNavigate={this.props.onNavigate} /&gt;
        &lt;/DrawerLayoutAndroid&gt;



    );
    //Actions.refresh({key: 'drawer', open: value =&gt; !value });

  }

  }
</code></pre>

<p>can some one hepl me?</p>
","5426128","","","","","2017-05-05 04:33:29","its possible open drawer layoout in another screen react native?","<react-native>","0","0","","",""
"51368442","1","51368989","","2018-07-16 18:54:57","","1","37","<p>I have a very simple react component that needs to connect to an API and retrieve some JSON data, which will then be used for displaying some information.</p>

<p>In the following class/component, I have <code>mounted</code> and <code>state</code> as a property. I normally use a constructor to hold my states but in this case, if I move the state to a constructor, I cannot seem to access the data (<code>projectInfo</code>) inside the renderer. When inside the renderer (line containinig <code>{projectInfo.name}</code>), I get the error: <strong>TypeError: Cannot read property 'name' of null</strong></p>

<p>How can I use the constructor in this class to hold the state? Why does the following class work but not when I use a constructor? What is the convention for handling something like this?</p>

<pre><code>class MyReportSummary extends Component {
  mounted = true;
  state = {
    projectInfo: null,
    isLoading: true,
    error: null
  };

  componentDidMount() {
    fetch(`/api/projects/${this.props.projectId}`)
      .then(response =&gt; {
        if (response.ok) {
          return response.json();
        } else {
          throw new Error(""Encountered problem fetching project info"");
        }
      })
      .then(data =&gt; {
        if (this.mounted) {
          this.setState({
            projectInfo: data
          });
        }
      })
      .catch(fetchError =&gt; {
        if (this.mounted) {
          this.setState({
            isLoading: false,
            error: fetchError
          });
        }
      });
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  render() {
    const { isLoading, error, projectInfo } = this.state;

    if (error) {
      return &lt;p&gt;{error.message}&lt;/p&gt;;
    }

    if (isLoading) {
      return &lt;p&gt;Loading...&lt;/p&gt;;
    }

    return (
      &lt;div className=""myReportSummary""&gt;
        Summary of Project name: {projectInfo.name}
        Number of events: {this.props.data.length}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>UPDATE</strong>: Just for clarity, the above sample code works just fine. What I'm trying to understand is if my class look like this that has a constructor initializing state, then I get that <em>TypeError</em>.</p>

<pre><code>class MyReportSummary extends Component {
  mounted = true;

  constructor(props) {
    super(props);

    this.state = {
        projectInfo: null,
        isLoading: false,
        error: null
    };
  }

  componentDidMount() {
    // same as the previous sample code
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  render() {
    //same as the previous sample code
  }
}
</code></pre>

<p>What is the correct convention for states? Is <code>constructor</code> not the proper way of doing this?</p>
","6450957","","6450957","","2018-07-16 19:28:41","2018-07-16 19:36:13","reactjs storing state in constructor vs property","<javascript><reactjs>","1","8","","",""
"49899237","1","49899481","","2018-04-18 12:01:54","","3","132","<p>I am trying to capture all click events outside of my SearchBar component so that I can then tell the dropdown menu to close when one clicks out of it.  I looked up examples of how to do this online and I need to use the global variable 'document' in javascript.  However, it seems react native does not support this.  Does anyone know a work around to use the 'document' variable or a react native equivalent?</p>

<pre><code>class Products extends Component {

    constructor(props) {
        super(props);

        this.setWrapperRef = this.setWrapperRef.bind(this);
        this.handleClickOutside = this.handleClickOutside.bind(this);
    }

    setWrapperRef(node) {
        this.wrapperRef = node;
    }

    handleClickOutside(event) {
        if (this.wrapperRef &amp;&amp; !this.wrapperRef.contains(event.target)) {
          alert('You clicked outside of me!');
        }
    }

    componentWillMount() {
        this.props.dispatch(getProductList());
    }

    componentDidMount() {
        document.addEventListener('mousedown', this.handleClickOutside);
    }

    componentWillUnmount() {
        document.removeEventListener('mousedown', this.handleClickOutside);
    }

    render() {
        const {isLoading, products} = this.props.products;

        if (isLoading) {
            return &lt;Loader isVisible={true}/&gt;;
        }

        return (
            &lt;View ref={this.setWrapperRef} style={styles.wrapper}&gt;
                &lt;Header/&gt;
                &lt;View style={styles.bodyWrapper}&gt;
                    &lt;ScrollView style={styles.scrollView}&gt;
                        &lt;ProductsContainer data={{productsList: { results: products }}}/&gt;
                    &lt;/ScrollView&gt;
                    &lt;SearchBar style={styles.searchBar}/&gt;
                &lt;/View&gt;
                &lt;Footer/&gt;
            &lt;/View&gt;
        );
    }
}

function mapStateToProps(state) {
    const {products} = state;
    return {
        products
    };
}

export default connect(mapStateToProps)(Products);
</code></pre>

<p><a href=""https://i.stack.imgur.com/yMaLe.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yMaLe.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/RI9Sr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RI9Sr.png"" alt=""enter image description here""></a></p>
","1226380","","","","","2018-04-18 12:15:12","How to use the variable 'document' in react native?","<javascript><reactjs><react-native>","1","3","","",""
"42335186","1","","","2017-02-20 01:40:58","","0","355","<p>I've been getting started with react-redux and finding it a very interesting way to simplify the front end code for an application using many objects that it acquires from a back end service where the objects need to be updated on the front end in approximately real time.</p>

<p>Using a container class largely automates the watching (which updates the objects in the store when they change). Here's an example:</p>

<pre><code>const MethodListContainer = React.createClass({
  render(){
    return &lt;MethodList {...this.props} /&gt;},

  componentDidMount(){
    this.fetchAndWatch('/list/method')},
  componentWillUnmount(){
    if (isFunction(this._unwatch)) this._unwatch()},

  fetchAndWatch(oId){
    this.props.fetchObject(oId).then((obj) =&gt; {
      this._unwatch = this.props.watchObject(oId);
      return obj})}});
</code></pre>

<p>In trying to supply the rest of the application with as simple and clear separation as possible, I tried to supply an alternative 'connect' which would automatically supply an appropriate container thus:</p>

<pre><code>const connect = (mapStateToProps, watchObjectId) =&gt; (component) =&gt; {
  const ContainerComponent = React.createClass({
    render(){
      return &lt;component {...this.props} /&gt;
    },

    componentDidMount(){
      this.fetchAndWatch()},
    componentWillUnmount(){
      if (isFunction(this._unwatch)) this._unwatch()},

    fetchAndWatch(){
      this.props.fetchObject(watchObjectId).then((obj) =&gt; {
        this._unwatch = this.props.watchObject(watchObjectId);
        return obj})}
  });
  return reduxConnect(mapStateToProps, actions)(ContainerComponent)
};
</code></pre>

<p>This is then used thus:</p>

<p>module.exports = connect(mapStateToProps, '/list/method')(MethodList)</p>

<p>However, <code>component</code> does not get rendered. The container is rendered except that the <code>component</code> does not get instantiated or rendered. The <code>component</code> renders (and updates) as expected if I don't pass it as a parameter and reference it directly instead.</p>

<p>No errors or warnings are generated.</p>

<p>What am I doing wrong?</p>
","1035279","","","","","2017-02-21 00:30:21","Why can't I curry a react component?","<javascript><react-redux>","2","0","","",""
"40143144","1","","","2016-10-19 23:31:00","","0","1331","<p>I'm having an issue when I use a navigate away from this component in react I get this error: warning.js:36 Warning: setState(...): ""Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the ProjectsHeader component.""</p>

<p>Now I've looked over the docs for componentWillUnmount which states ""Invoked immediately before a component is unmounted from the DOM.</p>

<p>Perform any necessary cleanup in this method, such as invalidating timers or cleaning up any DOM elements that were created in componentDidMount.""</p>

<p>The problem is that I don't know how to do that. I've looked at the other Stack overflow examples and I don't understand them and can't figure it out. There doesn't seem to be a good enough example for me to understand how to do it. I understand the lifecycle I just don't know how to execute it. </p>

<p>Here is my code: </p>

<pre><code>import React from 'react';
import jQuery from 'jquery';
import $ from 'jquery';

import ProjectsHeaderLinks from ""./ProjectsHeaderLinks.jsx"";

export default class ProjectsHeader extends React.Component {

    constructor() {
        super()
        this.state = {
            class: ""not-sticky-div"",
            class2: ""hidden-span"",
            class3: ""false""
        }
    }



    componentDidMount() {
        this.scrollTop();

    }

    componentWillUnmount(){
        this.scrollTop = null;
        console.log(""unmounted"");
    }


    scrollTop(){
        var that = this;
        let head = $("".header"");
        let stick = ""sticky"";
        let projHead = document.getElementById(""projHead"");
    $(window).scroll(function() {
        $(window).scrollTop() &gt; 400
            ? head.addClass(stick)
            : head.removeClass(stick);
        let newValue = projHead.classList.value.split(' ', 2);
        for (var i = 0; i &lt; newValue.length; i++) {
            newValue[i] === ""sticky""
                ? that.setState({class: ""sticky-div"", class2: ""visible-span"", class3: ""true""})
                : that.setState({class: ""not-sticky-div"", class2: ""hidden-span"", class3: ""true""});
            }
        })
    }



    render() {
        return (
            &lt;div id=""projHead"" className=""header""&gt;
                &lt;div className={this.state.class}&gt;
                {this.state.class === ""not-sticky-div""
                 ? &lt;div&gt;""This is My Projects Page"" --Lonnie McGill&lt;/div&gt;
                 : &lt;div&gt; &lt;ProjectsHeaderLinks/&gt; &lt;/div&gt;
            }
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>
","6951505","","","","","2016-10-19 23:52:21","componentWillUnmount & Warning: setState(...): error","<reactjs>","1","4","1","",""
"34677234","1","","","2016-01-08 12:32:04","","4","3103","<p>i am making VideoPlayer react component with jwpalyer and i am using webpack es6 for loading module
webpack support npm module loading &amp; there is no npm for jwplayer</p>

<p>so am trying to include jwplayer.js using es6 import but it giving me error 
ReferenceError: window is not defined</p>

<p>so any one can help me to properly setup jwplayer with webpack</p>

<pre><code>  import React, { PropTypes, Component } from 'react';
  import $ from 'jquery';
  import Player from ""./lib/jwplayer/jwplayer.js"";
  import styles from './VideoPayer.css';
  import withStyles from '../../decorators/withStyles';
  import Link from '../Link';

  @withStyles(styles)
  class VideoPlayer extends Component {

    static propTypes = {
      className: PropTypes.string,
    };

    static defaultProps = {
      file: '',
      image: ''
    };

    constructor(props) {
      super(props);
      this.playerElement = document.getElementById('my-player');
    }


    componentDidMount() {
      if(this.props.file) {
        this.setupPlayer();
      }
    }

    componentDidUpdate() {
      if(this.props.file) {
        this.setupPlayer();
      }
    }

    componentWillUnmount() {
       Player().remove(this.playerElement);
    }

    setupPlayer() {
      if(Player(this.playerElement)) {
        Player(this.playerElement).remove();
      }

      Player(this.playerElement).setup({
        flashplayer: require('./lib/player/jwplayer.flash.swf'),
        file: this.props.file,
        image: this.props.image,
        width: '100%',
        height: '100%',
      });
    }

    render() {
      return (
        &lt;div&gt;
          &lt;div id=""my-player"" className=""video-player""&gt;&lt;/div&gt;
        &lt;/div&gt;
      )
    }
  }

export default VideoPlayer;
</code></pre>
","1353052","","","","","2018-06-16 06:50:41","Proper way to implement jwplayer in react component using webpack (react-starter-kit)","<reactjs><jwplayer><webpack><jwplayer6><es6-module-loader>","2","0","1","",""
"43888397","1","","","2017-05-10 09:22:49","","0","808","<p>I am using reactjs and react GA for google analytic integration i have the following error in the console:</p>

<pre><code>Uncaught (in promise) Error: _registerComponent(...): Target container is not a DOM element.
at invariant (bundle.js:2844)
at Object._renderNewRootComponent (bundle.js:41047)
at Object._renderSubtreeIntoContainer (bundle.js:41137)
at Object.renderSubtreeIntoContainer [as unstable_renderSubtreeIntoContainer] (bundle.js:41079)
at OverlayTrigger.renderOverlay (bundle.js:85430)
at OverlayTrigger.componentDidUpdate (bundle.js:85319)
at measureLifeCyclePerf (bundle.js:90119)
at bundle.js:90773
at CallbackQueue.notifyAll (bundle.js:39950)
at ReactReconcileTransaction.close (bundle.js:95219)
</code></pre>

<p>I am trying to resolve the issue using several resources.But i couldn't find a solution.</p>

<p><strong>Code:</strong>
Videoplayer.jsx</p>

<pre><code>    import React, {Component} from 'react';
import {Link} from 'react-router';
import videojs from 'video.js';
import {Image, Modal} from 'react-bootstrap/lib';
import 'videojs-contrib-hls';
import GA from '../GA.jsx';

const liveVideoUrl = 'http://vid-129002.hls.chinanetcenter.broadcastapp.agoraio.cn/live/';
class VideoPlayer extends Component {
    constructor(props) {
        super(props);

        this.hideModal = this.hideModal.bind(this);
        this.state = {showPopup: false};        
        this.broadcastData = this.props.broadcastData;
        this.videoUrl = this.broadcastData.recordedUrl;
        this.videoType = 'video/mp4';
        let videoStreamName = this.broadcastData.streamId;
        this.live = null;

        if (this.broadcastData.status !== 'RECORDED') {
            this.videoUrl = liveVideoUrl + videoStreamName + '/playlist.m3u8';
            this.live = (&lt;Image className=""live-logo"" src=""/images/svg/live.svg""/&gt;);
            this.videoType = 'application/x-mpegURL';
        }
    }
    componentDidMount () {
        const
            self = this,
            options = {
                autoplay: true,
                controls: true,
                preload: ""auto"",
                hls: {
                    withCredentials: true
                }
            };

        const playerTarget = 'play_video';
        this.player = videojs(this.videoNode, options);
        this.player.src({
          src: this.videoUrl,
          type: this.videoType,
        });
        this.player.on('ended', () =&gt; {
            self.setState({showPopup: true});
        });



        if (this.player.play()) {
            GA.ManualGA(playerTarget);
        }

    }

    componentWillUnmount() {
        this.player &amp;&amp; this.player.dispose();
        this.player = null;
    }

    hideModal() {
        this.setState({showPopup: false});
    }

    render() {
        let screenShotUrl = this.broadcastData.screenShotUrl;
        let downloadLinkNode = [];

        if (screenShotUrl == null) {
            screenShotUrl = '/images/default-screenshot.png'
        }

        const style = {
            ""backgroundImage"": ""url("" + screenShotUrl + "")""
        };

        if (this.showBanner) {
            if (this.isIphone) {
                downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click"" /&gt;&lt;/Link&gt;);
            } else {
                downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;&lt;/Link&gt;);
            }
        } else {
            downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click""/&gt;
                &lt;/Link&gt;
            );
            downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;
                &lt;/Link&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;div className=""blur-bg"" style={style}/&gt;
                &lt;video className=""video-js vjs-sublime-skin vjs-big-play-centered"" data-setup='{ ""inactivityTimeout"": 0 }' ref={ r =&gt; { this.videoNode = r; } }/&gt;
                {this.live}
                &lt;Modal show={this.state.showPopup} dialogClassName=""app-download-play-end"" onHide={this.hideModal}&gt;
                    &lt;Modal.Header closeButton /&gt;
                    &lt;Modal.Body&gt;
                        &lt;Image src=""/images/swoo-logo-popup.svg"" className=""logo""/&gt;&lt;br/&gt;
                        &lt;Image src=""/images/svg/logo_black.svg""/&gt;
                        &lt;div className=""title""&gt;To view more broadcasts, install SWOO app&lt;/div&gt;
                        &lt;h5&gt;Get the App&lt;/h5&gt;
                        {downloadLinkNode}
                    &lt;/Modal.Body&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}

export default VideoPlayer
</code></pre>

<p><strong>GA.JSX</strong></p>

<pre><code>    function GA(ReactGA) {
    const objects = ['channel_click', 'channel_home_click', 'share_btn_click', 'share_btn_click', 'terms_cond_click', 'privacy_policy_click', 'discover_btn_click', 'profile_btn_click', 'app_dld_close_btn_click', 'top_broadcaster_click', 'app_dld_andoid_btn_click', 'broadcast_live_click', 'broadcast_recorded_click',
     'app_dld_ios_btn_click', 'app_dld_ios_homebtn_click', 'app_dld_andoid_homebtn_click', 'app_dld_aftervideo_android_click', 'app_dld_aftervideo_ios_click', 'play_video', 'pause_video'];

        ReactGA.initialize('UA-96792697-3');''
        document.addEventListener('click',(e) =&gt; {
            let target = e.target.getAttribute('data-ga');
            let additional_value = e.target.getAttribute('data-value');

            if (objects.indexOf(target) &gt;= 0) {
                ReactGA.event({category:'swoo', action: target});
            }

        });

         function ManualGA(target) {
                    ReactGA.event({category:'swoo', action: target});
        }
 }

export default GA;
</code></pre>

<p><strong>Index.jsx:</strong></p>

<pre><code>import React from 'react';
import {render} from 'react-dom';
import {Router, Route, IndexRoute, browserHistory, Redirect} from 'react-router';
import {Provider} from 'react-redux';
import Layout from './components/layout/layout.jsx';
import HomePageContainer from './containers/homePageContainer.jsx';
import SearchPageContainer from './containers/searchPageContainer.jsx';
import configureStore from './store/configureStore.jsx';
import BroadcastDetailContainer from './containers/broadcastDetailContainer.jsx';
import GA from './components/GA.jsx';
//import ManualGA from './components/GA.jsx';
import ReactGA from 'react-ga';
/////////-- Static Pages --///////////
import PrivacyPolicyContainer from './containers/privacyPolicyContainer.jsx';
import PrivacyPolicyforwebContainer from './containers/privacyPolicyforwebContainer.jsx';
import TermsofServiceContainer from './containers/termsOfService.jsx';
import TermsofServiceforwebContainer from './containers/termsofServiceforwebContainer.jsx';
import NotFoundPage from './containers/notFoundPage.jsx';

require(""./stylesheets/customResponsive.css"");
require(""./stylesheets/customStyle.css"");
require(""./stylesheets/videojs.css"");

ReactGA.initialize('UA-96791297-3');
GA(ReactGA);
//ManualGA(ReactGA);


/////////-- End Static Pages --///////////

const store = configureStore();

function fireTracking() {
    ReactGA.pageview(window.location.pathname);
}

render
(
    &lt;Provider store={store}&gt;
        &lt;Router onUpdate={fireTracking} history={browserHistory}&gt;
            &lt;Route component={Layout}&gt;
                &lt;Redirect from='/' to='/home'/&gt;
                &lt;Route path=""/home"" component={HomePageContainer}/&gt;
                &lt;Route path=""/search"" component={SearchPageContainer}/&gt;
                &lt;Route path=""/broadcast/:broadcastId"" component={BroadcastDetailContainer}/&gt;
                &lt;Route path={""/privacy-policy""} component={PrivacyPolicyContainer}/&gt;
                &lt;Route path={""/privacy""} component={PrivacyPolicyforwebContainer}/&gt;
                &lt;Route path={""/terms-of-service""} component={TermsofServiceContainer}/&gt;
                &lt;Route path={""/tos""} component={TermsofServiceforwebContainer}/&gt;
                &lt;Route path=""*"" component={NotFoundPage} /&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;,
    document.getElementById('container')
);
</code></pre>

<p>In <code>videoPlayer.jsx</code> I am getting the abbove error at</p>

<pre><code>if (this.player.play()) {
  GA.ManualGA(playerTarget);
}
</code></pre>
","7184879","","5025116","","2017-07-10 01:24:04","2017-07-10 01:24:04","reactjs Target container is not a DOM element error","<reactjs>","0","3","","",""
"45578194","1","45578394","","2017-08-08 21:19:24","","1","600","<p>I have read the other questions related to this and tried implementing what the answers were on there. </p>

<p>They recommended adding <code>/*global google */</code> - did not work </p>

<p>Next was to add <code>const google = window.google;</code> - did not work</p>

<p>I will post the code below and the error.</p>

<p>The error is happening where <code>new google.maps</code> is being called</p>

<p>Map.js: </p>

<pre><code>/* global google */
import { default as React, Component } from 'react';
import raf from 'raf';
import canUseDOM from 'can-use-dom';

const google = window.google;

import { withGoogleMap, GoogleMap, Circle, InfoWindow, Marker } from 'react-google-maps';
import withScriptjs from 'react-google-maps/lib/async/withScriptjs';

const googleMapURL =
  'https://maps.googleapis.com/maps/api/js?v=3.27&amp;libraries=places,geometry&amp;key=AIzaSyA7XEFRxE4Lm28tAh44M_568fCLOP_On3k';
const geolocation =
  canUseDOM &amp;&amp; navigator.geolocation
    ? navigator.geolocation
    : {
      getCurrentPosition(success, failure) {
        failure(""Your browser doesn't support geolocation."");
      },
    };
const GeolocationExampleGoogleMap = withScriptjs(
  withGoogleMap(props =&gt;
    &lt;GoogleMap defaultZoom={8} center={props.center}&gt;
      {props.center &amp;&amp;
        &lt;InfoWindow position={props.center}&gt;
          &lt;div&gt;User's Location&lt;/div&gt;
        &lt;/InfoWindow&gt;}
      {props.center &amp;&amp;
        &lt;Circle
          center={props.center}
          radius={props.radius}
          options={{
            fillColor: 'red',
            fillOpacity: 0.2,
            strokeColor: 'red',
            strokeOpacity: 1,
            strokeWeight: 1,
          }}
        /&gt;}
      &gt;
      {props.markers.map((marker, index) =&gt; {
        const onClick = () =&gt; props.onMarkerClick(marker);
        const onCloseClick = () =&gt; props.onCloseClick(marker);

        return (
          &lt;Marker
            key={index}
            position={marker.position}
            title={(index + 1).toString()}
            onClick={onClick}
          &gt;
            {marker.showInfo &amp;&amp;
              &lt;InfoWindow onCloseClick={onCloseClick}&gt;
                &lt;div&gt;
                  &lt;strong&gt;
                    {marker.content}
                  &lt;/strong&gt;
                  &lt;br /&gt;
                  &lt;em&gt;The contents of this InfoWindow are actually ReactElements.&lt;/em&gt;
                &lt;/div&gt;
              &lt;/InfoWindow&gt;}
          &lt;/Marker&gt;
        );
      })}
    &lt;/GoogleMap&gt;,
  ),
);

function generateInitialMarkers() {
  const southWest = new google.maps.LatLng(-31.203405, 125.244141);
  const northEast = new google.maps.LatLng(-25.363882, 131.044922);

  const lngSpan = northEast.lng() - southWest.lng();
  const latSpan = northEast.lat() - southWest.lat();

  const markers = [];
  for (let i = 0; i &lt; 5; i++) {
    const position = new google.maps.LatLng(
      southWest.lat() + latSpan * Math.random(),
      southWest.lng() + lngSpan * Math.random(),
    );
    markers.push({
      position,
      content: 'This is the secret message'.split(' ')[i],
      showInfo: false,
    });
  }
  return markers;
}

export default class GeolocationExample extends Component {
  constructor(props) {
    super(props);
    super(props);
    this.state = {
      center: null,
      content: null,
      radius: 6000,
      markers: generateInitialMarkers(),
    };

    const isUnmounted = false;
    handleMarkerClick = this.handleMarkerClick.bind(this);
    handleCloseClick = this.handleCloseClick.bind(this);
  }

  handleMarkerClick(targetMarker) {
    this.setState({
      markers: this.state.markers.map((marker) =&gt; {
        if (marker === targetMarker) {
          return {
            ...marker,
            showInfo: true,
          };
        }
        return marker;
      }),
    });
  }

  handleCloseClick(targetMarker) {
    this.setState({
      markers: this.state.markers.map((marker) =&gt; {
        if (marker === targetMarker) {
          return {
            ...marker,
            showInfo: false,
          };
        }
        return marker;
      }),
    });
  }

  componentDidMount() {
    const tick = () =&gt; {
      if (this.isUnmounted) {
        return;
      }
      this.setState({ radius: Math.max(this.state.radius - 20, 0) });

      if (this.state.radius &gt; 200) {
        raf(tick);
      }
    };

    geolocation.getCurrentPosition(
      (position) =&gt; {
        if (this.isUnmounted) {
          return;
        }
        this.setState({
          center: {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          },
          content: 'Location found using HTML5.',
        });

        raf(tick);
      },
      (reason) =&gt; {
        if (this.isUnmounted) {
          return;
        }

        this.setState({
          center: {
            lat: 60,
            lng: 105,
          },
          content: `Error: The Geolocation service failed (${reason}).`,
        });
      },
    );
  }

  componentWillUnmount() {
    this.isUnmounted = true;
  }

  render() {
    return (
      &lt;GeolocationExampleGoogleMap
        googleMapURL={googleMapURL}
        loadingElement={&lt;div style={{ height: '100%' }}&gt;loading...&lt;/div&gt;}
        containerElement={&lt;div style={{ height: '100%' }} /&gt;}
        mapElement={&lt;div style={{ height: '100%' }} /&gt;}
        center={this.state.center}
        content={this.state.content}
        radius={this.state.radius}
        onMarkerClick={this.handleMarkerClick}
        onCloseClick={this.handleCloseClick}
        markers={this.state.markers}
      /&gt;
    );
  }
}
</code></pre>
","","user7366497","","","","2017-08-08 21:35:38","Google is not defined using react google maps?","<javascript><google-maps><reactjs>","1","3","","",""
"40147503","1","","","2016-10-20 06:58:58","","1","1169","<p>I am using the excellent create-react-app tool to build an app. My problem is as trivial as the title suggests but I cannot fix it. I have published a bare-bones app on github to illustrate:</p>

<p><a href=""https://github.com/diarmuidoconnor/reactdemo"" rel=""nofollow"">https://github.com/diarmuidoconnor/reactdemo</a></p>

<p>The relevant excerpts from it are as follows.</p>

<p>The routing config is:</p>

<pre><code>     &lt;Router history={browserHistory} &gt;
        &lt;Route path=""/"" component={App}&gt;
           &lt;IndexRoute component={Foo}/&gt;
           &lt;Route path=""bar"" component={Bar} /&gt;
        &lt;/Route&gt;
      &lt;/Router&gt;
</code></pre>

<p>The Bar component code is:</p>

<pre><code> var Bar = React.createClass({
      componentWillUnmount: function() {
         localStorage.setItem('view', 2) ;
      },
      componentWillMount: function() {
           console.log('mounting') ;
          localStorage.setItem('view', 1) ;

       },

    render: function(){
         return (  
          &lt;div&gt;
            &lt;h1&gt;Bar &lt;/h1&gt;
          &lt;/div&gt;
        );
    }
  });
</code></pre>

<p>As you can see, it has componentWillMount and componentWillUnmount lifecycle methods. The former is called when I navigate to /bar (localStorage has the correct value, 1, for view key) but the latter is not when I move to a different URL (/) - localStorage value for the view key has not changed to 2, as I expected. It is still at 1.</p>

<p>My Environment</p>

<ul>
<li>OSX 10.9</li>
<li>node v4.2.2</li>
<li>npm 2.14.7</li>
<li>Chrome Version 53.0.2785.143</li>
</ul>
","7046170","","4723795","","2016-10-21 07:57:40","2016-10-21 07:57:40","ReactJS componentWillUnmount not called on route change","<reactjs>","2","3","1","",""
"33649322","1","33690586","","2015-11-11 11:10:50","","1","3495","<p>I can't solve this problem, I can't render the HTML of my <code>component</code> that i call from a <code>nested path</code> like <code>/page/detail</code></p>

<p><strong>My route tree</strong></p>

<pre><code>render(
    (&lt;Router history={history}&gt;
        &lt;Route path=""/"" component={App}&gt;
            &lt;IndexRoute component={Index}/&gt;
            &lt;Route path=""page"" component={Page}&gt;
                &lt;Route path=""/page/detail"" component={Detail} /&gt;
            &lt;/Route&gt;
        &lt;/Route&gt;
    &lt;/Router&gt;),
    document.getElementById('main')
)
</code></pre>

<p><strong>My {App} component renders this:</strong></p>

<pre><code>render() {
    return (
        &lt;div&gt;
            &lt;nav className=""navbar""&gt;
                &lt;ul className=""nav navbar-nav navbar-right""&gt;
                    &lt;li&gt;&lt;Link className=""menu-link"" ref=""menu"" to=""/page""&gt;Page Test&lt;/Link&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;
            &lt;div id=""content-wrapper""&gt;{this.props.children}&lt;/div&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>My route <code>/page/detail</code> is called from a <code>Link</code> inside the component <code>{Page}</code> but if i access to this link i see only what {Page} component renders. I've searched for some solution about nested routes with react-routers but i didn't find an answer.</p>

<p><strong>UPDATE:</strong></p>

<p>By this solution i've rendered my {Detail} component's html:
I've inserted this within {Page} component</p>

<pre><code>{this.props.children || &lt;div&gt;My Detail page&lt;/div&gt; }
</code></pre>

<p><strong>UPDATE 2</strong></p>

<p>In my {Page} component I've inserted a jQuery <a href=""https://mixitup.kunkalabs.com/"" rel=""nofollow"">plugin</a>.</p>

<pre><code>mix() {
    $(""#filter-gallery"").mixItUp();
}

destroy() {
    $('#filter-gallery').mixItUp('destroy');
}

componentDidMount() {
    this.mix();
}

componentWillUnmount() {
    this.destroy();
}
</code></pre>

<p>This plugin works only at {Page} refresh page, if i navigate to /page/detail and then come back to /page the plugin doesn't work.</p>
","4473972","","4473972","","2015-11-11 12:13:43","2015-11-13 10:26:52","ReactJS - react-router nested path not rendered","<javascript><reactjs><single-page-application><react-router><react-router-component>","1","9","0","",""
"48373776","1","","","2018-01-22 02:00:59","","0","44","<p>I am trying to use the following timepicker component in a parent, but it is being provided in a format that I am unfamiliar with:</p>

<pre><code>""use strict"";

(function (global, factory) {
if (typeof exports === ""object"" &amp;&amp; typeof module !== ""undefined"") module.exports = factory();
if (typeof define === ""function"" &amp;&amp; define.amd) define(factory);
(global || window).AReactTimepicker = factory();
})(this, function () {
var React = typeof require === ""function"" ? require(""react"") : window.React;

var CLOCK_SIZE = 222;

var TimePicker = React.createClass({
    getInitialState: function getInitialState() {
        return {
            visible: false,
            hour: 12,
            minute: 0,
            am: true,
            position: {
                top: 0,
                left: 0
            }
        };
    },

    componentWillMount: function componentWillMount() {
        document.addEventListener(""click"", this.hideOnDocumentClick);
    },

    componentWillUnmount: function componentWillUnmount() {
        document.removeEventListener(""click"", this.hideOnDocumentClick);
    },

    show: function show() {
        var trigger = this.refs.trigger.getDOMNode(),
            rect = trigger.getBoundingClientRect(),
            isTopHalf = rect.top &gt; window.innerHeight / 2;

        this.setState({
            visible: true,
            position: {
                top: isTopHalf ? rect.top + window.scrollY - CLOCK_SIZE - 3 : rect.top + trigger.clientHeight + window.scrollY + 3,
                left: rect.left
            }
        });
    },

    hide: function hide() {
        this.setState({
            visible: false
        });
    },

    hideOnDocumentClick: function hideOnDocumentClick(e) {
        if (!this.parentsHaveClassName(e.target, ""time-picker"")) this.hide();
    },

    parentsHaveClassName: function parentsHaveClassName(element, className) {
        var parent = element;
        while (parent) {
            if (parent.className &amp;&amp; parent.className.indexOf(className) &gt; -1) return true;

            parent = parent.parentNode;
        }

        return false;
    },

    onTimeChanged: function onTimeChanged(hour, minute, am) {
        this.setState({
            hour: hour,
            minute: minute,
            am: am
        });
    },

    onDone: function onDone() {
        this.hide();
    },

    render: function render() {
        return &lt;div className=""time-picker""&gt;
            &lt;input ref=""trigger"" type=""text"" readOnly=""true"" value={_getTimeString(this.state.hour, this.state.minute, this.state.am)} onClick={this.show} /&gt;
            &lt;Clock visible={this.state.visible} position={this.state.position} onTimeChanged={this.onTimeChanged} onDone={this.onDone} hour={this.state.hour} minute={this.state.minute} am={this.state.am} /&gt;
        &lt;/div&gt;;
    }
});

var Clock = React.createClass({
    getInitialState: function getInitialState() {
        return {
            hoursVisible: true,
            minutesVisible: false,
            position: ""below""
        };
    },

    componentWillReceiveProps: function componentWillReceiveProps(props) {
        if (this.props.visible &amp;&amp; !props.visible) this.setState({
            hoursVisible: true,
            minutesVisible: false,
            amPmVisible: false
        });
    },

    getTime: function getTime() {
        return {
            hour: this.props.hour,
            minute: this.props.minute,
            am: this.props.am
        };
    },

    onHourChanged: function onHourChanged(hour) {
        this._hour = hour;
        this.setState({
            hoursVisible: false,
            minutesVisible: true
        });
    },

    onHoursHidden: function onHoursHidden() {
        this.props.onTimeChanged(this._hour, this.props.minute, this.props.am);
    },

    onMinuteChanged: function onMinuteChanged(minute) {
        this.props.onDone();
        this._minute = minute;

        this.setState({
            minutesVisible: false,
            amPmVisible: true
        });
    },

    onMinutesHidden: function onMinutesHidden() {
        this.props.onTimeChanged(this.props.hour, this._minute, this.props.am);
    },

    onAmPmChanged: function onAmPmChanged(am) {
        this.props.onTimeChanged(this.props.hour, this.props.minute, am);
    },

    style: function style() {
        return {
            top: this.props.position.top,
            left: this.props.position.left
        };
    },

    render: function render() {
        return &lt;div className={""clock "" + (this.props.visible ? ""clock-show"" : ""clock-hide"")} style={this.style()}&gt;
            &lt;div className=""clock-face-wrapper""&gt;
                &lt;Hours visible={this.state.hoursVisible} time={this.getTime()} onClick={this.onHourChanged} onHidden={this.onHoursHidden} /&gt;
                &lt;Minutes visible={this.state.minutesVisible} time={this.getTime()} onClick={this.onMinuteChanged} onHidden={this.onMinutesHidden} /&gt;
            &lt;/div&gt;
            &lt;AmPmInfo time={this.getTime()} onChange={this.onAmPmChanged} /&gt;
        &lt;/div&gt;;
    }
});

var AmPmInfo = React.createClass({
    render: function render() {
        var time = this.props.time;
        return &lt;div className=""am-pm-info""&gt;
            &lt;div className={""am"" + (time.am ? "" selected"" : """")} onClick={this.props.onChange.bind(null, true)}&gt;AM&lt;/div&gt;
            &lt;div className=""time""&gt;{_getTimeString(time.hour, time.minute, time.am)}&lt;/div&gt;
            &lt;div className={""pm"" + (!time.am ? "" selected"" : """")} onClick={this.props.onChange.bind(null, false)}&gt;PM&lt;/div&gt;
        &lt;/div&gt;;
    }
});

var Hours = React.createClass({
    buildHours: function buildHours() {
        var hours = [];
        for (var i = 1; i &lt;= 12; i++) hours.push(i);
        return hours;
    },

    render: function() {
        var { time, ...props } = this.props;
        return &lt;Face {...props} type=""hours"" values={this.buildHours()} selected={this.props.time.hour} /&gt;;
    }
});

var Minutes = React.createClass({
    buildMinutes: function buildMinutes() {
        var minutes = [];
        for (var i = 1; i &lt;= 12; i++) minutes.push(_pad((i === 12 ? 0 : i) * 5));
        return minutes;
    },

    render: function() {
        var { time, ...props } = this.props;
        return &lt;Face {...props} type=""minutes"" values={this.buildMinutes()} selected={this.props.time.minute} /&gt;;
    }
});

var Face = React.createClass({
    componentDidMount: function componentDidMount() {
        this.refs.face.getDOMNode().addEventListener(""transitionend"", this.onTransitionEnd);
    },

    componentWillUnmount: function componentWillUnmount() {
        this.refs.face.getDOMNode().removeEventListener(""transitionend"", this.onTransitionEnd);
    },

    onTransitionEnd: function onTransitionEnd(e) {
        if (e.propertyName === ""opacity"" &amp;&amp; e.target.className.indexOf(""face-hide"") &gt; -1) this.props.onHidden();
    },

    render: function render() {
        return &lt;div ref=""face"" className={""face "" + this.props.type + (this.props.visible ? "" face-show"" : "" face-hide"")}&gt;
            {this.props.values.map(function(value, i) {
                return &lt;div key={i} className={""position position-"" + (i + 1) + (parseInt(this.props.selected) === parseInt(value) ? "" selected"" : """")} onClick={this.props.onClick.bind(null, value)}&gt;
                    {_pad(value)}
                &lt;/div&gt;
            }.bind(this))}
            &lt;LongHand type={this.props.type} selected={this.props.selected} /&gt;
            &lt;div className=""inner-face""&gt;&lt;/div&gt;
            &lt;Ticks /&gt;
        &lt;/div&gt;;
    }
});

var LongHand = React.createClass({
    render: function render() {
        var deg = (this.props.selected / (this.props.type === ""hours"" ? 12 : 60) * 360);
        return &lt;div&gt;
            &lt;div className=""long-hand"" style={{ transform: ""rotate("" + deg + ""deg) scale(1, 0.8)"", WebkitTransform: ""rotate("" + deg + ""deg) scale(1, 0.8)"" }}&gt;&lt;/div&gt;
            &lt;div className=""long-hand-attachment""&gt;&lt;/div&gt;
        &lt;/div&gt;;
    }
});

var Ticks = React.createClass({
    buildTick: function buildTick(index) {
        return React.createElement(
            ""div"",
            { key: index, className: ""tick "" + (index % 5 === 0 ? ""big "" : """"), style: { transform: ""rotate("" + index * 6 + ""deg)"", WebkitTransform: ""rotate("" + index * 6 + ""deg)"" } },
            React.createElement(""div"", null)
        );
    },

    render: function render() {
        var ticks = [];
        for (var i = 0; i &lt; 60; i++)
            ticks.push(this.buildTick(i));

        return &lt;div className=""ticks""&gt;
            {ticks}
        &lt;/div&gt;;
    }
});

function _pad(value) {
    value = value.toString();
    return value.length === 1 ? ""0"" + value : value;
}

function _getTimeString(hour, minute, am) {
    return hour + "":"" + _pad(minute) + "" "" + (am ? ""AM"" : ""PM"");
}

return TimePicker;
});
</code></pre>

<p>It seems to return a class, but I am unsure of how to incorporate it into the parent. I'm used to the typical method like so:</p>

<pre><code>import {Child} from 'childlocation';

export class Parent extends React.Component&lt;any, any&gt;{

render: function render() {
    return &lt;div&gt;
         &lt;Child /&gt;
    &lt;/div&gt;;
}
};
</code></pre>

<p>But I am not able to get the above code to properly execute in the parent. I have attempted to declare a variable that is equal to the function, but the component is blank when the code is executed. I also tried various combinations of export default and simply exporting the function as a variable and it doesn't seem to work either. Any ideas?</p>
","7974831","","","","","2018-01-22 02:00:59","Using react component when returned in a function","<javascript><reactjs>","0","2","","",""
"49553418","1","49557119","","2018-03-29 10:12:04","","0","176","<p>I’m Implementing deep link in react native app to click on View in app A to open app B. Before calling URL directly from another app I wanted to test it if it is working or not,</p>

<p>So for android it worked. I just set the launch option to URL and it showed the value of URL in console.</p>

<p>But in iPhone if I write the URL(<strong><em>testlink://</em></strong>) in safari browser it shows “safari cannot open the page because address is invalid”. </p>

<p>Steps I followed to setup deeplinking:</p>

<ol>
<li>Added following code in AppDelgate.m</li>
</ol>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    #import &lt;React/RCTLinkingManager.h&gt;
    
    - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
      sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
    {
      return [RCTLinkingManager application:application openURL:url
                          sourceApplication:sourceApplication annotation:annotation];
    }
    
    - (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity
     restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler
    {
     return [RCTLinkingManager application:application
                      continueUserActivity:userActivity
                        restorationHandler:restorationHandler];
    }</code></pre>
</div>
</div>
</p>

<ol start=""2"">
<li><p>Added a key in info.plist in XCode.</p>

<blockquote>
  <p>URLTypes -> Item 0 -> URL identifier(VALUE: testlink)</p>
</blockquote></li>
<li><p>Adding the following code in Home page of the App.</p></li>
</ol>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>   

 componentDidMount() {
      Linking.addEventListener('url', this._handleOpenURL);
    },
    componentWillUnmount() {
      Linking.removeEventListener('url', this._handleOpenURL);
    },
    _handleOpenURL(event) {
      console.log(event.url);
    }</code></pre>
</div>
</div>
</p>
","9107796","","9107796","","2018-03-29 10:28:35","2018-03-29 13:17:56","Implementing deep link in react native","<ios><react-native>","1","0","","",""
"48953369","1","48953954","","2018-02-23 17:35:59","","0","242","<p>In my React app that uses React-Router, I have a Home component like this:</p>

<pre><code>import React, { Component } from 'react';
import { Link } from 'react-router-dom';


class Home extends Component {

 componentDidMount() {
  window.addEventListener(""scroll"", this.handleScroll, true);
}

componentWillUnmount() {
 window.removeEventListener(""scroll"", this.handleScroll);
}

handleScroll(e) {
 e.preventDefault();
 // scroll event handling
}

render () {
 return (&lt;div&gt;
            // markup
            &lt;Link to=""/secondPage""&gt;&lt;/Link&gt;
        &lt;/div&gt;);
 }
}

export default Home;
</code></pre>

<p>However, when I click on the Link, navigating from ""/"" to ""/secondPage"", it routes to the new page but hasn't removed the event listener from the Home component. </p>

<p>According to the <a href=""https://github.com/ReactTraining/react-router/blob/800991cd2044293718fccd3763b9d91c2f811296/docs/guides/ComponentLifecycle.md"" rel=""nofollow noreferrer"">React-Router docs</a>, it seems that componentWillUnmount should be called.</p>

<p>Why is componentWillUnmount not called? </p>
","6245572","","6245572","","2018-02-23 18:16:29","2018-02-23 18:35:48","React/React-Router: componentWillUnmount not called when routing to new page","<reactjs><react-router>","2","2","","",""
"41215571","1","","","2016-12-19 03:59:10","","0","455","<p>I'm having the 100's of record in data object. I have an option to delete items one by one. If i remove one item and tab to next screen and come back previous screen the data is not getting updated. That item still there which i removed previously. I have an endpoint to remove items from data table. My question is after removing item from list, how to update the store?</p>

<p><strong>App.js</strong></p>

<pre><code>import React from 'react';
import { render } from 'react-dom';
import { Link } from 'react-router';

var MasterAPI = require('./Components/Flux/utils/MasterAPI');
var MasterStore = require('./Components/Flux/stores/MasterStore');

// Method to retrieve state from Stores
function getMasterState() {
  return {
    data: MasterStore.getMasterRefData()
  };
}

class App extends React.Component {
    constructor() {
        super();
        this.state = {
            data:[]
        };
    }
    componentDidMount() {
        MasterStore.addChangeListener(this._onChange.bind(this));
    }
    componentWillUnmount() {
        MasterStore.removeChangeListener(this._onChange.bind(this));
    }
    render() {
        return &lt;div&gt;
          {this.state.map(function(el, i){
                return &lt;div key={i}&gt;
                    &lt;div&gt;{el.name}&lt;/div&gt;
                    &lt;button&gt;Delete&lt;/button&gt;
                &lt;/div&gt;
            }
        &lt;/div&gt;;
    }
    _onChange() {
        this.setState(getMasterState());
    }
};

export default App; 
</code></pre>
","3913821","","","","","2016-12-19 07:07:30","How to update the flux store in react js after remove items?","<javascript><jquery><reactjs><reactjs-flux>","1","1","","",""
"49654451","1","","","2018-04-04 15:05:36","","0","104","<p>i have async component where everything works fine,but when i try to pass parameter in <code>path</code> like /home/:id?,then it fail to load and giving error 
<strong>Loading chunk failed.</strong></p>

<p>please help me how to pass parameter correctly using ""react-router"": ""^4.2.0""</p>

<pre><code>&lt;Switch&gt;
 &lt;Route path={`${match.url}home/:id?`} component={asyncComponent(() =&gt; 
     import('../containers/home'))}/&gt;
 &lt;Route path={`${match.url}dash`} exact component={asyncComponent(() =&gt; 
     import('../containers/dash'))}/&gt;
&lt;/Switch&gt;
</code></pre>

<blockquote>
  <p>async.js</p>
</blockquote>

<pre><code> export default function asyncComponent(importComponent) {
class AsyncFunc extends Component {
    constructor(props) {
        super(props);
        this.state = {
            component: null
        };
    }

    componentWillMount() {
        Nprogress.start();
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    async componentDidMount() {
        this.mounted = true;
        const {default: Component} = await importComponent();
        Nprogress.done();
        if (this.mounted) {
            this.setState({
                component: &lt;Component {...this.props} /&gt;
            });
        }
    }

    render() {
        const Component = this.state.component || &lt;div/&gt;;
        return (
            &lt;ReactPlaceholder type=""text"" rows={7} ready={Component !== 
    null}&gt;
                {Component}
            &lt;/ReactPlaceholder&gt;
        );
    }
}

 return AsyncFunc;
}
</code></pre>
","8759508","","","","","2018-04-04 15:05:36","loading async component with parameter in react router","<reactjs><react-router><react-redux><router><react-router-v4>","0","2","","",""
"51417291","1","51419595","","2018-07-19 07:56:54","","2","37","<p>In my component I use this.props.history.push(pathname:.. search:..) to rerender the component and fetch new data form a third party service. When I first call the page it renders. But when I call history push inside the component the URL updates correctly BUT the component doesn't rerender. I read a lot but couldn't get it working. Any ideas?</p>

<p>I'm using react router v4</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//index.js

  &lt;Provider store={store}&gt;
    &lt;BrowserRouter&gt;
      &lt;Switch&gt;
        &lt;Route path=""/login"" component={Login}/&gt;
        &lt;Route path=""/"" component={Main}/&gt;
      &lt;/Switch&gt;
    &lt;/BrowserRouter&gt;
  &lt;/Provider&gt;


//Main.js
//PropsRoute is used to push props to logs component so I can use them when fetching new data
const PropsRoute = ({ component: Component, ...rest }) =&gt; {
  return (
    &lt;Route {...rest} render={props =&gt; &lt;Component {...props} /&gt;}/&gt;
  );
};

class Main extends Component {
  render() {
    return (
        &lt;div className=""app""&gt;
          &lt;NavigationBar/&gt;
          &lt;div className=""app-body""&gt;
            &lt;SideBar/&gt;
            &lt;Switch&gt;
              &lt;PropsRoute path=""/logs"" component={Log}/&gt; //this component is not rerendering
              &lt;Route path=""/reports"" component={Reports}/&gt;
              &lt;Route path=""/gen"" component={Dashboard}/&gt;
              &lt;Redirect from=""/"" to=""/gen""/&gt;
            &lt;/Switch&gt;
          &lt;/div&gt;
        &lt;/div&gt;
    )
  }
}

export default Main;


//inside 'Log' component I call
import React, {Component} from 'react';
import {getSystemLogs} from ""../api"";
import {Link} from 'react-router-dom';
import _ from ""lodash"";
import queryString from 'query-string';

let _isMounted;

class Log extends Component {

  constructor(props) {
    super(props);

    //check if query params are defined. If not re render component with query params
    let queryParams = queryString.parse(props.location.search);
    if (!(queryParams.page &amp;&amp; queryParams.type &amp;&amp; queryParams.pageSize &amp;&amp; queryParams.application)) {
      this.props.history.push({
        pathname: '/logs',
        search: `?page=1&amp;pageSize=25&amp;type=3&amp;application=fdce4427fc9b49e0bbde1f9dc090cfb9`
      });
    }

    this.state = {
      logs: {},
      pageCount: 0,
      application: [
        {
          name: 'internal',
          id: '...'
        }
      ],
      types: [
        {
          name: 'Info',
          id: 3
        }
      ],
      paginationPage: queryParams.page - 1,
      request: {
        page: queryParams.page === undefined ? 1 : queryParams.page,
        type: queryParams.type === undefined ? 3 : queryParams.type,
        pageSize: queryParams.pageSize === undefined ? 25 : queryParams.pageSize,
        application: queryParams.application === undefined ? 'fdce4427fc9b49e0bbde1f9dc090cfb9' : queryParams.application      
      }
    };

    this.onInputChange = this.onInputChange.bind(this);
  }

  componentDidMount() {
    _isMounted = true;
    this.getLogs(this.state.request);
  }

  componentWillUnmount() {
    _isMounted = false;
  }

  getLogs(request) {
    getSystemLogs(request)
      .then((response) =&gt; {
        if (_isMounted) {
          this.setState({
            logs: response.data.Data,
            pageCount: (response.data.TotalCount / this.state.request.pageSize)
          });
        }
      });
  }

  applyFilter = () =&gt; {
    //reset page to 1 when filter changes
    console.log('apply filter');
    this.setState({
      request: {
        ...this.state.request,
        page: 1
      }
    }, () =&gt; {
      this.props.history.push({
      pathname: '/logs',
        search: `?page=${this.state.request.page}&amp;pageSize=${this.state.request.pageSize}&amp;type=${this.state.request.type}&amp;application=${this.state.request.application}`
      });
    });
  };

  onInputChange = () =&gt; (event) =&gt; {
    const {request} = this.state; //create copy of current object
    request[event.target.name] = event.target.value; //update object
    this.setState({request}); //set object to new object
  };

  render() {
    let logs = _.map(this.state.logs, log =&gt; {
      return (
          &lt;div className=""bg-white rounded shadow mb-2"" key={log.id}&gt;
           ...
          &lt;/div&gt;
      );
    });

    return (
      &lt;main className=""main""&gt;
        ...
      &lt;/main&gt;
    );
  }
}

export default Log;</code></pre>
</div>
</div>
</p>
","7031586","","7031586","","2018-07-19 08:27:41","2018-07-19 10:22:15","this.props.history.push not re-rendering react component","<reactjs><react-router><react-router-v4>","2","3","1","",""
"51446742","1","","","2018-07-20 16:21:47","","0","19","<p>Please Help,
I have a small demo that i created.
the code works great in the browser but fails in tests.</p>

<p>here is what the code does:</p>

<ul>
<li>render two links: ""HOME"" and ""MODELER"" as part of a <code>Navigation</code> component.</li>
<li>use <code>react-router</code> to implement the required routes: <code>/</code> to render <code>HomePage</code>
and <code>/modeler</code> to render <code>ModelerPage</code></li>
<li>The <code>HomePage</code> component should simply render <code>&lt;h1&gt;Home&lt;/h1&gt;</code>
<strong>- The <code>ModelerPage</code> component should render <code>&lt;h1&gt;Modeler&lt;/h1&gt;</code> as well as an initialized modeler
instance which is rendered into a container after the <code>&lt;h1&gt;</code>.</strong> By 'modeler' i refer to the library bpmn.js (docs can be found here: <a href=""https://github.com/bpmn-io/bpmn-js"" rel=""nofollow noreferrer"">https://github.com/bpmn-io/bpmn-js</a>)</li>
</ul>

<p>here is the link to the entire application and working demo:
<a href=""https://codesandbox.io/s/jr89309w9"" rel=""nofollow noreferrer"">https://codesandbox.io/s/jr89309w9</a></p>

<p>my problem is that when i try to load the modeler while in test, it fails with error: </p>

<pre><code>TypeError: Cannot read property 'appendChild' of null
</code></pre>

<p>here is my modeler component:</p>

<pre><code>import React, { Component } from ""react"";
import BpmnJS from ""bpmn-js/dist/bpmn-modeler.development.js"";
import ""bpmn-js/dist/assets/diagram-js.css"";
import ""bpmn-js/dist/assets/bpmn-font/css/bpmn-embedded.css"";
class ModelerPage extends Component {
  constructor(props) {
    super(props);
    this.viewer = new BpmnJS()
  }

  componentDidMount() {
    const cont = document.querySelector('.container')
    this.viewer.attachTo("".container"");
  }
  componentWillUnmount() {
    this.viewer.detach();
  }
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Modeler&lt;/h1&gt;
        &lt;div className=""container""&gt; &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
export default ModelerPage;
</code></pre>

<p>and here are my tests:</p>

<pre><code>import ""../jest-setup"";
import { mount } from ""enzyme"";
import React from ""react"";
import App from ""./App"";

it(""renders an app with 2 routes, home and modeler page"", async () =&gt; {

  const wrapper = mount(
    &lt;MemoryRouter initialEntries={[""/""]} initialIndex={0}&gt;
      &lt;App /&gt;
    &lt;/MemoryRouter&gt;
  );
  const HomeTitle = &lt;h1&gt;Home&lt;/h1&gt;;
  const ModelerTitle = &lt;h1&gt;Modeler&lt;/h1&gt;;


  // Home title is rendered
  expect(wrapper.contains(HomeTitle)).toEqual(true);

  // When clicking the /modeler link
  wrapper.find('[href=""/modeler""]').simulate(""click"", { button: 0 });

  // Modeler title is rendered
  expect(wrapper.contains(ModelerTitle)).toEqual(true);


  // Modeler container is rendered   
  expect(wrapper.html()).toMatch(/.bjs-container/);

});
</code></pre>

<p>the BpmJS library is loaded in the <code>componentDidMount()</code> so the DOM should be ready, but the <code>enzyme.mount()</code> is not really recreating the DOM.</p>

<p>how should these kind of components be tested ?</p>
","1851110","","","","","2018-07-20 21:55:59","reactjs Testing with Enzyme , TypeError: Cannot read property 'appendChild' of null","<javascript><reactjs><enzyme>","1","0","","",""
"49925340","1","","","2018-04-19 15:54:15","","0","31","<p>I created this component to display a Highchart. It is used in a dashboard component. I navigate to the dashboard from a  in a list.</p>

<p>It is working almost as expected, but not entirely.
If I go to dashboard for item A, all is fine. If Ithen press the back-button, and navigate to dashboard for item B - I see the chart data for item A. If I go back again, and to dash for C - I see the data for B.
Any kind soul who can figure out what I did wrong?</p>

<p>This is the chart component:</p>

<pre><code>import * as React from 'react';
import * as Highcharts from ""highcharts"";

export interface IMyChartProps {
    options: Highcharts.Options;
}

type ChartProps = IMyChartProps;

export class MyChart extends React.Component&lt;ChartProps, {}&gt; {
    chart: Highcharts.ChartObject;
    container: HTMLDivElement | null;

    componentDidMount() {
        if (this.container) {
            this.chart = Highcharts.chart(this.container, this.props.options);
            { this.chart }
        }
    }

    componentWillUnmount() {
        this.chart &amp;&amp; this.chart.destroy();
    }

    public render() {
        return &lt;div ref={(div) =&gt; { this.container = div; }}&gt;&lt;/div&gt;
    }
}
</code></pre>

<p>This is the dashboard component:</p>

<pre><code>import * as React from 'react';
import { Link, RouteComponentProps, NavLink } from 'react-router-dom';
import { connect } from 'react-redux';
import { ApplicationState } from '../../store';
import * as PeopleGroupsStore from '../../store/Client/PeopleGroups';
import * as Highcharts from ""highcharts"";
import { MyChart, IMyChartProps } from '../Shared/MyChart';

type SubscriberDashboardProps =
    PeopleGroupsStore.PeopleGroupsState
    &amp; typeof PeopleGroupsStore.actionCreators
    &amp; RouteComponentProps&lt;{ id: string }&gt;;

interface SubscriberDashboardViewState {
    segmentIndex: number;
    lineChartData: IMyChartProps;
    colChartData: IMyChartProps;
}

class MyDashboard extends React.Component&lt;MyDashboardProps, SubscriberDashboardViewState&gt; {
    constructor(props: MyDashboardProps) {
        super(props);
        this.setupChartOptions();

        this.state = {
            segmentIndex: 0,
            lineChartData: {
                options: this.lineChartOptions
            },
            colChartData: {
                options: this.colChartOptions
            }
        }

        this.setSegmentIndex = this.setSegmentIndex.bind(this);
    }

    lineChartOptions: Highcharts.Options;
    colChartOptions: Highcharts.Options;

    setSegmentIndex(newIndex: number) {
        this.setState({ segmentIndex: newIndex });
    }

    componentWillMount() {
        this.props.requestPeopleGroups(this.props.match.params.id, 999);
    }

    shouldComponentUpdate(nextProps: MyDashboardProps, nextState: MyDashboardViewState) {
        if (this.props.PeopleGroups != nextProps.PeopleGroups) {
            this.updateOptions();
            return true;
        }

        if (this.state.segmentIndex != nextState.segmentIndex) {
            return true;
        }

        return false;
    }

    updateOptions() {
        let lineChartSeries: Array&lt;Highcharts.LineChartSeriesOptions&gt; = [];
        let columnChartSeries: Array&lt;Highcharts.LineChartSeriesOptions&gt; = [];
        let lineChartXAxisCategories: Array&lt;string&gt; = [];
        let xAxisCatFilled: boolean = false;

        this.props.PeopleGroups.forEach((ss) =&gt; {
            let d: Array&lt;{ name: string, y: number }&gt; = [];
            let totPeople: number = 0;
            ss.History.forEach((h) =&gt; {
                let yearWeek: string = h.Year.toString() + 'w' + h.Week.toString();
                d.push({ name: yearWeek, y: h.Count });
                if (!xAxisCatFilled) lineChartXAxisCategories.push(yearWeek);
                totPeople += h.Count;
            })
            lineChartSeries.push({
                name: ss.Name,
                data: d
            });
            columnChartSeries.push({
                name: ss.Name,
                data: [totPeople]
            });
            xAxisCatFilled = lineChartXAxisCategories.length &gt; 0;
        });

        this.lineChartOptions.xAxis = { categories: lineChartXAxisCategories };
        this.lineChartOptions.series = lineChartSeries;
        this.colChartOptions.xAxis = { categories: [''] };
        this.colChartOptions.series = columnChartSeries;

        this.setState(
            {
                lineChartData: {
                    options: this.lineChartOptions
                },
                colChartData: {
                    options: this.colChartOptions
                }
            }
        );
    }

    public render() {
        return (
            &lt;div&gt;
                &lt;div className=""row""&gt;
                    {this.renderTable()}
                    {this.renderChart()}
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }

    renderTable() {
        return (
            &lt;div&gt; ... omitted table rendering
            &lt;/div&gt;);
    }

    renderChart() {
        this.updateOptions();

        return (
            &lt;div&gt;
                &lt;div&gt;
                    &lt;div key=""lineChartDiv""&gt;&lt;MyChart options={this.state.lineChartData.options} &gt;&lt;/MyChart&gt;&lt;/div&gt;
                    &lt;div key=""colChartDiv""&gt;&lt;MyChart options={this.state.colChartData.options} &gt;&lt;/MyChart&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }

    setupChartOptions() {
        this.lineChartOptions = {
        //omitted setup
        };

        this.colChartOptions = {
        //omitted setup
        };
    }
}

export default connect(
    (state: ApplicationState) =&gt; state.PeopleGroups,
    PeopleGroupsStore.actionCreators
)(MyDashboard) as typeof MyDashboard;
</code></pre>

<p>Edit: changed to more general naming.</p>
","323313","","323313","","2018-04-20 13:19:50","2018-04-20 13:19:50","Old highchart data in react component when going back and forward","<reactjs><typescript><highcharts><redux>","2","0","","",""
"49641572","1","","","2018-04-04 01:57:46","","1","155","<p>I have a watchKit app connected with a react-native iOS app with <a href=""https://github.com/mtford90/react-native-watch-connectivity"" rel=""nofollow noreferrer"">react-native-watch-connectivity</a>.</p>

<p>I want to use the applicationContext to communicate between the devices.</p>

<p>From react-native, I use <code>watch.updateApplicationContext({ dataFromRN: ""data"" })</code> to define it and I can get it in iWatch side.</p>

<p><strong>But when I use <code>updateApplicationContext([""data"":""data""])</code> in iWatch side, an updated context event is catch by react-native but the data is not updated.</strong></p>

<pre><code>// iWatch
try session?.updateApplicationContext([""dataFromWatch"":""data""])
print(session?.applicationContext ?? """")
</code></pre>

<blockquote>
  <p>[""dataFromWatch"": ""data""]</p>
</blockquote>

<p>but in react-native, I have the following output for this event:</p>

<pre><code>// react-native iOS
receiveApplicationContext(err, applicationContext) {
  console.log(""receiveApplicationContext()"", applicationContext)
</code></pre>

<blockquote>
  <p>receiveApplicationContext() {dataFromRN: ""data""}</p>
</blockquote>

<p>dataFromRN is a previous applicationContext defined from react-native side.</p>

<p>Event if react-native catch an event, the applicationContext is not updated.</p>

<p>(react-native-watch-connectivity has react version defined to <strong>15.4.2</strong> but I'm using react <strong>16.2.0</strong>. Is something can be breaking changed between this versions ?)</p>

<p>I guess I have to update something in react-native-watch-connectivity, but I would like to know where.</p>

<p>If you have any element to fix this issue...</p>

<p>Thx</p>

<p>iOS side (with react-native)</p>

<pre><code>import React, { Component } from ""react"";
import {
  Platform,
  StyleSheet,
  Text,
  View,
  ScrollView,
  AsyncStorage,
  TouchableHighlight
} from ""react-native"";
import * as watch from ""react-native-watch-connectivity"";

type Props = {};
export default class App extends Component&lt;Props&gt; {
  constructor(props) {
    super(props);
    this.state = { match: [] };
    this.receiveUserInfo = this.receiveUserInfo.bind(this);
    this.subscribeToApplicationContext = this.subscribeToApplicationContext.bind(this);
    this.subscribeToWatchEvents = this.subscribeToWatchEvents.bind(this);
  }

  receiveUserInfo(err, userInfo) {
    if (!err) {
      if (userInfo.currentMatch !== undefined) {
        console.log(""receiveUserInfo()"", userInfo);
      }
    }
  }

  receiveApplicationContext(err, applicationContext) {
    if (!err) {
      console.log(""receiveApplicationContext()"", applicationContext);
        watch.getApplicationContext().then(context =&gt; {
        console.log(""getApplicationContext()"", context);
      });
    }
  }

  subscribeToWatchEvents() {
    this.subscriptions = [
      watch.subscribeToUserInfo(this.receiveUserInfo),
      watch.subscribeToApplicationContext(this.receiveApplicationContext)
    ];
  }

  componentDidMount() {
    this.subscribeToWatchEvents();
  }

  componentWillUnmount() {}

  render() {
    return (
      &lt;View/&gt;
    );
  }
}
</code></pre>

<p>iWatch side (swift)</p>

<pre><code>import WatchKit
import Foundation
import WatchConnectivity

class MainController: WKInterfaceController, WCSessionDelegate {

  var session: WCSession?

  override func awake(withContext context: Any?) {
    super.awake(withContext: context)
    if WCSession.isSupported() {
      self.session = WCSession.default
      self.session?.delegate = self
      self.session?.activate()
    }
  }

  func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
    print(""activationDidCompleteWith"", activationState)
  }

  func session(_ session: WCSession, didReceiveApplicationContext applicationContext: [String : Any]) {
    print(""didReceiveApplicationContext"", applicationContext)
  }

  func sendUserInfo() {
    session?.transferUserInfo([""data"":""data""])
    do {
      try session?.updateApplicationContext([""data"":""data""])
    } catch {
      print(""updateApplicationContext error"")
    }
    print(session?.applicationContext ?? """")
  }

  @IBAction func point() {
    sendUserInfo()
  }

}
</code></pre>
","2255168","","2255168","","2018-04-06 15:31:19","2018-04-06 15:31:19","get ApplicationContext on react-native","<swift><reactjs><react-native><watchkit><react-native-ios>","1","4","","",""
"50356449","1","50503076","","2018-05-15 17:51:06","","2","145","<p>I have a Sharepoint Framework webpart which basically has a property side bar where I can select the Sharepoint List, and based on the selection it will render the list items from that list into an Office UI DetailsList Component.</p>

<p>When I debug the REST calls are all fine, however the problem is I never get any data rendered on the screen. </p>

<p>so If I select GenericList it should query Generic LIst, if I select Directory it should query the Directory list, however when I select Directory it still says that the selection is GenericList, not directory.</p>

<p>This is my webpart code</p>

<pre><code>import * as React from ""react"";
import * as ReactDom from ""react-dom"";
import { Version } from ""@microsoft/sp-core-library"";
import {
  BaseClientSideWebPart,
  IPropertyPaneConfiguration,
  PropertyPaneTextField,
  PropertyPaneDropdown,
  IPropertyPaneDropdownOption,
  IPropertyPaneField,
  PropertyPaneLabel
} from ""@microsoft/sp-webpart-base"";

import * as strings from ""FactoryMethodWebPartStrings"";
import FactoryMethod from ""./components/FactoryMethod"";
import { IFactoryMethodProps } from ""./components/IFactoryMethodProps"";
import { IFactoryMethodWebPartProps } from ""./IFactoryMethodWebPartProps"";
import * as lodash from ""@microsoft/sp-lodash-subset"";
import List from ""./components/models/List"";
import { Environment, EnvironmentType } from ""@microsoft/sp-core-library"";
import IDataProvider from ""./components/dataproviders/IDataProvider"";
import MockDataProvider from ""./test/MockDataProvider"";
import SharePointDataProvider from ""./components/dataproviders/SharepointDataProvider"";

export default class FactoryMethodWebPart extends BaseClientSideWebPart&lt;IFactoryMethodWebPartProps&gt; {
  private _dropdownOptions: IPropertyPaneDropdownOption[];
  private _selectedList: List;
  private _disableDropdown: boolean;
  private _dataProvider: IDataProvider;
  private _factorymethodContainerComponent: FactoryMethod;

  protected onInit(): Promise&lt;void&gt; {
    this.context.statusRenderer.displayLoadingIndicator(this.domElement, ""Todo"");

    /*
    Create the appropriate data provider depending on where the web part is running.
    The DEBUG flag will ensure the mock data provider is not bundled with the web part when you package the
     solution for distribution, that is, using the --ship flag with the package-solution gulp command.
    */
    if (DEBUG &amp;&amp; Environment.type === EnvironmentType.Local) {
      this._dataProvider = new MockDataProvider();
    } else {
      this._dataProvider = new SharePointDataProvider();
      this._dataProvider.webPartContext = this.context;
    }

    this.openPropertyPane = this.openPropertyPane.bind(this);

    /*
    Get the list of tasks lists from the current site and populate the property pane dropdown field with the values.
    */
    this.loadLists()
      .then(() =&gt; {
        /*
         If a list is already selected, then we would have stored the list Id in the associated web part property.
         So, check to see if we do have a selected list for the web part. If we do, then we set that as the selected list
         in the property pane dropdown field.
        */
        if (this.properties.spListIndex) {
          this.setSelectedList(this.properties.spListIndex.toString());
          this.context.statusRenderer.clearLoadingIndicator(this.domElement);
        }
      });

    return super.onInit();
  }

  // render method of the webpart, actually calls Component
  public render(): void {
    const element: React.ReactElement&lt;IFactoryMethodProps &gt; = React.createElement(
      FactoryMethod,
      {
        spHttpClient: this.context.spHttpClient,
        siteUrl: this.context.pageContext.web.absoluteUrl,
        listName: this._dataProvider.selectedList === undefined ? ""GenericList"" : this._dataProvider.selectedList.Title,
        dataProvider: this._dataProvider,
        configureStartCallback: this.openPropertyPane
      }
    );

    // reactDom.render(element, this.domElement);
    this._factorymethodContainerComponent = &lt;FactoryMethod&gt;ReactDom.render(element, this.domElement);

  }

  // loads lists from the site and fill the dropdown.
  private loadLists(): Promise&lt;any&gt; {
    return this._dataProvider.getLists()
      .then((lists: List[]) =&gt; {
        // disable dropdown field if there are no results from the server.
        this._disableDropdown = lists.length === 0;
        if (lists.length !== 0) {
          this._dropdownOptions = lists.map((list: List) =&gt; {
            return {
              key: list.Id,
              text: list.Title
            };
          });
        }
      });
  }

  protected get dataVersion(): Version {
    return Version.parse(""1.0"");
  }

  protected onPropertyPaneFieldChanged(propertyPath: string, oldValue: any, newValue: any): void {
    /*
    Check the property path to see which property pane feld changed. If the property path matches the dropdown, then we set that list
    as the selected list for the web part.
    */
    if (propertyPath === ""spListIndex"") {
      this.setSelectedList(newValue);
    }

    /*
    Finally, tell property pane to re-render the web part.
    This is valid for reactive property pane.
    */
    super.onPropertyPaneFieldChanged(propertyPath, oldValue, newValue);
  }

  // sets the selected list based on the selection from the dropdownlist
  private setSelectedList(value: string): void {
    const selectedIndex: number = lodash.findIndex(this._dropdownOptions,
      (item: IPropertyPaneDropdownOption) =&gt; item.key === value
    );

    const selectedDropDownOption: IPropertyPaneDropdownOption = this._dropdownOptions[selectedIndex];

    if (selectedDropDownOption) {
      this._selectedList = {
        Title: selectedDropDownOption.text,
        Id: selectedDropDownOption.key.toString()
      };

      this._dataProvider.selectedList = this._selectedList;
    }
  }


  // we add fields dynamically to the property pane, in this case its only the list field which we will render
  private getGroupFields(): IPropertyPaneField&lt;any&gt;[] {
    const fields: IPropertyPaneField&lt;any&gt;[] = [];

    // we add the options from the dropdownoptions variable that was populated during init to the dropdown here.
    fields.push(PropertyPaneDropdown(""spListIndex"", {
      label: ""Select a list"",
      disabled: this._disableDropdown,
      options: this._dropdownOptions
    }));

    /*
    When we do not have any lists returned from the server, we disable the dropdown. If that is the case,
    we also add a label field displaying the appropriate message.
    */
    if (this._disableDropdown) {
      fields.push(PropertyPaneLabel(null, {
        text: ""Could not find tasks lists in your site. Create one or more tasks list and then try using the web part.""
      }));
    }

    return fields;
  }

  private openPropertyPane(): void {
    this.context.propertyPane.open();
  }

  protected getPropertyPaneConfiguration(): IPropertyPaneConfiguration {
    return {
      pages: [
        {
          header: {
            description: strings.PropertyPaneDescription
          },
          groups: [
            {
              groupName: strings.BasicGroupName,
              /*
              Instead of creating the fields here, we call a method that will return the set of property fields to render.
              */
              groupFields: this.getGroupFields()
            }
          ]
        }
      ]
    };
  }
}
</code></pre>

<p>This is my component code</p>

<pre><code>//#region Imports
import * as React from ""react"";
import styles from ""./FactoryMethod.module.scss"";
import  { IFactoryMethodProps } from ""./IFactoryMethodProps"";
import {
  IDetailsListItemState,
  IDetailsNewsListItemState,
  IDetailsDirectoryListItemState,
  IDetailsAnnouncementListItemState,
  IFactoryMethodState
} from ""./IFactoryMethodState"";
import { IListItem } from ""./models/IListItem"";
import { IAnnouncementListItem } from ""./models/IAnnouncementListItem"";
import { INewsListItem } from ""./models/INewsListItem"";
import { IDirectoryListItem } from ""./models/IDirectoryListItem"";
import { escape } from ""@microsoft/sp-lodash-subset"";
import { SPHttpClient, SPHttpClientResponse } from ""@microsoft/sp-http"";
import { ListItemFactory} from ""./ListItemFactory"";
import { TextField } from ""office-ui-fabric-react/lib/TextField"";
import {
  DetailsList,
  DetailsListLayoutMode,
  Selection,
  buildColumns,
  IColumn
} from ""office-ui-fabric-react/lib/DetailsList"";
import { MarqueeSelection } from ""office-ui-fabric-react/lib/MarqueeSelection"";
import { autobind } from ""office-ui-fabric-react/lib/Utilities"";
import PropTypes from ""prop-types"";
//#endregion

export default class FactoryMethod extends React.Component&lt;IFactoryMethodProps, IFactoryMethodState&gt; {
  constructor(props: IFactoryMethodProps, state: any) {
    super(props);
    this.setInitialState();
  }


  // lifecycle help here: https://staminaloops.github.io/undefinedisnotafunction/understanding-react/
  //#region Mouting events lifecycle
  // the data returned from render is neither a string nor a DOM node.
  // it's a lightweight description of what the DOM should look like.
  // inspects this.state and this.props and create the markup.
  // when your data changes, the render method is called again.
  // react diff the return value from the previous call to render with
  // the new one, and generate a minimal set of changes to be applied to the DOM.
  public render(): React.ReactElement&lt;IFactoryMethodProps&gt; {
    if (this.state.hasError) {
      // you can render any custom fallback UI
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    } else {
      switch(this.props.listName) {
          case ""GenericList"":
            // tslint:disable-next-line:max-line-length
            return &lt;this.ListMarqueeSelection items={this.state.DetailsListItemState.items} columns={this.state.columns} /&gt;;
          case ""News"":
            // tslint:disable-next-line:max-line-length
            return &lt;this.ListMarqueeSelection items={this.state.DetailsNewsListItemState.items} columns={this.state.columns}/&gt;;
          case ""Announcements"":
            // tslint:disable-next-line:max-line-length
            return &lt;this.ListMarqueeSelection items={this.state.DetailsAnnouncementListItemState.items} columns={this.state.columns}/&gt;;
          case ""Directory"":
            // tslint:disable-next-line:max-line-length
            return &lt;this.ListMarqueeSelection items={this.state.DetailsDirectoryListItemState.items} columns={this.state.columns}/&gt;;
          default:
            return null;
      }
    }
  }

  public componentDidCatch(error: any, info: any): void {
    // display fallback UI
    this.setState({ hasError: true });
    // you can also log the error to an error reporting service
    console.log(error);
    console.log(info);
  }



  // componentDidMount() is invoked immediately after a component is mounted. Initialization that requires DOM nodes should go here.
  // if you need to load data from a remote endpoint, this is a good place to instantiate the network request.
  // this method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in componentWillUnmount().
  // calling setState() in this method will trigger an extra rendering, but it is guaranteed to flush during the same tick.
  // this guarantees that even though the render() will be called twice in this case, the user won’t see the intermediate state.
  // use this pattern with caution because it often causes performance issues. It can, however, be necessary for cases like modals and
  // tooltips when you need to measure a DOM node before rendering something that depends on its size or position.
   public componentDidMount(): void {
    this._configureWebPart = this._configureWebPart.bind(this);
    this.readItemsAndSetStatus();
  }

  //#endregion
  //#region Props changes lifecycle events (after a property changes from parent component)
  // componentWillReceiveProps() is invoked before a mounted component receives new props.
  // if you need to update the state in response to prop
  // changes (for example, to reset it), you may compare this.props and nextProps and perform state transitions
  // using this.setState() in this method.
  // note that React may call this method even if the props have not changed, so make sure to compare the current
  // and next values if you only want to handle changes.
  // this may occur when the parent component causes your component to re-render.
  // react doesn’t call componentWillReceiveProps() with initial props during mounting. It only calls this
  // method if some of component’s props may update
  // calling this.setState() generally doesn’t trigger componentWillReceiveProps()
  public componentWillReceiveProps(nextProps: IFactoryMethodProps): void {
    if(nextProps.listName !== this.props.listName) {
      this.readItemsAndSetStatus();
    }
  }

  //#endregion
  //#region private methods
  private _configureWebPart(): void {
    this.props.configureStartCallback();
  }

  public setInitialState(): void {
    this.state = {
      hasError: false,
      status: this.listNotConfigured(this.props)
        ? ""Please configure list in Web Part properties""
        : ""Ready"",
      columns:[],
      DetailsListItemState:{
        items:[]
      },
      DetailsNewsListItemState:{
        items:[]
      },
      DetailsDirectoryListItemState:{
        items:[]
      },
      DetailsAnnouncementListItemState:{
        items:[]
      },
    };
  }

  // reusable inline component
  private ListMarqueeSelection = (itemState: {columns: IColumn[], items: IListItem[] }) =&gt; (
      &lt;div&gt;
          &lt;DetailsList
            items={ itemState.items }
            columns={ itemState.columns }
            setKey=""set""
            layoutMode={ DetailsListLayoutMode.fixedColumns }
            selectionPreservedOnEmptyClick={ true }
            compact={ true }&gt;
          &lt;/DetailsList&gt;
      &lt;/div&gt;
  )

  // read items using factory method pattern and sets state accordingly
  private readItemsAndSetStatus(): void {
    this.setState({
      status: ""Loading all items...""
    });

    const factory: ListItemFactory = new ListItemFactory();
    factory.getItems(this.props.spHttpClient, this.props.siteUrl, this.props.listName)
    .then((items: any[]) =&gt; {

      var myItems: any = null;
      switch(this.props.listName) {
          case ""GenericList"":
              myItems = items as IListItem[];
              break;
          case ""News"":
              myItems = items as INewsListItem[];
              break;
          case ""Announcements"":
              myItems = items as IAnnouncementListItem[];
              break;
          case ""Directory"":
              myItems = items as IDirectoryListItem[];
              break;
      }

      const keyPart: string = this.props.listName === ""GenericList"" ? """" : this.props.listName;
        // the explicit specification of the type argument `keyof {}` is bad and
        // it should not be required.
        this.setState&lt;keyof {}&gt;({
          status: `Successfully loaded ${items.length} items`,
          [""Details"" + keyPart + ""ListItemState""] : {
            myItems
          },
          columns: buildColumns(myItems)
        });
    });
  }

  private listNotConfigured(props: IFactoryMethodProps): boolean {
    return props.listName === undefined ||
      props.listName === null ||
      props.listName.length === 0;
  }

  //#endregion
}
</code></pre>

<p>I think the rest of the code is not neccesary</p>

<p>Update
SharepointDataProvider.ts</p>

<pre><code>import {
    SPHttpClient,
    SPHttpClientBatch,
    SPHttpClientResponse
  } from ""@microsoft/sp-http"";
  import { IWebPartContext } from ""@microsoft/sp-webpart-base"";
  import List from ""../models/List"";
  import IDataProvider from ""./IDataProvider"";

  export default class SharePointDataProvider implements IDataProvider {
      private _selectedList: List;
      private _lists: List[];
      private _listsUrl: string;
      private _listItemsUrl: string;
      private _webPartContext: IWebPartContext;

      public set selectedList(value: List) {
        this._selectedList = value;
        this._listItemsUrl = `${this._listsUrl}(guid'${value.Id}')/items`;
      }

      public get selectedList(): List {
        return this._selectedList;
      }

      public set webPartContext(value: IWebPartContext) {
        this._webPartContext = value;
        this._listsUrl = `${this._webPartContext.pageContext.web.absoluteUrl}/_api/web/lists`;
      }

      public get webPartContext(): IWebPartContext {
        return this._webPartContext;
      }

      // get all lists, not only tasks lists
      public getLists(): Promise&lt;List[]&gt; {
        // const listTemplateId: string = '171';
        // const queryString: string = `?$filter=BaseTemplate eq ${listTemplateId}`;
        // const queryUrl: string = this._listsUrl + queryString;
        return this._webPartContext.spHttpClient.get(this._listsUrl, SPHttpClient.configurations.v1)
          .then((response: SPHttpClientResponse) =&gt; {
            return response.json();
          })
          .then((json: { value: List[] }) =&gt; {
            return this._lists = json.value;
          });
      }
    }
</code></pre>

<p>Idataprovider.ts</p>

<pre><code>import { IWebPartContext } from ""@microsoft/sp-webpart-base"";
import List from ""../models/List"";
import {IListItem} from ""../models/IListItem"";

interface IDataProvider {
  selectedList: List;
  webPartContext: IWebPartContext;
  getLists(): Promise&lt;List[]&gt;;
}

export default IDataProvider;
</code></pre>
","1014217","","1014217","","2018-05-15 18:25:54","2018-05-24 07:07:09","not proper use of react lifecycle","<javascript><reactjs><typescript><sharepoint><spfx>","2","7","","",""
"34097560","1","","","2015-12-04 21:14:33","","12","11730","<p>I have a react component that is the detail view from a list.</p>

<p>I am trying to replace the image with a default image if the image does not exist and there is a 404 error.  </p>

<p>I would normally use the onerror method in the img tag but that doesn't seem to be working.</p>

<p>I am not sure how to do this with react.</p>

<p>Here is my component:</p>

<pre><code>import React from 'react';
import {Link} from 'react-router';
import ContactStore from '../stores/ContactStore'
import ContactActions from '../actions/ContactActions';

class Contact extends React.Component {
  constructor(props) {
    super(props);
    this.state = ContactStore.getState();
    this.onChange = this.onChange.bind(this); 
 }

componentDidMount() {
  ContactStore.listen(this.onChange);
  ContactActions.getContact(this.props.params.id);
}

componentWillUnmount() {
  ContactStore.unlisten(this.onChange);
}

componentDidUpdate(prevProps) {
  if (prevProps.params.id !== this.props.params.id) {
    ContactActions.getContact(this.props.params.id);
  }
}

onChange(state) {
  this.setState(state);
}

render() {
  return (
    &lt;div className='container'&gt;
      &lt;div className='list-group'&gt;
        &lt;div className='list-group-item animated fadeIn'&gt;
          &lt;h4&gt;{this.state.contact.displayname}&lt;/h4&gt;
          &lt;img src={this.state.imageUrl} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
}

export default Contact;
</code></pre>
","4017056","","1677912","","2016-03-05 18:23:33","2018-01-12 08:52:34","react.js Replace img src onerror","<javascript><reactjs><http-status-code-404>","5","1","6","",""
"50394144","1","50395843","","2018-05-17 14:34:43","","0","46","<p>I want to use the <code>Header</code> Component as a Clock timer. I hope my page rendering per one sec. I followed some example in google search. But, couldn't find example like this.
Why doesn't this <code>tick()</code> function work?
There are no errors in the console.</p>

<p>This is my first code:</p>

<pre><code>class index extends React.Component&lt;Props, {}&gt; {
constructor({ title }: Props) {
    super({ title });
}

render() {
    return (
        &lt;Layout title={this.props.title}&gt;
            &lt;div className=""header""&gt;&lt;Header/&gt;&lt;/div&gt;
            &lt;div className=""search-bar""&gt;&lt;SearchBar/&gt;&lt;/div&gt;
            &lt;div className=""Footer""&gt;&lt;Footer/&gt;&lt;/div&gt;
        &lt;/Layout&gt;
    );
}
}
</code></pre>

<p>Second code:</p>

<pre><code>class Header extends React.Component&lt;{}, States&gt;{
intervalID: any;
constructor() {
    super({}, {});
    this.state = {
        date: new Date().toLocaleString(),
    } 
    this.tick = this.tick.bind(this);
}

componentDidMount() {
    this.intervalID = setInterval(() =&gt; this.tick(), 1000);
}

componentWillUnmount() {
    clearInterval(this.intervalID);
}

tick() {
    this.setState({
        date: new Date().toLocaleString(),
    })
}

render() {
    return (
        &lt;header&gt;
            &lt;p&gt;Header: {this.state.date}&lt;/p&gt;
        &lt;/header&gt;
    );
}
}

export default Header;
</code></pre>

<p>This code (Node.js router) calls <code>First</code> page. <code>App</code> uses 'express-react-view' for its view engine.</p>

<pre><code>import { Request, Response }  from ""express"";

/**
* Get /
* Home page.
* @param req 
* @param res 
*/
export let index = (req: Request, res: Response) =&gt; {
   res.render(""index"", {""title"": ""React, Front-end""})
};
</code></pre>
","9492357","","5411817","","2018-05-17 15:30:39","2018-05-17 15:58:03","My react component timer doesn't work","<node.js><reactjs><typescript><jsx>","1","6","","",""
"50400736","1","","","2018-05-17 21:25:24","","0","91","<p>I am trying to use the barcode scanner from <code>react-native-camera</code>. First, off it scans a QR-code and extracts a String, after that it navigates to the next Screen with <code>react-navigation</code>. In the second screen, it makes an API-call. </p>

<p>Now if I go back to the scanner screen, de QR-code will be scanned immediately. That's where I run into an error and the scanner freezes. I usually get this error: </p>

<pre><code>Can't call setState (or forceUpdate) on an unmounted component
</code></pre>

<p>I think it's because my <code>componentWillUnmount</code> cleanup doesn't work properly or fast enough, but I already cancel the axios request. </p>

<pre><code>       requestCode = (code) =&gt; {
        if (cancel != undefined) {
          cancel();
        }
        axios.get(API_URI + code, {
          cancelToken: new CancelToken(function executor(c) {
            cancel = c;
          })
        }).then(response =&gt; {
          console.log(response)
          //checks if code was already called
          this.checkUsed(response.data)
        })
          .catch(error =&gt; {
            this.setState({ isValid: false })
          });
        }

    componentWillUnmount() {
        cancel();
      }
</code></pre>

<p>Maybe I could mount the camera-scanner a little bit later so it doesn't scan this fast or is it maybe even an error with React Navigation?</p>
","4869857","","","","","2018-05-17 21:25:24","react-native-camera barcode scanner freezes, because it scans too fast","<react-native><react-native-ios><react-native-camera><react-lifecycle>","0","0","","",""
"49722505","1","49833490","","2018-04-08 20:33:41","","0","193","<p>I am trying to use nested navigators with a redux integration, but the app fails to load with the following error: </p>

<p><a href=""https://i.stack.imgur.com/vcNa4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vcNa4.png"" alt=""Error""></a></p>

<p>Everything was working fine until I added a second layer of navigators for the login flow.</p>

<p>How can I accomplish this?</p>

<p>Here is the complete code for the navigator and integrating it with redux:</p>

<pre><code>import React, { Component } from 'react';
import { BackHandler } from ""react-native"";

import { connect } from 'react-redux';
import { fromJS } from 'immutable';

import { dogTypes } from '../ducks/dog';

import { StackNavigator, addNavigationHelpers, NavigationActions } from 'react-navigation';
import { createReduxBoundAddListener, createReactNavigationReduxMiddleware } from 'react-navigation-redux-helpers';

import MainScreen from '../screens/MainScreen';
import SecondScreen from '../screens/SecondScreen';
import AuthLoadingScreen from '../screens/AuthLoadingScreen';
import AuthScreen from '../screens/AuthScreen';

import HeaderWithMenu from '../components/Headers/HeaderWithMenu';
import HeaderWithBack from '../components/Headers/HeaderWithBack';

import Translations from '../translations/screens';

const MainNavigator = StackNavigator({
  LoginFlow: {
    screen: StackNavigator({
      AuthLoading: AuthLoadingScreen,
      Auth: AuthScreen,
    },
    {
      initialRouteName: 'AuthLoading',
    })
  },
  MainFlow: {
    screen: StackNavigator({
      Main: {
        screen: MainScreen,
        navigationOptions: ({navigation}) =&gt; ({
          header: &lt;HeaderWithMenu title={Translations.t('mainScreen')}/&gt;
        })
      },
      Second: { 
        screen: SecondScreen,
        navigationOptions: ({navigation}) =&gt; ({
          header: &lt;HeaderWithBack title={Translations.t('secondScreen')} navigation={navigation}/&gt;
        })
      },
    },
    {
      initialRouteName: 'Main'
    })
  }
},
{
  initialRouteName: 'MainFlow'
});

const initialState = fromJS(
  {
    index: 0,
    routes: [
      {
        index: 0,
        key: 'MainFlow',
        routeName: 'MainFlow',
        routes: [
          {
            key: 'Main',
            routeName: 'Main'
          }
        ]
      }
    ]
  }
);

export const mainNavReducer = (state = initialState, action) =&gt; {
  let nextState;
  switch (action.type) {
    case dogTypes.DOG_BIGGER:
      nextState = state.merge(MainNavigator.router.getStateForAction(
        MainNavigator.router.getActionForPathAndParams('Second'),
        state.toJS()
      ));
      break;
    default:
      nextState = state.merge(MainNavigator.router.getStateForAction(action, state.toJS()));
      break;
  }

  // Simply return the original `state` if `nextState` is null or undefined.
  return nextState || state;
};

export const mainNavMiddleware = createReactNavigationReduxMiddleware(
  ""root"",
  state =&gt; state.nav,
)

const addListener = createReduxBoundAddListener(""root"");

class App extends Component {
  componentDidMount() {
    BackHandler.addEventListener(""hardwareBackPress"", this.onBackPress);
  }
  componentWillUnmount() {
    BackHandler.removeEventListener(""hardwareBackPress"", this.onBackPress);
  }
  onBackPress = () =&gt; {
    const { dispatch, nav } = this.props;
    if (nav.index === 0) {
      return false;
    }
    dispatch(NavigationActions.back());
    return true;
  };

  render() {
    return (
      &lt;MainNavigator navigation={addNavigationHelpers({
        dispatch: this.props.dispatch,
        state: this.props.nav,
        addListener,
      })} /&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; {
  return {
    nav: state.get('nav').toJS()
  }
};

export const MainNavigatorComponent = connect(mapStateToProps)(App);
</code></pre>
","3261025","","3261025","","2018-04-08 22:02:14","2018-04-14 16:12:00","Use nested navigators with react-navigation and redux integration","<react-native><react-redux><react-navigation>","2","0","","",""
"50334535","1","","","2018-05-14 15:58:09","","0","58","<p>I ran in to a problem the last few days that I just can't seem to crack.</p>

<p><strong>What I'm trying to do:</strong> We have a sidebar, from which you can select a ""<strong>Study</strong>"". This study determines what you see on the main content block, as each <strong>study</strong> has different data and users assosciated with it. In the main content block, I have <strong>forms</strong> set up, one for each user.</p>

<p><strong>The problem:</strong> On first page load, everything works fine. However, if you change the <strong>study</strong>, thus, rendering the page anew with componentWillReceiveProps, the new forms that are loaded are there, but with blank values (no initial values) and an <em>initialized</em> value of <code>false</code>. They're also not selectable in any way - the form itself is one selection dropdown and 3 checkboxes, and you can't select any of them.</p>

<p>Refreshing the page causes the forms to work again, even on the new study. </p>

<p><strong>What I've tried:</strong></p>

<ul>
<li>Manually initializing the forms with <code>this.props.dispatch(initialize(form_name))</code>. This causes the forms to be initialized with the correct values, but there's still no way to interact with them in any way.</li>
<li>Manually updatine (this.forceUpdate) on the parent's study prop change. This changed nothing</li>
<li>Setting <code>enableReinitialize</code> to <code>true</code></li>
<li>Providing a <code>key</code> to the parent page so it renders fresh every time (a hack I thought would work, but either I didn't do it right or it had no effect.)</li>
<li>Destroying the old forms when in the process of switching study props</li>
</ul>

<p>Here's the code of the Parent component and the Form component. This sidebar is in a seperate component, if you want to see that for some reason just ask. There's a lot going on in these files, mostly other extraneous UI stuff for the app, but I noted where the form is rendered in the parent with <code>//FORM IN QUESTION IS RENDERED HERE</code>.</p>

<p><strong>PARENT</strong></p>

<pre><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import IconButton from 'material-ui/IconButton';
import Button from 'material-ui/Button';
import InviteUsersDialog from './InviteUsersDialog';
import SwipeableViews from 'react-swipeable-views';
import AppBar from 'material-ui/AppBar';
import Tabs, { Tab } from 'material-ui/Tabs';

import Avatar from 'material-ui/Avatar';
import tempAvatar from '../../Assets/temp-avatar.jpg';

import ExpansionPanel, {
  ExpansionPanelDetails,
  ExpansionPanelSummary,
} from 'material-ui/ExpansionPanel';

import Typography from 'material-ui/Typography';

import ExpandMoreIcon from 'material-ui-icons/ExpandMore';

import { withRouter } from 'react-router-dom';
import { withStyles } from 'material-ui/styles';
import { connect } from 'react-redux';

import { getUsersAction, getInvestigationPermissionsAction, resetUsersError, destroyFormsAction } from '../../actions/manage';

import { MenuItem } from 'material-ui/Menu';
import { Field, FieldArray, reduxForm, getFormValues, change, reset, destroy } from 'redux-form';

import {
  Checkbox,
  RadioGroup,
  Select,
  TextField,
  Switch,
} from 'redux-form-material-ui'

import PermissionsForm from './PermissionsForm';

import compose from 'recompose/compose';

class Manage extends Component {

    constructor(props) {
        super(props);
        if (this.props.investigation) {
            this.props.getUsersAction(this.props.investigation)
        }
    }

    state = {
        inviteOpen: false,
        expanded: null,
        value: 0
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.investigation !== nextProps.investigation) {
            this.props.getUsersAction(nextProps.investigation)

        }
    }

    handleInviteOpen = () =&gt; {
        this.setState({
            inviteOpen: true
        })
    }

    updateOnSave = () =&gt; {
        this.setState({
            expanded: null
        })
        this.props.getUsersAction(this.props.investigation).then(() =&gt; {
            this.props.getInvestigationPermissionsAction(this.props.investigation)
        })
    }

    closeOnCancel = () =&gt; {
        this.setState({
            expanded: null
        })
    }

    closeDialog = () =&gt; {
        this.setState({
            inviteOpen: false
        })
    }

    handleChange = (event, value) =&gt; {
        console.log(value)
        this.setState({ value });
    };

    handleChangeIndex = index =&gt; {
        this.setState({ value: index });
    };

    handleExpansionChange = panel =&gt; (event, expanded) =&gt; {
        this.setState({
          expanded: expanded ? panel : false,
        });
    }

    render() {
        const { expanded } = this.state;
        let inviteUsers = null;
        if (this.state.inviteOpen === true) {
            inviteUsers = (
                &lt;InviteUsersDialog open={this.state.inviteOpen} updateOnSave={this.updateOnSave} closeDialog={this.closeDialog}/&gt;
            )
        } else {
            inviteUsers = null;
        }

        if (this.props.usersError) {
            this.props.history.push('/dash')
            this.props.resetUsersError()
        }

        let usersList = null;
        if (this.props.users) {
            console.log(""USERS:"", this.props.users)
            usersList = (
                &lt;div className={this.props.classes.usersExpansions}&gt;
                    &lt;ExpansionPanel className={this.props.classes.expansionPanel} expanded={false}&gt;
                      &lt;ExpansionPanelSummary className={this.props.classes.expansionSummary} expandIcon={&lt;ExpandMoreIcon className={this.props.classes.headerExpandMore}/&gt;}&gt;
                        &lt;div className={this.props.classes.headerAvatarContainer}&gt;
                            &lt;div className={this.props.classes.userInfo}&gt;
                                &lt;Typography className={this.props.classes.headingName}&gt;Name&lt;/Typography&gt;
                                &lt;Typography className={this.props.classes.headingEmail}&gt;Email&lt;/Typography&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;Typography className={this.props.classes.headerStatus}&gt;Status&lt;/Typography&gt;
                        &lt;Typography className={this.props.classes.headerPermissions}&gt;Permissions&lt;/Typography&gt;
                      &lt;/ExpansionPanelSummary&gt;
                    &lt;/ExpansionPanel&gt;
                {this.props.users.currentUsers.map((user) =&gt;
                    &lt;ExpansionPanel className={this.props.classes.expansionPanel} expanded={expanded === user.email + '-' + this.props.investigation} onChange={this.handleExpansionChange(user.email + '-' + this.props.investigation)}&gt;
                      &lt;ExpansionPanelSummary className={this.props.classes.expansionSummary} expandIcon={&lt;ExpandMoreIcon /&gt;}&gt;
                        &lt;div className={this.props.classes.avatarContainer}&gt;
                            &lt;Avatar
                                alt={user.name}
                                src={user.avatarImg ? ""data:image/jpeg;base64,"" + user.avatarImg : tempAvatar}
                                className={this.props.classes.avatar}
                                style={{ borderRadius: 2.1 }}
                            /&gt;
                            &lt;div className={this.props.classes.userInfo}&gt;
                                &lt;Typography className={this.props.classes.headingName}&gt;{user.name}&lt;/Typography&gt;
                                &lt;Typography className={this.props.classes.headingEmail}&gt;{user.email}&lt;/Typography&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;Typography className={this.props.classes.status}&gt;{expanded === user.email + '-' + this.props.investigation ? '' : 'Activated'}&lt;/Typography&gt;
                        &lt;Typography className={this.props.classes.headingPermissions}&gt;{expanded === user.email + '-' + this.props.investigation ? '' : user.permissionsArr.join(', ')}&lt;/Typography&gt;
                      &lt;/ExpansionPanelSummary&gt;
                      &lt;ExpansionPanelDetails className={this.props.classes.detailsContainer}&gt;
                        //FORM IN QUESTION IS RENDERED HERE
                        &lt;PermissionsForm 
                         form={`PermissionsForm_${user.identifier + '-' + this.props.investigation}`} 
                         updateOnSave={this.updateOnSave} closeOnCancel={this.closeOnCancel} 
                         loggedInUser={user.email === localStorage.getItem('userEmail') ? true : false} 
                         formName={`PermissionsForm_${user.identifier + '-' + this.props.investigation}`} 
                         initialValues={{identifier: user.identifier, viewPermissions: user.permissions.viewEntries === true ? 'allEntries' : 'ownEntries', addEntriesPermissions: true, exportPermissions: user.permissions.export, manageInvestPermissions: user.permissions.manageInvest}}/&gt;
                      &lt;/ExpansionPanelDetails&gt;
                    &lt;/ExpansionPanel&gt;
                )}
                {this.props.users.pendingUsers.map((user) =&gt;
                    &lt;ExpansionPanel className={this.props.classes.expansionPanel} expanded={false} onChange={this.handleExpansionChange(user.email + '-' + this.props.investigation)}&gt;
                      &lt;ExpansionPanelSummary className={this.props.classes.expansionSummary} expandIcon={&lt;ExpandMoreIcon className={this.props.classes.headerExpandMore}/&gt;}&gt;
                        &lt;div className={this.props.classes.avatarContainer}&gt;
                            &lt;Avatar
                                alt={user.name}
                                src={tempAvatar}
                                className={this.props.classes.avatar}
                                style={{ borderRadius: 0 }}
                            /&gt;
                            &lt;div className={this.props.classes.userInfo}&gt;
                                &lt;Typography className={this.props.classes.headingEmail}&gt;{user.email}&lt;/Typography&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;Typography className={this.props.classes.status}&gt;Pending&lt;/Typography&gt;
                        &lt;Typography className={this.props.classes.headingPermissions}&gt;{user.permissionsArr.join(', ')}&lt;/Typography&gt;
                      &lt;/ExpansionPanelSummary&gt;
                    &lt;/ExpansionPanel&gt;
                )}
                &lt;/div&gt;
            )
        }
        return (
            &lt;div className={this.props.classes.container}&gt;
                &lt;div className={this.props.classes.pageHeaderContainer}&gt;
                    &lt;h2 className={this.props.classes.title}&gt;Manage users&lt;/h2&gt;
                    &lt;Button color=""primary"" raised className={this.props.classes.inviteButton} onClick={this.handleInviteOpen}&gt;Invite user&lt;/Button&gt;
                &lt;/div&gt;
                {inviteUsers}
                &lt;AppBar position=""static"" color=""default"" className={this.props.classes.tabsAppBar}&gt;
                  &lt;Tabs
                    value={this.state.value}
                    onChange={this.handleChange}
                    indicatorColor=""primary""
                    textColor=""primary""
                    fullWidth
                    className={this.props.classes.tabs}
                  &gt;
                    &lt;Tab label=""People"" /&gt;
                    &lt;Tab label=""Groups"" /&gt;
                  &lt;/Tabs&gt;
                &lt;/AppBar&gt;
                &lt;SwipeableViews
                  axis={'x'}
                  index={this.state.value}
                  onChangeIndex={this.handleChangeIndex}
                &gt;
                &lt;div className={this.props.classes.peopleContainer}&gt;
                    {usersList}
                &lt;/div&gt;
                &lt;div&gt;

                &lt;/div&gt;
                &lt;/SwipeableViews&gt;
            &lt;/div&gt;
        );
    }
}


const styles = {
};

function mapStateToProps(state, ownProps) {
  return { 
    investigation: state.manage.savedInvest,
    users: state.manage.authorizedUsers,
    usersError: state.manage.usersError
  };
}


export default compose(
  withRouter,
  connect(mapStateToProps, {getUsersAction, getInvestigationPermissionsAction, resetUsersError, destroyFormsAction}),
  withStyles(styles)
)(Manage);
</code></pre>

<p><strong>FORM</strong></p>

<pre><code>import React from 'react';
import Dialog, {
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from 'material-ui/Dialog';

import Button from 'material-ui/Button';
import Input, { InputLabel } from 'material-ui/Input';

import { withStyles } from 'material-ui/styles';

import List, { ListItem, ListItemIcon, ListItemText } from 'material-ui/List';

import Typography from 'material-ui/Typography';

import Divider from 'material-ui/Divider'

import SelectBase from 'material-ui/Select';
import { MenuItem } from 'material-ui/Menu';
import { Field, FieldArray, reduxForm, getFormValues, change, reset, initialize } from 'redux-form';
import { patchPermissionsAction } from '../../actions/manage';
import { resetFormsAction } from '../../actions/dashboard';
import { connect } from 'react-redux';
import { withRouter } from 'react-router-dom';

import Tooltip from 'material-ui/Tooltip';

import PropTypes from 'prop-types';

import compose from 'recompose/compose';

import {
  Checkbox,
  RadioGroup,
  Select,
  TextField,
  Switch,
} from 'redux-form-material-ui'

const required = value =&gt; (value == null ? 'Required' : undefined)

class PermissionsForm extends React.Component {
  constructor(props) {
    super(props);
  }

  static contextTypes = {
    form: PropTypes.string
  }
  submit = (values) =&gt; {
    this.props.patchPermissionsAction(values, this.props.investigation).then(() =&gt; {
      this.props.updateOnSave();
    })
  }

  handleCancel = () =&gt; {
    this.props.closeOnCancel();
    this.props.dispatch(reset(this.props.formName))
  }

  componentDidUpdate() {
    console.log(""!"")
    if(!this.props.initialized) {
      console.log(""!!"")
    }
  }

  componentWillUnmount() {

  }

  render() {
    const { handleSubmit, pristine, reset, submitting } = this.props

    let managePerm = null;
    if (this.props.loggedInUser) {
      managePerm = (
        &lt;Tooltip id=""tooltip-top-start"" title=""Coming soon"" placement=""top""&gt;
          &lt;Typography className={this.props.classes.status}&gt;Manage users&lt;/Typography&gt;
        &lt;/Tooltip&gt;
      )
    } else {
      managePerm = (&lt;Typography className={this.props.classes.status}&gt;Manage users&lt;/Typography&gt;)
    }

    return (
      &lt;div className={this.props.classes.permFormContainer}&gt;
        &lt;Divider /&gt;
        &lt;form onSubmit={ handleSubmit(this.submit) }&gt;
        &lt;div className={this.props.classes.innerFormContainer}&gt;
            &lt;div className={this.props.classes.groupsContainer}&gt;
            &lt;br/&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt;
              &lt;Typography className={this.props.classes.status}&gt;View&lt;/Typography&gt;
              &lt;Field name=""viewPermissions"" component={Select}&gt;
                &lt;MenuItem value=""ownEntries""&gt;View own entries&lt;/MenuItem&gt;
                &lt;MenuItem value=""allEntries""&gt;View all entries&lt;/MenuItem&gt;
              &lt;/Field&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt;
            &lt;Tooltip id=""tooltip-top-start"" title=""Coming soon"" placement=""top""&gt;
              &lt;Typography className={this.props.classes.status}&gt;Add entries&lt;/Typography&gt;
            &lt;/Tooltip&gt;
            &lt;Field
              name=""addEntriesPermissions""
              component={Checkbox}
              normalize={v =&gt; !!v}
              disabled={true}
            /&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt; 
            &lt;Typography className={this.props.classes.status}&gt;Export data&lt;/Typography&gt;
            &lt;Field
              name=""exportPermissions""
              component={Checkbox}
              normalize={v =&gt; !!v}
            /&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt;
            {managePerm}
            &lt;Field
              name=""manageInvestPermissions""
              component={Checkbox}
              normalize={v =&gt; !!v}
              disabled={this.props.loggedInUser === true ? true : false}
            /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;Divider /&gt;
        &lt;div className={this.props.classes.actionButtons}&gt;

          &lt;Tooltip id=""tooltip-top-start"" title=""Coming soon"" placement=""top""&gt;
          &lt;Button color=""error"" className={this.props.classes.deleteButton}&gt;
            Delete account
          &lt;/Button&gt;
          &lt;/Tooltip&gt;
          &lt;div className={this.props.classes.saveAndCancelButtons}&gt;
            &lt;Button onClick={this.handleCancel} className={this.props.classes.cancelButton}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button type=""submit"" disabled={submitting} color=""primary"" className={this.props.classes.saveButton}&gt;
              Save
            &lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }
}

function mapStateToProps(state, ownProps) {
  return { 
    investigation: state.manage.savedInvest,
    investTitle: state.manage.savedInvestTitle
  };
}

const styles = theme =&gt; ({
});

const reduxFormmPermissions = reduxForm({
  enableReinitialize : true
})(PermissionsForm);

export default compose(
  withRouter,
  connect(mapStateToProps, {patchPermissionsAction}),
  withStyles(styles)
)(reduxFormmPermissions);
</code></pre>

<p>Thanks much for anybody who can help me get to the bottom of this. Real head-banger.</p>
","5335646","","5335646","","2018-05-14 16:03:30","2018-05-29 17:09:29","Redux form renders in unitialized state (and unable to be initialized) when reactively changing content on page","<reactjs><redux><redux-form>","1","6","","",""
"50346640","1","","","2018-05-15 09:24:25","","0","53","<p><strong>I have three .js files in my react native project:</strong></p>

<ul>
<li>App.js</li>
<li>LoginPage.js</li>
<li>RootNavigation.js</li>
</ul>

<p>My launcher screen is <strong>LoginPage.js</strong>  now i need to go to <strong>Rootnavigation.js</strong> .</p>

<p><strong>RootNavigation.js</strong> has import <strong>MainTabnavigator.js</strong></p>

<p><strong>App.js:</strong></p>

<pre><code>    import React from 'react';
import { Platform, StatusBar, StyleSheet, View } from 'react-native';
import { AppLoading, Asset, Font } from 'expo';
import { Ionicons } from '@expo/vector-icons';
import RootNavigation from './navigation/RootNavigation';
import LoginPage from './screens/LoginPage';
import { createSwitchNavigator, createStackNavigator } from 'react-navigation';



export class App extends React.Component {
  state = {
    isLoadingComplete: false,
  };


  render() {
    if (!this.state.isLoadingComplete &amp;&amp; !this.props.skipLoadingScreen) {
      return (
        &lt;AppLoading
          startAsync={this._loadResourcesAsync}
          onError={this._handleLoadingError}
          onFinish={this._handleFinishLoading}
        /&gt;
      );
    } else {
      return (
        &lt;View style={styles.container}&gt;
          {Platform.OS === 'ios' &amp;&amp; &lt;StatusBar barStyle=""default"" /&gt;}
          &lt;RootNavigation /&gt;
        &lt;/View&gt;
      );
    }
  }

  _loadResourcesAsync = async () =&gt; {
    return Promise.all([
      Asset.loadAsync([
        require('./assets/images/robot-dev.png'),
        require('./assets/images/robot-prod.png'),
      ]),
      Font.loadAsync({
        // This is the font that we are using for our tab bar
        ...Ionicons.font,
        // We include SpaceMono because we use it in HomeScreen.js. Feel free
        // to remove this if you are not using it in your app
        'space-mono': require('./assets/fonts/SpaceMono-Regular.ttf'),
      }),
    ]);
  };

  _handleLoadingError = error =&gt; {
    // In this case, you might want to report the error to your error
    // reporting service, for example Sentry
    console.warn(error);
  };

  _handleFinishLoading = () =&gt; {
    this.setState({ isLoadingComplete: true });
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
});
export default justsms = createStackNavigator(
{

 First: { screen: LoginPage },

 Second: { screen: App }

});
</code></pre>

<p><strong>LoginPage.js:</strong></p>

<pre><code>import React from 'react';
import {Image,  Platform,  ScrollView,  StyleSheet,  Text,  TouchableOpacity,  View, Button} from 'react-native';
export default class LoginPage extends React.Component {
  static navigationOptions={
    title:'Login Page'
  };
  NavigateActivityFunction = () =&gt;
  {
     this.props.navigation.navigate('Second');

  }
  render(){
    return(&lt;View style={styles.container}&gt;
     &lt;Button title='Tab Activity' onPress={this.NavigateActivityFunction}/&gt;
&lt;/View&gt;
);
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    justifyContent:'center'

  }
});
</code></pre>

<p>RootNavigation.js:</p>

<pre><code>import React from 'react';
import { Notifications } from 'expo';
import { createSwitchNavigator } from 'react-navigation';

import MainTabNavigator from './MainTabNavigator';
import registerForPushNotificationsAsync from '../api/registerForPushNotificationsAsync';

const AppNavigator = createSwitchNavigator({
  // You could add another route here for authentication.
  // Read more at https://reactnavigation.org/docs/en/auth-flow.html
  Main: MainTabNavigator,
});

export default class RootNavigation extends React.Component {
  componentDidMount() {
    this._notificationSubscription = this._registerForPushNotifications();
  }

  componentWillUnmount() {
    this._notificationSubscription &amp;&amp; this._notificationSubscription.remove();
  }

  render() {
    return &lt;AppNavigator /&gt;;
  }

  _registerForPushNotifications() {
    // Send our push token over to our backend so we can receive notifications
    // You can comment the following line out if you want to stop receiving
    // a notification every time you open the app. Check out the source
    // for this function in api/registerForPushNotificationsAsync.js
    registerForPushNotificationsAsync();

    // Watch for incoming notifications
    this._notificationSubscription = Notifications.addListener(this._handleNotification);
  }

  _handleNotification = ({ origin, data }) =&gt; {
    console.log(`Push notification ${origin} with data: ${JSON.stringify(data)}`);
  };
}
</code></pre>

<p><strong>MainTabNavigator.js:</strong></p>

<pre><code>import React from 'react';
import { Platform } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { createStackNavigator, createBottomTabNavigator } from 'react-navigation';

import TabBarIcon from '../components/TabBarIcon';
import HomeScreen from '../screens/HomeScreen';
import LinksScreen from '../screens/LinksScreen';
import SettingsScreen from '../screens/SettingsScreen';

const HomeStack = createStackNavigator({
  Home: HomeScreen,
});

HomeStack.navigationOptions = {
  tabBarLabel: 'Home',
  tabBarIcon: ({ focused }) =&gt; (
    &lt;TabBarIcon
      focused={focused}
      name={
        Platform.OS === 'ios'
          ? `ios-information-circle${focused ? '' : '-outline'}`
          : 'md-information-circle'
      }
    /&gt;
  ),
};

const LinksStack = createStackNavigator({
  Links: LinksScreen,
});

LinksStack.navigationOptions = {
  tabBarLabel: 'Links',
  tabBarIcon: ({ focused }) =&gt; (
    &lt;TabBarIcon
      focused={focused}
      name={Platform.OS === 'ios' ? `ios-link${focused ? '' : '-outline'}` : 'md-link'}
    /&gt;
  ),
};

const SettingsStack = createStackNavigator({
  Settings: SettingsScreen,
});

SettingsStack.navigationOptions = {
  tabBarLabel: 'Settings',
  tabBarIcon: ({ focused }) =&gt; (
    &lt;TabBarIcon
      focused={focused}
      name={Platform.OS === 'ios' ? `ios-options${focused ? '' : '-outline'}` : 'md-options'}
    /&gt;
  ),
};

export default createBottomTabNavigator({
  HomeStack,
  LinksStack,
  SettingsStack,
});
</code></pre>

<p>Here when i click on button in <strong>LoginPage.js</strong> it should go to tab activity . I tried <strong>importing</strong> <strong>MainTabNavigator.js</strong> in <strong>App.js</strong> but when i click on button nothing is happening. I would be glad if someone Help me in this issue.</p>
","6401556","","","","","2018-05-15 09:24:25","How to move from first screen(just with button to tabbed activity) to second screen(tab activity) in react native","<javascript><android><reactjs><react-native><react-navigation>","0","0","","",""
"50367067","1","50367566","","2018-05-16 09:26:58","","0","26","<p>I'm working on a captcha using reactjs and ant design. Its the code is working, its just there's a warning that I cant solve.</p>

<p>Looks like it will be a problem in the future.</p>

<p>Thanks,</p>

<p>hope you understand me.</p>

<blockquote>
  <p>Warning: Encountered two children with the same key, <code>u</code>. Keys should
  be unique so that components maintain their identity across updates.
  Non-unique keys may cause children to be duplicated and/or omitted —
  the behavior is unsupported and could change in a future version.</p>
</blockquote>

<p><a href=""https://codesandbox.io/s/yjq06nw6w1"" rel=""nofollow noreferrer"">SAMPLE CODE</a></p>

<pre><code>let numbers = [];
function NumberList() {
  var rand = Math.random()
    .toString(36)
    .substr(2, 4);
  var a = rand.split("""").join("","");
  var array = a.split("","");
  numbers = array;
  const listItems = numbers.map(number =&gt; (
    &lt;div key={number.toString()}&gt;{number}&lt;/div&gt;
  ));
  return &lt;div className=""randomChars""&gt;{listItems}&lt;/div&gt;;
}

// Captcha.
class Captcha extends Component {
  componentDidMount() {
    this.props.onRef(this);
  }
  componentWillUnmount() {
    this.props.onRef(undefined);
  }

  fetchCaptcha() {
    let concatNumbers = numbers.join("""");
    return concatNumbers;
  }
  render() {
    return (
      &lt;div className=""Captcha"" ref=""childref""&gt;
        &lt;NumberList /&gt;
      &lt;/div&gt;
    );
  }
</code></pre>
","5220270","","","","","2018-05-16 09:48:03","Remove warning on captcha using reactjs","<reactjs><captcha><antd>","1","0","","",""
"35295435","1","35300791","","2016-02-09 15:08:40","","0","440","<p>I'm running react-router 1.0.3</p>

<p>My aim is to intercept a user navigating away from a page and put up the standard browser confirm dialog.</p>

<p>On the Github page [1] the page says that the LifeCycle mixin is deprecated. (It looks like I could use it but perhaps should not if it is being deprecated).</p>

<p>From this page [2] it appears that in v.2 one can use the new feature router.setRouteLeaveHook (which looks good). This will set up listenBeforeLeavingRoute for you (and unbind it).</p>

<p>So: for version 1.0.3 what should I use to put a hook into the leavepage transition event? It looks like not the LifeCycle mixin. But setRouteLeaveHook is not yet available. I should perhaps implement it manually; like this: @props.history.listenBeforeLeavingRoute(@props.route, callback)? If I do do I need to manually remove the listener in componentWillUnmount? (I believe so). </p>

<p>Also - is v 2.0.0 in production? if I just run npm install I get version 1.0.3</p>

<p>(React-Router is great but the problem is that the docs always seem to be out of synch with the current release. The producers of it don't seem to see documentation as an integral part of the software; which, to my mind it is).</p>

<ol>
<li><a href=""https://github.com/rackt/react-router/blob/master/docs/API.md"" rel=""nofollow"">https://github.com/rackt/react-router/blob/master/docs/API.md</a></li>
<li><a href=""https://github.com/rackt/react-router/blob/master/upgrade-guides/v2.0.0.md#mixins-are-deprecated"" rel=""nofollow"">https://github.com/rackt/react-router/blob/master/upgrade-guides/v2.0.0.md#mixins-are-deprecated</a></li>
</ol>
","","user911625","","user911625","2016-02-09 15:19:51","2016-02-09 19:40:57","React-Router Lifecycle mixin - depreacted? What to use instead for confirming navigation in v1.0.3?","<react-router>","1","0","","",""
"44207684","1","44207827","","2017-05-26 18:03:35","","1","463","<p>I keep getting this warning whenever my internet connection is bad (I'm not sure even if this the right cause for this to happen). 
I'm getting this in the pages that displays data from Firebase database in react native application (iOS/android).
PS: I'm not considering to make the offline mode (it's not a requirement).
I'm sharing with you the code I'm using in one of these pages (it's very similar in all pages) </p>

<p><strong>Code</strong></p>

<pre><code>    constructor(props) {
            super(props);
            this.state = {
                dataSource: new ListView.DataSource({
                    rowHasChanged: (row1, row2) =&gt; row1 !== row2,
                })
            };

            this.itemsRef = this.getRef().child('path');

        }

        getRef() {
            return firebaseApp.database().ref();
        }
        componentDidMount() {
            this.listenForItems(this.itemsRef);
        }
        listenForItems(itemsRef) {

            itemsRef.on('value', (snap) =&gt; {
                if (snap.val()) {
                    var items = [];
                    snap.forEach((child) =&gt; {
                        items.push({
                            text : child.val().text,
                            title: child.val().title,
                            key: child.key
                        });
                    });

 this.setState({dataSource: this.state.dataSource.cloneWithRows(items)});
                }

            });

        }

        render() {
            return (
                &lt;View&gt;
                    &lt;ListView
                        automaticallyAdjustContentInsets={true}
                        dataSource={this.state.dataSource}
                        renderRow={this._renderItem.bind(this)}/&gt;
                &lt;/View&gt;

            );
        }

        _renderItem(item) {
            return (
                &lt;View&gt;
                    &lt;Text&gt;{item.title}&lt;/Text&gt;
                    &lt;Text&gt;{item.text}&lt;/Text&gt;
                &lt;/View&gt;
            );
        }
    }
</code></pre>

<p>and here is the warning I keep getting : <a href=""https://i.stack.imgur.com/zrbaL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zrbaL.png"" alt=""enter image description here""></a></p>

<p>It does mention the name of the component but I still don't know what might be the reason for this </p>

<p><strong>UPDATE:</strong> I tried this proposed solution : </p>

<pre><code>componentWillUnmount() {
        this.itemRef.off();
    }
</code></pre>

<p>In fact I have a back button that changes from one page to another (each page has her own path and data extracted from Firebase but with similar code) and I get this error: <code>this.itemRef</code> is different in each page. 
But I get this error : <a href=""https://i.stack.imgur.com/JnKT2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JnKT2.png"" alt=""enter image description here""></a>
Any idea or suggestion .. thank you </p>
","3521011","","3521011","","2017-05-26 21:44:35","2017-05-26 21:50:16","setState: can only update a mounted or mounting component react native /undefined is not an object","<javascript><firebase><react-native><try-catch><warnings>","1","0","0","",""
"44024527","1","","","2017-05-17 12:12:42","","2","319","<p>I am implementing internationalization in a react application with the <a href=""https://github.com/yahoo/react-intl"" rel=""nofollow noreferrer"">react-intl</a> library. The language can be triggered in different components, so I used the <a href=""https://github.com/mroderick/PubSubJS"" rel=""nofollow noreferrer"">pubsub-js</a> library to publish an event each time the language is changed, and subscrib to this event in my central App Component, which then switches the locale and messages which are displayed in the whole application. </p>

<p>My question concerns writing tests with <a href=""https://facebook.github.io/jest/"" rel=""nofollow noreferrer"">jest</a> and <a href=""https://github.com/airbnb/enzyme"" rel=""nofollow noreferrer"">enzyme</a> which would trigger the language change and have my App component updated with the language, so I can assert that the state variables dealing with the locale are correctly updated. Is it possible to trigger such events, or am I on a wrong path here? My code is listed below</p>

<pre><code>//Relevant parts of the app component


class App extends Component {
  constructor(props) {
    super(props);
    this.localeStore = new LocaleStore();
    this.state = {
      locale: this.localeStore.locale(),
      messages: this.localeStore.messages()
    };
  }

  componentDidMount() {
    PubSub.subscribe(LocaleEvent.change, (event, locale) =&gt; {
      this.setState({locale: locale.code, messages: locale.messages})
    });
  }

  componentWillUnmount() {
    PubSub.unsubscribe(LocaleEvent.change);
  }

  render() {
    return (
      &lt;IntlProvider key={ this.state.locale } locale={ this.state.locale } messages={ this.state.messages }&gt;
        &lt;div&gt;
          ...
        &lt;/div&gt;
      &lt;/IntlProvider&gt;
    );
  }
}

// App.test.js

describe('App', () =&gt; {
  it('renders without crashing', () =&gt; {
    const div = document.createElement('div');
    mount(&lt;App /&gt;);
  });

  // This test fails, because the event is not published and the state does not change
  it('correctly switches the language when the language change event is triggered', () =&gt; {
    let app = mount(&lt;App /&gt;);

    PubSub.publish('locale.change', {code: 'en', messages: {}});

    expect(app.state().locale).toEqual('en');
  });
});
</code></pre>
","199072","","","","","2017-05-18 15:40:42","How to trigger a Pubsub.js event in a jest test for react.js","<javascript><reactjs><publish-subscribe><jestjs><enzyme>","1","4","","",""
"43291169","1","43291243","","2017-04-08 06:59:49","","1","44","<p>I have set a simple example here: <a href=""https://www.webpackbin.com/bins/-KhBJPs2jLmpQcCTSRBk"" rel=""nofollow noreferrer"">https://www.webpackbin.com/bins/-KhBJPs2jLmpQcCTSRBk</a></p>

<p>This is my class in the question:</p>

<pre><code>import React, { Component, PropTypes } from 'react';

import { Redirect } from 'react-router-dom';

class RedirectMessage extends Component {

  componentWillMount () {
    const { timeToRedirect } = this.props;
    const time = timeToRedirect || 5000;
    console.log(`timer is set to ${time}`)
    this.timer = setInterval(this.setoffRedirect.bind(this), time)
  }

  componentWillUnmount () {
    clearInterval(this.timer);
  }

  setoffRedirect () {
    console.log('setoffRedirect');
    clearInterval(this.timer);
    this.setState({startRedirect: true})
  }

  getDestination() {
    const { destination }  = this.props;
    return destination || '/';
  }

  render() {
    const {
      message,
      startRedirect
    } = this.props;

    console.log(`setoffRedirect &gt;&gt;&gt; ${startRedirect}`);
    if (startRedirect) {
      return (
        &lt;Redirect to={this.getDestination()} /&gt;
      )
    }
    return (
      &lt;div &gt;
        {message}
      &lt;/div&gt;
    );
  }

}

export default RedirectMessage;
</code></pre>

<p>What I want to achieve is to display a message before I redirect to another url</p>

<p>Here are the logic:</p>

<ol>
<li>set up a timer in <code>componentWillMount</code></li>
<li>When the timer callback is called, it uses <code>setState</code> to set <code>startRedirect</code> to true</li>
<li>In <code>render</code> if <code>startRedirect</code> is true, a <code>Redirect</code> tag will be rendered can cause url redirect</li>
</ol>

<p>However the problem is the <code>startRedirect</code> remains undefined even after the timer callback is called. What have I missed?</p>
","58129","","","","","2017-04-08 07:14:27","Unable to read a state from a reactjs component after it is set","<reactjs><ecmascript-6><jsx>","1","2","1","",""
"35519738","1","","","2016-02-20 05:55:00","","0","80","<p>I have three questions:</p>

<ol>
<li><p>There is apparently an unrecognized token in my <code>_dismiss</code> function. What am I doing wrong? Chrome points to the line <code>progress.currentStep: 4,</code> specifically a couple of spaces before <code>progress.currentStep:4,</code>. Any ideas why?</p></li>
<li><p>I'm trying to trigger a state change when the <code>esc</code> key is pressed. I want to change the state so the returned things are changed. In the return statement there are a bunch of if/else statements, displaying different elements depending on if the <code>currentStep == 1</code> or 2, or 3. FYI <code>4 == numSteps</code>, so I want nothing to render after the escape key has been pressed. Is this the proper way to do it? The listener is added when the component has rendered, then removed when component is unmounted. My only concern is changing the state would make the component fresh and call <code>reconcileState</code>, which leads to my last question --- </p></li>
<li><p>When is <code>reconcileState</code> called? The react docs on reconciliation wasn't very clear, and most docs on the lifecycle of components focused on mounting and un-mounting. </p>

<pre><code>import xContainerStore ... etc.
class xContainer extends Container {
constructor(props) {
        super(props);
        this._dismiss = this._dismiss.bind(this);
}

componentDidMount() {
        super.componentDidMount();
        document.addEventListener(""keydown"", this._dismiss, false);
}

componentWillUnmount() {
        super.componentWillUnmount();
        document.removeEventListener(""keydown"", this._dissmiss, false);
}

reconcileState(state, props) {
        Object.assign(state, props);
        state.progress = xContainerStore.progress;
        state.currentUser = xContainerStore.currentUser;
}

_dismiss(event) {
        if (event.keyCode == 27) {
                this.setState({
                        progress.currentStep: 4, // when you press esc, state is changed and some modal now should not show up.
                });
        }
        console.log(""esc pressed"");
}

stores() { return [OnboardingStore]; }

render() {
        if (this.state.progress.currentStep &gt;= this.state.progress.numSteps) return null;

        return (
                some stuff depending on state
            ...
       )
</code></pre>

<p>}</p></li>
</ol>
","4604899","","","","","2016-02-20 06:03:16","reactjs formatting issue + keypress event","<javascript><reactjs>","1","0","","",""
"45363008","1","","","2017-07-28 00:24:01","","0","243","<p>Since React uses lifecycle methods and the virtual dom how can I detect when my video has finished playing. I found another question like this on stackoverflow that suggested to use componentWillUnmount but there's no point at which I remove the video from the dom, so componentWillUnmount won't get fired... </p>

<p>How can I detect when video finished playing react? </p>
","8332788","","","","","2018-06-08 22:22:50","How can I detect when video finished playing react?","<reactjs>","1","0","","",""
"44320777","1","44325666","","2017-06-02 04:25:47","","0","925","<p>My markers won't render on the map. I initially had a stateless functional component but changed to a class to use <code>this.forceUpdate()</code> and it still didn't work. What am I doing wrong? I have tested on both Android and iOS real devices. The map is showing but not the markers. Could it be that the map is appearing on top of the markers, like a <code>zIndex</code> issue? I hardcoded a <code>marker</code> there to be sure the problem isn't with my <code>props.markers</code></p>

<pre><code>import { StyleSheet } from 'react-native'
import React, { Component } from 'react'
import MapView from 'react-native-maps'
import { connect } from 'react-redux'
import {
  Button,
  Container
} from 'native-base'

import selectMarkers from './markers.selector'

import { updateRegion } from './map.action'
import Icon from 'react-native-vector-icons/FontAwesome'
import { toggleMenu } from '../search-page/searchPage.action'
import mapStyle from './style'

const mapStateToProps = (state) =&gt; ({
  region: state.get('map').get('region'),
  markers: selectMarkers(state)
})

const mapDispatchToProps = (dispatch) =&gt; ({
  onRegionChange: (region) =&gt; {
    dispatch(updateRegion(region))
  },
  onToggleMenuClick: () =&gt; {
    dispatch(toggleMenu())
  }
})

class Map extends Component {

  componentDidMount() {
    const { store } = this.context
    this.unsubscribe = store.subscribe(() =&gt; { })
    this.forceUpdate()
  }

  componentWillUnmount() {
    this.unsubscribe()
  }

  render() {
  console.log('map')
  console.log('markers', this.props.markers)
    return (
      &lt;Container&gt;
        &lt;MapView
          style={styles.map}
          region={{
            latitude: this.props.region.latitude,
            longitude: this.props.region.longitude,
            latitudeDelta: this.props.region.latitudeDelta,
            longitudeDelta: this.props.region.longitudeDelta,
          }}
        &gt;
          {
            this.props.markers.map(marker =&gt; {
              return (
                &lt;MapView.Marker
                  onLoad={() =&gt; this.forceUpdate()}
                  coordinate={{ latitude: marker.latitude, longitude: marker.longitude }}
                  title={marker.name}
                /&gt;
              )
            })}

          &lt;MapView.Marker
            coordinate={{ latitude: 174.7666099, longitude: -36.8457991 }}
            title={""title""}
            description={""description""}
            onLoad={() =&gt; this.forceUpdate()}
            key={1}
          /&gt;
        &lt;/MapView&gt;
        &lt;Button
          small
          icon
          style={mapStyle.toggleMenuButton}
          onPress={() =&gt; this.props.onToggleMenuClick()}&gt;
          &lt;Icon name=""sliders"" size={20} color=""#FFFFFF"" /&gt;
        &lt;/Button&gt;
      &lt;/Container&gt;
    )
  }
}

Map.contextTypes = {
  store: React.PropTypes.object
}

Map.propTypes = {
  region: React.PropTypes.shape({
    latitude: React.PropTypes.number,
    longitude: React.PropTypes.number,
    latitudeDelta: React.PropTypes.number,
    longitudeDelta: React.PropTypes.number
  }).isRequired,
  onRegionChange: React.PropTypes.func.isRequired,
  onToggleMenuClick: React.PropTypes.func.isRequired,
  markers: React.PropTypes.array
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Map)

const styles = StyleSheet.create({
  map: {
    ...StyleSheet.absoluteFillObject,
    zIndex: -1
  }
})
</code></pre>
","3935156","","3935156","","2017-06-02 05:03:42","2017-06-02 09:39:40","react-native-maps markers not displayed on map","<javascript><react-native><redux><react-native-ios><react-native-maps>","1","0","","",""
"44094487","1","44094613","","2017-05-21 07:56:45","","2","1673","<p>I try to add hammer js to my reactjs component and my component looks as it follows</p>

<pre><code>import React from 'react';
import _ from 'underscore';
import Hammer from 'hammerjs';


class Slider extends React.Component {

    constructor(props) {
        super(props)
        this.updatePosition = this.updatePosition.bind(this);
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);

        this.state = {
            images: [],
            slidesLength: null,
            currentPosition: 0,
            slideTransform: 0,
            interval: null
        };
    }


    next() {
        console.log('swipe')
        const currentPosition = this.updatePosition(this.state.currentPosition - 10);
        this.setState({ currentPosition });

    }

    prev() {

        if( this.state.currentPosition !== 0) {
            const currentPosition = this.updatePosition(this.state.currentPosition + 10);
            this.setState({currentPosition});
        }
    }


    componentDidMount() {

        this.hammer = Hammer(this._slider)
        this.hammer.on('swipeleft', this.next());
        this.hammer.on('swiperight', this.prev());


    }

    componentWillUnmount() {
        this.hammer.off('swipeleft', this.next())
        this.hammer.off('swiperight', this.prev())
    }


    handleSwipe(){
        console.log('swipe')
    }

    scrollToSlide() {

    }

    updatePosition(nextPosition) {
        const { visibleItems, currentPosition } = this.state;
        return nextPosition;
    }

    render() {
        let {slides, columns} = this.props
        let {currentPosition} = this.state
        let sliderNavigation = null

        let slider = _.map(slides, function (slide) {
            let Background = slide.featured_image_url.full;
            if(slide.status === 'publish')
                return &lt;div className=""slide"" id={slide.id}  key={slide.id}&gt;&lt;div className=""Img"" style={{ backgroundImage: `url(${Background})` }} data-src={slide.featured_image_url.full}&gt;&lt;/div&gt;&lt;/div&gt;
        });

        if(slides.length &gt; 1 ) {

          sliderNavigation =   &lt;ul className=""slider__navigation""&gt;
                &lt;li data-slide=""prev"" className="""" onClick={this.prev}&gt;previous&lt;/li&gt;
                &lt;li data-slide=""next"" className="""" onClick={this.next}&gt;next&lt;/li&gt;
            &lt;/ul&gt;
        }

        return &lt;div ref={
            (el) =&gt; this._slider = el
        } className=""slider-attached""
                    data-navigation=""true""
                    data-columns={columns}
                    data-dimensions=""auto""
                    data-slides={slides.length}&gt;
                    &lt;div className=""slides"" style={{ transform: `translate(${currentPosition}%, 0px)`, left : 0 }}&gt; {slider} &lt;/div&gt;

                    {sliderNavigation}
            &lt;/div&gt;
    }
}

export default Slider;
</code></pre>

<p>the problem is like on tap none of the components method are fired.
How do I deal in this case with the hammer js events in <code>componentDidMount</code></p>
","1831740","","","","","2017-05-21 08:10:28","adding hammerjs to a react js component properly","<reactjs><events><components><hammer.js>","1","0","","",""
"44464473","1","","","2017-06-09 18:22:38","","0","355","<p>So I have some react code that I am compiling with webpack. Part of this code consists of getting the value of a cookie used for authentication via JSON Web Tokens. The problem I'm having with this I don't have access to the response variable. Any help would be awesome, thanks!</p>

<pre><code>var Cookies = require('cookies');
var cookieParser = require('cookie-parser');

var React = require('react');
var ReactDOM = require('react-dom');
import { Router, Route, browserHistory, Link } from 'react-router';

import 'whatwg-fetch'

var name = document.getElementById('name').innerHTML;   



  var start = false;
  var Assets = React.createClass({
    getInitialState: function(){
      return {
        assets: [],
        secondsElapsed: 0
      }
    },
    tick: function() {
      if(start === true){
        console.log(name);

        var myHeaders = new Headers();

        var token = new Cookies(req,res).get('access_token'); //NEED ACCESS TO RES HERE

        myHeaders.append('acess_token', token);

        var myInit = { method: 'GET',
               headers: myHeaders};

        fetch('/api/user/all/?name='+name, myInit).then(function(data){
          return data.json();
        }).then( json =&gt; {
          this.setState({
              assets: json
            });
        });
    }
    },
    componentDidMount: function() {
      this.interval = setInterval(this.tick, 1000);
    },
    componentWillUnmount: function() {
      clearInterval(this.interval);
    },
    render: function(){
      var assets = this.state.assets;
      assets = assets.map(function(asseti,index){
        return(
          asseti.map(function(asset, index){
            return(
              &lt;li key={index}&gt;
                        &lt;span className={asset.active}&gt;&lt;/span&gt;
                        &lt;span&gt;{asset.name}&lt;/span&gt;
                        &lt;span &gt;{asset.description}&lt;/span&gt;
              &lt;/li&gt;
            )
          })
        )
      });
      return(
        &lt;div&gt;
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;input type=""submit"" value=""Find assets"" /&gt;
          &lt;/form&gt;
          {assets}
        &lt;/div&gt;
      );
    },
    handleSubmit: function(e){
      e.preventDefault();
      start = true;

      fetch('/api/user/all/?name='+name).then(function(data){
        return data.json();
      }).then( json =&gt; {
        this.setState({
          assets: json
        });
      });
    }
  });

ReactDOM.render(&lt;Assets /&gt;, document.getElementById('assets'));
</code></pre>
","4087009","","2313887","","2017-07-07 13:27:24","2017-12-01 01:40:45","Access response object in react code to get value of a cookie","<reactjs><cookies><webpack>","1","0","","",""
"44416337","1","","","2017-06-07 15:03:22","","2","437","<p>I am using react-native-fcm component in my RN app for push notifications.
It is working perfect but I notice an issue that is driving me crazy, when we
release a new version on play store and the app is updated the token expires,
we have already saved the old token and we send notifications to that fcm token,
so users stops receiving notifications.</p>

<p>If the user log out and log in again I get the new token but of course I can't force to my users to do that, in the component examples I found a refresh token event but it's not working, do you know why the event is not receiving the new token when it refresh? What I am doing wrong? Thanks.</p>

<p>Here is my code (I deleted some parts for readability):</p>

<pre><code>import React, { Component } from 'react';
import { ScrollView, View, Text, Linking, TouchableOpacity, AppState } from 'react-native';
import { connect } from 'react-redux';
import FCM, { FCMEvent } from 'react-native-fcm';
import { getTopNotification, updateUser } from '../api';
import { topNotificationChanged, logOut } from '../actions';

class Home extends Component {
  constructor() {
    super();
    this.onLogOutPress.bind(this);
  }

  state = { topNotificationLink: '', appState: AppState.currentState };

  componentDidMount() {
    AppState.addEventListener('change', this.handleAppStateChange);
    this.refreshTokenListener = FCM.on(FCMEvent.RefreshToken, fcmToken =&gt; {
      updateUser(this.props.user.id, this.props.user.token, { fcmToken });
    });
  }

  componentWillUnmount() {
    AppState.removeEventListener('change', this.handleAppStateChange);
    this.refreshTokenListener.remove();
  }

  handleAppStateChange = (nextAppState) =&gt; {
    if (this.state.appState.match(/inactive|background/) &amp;&amp; nextAppState === 'active') {
      this.onFocus();
    }
    this.setState({ appState: nextAppState });
  }

  render() {
    return (
      &lt;ScrollView&gt;
        {this.renderTopNotification()}
        {this.renderMenuOptions()}
      &lt;/ScrollView&gt;
    );
  }
}

const mapStateToProps = state =&gt; {
  return {
    user: state.auth.user,
    lang: state.auth.lang,
    topNotificationText: state.main.topNotificationText
  };
};

export default connect(mapStateToProps, { topNotificationChanged, logOut })(Home);
</code></pre>
","1356311","","","","","2017-06-07 15:03:22","react-native-fcm token refresh when app is updated","<javascript><firebase><react-native><firebase-cloud-messaging>","0","2","","",""
"27042456","1","","","2014-11-20 14:48:01","","0","623","<p>I am using a react-bootstrap modal for login.
The user hits 'Log in' and a request is sent to our server.
If the login fails - we set the state - LOGIN_FAILED</p>

<p>At this point the react application re-renders.</p>

<p>The reason the login failed is available in state as an error message e.g. ""Incorrect username or password"". Since the modal is already active, we re-render it with the error message below the 'Log in' button.</p>

<p>This works fine - apart from the very first time you use the modal(or after refreshing the page)</p>

<p>In this case the modal disappears.</p>

<p>I debugged it and see this code is executed and the modal gets unmounted:</p>

<p><strong>OverlayMixin.js</strong></p>

<pre><code>componentWillUnmount: function () {
    this._unrenderOverlay();
    if (this._overlayTarget) {
      this.getContainerDOMNode()
        .removeChild(this._overlayTarget);
      this._overlayTarget = null;
    }
  },
</code></pre>

<p>.
.
.</p>

<pre><code>_unrenderOverlay: function () {
    React.unmountComponentAtNode(this._overlayTarget);
    this._overlayInstance = null;
  },
</code></pre>

<p>Has anyone come across this before? I am considering using a OverlayMixin to see if it makes any difference but would like to know the root cause.</p>

<p>Any help appreciated.</p>

<p>Here is the LoginModal react component:</p>

<pre><code>var LoginModal = React.createClass({

propTypes:{
    errorText: React.PropTypes.string,
    onRequestHide: React.PropTypes.func,
    state: React.PropTypes.string
},

getInitialState: function() {
    return {
        fbNotAuthorisedOn: false,
       fbLoginErrorOn: false,
        valid: false,
        showErrors: false
    };
},

componentWillReceiveProps: function(nextProps) {
    if(this.props.state === 'LOGIN_FAILED'){
        this.setState({
          showErrors: true
        });
    }
},

_onSubmit: function(e) {
    if(e &amp;&amp; typeof e !== 'undefined') {
        e.stopPropagation();
        e.preventDefault();
    }
    var email = this.refs.email.getValue();
    var password = this.refs.password.getValue();

    UserAPIUtils.login(email, password);
},

_onKeyDown: function(event) {
    if (event.keyCode === AppConstants.ENTER_KEY_CODE &amp;&amp; this.state.valid) {
        this._onSubmit(event);
    }
},

_handleHide: function() {
    this.refs.loginModal.props.onRequestHide();
},

_handleFBNotAuthorised: function(message) {
    Router.transitionTo('facebook-error', { errorMessage:      AppConstants.FACEBOOK_INSUFFICENT_PERMISSIONS_ERROR });
},

_handleFBLoginError: function(errorMessage) {
    Router.transitionTo('facebook-error', { errorMessage: errorMessage});
},

_onChange: function(){
    if(this.refs.email.getValue() &amp;&amp; this.refs.password.getValue()){
        this.setState({valid:true});
    }else{
        this.setState({valid:false});
    }
},

render: function () {
var errorText = '';
if(this.state.showErrors){
    if(this.props.errorText){
        errorText = this.props.errorText;
    }else{
        errorText = 'Login failed, please try again';
    }
}

return this.transferPropsTo(
    &lt;Modal className=""signPopUpModal""
        title=""Log In""
        backdrop={true}
        animation={true}
        ref=""loginModal""
        id=""loginModal""
        className=""signPopUpModal""&gt;
          &lt;div className=""modal-body""&gt;
            &lt;form role=""form"" onSubmit={this._onSubmit}&gt;
                &lt;Input id=""email""
                    ref=""email""
                    type=""email""
                    placeholder=""Enter your email address""
                    groupClassName=""group-class""
                    wrapperClassName=""wrapper-class""
                    labelClassName=""label-class""
                    addonBefore={Glyphicon({glyph:'user'})}
                    onKeyDown={this._onKeyDown}
                    onChange={this._onChange}/&gt;
                &lt;Input id=""password"" type=""password"" ref=""password""
                    placeholder=""Enter your password""
                    groupClassName=""group-class""
                    wrapperClassName=""wrapper-class""
                    labelClassName=""label-class""
                    addonBefore={Glyphicon({glyph:'lock'})}
                    onKeyDown={this._onKeyDown}
                    onChange={this._onChange}/&gt;
            &lt;div className=""row""&gt;
                {errorText}
            &lt;/div&gt;
            &lt;div className=""row""&gt;
              &lt;div className=""col-md-3 col-xs-6""&gt;
                &lt;div className=""remember-me link""&gt;
                    &lt;input type=""checkbox""&gt;Remember me&lt;/input&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div className=""col-md-3 col-md-offset-6 col-xs-6""&gt;
                &lt;div className=""pass link""&gt;
                    &lt;ResetPasswordModalTrigger modal={this.transferPropsTo(&lt;ResetPasswordModal
                        closeLoginHandler={this._handleHide} /&gt;)}&gt;
                        &lt;a href=""#""&gt;Forgot Password?&lt;/a&gt;
                    &lt;/ResetPasswordModalTrigger&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=""row""&gt;
              &lt;Button id=""loginBtn"" type=""submit""
                    ref=""loginButton""
                    disabled={!this.state.valid}
                    block={true}
                    className=""btn-highlight col-md-12""&gt;Log in&lt;/Button&gt;
            &lt;/div&gt;
            &lt;div className=""row""&gt;
              &lt;p className=""or""&gt;or&lt;/p&gt;
            &lt;/div&gt;
            &lt;div className=""row""&gt;
                &lt;FacebookLogin  closeLoginHandler={this._handleHide}
                                onNotAuthorizedResponse={this._handleFBNotAuthorised}
                                onErrorResponse={this._handleFBLoginError} /&gt;
            &lt;/div&gt;
            &lt;div className=""row signup""&gt;
                &lt;p&gt;Don't have an account?
                &lt;RegisterModalTrigger modal={&lt;RegisterModal closeLoginHandler={this._handleHide} /&gt;}&gt;
                    &lt;a href=""#""&gt;Sign Up&lt;/a&gt;
                &lt;/RegisterModalTrigger&gt;
            &lt;/p&gt;
            &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/Modal&gt;
);

}
});

module.exports = LoginModal ;`
</code></pre>
","3350887","","717383","","2015-03-27 15:30:04","2015-03-27 15:30:04","reactjs bootstrap modal does not re-render the first time","<modal-dialog><render><reactjs><react-bootstrap>","1","1","","",""
"36271297","1","36375955","","2016-03-28 21:13:59","","2","1033","<p>Using Meteor 1.3, I have a react component wrapped with tracker-react. I set it up like the example on <a href=""https://github.com/ultimatejs/tracker-react#implementation"" rel=""nofollow"">tracker-react github</a> </p>

<pre><code>class TaskIndex extends TrackerReact(React.Component) {

  constructor() {
    super();
    this.state = {
      subscription: {
        tasks: Meteor.subscribe(""tasks"", Meteor.userId() )
      }
    }
  }

  componentWillUnmount() {
      this.state.subscription.tasks.stop();
  }

  getTasks() {
      return  Tasks.find().fetch()
  }

  render() {
   //... displays the tasks
  }

}
</code></pre>

<p>The subscription passes the current user to get the right tasks. The problem is, when I logout, and Meteor.userId() becomes undefined, the subscription is not updated. The tasks stay visible until I refresh the page. The reverse is true when I login: no tasks appear when Meteor.userId() becomes valid.</p>

<p>If instead I put the subscription in the getTasks() method as below, it behaves correctly, but feels wrong. Should the subscription be in one of the lifecycle methods? How do I stop the subscription, do I even need to?</p>

<pre><code>  getTasks() {
      Meteor.subscribe(""tasks"", Meteor.userId() );
      return  Tasks.find().fetch()
  }
</code></pre>

<p>Thanks</p>
","179412","","","","","2016-08-03 18:35:46","Where should I put the Meteor subscription in a tracker-react container?","<javascript><meteor><reactjs><ecmascript-6>","2","0","","",""
"50106269","1","","","2018-04-30 18:34:12","","1","368","<p>I'm trying to show push notification when app is closed so I'm setting up the push notification with react-native-firebase with <a href=""https://rnfirebase.io/docs/v4.0.x/notifications/android"" rel=""nofollow noreferrer"">this docs</a> </p>

<p>I set AndroidManifest.xml as described in docs</p>

<pre><code>    &lt;manifest xmlns:android=""http://schemas.android.com/apk/res/android""
    package=""com.moonsite.sqlivetrivia""
    android:versionCode=""1""
    android:versionName=""1.0""&gt;

    &lt;uses-permission android:name=""android.permission.INTERNET"" /&gt;
    &lt;uses-permission android:name=""android.permission.ACCESS_NETWORK_STATE"" /&gt;
    &lt;uses-permission android:name=""android.permission.SYSTEM_ALERT_WINDOW""/&gt;
    &lt;uses-permission android:name=""android.permission.RECEIVE_BOOT_COMPLETED"" /&gt;
    &lt;uses-permission android:name=""android.permission.VIBRATE"" /&gt;

    &lt;uses-sdk
        android:minSdkVersion=""16""
        android:targetSdkVersion=""22"" /&gt;

    &lt;application
      android:name="".MainApplication""
      android:allowBackup=""true""
      android:label=""@string/app_name""
      android:icon=""@mipmap/ic_launcher""
      android:theme=""@style/AppTheme""&gt;
      &lt;receiver android:name=""io.invertase.firebase.notifications.RNFirebaseNotificationReceiver""/&gt;
  &lt;receiver android:enabled=""true"" android:exported=""true""  android:name=""io.invertase.firebase.notifications.RNFirebaseNotificationsRebootReceiver""&gt;
    &lt;intent-filter&gt;
      &lt;action android:name=""android.intent.action.BOOT_COMPLETED""/&gt;
      &lt;action android:name=""android.intent.action.QUICKBOOT_POWERON""/&gt;
      &lt;action android:name=""com.htc.intent.action.QUICKBOOT_POWERON""/&gt;
      &lt;category android:name=""android.intent.category.DEFAULT"" /&gt;
    &lt;/intent-filter&gt;
  &lt;/receiver&gt;
  &lt;meta-data
    android:name=""com.google.firebase.messaging.default_notification_icon""
    android:resource=""@drawable/ic_stat_ic_notification"" /&gt;
      &lt;meta-data
    android:name=""com.google.firebase.messaging.default_notification_color""
    android:resource=""@color/colorAccent"" /&gt;
       &lt;!-- 

      &lt;meta-data
    android:name=""com.google.firebase.messaging.default_notification_channel_id""
    android:value=""@string/default_notification_channel_id""/&gt; --&gt;
      &lt;service android:name=""io.invertase.firebase.messaging.RNFirebaseMessagingService""&gt;
        &lt;intent-filter&gt;
        &lt;action android:name=""com.google.firebase.MESSAGING_EVENT"" /&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;
    &lt;service android:name=""io.invertase.firebase.messaging.RNFirebaseInstanceIdService""&gt;
        &lt;intent-filter&gt;
        &lt;action android:name=""com.google.firebase.INSTANCE_ID_EVENT""/&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;
      &lt;service android:name=""io.invertase.firebase.messaging.RNFirebaseBackgroundMessagingService"" /&gt;

      &lt;activity
        android:name="".MainActivity""
        android:label=""@string/app_name""
        android:configChanges=""keyboard|keyboardHidden|orientation|screenSize""
        android:windowSoftInputMode=""adjustResize""
        android:launchMode=""singleTop""

        &gt;
        &lt;intent-filter&gt;
            &lt;action android:name=""com.google.firebase.MESSAGING_EVENT"" /&gt;
            &lt;action android:name=""android.intent.action.MAIN"" /&gt;
            &lt;category android:name=""android.intent.category.LAUNCHER"" /&gt;
        &lt;/intent-filter&gt;
      &lt;/activity&gt;
      &lt;activity android:name=""com.facebook.react.devsupport.DevSettingsActivity"" /&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>

<p>then I wrote the code in react native</p>

<pre><code>    import React, { Component } from 'react'
import { View } from 'react-native'
import { Input, Text, Button } from '../Components'
import type { RemoteMessage } from 'react-native-firebase'
import firebase from 'react-native-firebase'
import type { Notification, NotificationOpen } from 'react-native-firebase';

export default class TestComponent extends Component {

  async componentDidMount() {
    await this.SetUpAuth();
    await this.SetUpMessaging();
    this.notificationOpenedListener = firebase.notifications().onNotificationOpened((notificationOpen: NotificationOpen) =&gt; {
      // Get the action triggered by the notification being opened
      const action = notificationOpen.action;
      // Get information about the notification that was opened
      const notification: Notification = notificationOpen.notification;
    });
    const notificationOpen: NotificationOpen = await firebase.notifications().getInitialNotification();
    if (notificationOpen) {
      console.log(notificationOpen)
      // App was opened by a notification
      // Get the action triggered by the notification being opened
      const action = notificationOpen.action;
      // Get information about the notification that was opened
      const notification: Notification = notificationOpen.notification;
    }


  }
  componentWillUnmount() {

  }


  async SetUpAuth() {
    const credential = await firebase.auth().signInAnonymouslyAndRetrieveData();
    if (credential) {
      console.log('default app user -&gt;', credential.user.toJSON());
    } else {
      console.error('no credential');
    }
  }
  async SetUpMessaging() {
    this.notification2 = new firebase.notifications.Notification()
      .setNotificationId('notificationId')
      .setTitle('My notification title')
      .setBody('My notification body')
      .android.setChannelId('test')
      .android.setClickAction('action')
      .setData({
        key1: 'value1',
        key2: 'value2',
      });

    this.notification2
      .android.setChannelId('channelId')
      .android.setSmallIcon('ic_launcher');
    console.log('assa')

    onTokenRefreshListener = firebase.messaging().onTokenRefresh(fcmToken =&gt; {
      console.log('token generated -&gt;', fcmToken);
      //   store.dispatch(DeviceActions.SetFCMToken(fcmToken));
    });

    const fcmToken = await firebase.messaging().getToken();
    if (fcmToken) {
      // user has a device token
      console.log('has token -&gt;', fcmToken);
      console.log(firebase.auth().currentUser._user)
      firebase.database().ref(`/users/${firebase.auth().currentUser._user.uid}`).set({ pushToken: fcmToken })
      //   store.dispatch(DeviceActions.SetFCMToken(fcmToken));
    } else {
      // user doesn't have a device token yet
      console.error('no messaging token');
    }

    const messagingEnabled = await firebase.messaging().hasPermission();
    if (messagingEnabled) {
      // user has permissions
      console.log('User has FCM permissions');
    } else {
      // user doesn't have permission
      console.log('User does not have FCM permissions');
      await this.RequestMessagePermissions();
    }

    messageListener = firebase.messaging().onMessage((message: RemoteMessage) =&gt; {
      console.log(`Recieved message - ${JSON.stringify(message)}`);
    });

    notificationDisplayedListener = firebase
      .notifications()
      .onNotificationDisplayed(notification =&gt; {
        // Process your notification as required
        // ANDROID: Remote notifications do not contain the channel ID. You will have to specify this manually if you'd like to re-display the notification.
        console.log(`Recieved notification 1`);
      });
    notificationListener = firebase
      .notifications()
      .onNotification(notification =&gt; {
        console.log(notification)
        firebase.notifications().displayNotification(this.notification2)
        // Process your notification as required
        console.log(`Recieved notification 2`);
      });
  }


  async RequestMessagePermissions() {
    console.log('request')
    console.log('Requesting FCM permission');
    await firebase
      .messaging()
      .requestPermission()
      .catch(err =&gt; console.err(err));
  }


  render() {
    return (
      &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;

      &lt;/View&gt;
    )
  }
}
</code></pre>

<p>then I created firebase http function just for test</p>

<pre><code>export const sendNotification = functions.https
.onRequest(async (req, res) =&gt; {
    try {
        const { token } = req.query;
        let tokens = 'fyTfgNZAUBA:APA91bGnx9Vp9MwRA4ohVKcNOM8d5s4a4TXdtI0KTSzcWEgZX1WoLGpofcVQFTCdSbnbqObkukzJEXF3cbmvENYD5pr2MrukjqUNy_bclDuM3rJsV5iSU1vWywL2ZVijJ3s0E9GNfRRe'
        var payload = {
            notification: {
              title: 'Urgent action needed!',
              body: 'Urgent action is needed to prevent your account from being disabled!',
              sound: 'default',
                color: '#84B2D9',
                icon: 'ic_notification',
                click_action: 'OPEN_MAIN_ACTIVITY'
            }
          };

          // Set the message as high priority and have it expire after 24 hours.
          var options = {
            priority: 'high',
            timeToLive: 60 * 60 * 24
          };


          console.log('token',token)
        let d = await admin.messaging().sendToDevice(tokens, payload,options);
        return res.status(200).send({ success: d})

    } catch (e) {
        console.info(e)
        return res.status(400).send({ error: 0 })

    }
</code></pre>

<p>})</p>

<p>in the response from http function I get success(as you can see here)</p>

<pre><code>{
""success"": {
    ""results"": [
        {
            ""messageId"": ""0:1525112032423298%a0cec506a0cec506""
        }
    ],
    ""canonicalRegistrationTokenCount"": 0,
    ""failureCount"": 0,
    ""successCount"": 1,
    ""multicastId"": 5934848553304349000
}
</code></pre>

<p>}</p>

<p>and in my debugger in console log I get the notification as I want 
<a href=""https://i.stack.imgur.com/05QCS.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/05QCS.jpg"" alt=""enter image description here""></a></p>

<p>but the issue I don't get push notification when app is closed. I want to get any notification when I'm not into the app.</p>

<p>in addition when I use to display the notification when I get any notification</p>

<pre><code>notificationListener = firebase
  .notifications()
  .onNotification(notification =&gt; {
    console.log(notification)
    firebase.notifications().displayNotification(this.notification2)
    // Process your notification as required
    console.log(`Recieved notification 2`);
  });
</code></pre>

<p>}</p>

<p>so it not display my details here</p>

<pre><code>  this.notification2 = new firebase.notifications.Notification()
  .setNotificationId('notificationId')
  .setTitle('My notification title')
  .setBody('My notification body')
  .android.setChannelId('test')
  .android.setClickAction('action')
  .setData({
    key1: 'value1',
    key2: 'value2',
  });
</code></pre>

<p>so do i need to save it on state and then in title to display the data? </p>
","6455516","","6455516","","2018-04-30 22:36:04","2018-07-02 13:50:35","react native firebase push notification when app is closed/swiped from list","<android><firebase><react-native><push-notification><google-cloud-messaging>","1","5","","",""
"49060982","1","","","2018-03-02 00:33:48","","0","62","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","4812854","","4812854","","2018-03-02 22:05:39","2018-03-02 22:05:39","How to avoid rerendering element in the array in react?","<javascript><reactjs><redux-form>","0","11","","",""
"36678317","1","36681701","","2016-04-17 15:14:19","","0","109","<p>I am trying to add a default property that should refer to an instance function when I am inheriting a component class in ReactJS, and ES6. In detail, I have the datepicker from npm (react-day-picker) and want to make sure that two properties are always sent to the base class:</p>

<pre><code>export default class DayPicker extends BaseDayPicker {
constructor(props) {
    var { ...newProps } = props;
    newProps.onMouseDown = this.onDayPickerMouseDown;
    newProps.onMouseUp = this.onDayPickerMouseUp;
    super(newProps);
}

componentDidMount() {
    super.componentDidMount &amp;&amp; super.componentDidMount();
    window.addEventListener('mousedown', this.onPageClick, false);
}

componentWillUnmount() {
    super.componentWillUnmount &amp;&amp; super.componentWillUnmount();
    window.addEventListener('mousedown', this.onPageClick, false);
}   

onPageClick = (e) =&gt; {
    if (!this.isDayPickerMouseDown) {
        this.props.onPageClick &amp;&amp; this.props.onPageClick();
    }
};  

onDayPickerMouseDown = (e) =&gt; {
    this.isDayPickerMouseDown = true;
};

onDayPickerMouseUp = (e) =&gt; {
    this.isDayPickerMouseDown = false;
};  

render() {
    return super.render();
}
</code></pre>

<p>}</p>

<p>The problem with the code above is that I get <code>'this' is not allowed before super()</code>.</p>

<p>I cannot find a way to solve this. If it is not possible to add default properties that must use <code>this</code>, is it possible to solve it in the render method?</p>
","665794","","","","","2016-04-22 05:12:30","Add default properties when inheriting reactjs class in ES6","<javascript><reactjs><ecmascript-6>","2","2","","",""
"36251703","1","","","2016-03-27 19:33:04","","0","430","<p>Ive got a problem with applying styles to my React Components.
I generated template to my project via Yeoman. It created a lot of config files, not only webpack.config.js and because of that I'm a little bit confused. As Readme file of react-generator says it support out of the box some features without installing it: 
*Different supported style languages (sass, scss, less, stylus)
*Style transformations via PostCSS
According to this I show part of <code>cfg/default.js</code></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>'use strict';
const path = require('path');
const srcPath = path.join(__dirname, '/../src');
const dfltPort = 8000;
function getDefaultModules() {
  return {
    preLoaders: [{
        test: /\.(js|jsx)$/,
        include: srcPath,
        loader: 'eslint-loader'
      }],
    loaders: [
      {
        test: /\.css$/,
        loader: 'style-loader!css-loader!postcss-loader'
      },
      {
        test: /\.sass/,
        loader: 'style-loader!css-loader!postcss-loader!sass-loader?outputStyle=expanded&amp;indentedSyntax'
      },
      
      {
        test: /\.scss/,
        loader: 'style-loader!css-loader!postcss-loader!sass-loader?outputStyle=expanded'
      },
      {
        test: /\.less/,
        loader: 'style-loader!css-loader!postcss-loader!less-loader'
      },
      {
        test: /\.styl/,
        loader: 'style-loader!css-loader!postcss-loader!stylus-loader'
      },</code></pre>
</div>
</div>
</p>

<p>I think this part is responsible for converting <code>.scss</code> files.</p>

<p>So in my <code>todosStyle.scss</code> file I've got this code:</p>

<pre><code>      .todos {
    display: flex;
    flex-flow: row wrap;
    justify-content: center;
    width: 100%;} 
  .input {
    display: block;
    text-align: center;}
  .button {
    width: 60px;
    margin: 5px; }
  .label {
    display: block;
    border: solid 1px; }
</code></pre>

<p>Base on this styling I want to style my component <code>Todos.jsx</code>:</p>

<pre><code>import React from ""react"";

    import Todo from ""./Layout/Todo.jsx"";
    import TodoStore from ""../../stores/TodoStore.jsx"";
    import * as TodoActions from ""../../actions/TodoActions.jsx"";
    import styles from '../../styles/todosStyle.scss';

    export default class Todos extends React.Component {
      constructor() {
        super();
        this.getAllTodos = this.getAllTodos.bind(this);
        this.state = {
          todos: TodoStore.getAll(),
        };
      }

      getAllTodos(){
          this.setState({
          todos: TodoStore.getAll(),
        });
      }

      componentWillMount(){
        TodoStore.on('change', this.getAllTodos);
      }

      componentWillUnmount(){
        TodoStore.removeListener('change', this.getAllTodos);
      }

      createTodo(){
        if (this.refs.addTodo.value != ''){
          TodoActions.createTodo(this.refs.addTodo.value);
          this.refs.addTodo.value = '';
        }
      }

      deleteTodo(todo){
        TodoActions.deleteTodo(todo);
      }

      completeTodo(todo){
        TodoActions.completeTodo(todo);
      }

      render() {
        const {todos} = this.state;
        const TodoComponents = todos.map(todo =&gt;{
          return &lt;Todo key={todo.id} {...todo} completeTodo={this.completeTodo.bind(this, todo)} deleteTodo={this.deleteTodo.bind(this, todo)}/&gt;;
        });

        return (
          &lt;div&gt;
            &lt;h1&gt;Todos&lt;/h1&gt;
            &lt;div class = {styles.input}&gt;
              &lt;label class= {styles.label}&gt;Add new Todo&lt;/label&gt;
              &lt;input ref=""addTodo""/&gt; 
              &lt;button class={styles.button} onClick = {this.createTodo.bind(this)}&gt;&lt;i class=""fa fa-plus-square-o""&gt;&lt;/i&gt;&lt;/button&gt;
            &lt;/div&gt;
            &lt;ul class={styles.todos} class=""row""&gt;{TodoComponents}&lt;/ul&gt;
          &lt;/div&gt;
        );
      }
    }
</code></pre>

<p>but styling isn't applied, although I've imported <code>todosStyle.scss</code></p>

<p>Could someone help me?</p>
","5671775","","","","","2016-05-11 15:33:23","How to apply styles to the react component via css modules","<javascript><reactjs><sass><webpack>","2","0","","",""
"45033474","1","45033617","","2017-07-11 11:37:47","","0","69","<p>I was playing with this example timer and then wanted to see if I could capture/pass data into the timer so I started with a simple message. If I remove the message to timer it ticks accordingly. I started logging other lifecycle methods but I am curious if this is JS thing which I don't think it is versus something in react life cycle. I forked a JS bin <a href=""http://jsfiddle.net/4Lhnq7a9/"" rel=""nofollow noreferrer"">here with ex</a></p>

<p>'code' </p>

<pre><code>var Timer = React.createClass({
getInitialState: function() {
 return {secondsElapsed: 0};
},
tick: function(msg) {
 console.log('msg is',msg);
 this.setState({secondsElapsed: this.state.secondsElapsed + 1});
},
componentDidMount: function() {
 this.interval = setInterval(this.tick('hi'), 1000);
},
componentWillUnmount: function() {
 clearInterval(this.interval);
},
render: function() {
 return (
   &lt;div&gt;Seconds Elapsed: {this.state.secondsElapsed}&lt;/div&gt;
 );
}
});

React.render(&lt;Timer /&gt;, document.getElementById(""content""));
</code></pre>
","112665","","","","","2017-07-11 12:57:35","Why does this interval stop ticking in react?","<javascript><reactjs><timer>","2","0","","",""
"27737535","1","27748521","","2015-01-02 04:56:29","","0","636","<p>In a react.js app I have a <code>Tip</code> component that uses the Tether library, as a mixin, to allow it to attach to some other component that requires a tip.  This works great, however I am a little confuses on how to remove the tip when the user clicks the close link.</p>

<p>After some reading around it seems that the best practice is, from the tip component, call a passsed in method from the parent, that will not render the component on the next pass.  Unfortunately, when I do this I get an error message saying:</p>

<pre><code>Uncaught Error: Invariant Violation: processUpdates(): Unable to find child 2 of element. This probably means the DOM was unexpectedly mutated
</code></pre>

<p>The first question is, whether there is a better way to insert the tip?  If you checkout the <code>getTip()</code> method that seems pretty ugly to do a conditional insertion of the component.</p>

<p>The second question is to why the error mentioned above is occuring.</p>

<p>Thanks for any help.</p>

<p>Here is the code:</p>

<h3>parent component</h3>

<pre><code>React.createClass({

    getTip: function() {
        if (!this.state.showTip) return React.createElement('div', null, '');

        return React.createElement(Tip, {
            closeText: 'Got it!',
            destroy: this.removeTip,
            attachment: 'top center',
            targetAttachment: 'bottom center'
          },
          'Click outer arrows to skip by the week and inner arrows to skip by the day.');
    },

    removeTip: function() {
      this.setState({showTip: false});
    },

    render: function() {
        var tip = this.getTip();

        return (
          &lt;div className=""page""&gt;
            &lt;header&gt;
              &lt;div className=""dates__header__details""&gt;
                &lt;!-- stuff --&gt;

                {tip}
              &lt;/div&gt;
              ...   
})
</code></pre>

<h3>Tip component</h3>

<pre><code>var React = require('react');
var Tether = require('../tether/tether');

var Tip = React.createClass({

  mixins: [Tether],

  propTypes: {
    destroy: React.PropTypes.func.isRequired
  },

  getInitialState: function() {
    return {
      isVisible: true
    }
  },

  remove: function() {
    this.setState({isVisible: false});
    setTimeout(function() {
      this.props.destroy();
    }.bind(this), 500);
  },

  render: function() {
    // ...

    return (
      &lt;div className={classList}&gt;
        {this.props.children}

        &lt;div className=""tip__close"" onClick={this.remove}&gt;{this.props.closeText}&lt;/div&gt;
      &lt;/div&gt;
    );
  }

});
</code></pre>

<h3>Tether component</h3>

<pre><code>var React = require('react');
var T = require('../../../../../bower_components/tether/tether');

var Tether = {

  propTypes: {
    attachment: React.PropTypes.string.isRequired,
    targetAttachment: React.PropTypes.string.isRequired
  },

  componentDidMount: function() {
    var el = this.getDOMNode();

    var tether = new T({
      target: el.parentNode,
      element: el,
      attachment: this.props.attachment,
      targetAttachment: this.props.targetAttachment
    });

    this.setState({'tether': tether});
  },

  componentWillUnmount: function() {
    var t = this.state.tether;
    t.destroy();
  }
};

module.exports = Tether;
</code></pre>
","26849","","26849","","2015-01-02 19:39:42","2015-01-02 21:03:15","Conditional react.js render is throwing an error","<javascript><reactjs>","1","4","","",""
"44861092","1","44861198","","2017-07-01 12:45:03","","0","1048","<p>I'm new to react and programming in general, I have searched and only found solutions for js not react specific.</p>

<p>Having trouble displaying next or previous item in an array passed via props. When Next button is clicked I only see the same item in the array being returned not the next item, I understand previous will return null as displaying first item on load.</p>

<pre><code>import React, { Component } from 'react'
import VideoPlayer from './Video'
import axios from 'axios'

export default class App extends Component {
constructor(props) {
super(props);

this._TogglePrev = this._TogglePrev.bind(this);
this._ToggleNext = this._ToggleNext.bind(this);

// app state
this.state = {
videos: [],
selectedVideo: null
 }
}

componentDidMount() {
   axios.get('http://localhost:5000/v1/video?id=287948764917205')
   .then((result)=&gt; {
     var videos = result.data.payload
     this.setState({
       videos: videos,
       selectedVideo: videos[0]
     });
   })
 }

componentWillUnmount() {
 this.serverRequest.abort()
 }

// State transitions
  _ToggleNext() {
    console.log(""something worked"");
    // take a copy of our state
    const selectedVideo = this.state.selectedVideo;
    // next video
    var i = 0,
    max = selectedVideo.length;
    for (i; i &lt; max; i += 1) {
        if (selectedVideo[i]) {
            return selectedVideo[i + 1];
        }
    }
    //set our state
    this.setState( selectedVideo );
    console.log(selectedVideo)
  }

  _TogglePrev() {
    console.log(""something worked"");
    var current = this.state.selectedVideo;
    var prev = current - 1;
    if (prev &lt; 0) {
      prev = this.state.videos.length - 1;
    }
    // update our state
    this.setState({ prev });
  }

 render() {
  return (
     &lt;div className=""App"" style={{width: '100%', height: '100%'}}&gt;
       &lt;div className=""controls""&gt;
         &lt;button className=""toggle toggle--prev"" onClick={this._TogglePrev}&gt;Prev&lt;/button&gt;
         &lt;button className=""toggle toggle--next"" onClick={this._ToggleNext}&gt;Next&lt;/button&gt;
       &lt;/div&gt;
        &lt;VideoPlayer video={this.state.selectedVideo} /&gt;
     &lt;/div&gt;
  )
 }
}
</code></pre>

<p>The returned data</p>

<pre><code>[
 {  eventId: ""287948764917205""
  userName: ""Jon Doe""
  videoLink: ""https://""https:s3.amazonaws.com/...""""
  userPhotoLink: ""https://""https:s3.amazonaws.com/...""""
 },
 { eventId: ""287948764917205""
 userName: ""Jane Thompson""
 videoLink: ""https://""https:s3.amazonaws.com/...""""
 userPhotoLink: ""https://""https:s3.amazonaws.com/...""""
 }  
]
</code></pre>
","7893337","","","","","2017-07-01 13:18:10","get next Next/Previous item in array using react","<javascript><arrays><reactjs>","2","1","","",""
"36498387","1","","","2016-04-08 11:24:24","","2","469","<p>I have read <a href=""https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html"" rel=""nofollow"">isMounted is an Antipattern</a> and am still unsure if the codes below will cause memory leak when using with callback?</p>

<pre class=""lang-js prettyprint-override""><code>class MyComponent extends React.Component {
  componentDidMount() {
    this.mounted = true
  }
  componentWillUnmount() {
    this.mounted = false
  }
  someAPIcall() {
    callSomething(argument, (err, result) =&gt; {
      if (this.mounted === false) return
      // otherwise do something
      this.setState({...})         
    })
  }
}
</code></pre>
","2910052","","","","","2016-04-08 13:04:46","React js componentWillUnmount for callbacks","<reactjs>","1","1","1","",""
"45317421","1","","","2017-07-26 04:21:15","","1","160","<p>This question is mainly for contributors of React Native or those who know the underlying library fairly well. There doesn't seem to be a discussion on Github I can follow, so I brought it up here.</p>

<p>In the release notes of <a href=""https://github.com/facebook/react-native/releases/tag/v0.43.4"" rel=""nofollow noreferrer"">0.43.4</a>, there is a change called ""<a href=""https://github.com/facebook/react-native/commit/5eb3ab3522bd1d46fb4f8471c8207f1e0bc2cc25"" rel=""nofollow noreferrer"">Switch componentWillMount / componentWillUnmount order</a>"". Could someone explain to me what they mean by ""<em>componentWillMount happens before
componentWillUnmount when a child switches</em>""?</p>

<p>From my understanding of the React lifecycle, <code>componentWillMount</code> always happens before <code>componentWillUnmount</code>, but the <strong>when a child switches</strong> part is confusing me.</p>
","4776002","","","","","2017-07-26 04:21:15","ComponentWillMount / componentWillUnmount order after RN 0.43.4","<reactjs><react-native>","0","0","","",""
"44863013","1","46862878","","2017-07-01 16:17:59","","1","49","<p>Using <a href=""https://github.com/facebook/draft-js/issues/160#issuecomment-192427332"" rel=""nofollow noreferrer"">this</a> comment, I am trying to use Draft.js in my rails application. </p>

<p>But I constantly get the error: </p>

<p><code>Draft.min.self-b1d4414….js?body=1:1 Uncaught ReferenceError: Immutable is not defined</code></p>

<p>Can anybody tell, what is the <em>possibly obvious</em> mistake that I am making?</p>

<p>Details:</p>

<p>I use only react-rails to keep things simple. Gemfile has following related lines:</p>

<pre><code>gem 'react-rails'
gem 'bootstrap-sass'
</code></pre>

<p>I placed <code>Draft.min.js</code> under <code>app/assets/javascripts/externallibraries/</code>
and <code>Draft.css</code> under <code>app/assets/stylesheets/externallibraries</code>.</p>

<p>The related files, <code>application.js</code>:</p>

<pre><code>/*
 //= require jquery
 //= require jquery_ujs
 //= require turbolinks
 //= require react
 //= require react_ujs
 //= require bootstrap-sprockets
 //= require react
 //= require react_ujs
 //= require externallibraries/Draft.min
 //= require components
 //= require_tree .
*/
</code></pre>

<p>And <code>application.css</code>:</p>

<pre><code>/*
 *= require externallibraries/Draft
 *= require_tree .
 *= require_self
*/
</code></pre>

<p>And finally my jsx file is:</p>

<pre><code>class NewPost extends React.Component {
    constructor() {
        super();
        this.state = {
            editorState: EditorState.createEmpty()
        };
        this.onChange = (editorState) =&gt; this.setState({editorState});
    }

    componentDidMount(){
    }

    componentWillMount() {
    };

    componentWillUnmount() {
    }

    componentWillReceiveProps(nextProps) {
        if(JSON.stringify(this.props.some_field) !== JSON.stringify(nextProps.some_field) &amp;&amp; nextProps.retrieved_data != null) // Check if it's a new user, you can also use some unique, like the ID
        {
            this.setState({some_field: nextProps.some_field});
        }
    } 

    render() {
        return (
            &lt;div&gt;
                {""My state is: "" + JSON.stringify(this.state, null, ""   "")}
                {""And my props are: "" + JSON.stringify(this.props, null, ""  "")}
                &lt;Editor editorState={this.state.editorState} onChange={this.onChange} /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
","1870873","","1870873","","2017-07-03 07:59:00","2017-10-21 11:42:31","How to use vendor React modules / components within a rails application with only react-rails gem?","<javascript><ruby-on-rails><reactjs>","1","0","","",""
"36311406","1","","","2016-03-30 14:10:49","","0","3406","<p>My node.js server sends with socket.io new data each 10s. In my web application I update this.state each time that my server sends data and force to update with forceUpdate()</p>

<p>However, my react component doesn't refresh, I don't know why. I followed the doc but I missed something...</p>

<p><strong>Parent :</strong></p>

<pre><code>class DataAnalytics extends React.Component {
  constructor(props) {
    super(props);
    socket = this.props.socket;
    this.state = {data: []};

    socket.on('dataCharts', (res) =&gt; {
      console.log(""new data charts : ""+res);
      var data = JSON.parse(res);   
      this.setState({data: data});
      this.forceUpdate();
    });
  }

  componentWillUnmount() {
    socket.off('dataCharts');
  }

  render() {
    return (
    &lt;div id=""dataAnalytics""&gt;
      &lt;Stats data={this.state.data}&gt;&lt;/Stats&gt;
    &lt;/div&gt;
    );
  }
}

export default DataAnalytics;
</code></pre>

<p><strong>Child :</strong></p>

<pre><code>class Stats extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div className=""stats"" style={{textAlign:'center'}}&gt;
        &lt;h4&gt;Number: &lt;/h4&gt;
      &lt;/div&gt;
    );
  }

  componentDidUpdate() {
    var data = this.props.data;

    if(!jQuery.isEmptyObject(data)) {
      $( "".stats"" ).html(""&lt;h4&gt;Number : data['nb']['counterIn']&lt;/h4&gt;"");
    }
  }
}

export default Stats;
</code></pre>

<p>Anyone know how to refresh automatically my React component.</p>
","5279661","","","","","2016-03-30 14:20:56","Refresh react component","<javascript><reactjs>","1","3","1","",""
"45412054","1","45412215","","2017-07-31 09:26:51","","0","158","<p>I've used the guide in the videojs docs to create a component that is working correctly (see below).  Once, loaded I can also control the player from the console with API functions like <code>window.player.play()</code>. </p>

<p>I would now like to create a play/pause button component.  If I just use <code>onClick = {window.player.play}</code>, player doesn't exist when the page loads and causes an error.  </p>

<p>I would like the Play/Pause components to be siblings of VideoPlayer:</p>

<pre><code>&lt;div&gt;
  &lt;VideoPlayer props /&gt;
  &lt;PlayButton /&gt;
  &lt;PauseButton /&gt;
&lt;/div&gt;
</code></pre>

<p>What is the best way of accessing my player from other components?</p>

<pre><code>import React from 'react';

export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js

    this.player = window.videojs(this.videoNode, this.props, function onPlayerReady() {
      console.log('onPlayerReady', this)
    });
    window.player = this.player;
    }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  // wrap the player in a div with a `data-vjs-player` attribute
  // so videojs won't create additional wrapper in the DOM
  // see https://github.com/videojs/video.js/pull/3856
  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
      &lt;/div&gt;

    )
  }
}
</code></pre>
","1285360","","1285360","","2017-07-31 09:37:03","2017-07-31 09:45:30","Accessing videojs player in react component from other component","<reactjs><video.js>","1","2","","",""
"45334609","1","","","2017-07-26 18:15:55","","1","269","<p>Im creating a react native app that has built in methods for grabbing my longitude and latitude coordinates. I'm using an android for this.</p>

<p>I't works fairly randomly, even though i am using a setInterval. Sometimes it only responds when I'm moving around, and sometimes it will update properly even when I'm not moving.</p>

<pre><code>import React, { Component } from 'react';
import { View, Text } from 'react-native';


class Geolocation extends Component {
  constructor(props) {
    super(props);

   this.state = {
      latitude: null,
      longitude: null,
      error: null
    };

   setInterval(this.location.bind(this),3000)
  }

 location(){
    this.watchId = navigator.geolocation.getCurrentPosition(
      (position) =&gt; {
        let obj = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          error: null
        }
        this.setState(obj);
      },
      (error) =&gt; this.setState({ error: error.message }),
      { enableHighAccuracy: true, timeout: 200000, maximumAge: 1000},
    );
  }

 componentDidMount() {
    this.location()
  }

 componentWillUnmount() {
    navigator.geolocation.clearWatch(this.watchId);
  }

 render() {
    return (

             &lt;View style={{ position: 'relative', top: 70, flexGrow: 1, 
alignItems: 'center', justifyContent: 'center' }}&gt;
              &lt;Text&gt;Latitude: {this.state.latitude}&lt;/Text&gt;
              &lt;Text&gt;Longitude: {this.state.longitude}&lt;/Text&gt;
                {this.state.error ? &lt;Text&gt;Error: {this.state.error}&lt;/Text&gt; : null}
             &lt;/View&gt;

    );
  }
}

export default Geolocation;
</code></pre>

<p>Again my problem is the location doesn't update properly, I've tried on both wifi and my phones 4g data and no change.</p>

<p>How do I make the location coordinates update regularly?</p>

<p>Any help is greatly appreciated!</p>
","7848070","","","","","2017-07-26 18:15:55","How do I continually update my gps coordinates in react native?","<javascript><android><react-native><gps>","0","6","","",""
"44730057","1","","","2017-06-23 21:16:19","","1","310","<p>I have page which had componentA and on componentDidMount cycle method i am updating state which trigger some animation but if I refresh the page animation doesn't play. Please let know how I can resolve this issue. below is my component code</p>

<pre><code>import React from 'react';
import { findDOMNode } from 'react-dom';
import Nav from ""../nav/nav-component"";
class Mylist extends React.Component{
  constructor(props) {
    super(props);
    this.handleScroll = this.handleScroll.bind(this);
    this.state = { animationClass: '' , transform : 12  };
  }
  componentDidMount() {
      window.addEventListener('scroll', this.handleScroll);
      this.setState({animationClass:'animate'});
  };
  componentDidUpdate() {
      //this.setState({animationClass:''});
  };

  componentWillUnmount() {
      window.removeEventListener('scroll', this.handleScroll);
      this.setState({animationClass:''});
  };
  handleScroll(event){
    const scrollTop = event.srcElement.body.scrollTop,
          ele = findDOMNode(this.refs.toggle), // how to get dom element in react
          childElements = ele.children,
          componentTopPos = ele.getBoundingClientRect();
    //itemTranslate = Math.min(0, scrollTop/3 - 60);

    console.log(""scrollTop"",scrollTop);
    console.log(childElements);
    console.log(""componentTopPos"",componentTopPos);

     console.log(this);
    this.setState({
      transform: ""dsfdf""
    });
  }
  render(){
    return ( 
      &lt;div className={'header '+this.state.animationClass}&gt;
      &lt;Nav /&gt;
      &lt;/div&gt; 
    );
  }
}
export default Mylist;
</code></pre>
","5031236","","","","","2017-06-23 21:16:19","On page refresh which life cycle method called in react?","<javascript><reactjs><ecmascript-6>","0","1","","",""
"44867383","1","","","2017-07-02 04:12:34","","2","172","<p>I need to delete the polyline I've drawn on the  component when a user performs a new search. Right now I end up with 2+ routes all drawn on the same map instead of the new search displaying only the new route.</p>

<p>I followed this tutorial to render the polyline: <a href=""https://medium.com/@ali_oguzhan/react-native-maps-with-google-directions-api-bc716ed7a366"" rel=""nofollow noreferrer"">https://medium.com/@ali_oguzhan/react-native-maps-with-google-directions-api-bc716ed7a366</a>. </p>

<p>I've tried emptying state(which gives the polyline the coordinates to draw through) in componentWillUnmount and ComponentWillMount.
I've also seen references to polyline.remove() but that functionality doesn't exists with react-native-maps or the mapbox/polyline package as far as I can tell. Mapbox appears to have a way to delete layers however I can't find a way to incorporate that into my project. </p>

<p>I'd appreciate any leads about how to delete the polyline.</p>

<p>Here's some of the code. JSX: </p>

<pre><code>    &lt;MapView style={styles.map} initialRegion={{
      latitude:startLat,
      longitude:startLng,
      latitudeDelta: 0.0922,
      longitudeDelta: 0.0421
    }}
    showsUserLocation={true}
    loadingEnabled={true}
    loadingIndicatorColor=""#e6fef6""
    loadingBackgroundColor=""#400230""
    &gt;
    &lt;MapView.Polyline
        coordinates={this.state.coords}
        strokeWidth={2}
        strokeColor=""purple""/&gt;

    &lt;/MapView&gt;
</code></pre>

<p>Decoding the Polyline: </p>

<pre><code>      async getBikeDirections(startBike, endBike) {
try {
  let respBike = await fetch(`https://maps.googleapis.com/maps/api/directions/json?origin=${startBike}&amp;destination=${endBike}&amp;mode=bicycling`)

  let respJsonBike = await respBike.json()
  let completeBikeSteps = respJsonBike.routes[0].legs[0].steps
  let pointsBike = Polyline.decode(respJsonBike.routes[0].overview_polyline.points)

  let coordsBike = pointsBike.map((point, index) =&gt; {
    return {
      latitude: point[0],
      longitude: point[1]
    }
  })

  let text = completeBikeSteps.map((obj, index) =&gt; {
    let regex = /(&lt;([^&gt;]+)&gt;)/ig,
      result = obj.html_instructions.replace(regex, """")
    return result
  })

  return {
    coordsBike,
    text
  }
} catch (error) {
  alert(error)
  return error
}
</code></pre>

<p>}</p>
","8202883","","","","","2017-07-02 04:12:34","delete Polyline rendered with react-native(0.45.1), react-native-maps(0.15.3) and mapbox","<react-native><mapbox><polyline><google-direction><react-native-maps>","0","0","","",""
"44726897","1","","","2017-06-23 17:21:42","","0","58","<p>Hi I try to make simple contact from in react, but I stuck on fetch() method.
This is my code. I have no idea what is wrong.</p>

<p><strong>FrontEnd</strong></p>

<pre><code>export default class ContactForm extends React.Component&lt;IContactFormProps, any&gt; {

  constructor(props) {
    super(props);
    // local state
    this.state = {
      tl: new TimelineMax({paused: true, delay: 1}),
      name: """",
      email: """",
      subject: """",
      message: """",
      sent: false,
    }
    this.handleOnSubmit = this.handleOnSubmit.bind(this);
    this.handleClearForm = this.handleClearForm.bind(this);
    this.handleChange = this.handleChange.bind(this);
    this.startAnimation = this.startAnimation.bind(this);
  }

  handleOnSubmit(e) {
    console.log(""ContactForm-&gt;handleOnSubmit(e)."");
    e.preventDefault();

    let formData = new FormData();
    formData.append(name, this.state.name);
    console.log(""formData: "" + formData);

    fetch('/contact', {
      method: 'POST',
      body: formData
    })
    .then((response) =&gt; {
      console.log(""response: "" + response);
      console.log(""response.ok: "" + response.ok);
      return response.json();
    })
    .then((responseJson) =&gt; {
      console.log(""responseJson: "" + responseJson);
    })
    .catch((error) =&gt; {
      console.log(""error from fetch: "" + error);
    });

  }

  handleClearForm(e) {
    console.log(""ContactForm-&gt;handleClearForm(e)."");
    // e.preventDefault();
  }

  handleChange(event) {
    const target = event.target;
    const name = event.target.name;
    const value = event.target.value;

    this.setState({
      [name]: value
    });
    // console.log(""event.target.value: "" + event.target.value);
    // this.setState({value: event.target.value});
  }

  startAnimation() {
    console.log(""ContactForm-&gt;startAnimation()."");
  }

  componentDidMount() {
    this.startAnimation();
  }

  componentWillUnmount() {

  }

  render() {
    return (
        &lt;form className=""contact-form-cnt""
          onSubmit={ this.handleOnSubmit }&gt;
          &lt;div className=""top-row""&gt;
            &lt;input type=""text"" name=""name"" placeholder=""Name""
              className=""name"" ref=""name""
              value={this.state.name} onChange={this.handleChange}/&gt;
            &lt;input type=""text"" name=""email"" placeholder=""Em@il""
              className=""email"" ref=""email""
              value={this.state.email} onChange={this.handleChange}/&gt;
          &lt;/div&gt;
          &lt;input type=""text"" name=""subject"" placeholder=""Subject""
            className=""subject"" ref=""subject""
            value={this.state.subject} onChange={this.handleChange}/&gt;
          &lt;textarea name=""message"" placeholder=""Write Your message here.""
            className=""message"" ref=""message""
            value={this.state.message} onChange={this.handleChange}&gt;&lt;/textarea&gt;
          &lt;button type=""submit"" name=""submit""
            className=""submit"" ref=""Send""
            onClick={ this.handleClearForm }&gt;Send&lt;/button&gt;
        &lt;/form&gt;
    );

  };
};
</code></pre>

<p><strong>BackEnd</strong></p>

<pre><code>'use strict';

const path = require('path');
const express = require('express');
const bodyParser = require('body-parser');
const winston = require('winston');

const distPath = path.join(__dirname, '../dist');
const indexFileName = 'index.html';
const app = express();
const PORT = process.env.PORT || 8080;

app.use(bodyParser.urlencoded({
    extended: false
}));
app.use(bodyParser.json());

app.use(express.static(distPath));
app.get('*', (req, res) =&gt; res.sendFile(path.join(distPath, indexFileName)));

app.post(""/contact"", (req, res) =&gt; {
    try {
        console.log(""mail sending succes!"");
    }
    catch ( error ) {
        console.log(""mail sending failure!"");
    }
});

app.listen(PORT, (err) =&gt; {
    if (err) {
        winston.error(err);
        return;
    }

    winston.info(`Listening on port ${PORT}`);
});
</code></pre>

<p>URL: </p>

<blockquote>
  <p><a href=""http://localhost:8080/contact"" rel=""nofollow noreferrer"">http://localhost:8080/contact</a></p>
</blockquote>

<p><strong>and error</strong></p>

<p>POST <a href=""http://localhost:8080/contact"" rel=""nofollow noreferrer"">http://localhost:8080/contact</a> 404 (Not Found)</p>

<p>I think it's something with url, but I'am out of ideas. Any sugestions?</p>
","4469658","","","","","2017-06-26 10:48:10","I can't fetch react form","<json><reactjs><express><post><fetch-api>","1","2","","",""
"45178122","1","","","2017-07-18 22:25:39","","1","369","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p>Update:</p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<p>constructor(props) {
    super(props);</p>

<pre><code>this.state = {
    title: 'David Powell',
    nav: {},
    currentPage: """",
    pageContent: """",
    pageTitle: """",
    pageTemplate: """",
    pageId: 0,
    pageCustomMeta: {},
    archiveData: []
}
</code></pre>

<p>}</p>

<p>When a page is called I set the values based on what the api returns I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<p>getPageData(slug){
    console.log(this.state);
    axios.get('<a href=""http://admin.sitedata.co/pages?slug="" rel=""nofollow noreferrer"">http://admin.sitedata.co/pages?slug=</a>'+slug)
    .then((response) => {
        console.log(response.data);</p>

<pre><code>    this.setState({
        pageContent:response.data[0].content.rendered,
        currentPage:slug,
        pageTitle:response.data[0].title.rendered,
        pageTemplate:response.data[0].template,
        pageId:response.data[0].id,
        pageCustomMeta:response.data[0].post_meta,
        archiveData:[]
    },function(){
        console.log(this.state);
        /*
        *   set the page title
        *   check if the page is at home
        *   get page custom meta
        */
        document.title = this.state.pageTitle;
        this.isHome();
        //this.getPageCustomMeta(this.state.pageId);
    });

})
.catch((error) =&gt; {
    console.log(error);
});
</code></pre>

<p>}</p>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","249316","","249316","","2017-07-19 02:32:23","2017-07-19 02:32:23","Changing a state with the route changes in ReactJS and react-router?","<javascript><reactjs>","0","4","","",""
"28396231","1","28690338","","2015-02-08 16:15:42","","1","1219","<p>I want to track loading, success and error state of Asynchronous Ajax request. My store is changing on loading, success and error action but react component is changing only when there is success or error. Therefore I am unable to detect loading state in react component.</p>

<p>Below is how my code looks like :</p>

<p><strong>Dispatcher</strong></p>

<pre><code>var AppDispatcher = assign(new Dispatcher(), {
       handleServerAction: function(action) {
       var payload = {
         source: PayloadSources.SERVER_ACTION,
         action: action
       };
       this.dispatch(payload);
       }
    });
</code></pre>

<p><strong>Action Creator</strong></p>

<pre><code>var ActionCreator = {
  loadData: function() {
  //Calling Synchronous Action          
     AppDispatcher.handleServerAction({actionType:ActionTypes.LOAD_DATA});

  //Calling Asynchronous Action
  ApiClient.getData(function(dataObj) {
  AppDispatcher.handleServerAction({actionType:ActionTypes.LOAD_DATA_SUCCESS, dataObj: dataObj});
   }.bind(this), function(error) {
  AppDispatcher.handleServerAction({actionType:ActionTypes.LOAD_DATA_FAIL, error: error});
    }.bind(this));
 }
};
</code></pre>

<p><strong>API CLIENT</strong></p>

<pre><code>var ApiClient = {
/**
* @param success callback
* @param failure callback
*/
getData : function(success, failure){
  $.ajax({
     url : '/api/get-data',
     dataType: 'json',
     success : function(data){
        success(data);
     },
     error : function(jqXHR, textStatus, errorThrown){
        failure(errorThrown);
     }
  });
 }
};
</code></pre>

<p><strong>AppStore</strong></p>

<pre><code>   var _state = {
           loading: false,
           error : null,
           dataObj: {}
         };

 function persistStoreData(loading, error, response) {
  _state.loading = loading;
  _state.error = error;
  _state.dataObj = response;
 }
var AppStore = assign({}, EventEmitter.prototype, {
   //writing only few important parts
   getState: function(){
      return _state;
   },
  dispatcherIndex: AppDispatcher.register(function(payload) {
  var action = payload.action;
  switch(action.actionType){
     case ActionTypes.LOAD_DATA:
        persistStoreData(true, null, {});
        break;
     case ActionTypes.LOAD_DATA_SUCCESS:
        persistStoreData(false, null, action.dataObj);
        break;
     case ActionTypes.LOAD_DATA_FAIL:
        persistStoreData(false, payload.action.error, {});
        break;
     default:
        return true;
  }
  AppStore.emitChange();
  return true; // No errors. Needed by promise in Flux Dispatcher.
)};
</code></pre>

<p><strong>React Component</strong></p>

<pre><code>var AppComponent = React.createClass({

 getInitialState: function() {
   return AppStore.getState();
 },

 componentDidMount: function() {
   ActionCreator.loadData();//Invoking Action, loading data
   AppStore.addChangeListener(this._onChange);
 },

 componentWillUnmount: function() {
   AppStore.removeChangeListener(this._onChange);
 },

 render: function(){
    &lt;div className=""panel-body""&gt;
         {this.state.error ? ""Error loading data"" : null}
         {this.state.loading ? 'Loading...': null}
         {this.state.dataObj?'Success': null}
    &lt;/div&gt;
 }
});
</code></pre>
","1922960","","1922960","","2015-02-08 16:34:52","2015-02-24 07:33:25","Displaying AJAX Call loading state in reactjs with flux","<reactjs><reactjs-flux>","1","2","","",""
"44918084","1","","","2017-07-05 06:02:18","","0","107","<p>I'm building a simple web app using React where the user enters a valid username to bring up a diary of recently eaten food items. I have a single username field at the top of the page that I want to be sticky as the user scrolls down the entirety of the page. But as it is now, the username field is just scrolling out of view like a normal component. What am I missing? Any help would be appreciated.</p>

<p>app.js</p>

<pre><code>import React, { Component } from 'react';
import {StickyContainer, Sticky} from 'react-sticky';
import Username from '../containers/username';
import DiaryList from '../containers/diary_list';

export default class App extends Component {
  render() {
    return (
      &lt;div&gt;       
        &lt;h1 className=""text-xs-center""&gt;Diary&lt;/h1&gt;
        &lt;StickyContainer&gt;
            &lt;Sticky&gt;
                {() =&gt; {
                    return &lt;Username /&gt;}}
            &lt;/Sticky&gt;
            &lt;DiaryList /&gt;
        &lt;/StickyContainer&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>username.js</p>

<pre><code>import React, {Component} from 'react';
import {connect} from 'react-redux';

import {fetchUser} from '../actions/index';

class Username extends Component {
    constructor(props){
        super(props);

        this.state = {term: ''};
        this.onInputChange = this.onInputChange.bind(this);
    }

    onInputChange(event) {
        this.setState({term: event.target.value}, 
            () =&gt; this.props.fetchUser(this.state.term)
        );
    }

    render(){
        return(
            &lt;div className=""username""&gt;
                &lt;span className=""username-field""&gt;Username:&lt;/span&gt;
                &lt;input value = {this.state.term}
                onChange={this.onInputChange}   /&gt;
            &lt;/div&gt;
        )   
    }
}

export default connect(null, {fetchUser})(Username);
</code></pre>

<p>diary_list.js</p>

<pre><code>import React, {Component} from 'react';
import {connect} from 'react-redux';
import DishChart from './dish_chart';

class DiaryList extends Component {
    constructor(props) {
        super(props);

        this.state = {width: $(window).width(), 
                        height: $(window).height()
        }

        this.updateDimensions = this.updateDimensions.bind(this);
    }

    componentDidMount() {
        window.addEventListener(""resize"",  this.updateDimensions);
    }

    componentWillUnmount() {
        window.removeEventListener(""resize"", this.updateDimensions);
    }

    updateDimensions() {
        this.setState({width: $(window).width(), height: $(window).height()});
    }

    renderDiary(diaryData, key=diaryData.dishId) {
        return (
            &lt;div key={diaryData.dishId}&gt;
                &lt;div  className=""col-sm-6 col-md-4 col-lg-3"" &gt;
                    &lt;ul className=""list-group""&gt;
                        &lt;li className=""list-group-item""&gt;
                            &lt;img className=""img-thumbnail""src={diaryData.imageLink} alt=""No image available.""/&gt;
                        &lt;/li&gt;
                        &lt;li className=""list-group-item""&gt;{diaryData.dishName}&lt;/li&gt;
                        &lt;li className=""list-group-item""&gt;Price: {diaryData.price}&lt;/li&gt;
                        &lt;li className=""list-group-item""&gt;Calories: {diaryData.calories}&lt;/li&gt;
                        &lt;li className=""list-group-item""&gt;Health Score: {diaryData.healthScoreM}&lt;/li&gt;
                        &lt;div className=""container-fluid""&gt;
                        &lt;li className=""list-group-item row""&gt;
                            &lt;div className=""col-xs-4 carbs""&gt;
                                {`${diaryData.carbohydrates}G Carbs`}
                            &lt;/div&gt;
                            &lt;div className=""col-xs-4 fat""&gt;
                                {`${diaryData.totalFat}G Fat`}
                            &lt;/div&gt;
                            &lt;div className=""col-xs-4 protein""&gt;
                                {`${diaryData.protein}G Protein`}
                            &lt;/div&gt;
                        &lt;/li&gt;
                        &lt;/div&gt;
                        &lt;li className=""list-group-item recharts-wrapper""&gt;
                        &lt;DishChart data={diaryData} /&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
                {($(window).width() &gt;= 480 &amp;&amp; $(window).width() &lt; 768) &amp;&amp;
                    key % 2 == 1 &amp;&amp; 
                        &lt;div className=""clearfix visible-sm-block""&gt;&lt;/div&gt;
                }
                {($(window).width() &gt;= 768 &amp;&amp; $(window).width() &lt; 992) &amp;&amp;
                    key % 3 == 2 &amp;&amp;
                        &lt;div className=""clearfix visible-md-block""&gt;&lt;/div&gt;
                }
                {$(window).width() &gt;= 992 &amp;&amp;
                    key % 4 == 3 &amp;&amp;
                        &lt;div className=""clearfix visible-lg-block""&gt;&lt;/div&gt;
                }
            &lt;/div&gt;
        )
    }

    render() {
        if (this.props.diary.data == undefined) {
            return (
                &lt;div&gt;
                    Please enter a valid username.
                &lt;/div&gt;
            )
        }

        return (
            &lt;div className=""diary""&gt;
                {this.props.diary.data.map(this.renderDiary)}
            &lt;/div&gt;
        );
    }
}

function mapStateToProps(state) {
    return {
        diary: state.diary
    };
}

export default connect(mapStateToProps)(DiaryList);
</code></pre>
","8256962","","","","","2017-07-05 06:02:18","Having trouble implementing react-sticky component for username field","<reactjs>","0","2","","",""
"37921369","1","37922246","","2016-06-20 11:27:48","","2","2746","<p>I've a react component that listens to route changes using browserHistory's listen method. After registering a handler with</p>

<pre><code>browserHistory.listen(this.handleRouteChanged)
</code></pre>

<p>in ComponentDidMount, how do I remove the listener in componentWillUnmount? </p>

<p>I can't find any documentation on this, and searching through github issues I've found suggestions using browserHistory.unregisterTransitionHook which doesn't seem to remove the listener, and in addition seems to be deprecated.</p>

<p>Any ideas?</p>
","237335","","","","","2016-06-20 12:09:29","Removing react-router browserHistory change listener","<reactjs><react-router>","1","0","1","",""
"45501035","1","45501208","","2017-08-04 07:47:37","","2","56","<p>I am using an <a href=""https://github.com/malte-wessel/react-custom-scrollbars/blob/master/src/Scrollbars/index.js"" rel=""nofollow noreferrer"">open source scrollbar component</a> in my react app. </p>

<p>I have extended the component so that it looks like this:</p>

<pre><code>import PropTypes from ""prop-types"";
import Scrollbars from ""react-custom-scrollbars"";

//  This component extends react-custom-scrollbars and allows
//  the developer to force an update of the scrollbars
//  every 'X' ms.

class ForcedScrollbars extends Scrollbars {

    componentDidMount() {
        this.rerenderTimer = setInterval(() =&gt; {
            this.update();
        }, this.props.forceRerenderTimer);
    }

    componentWillUnmount() {
         clearInterval(this.rerenderTimer);

    }
}

ForcedScrollbars.propTypes = {
    forceRerenderTimer: PropTypes.number
};

export default ForcedScrollbars;
</code></pre>

<p>I have two questions. </p>

<ol>
<li><p>The <code>componentDidMount</code> method in the parent component <code>Scrollbars</code> looks like this:</p>

<pre><code>componentDidMount() {
   this.addListeners();
   this.update();
   this.componentDidMountUniversal();
}
</code></pre></li>
</ol>

<p>In my <code>ForcedScrollbars</code> component will the same methods get called in the <code>ForcedScrollbars</code> <code>componentDidMount</code> call or do I have to call them again explicitly? i.e.</p>

<pre><code>class ForcedScrollbars extends Scrollbars {

    componentDidMount() {
       this.addListeners();
       this.update();
       this.componentDidMountUniversal();
       this.rerenderTimer = setInterval(() =&gt; {
          this.update();
       }, this.props.forceRerenderTimer);
    }

  // REST OF COMPONENT //
</code></pre>

<ol start=""2"">
<li>I am seeing an error in the console </li>
</ol>

<blockquote>
  <p>Warning: Unknown prop forceRerenderTimer on  tag. Remove this
  prop from the element. For details, see ...(facebook link)...</p>
</blockquote>

<p>As you can see in my code above I have the following which doesn't appear to work. </p>

<pre><code>ForcedScrollbars.propTypes = {
    forceRerenderTimer: PropTypes.number
};
</code></pre>

<p>Also I have tried which didn't appear to work either.</p>

<pre><code>Scrollbars.propTypes = {
    forceRerenderTimer: PropTypes.number
};
</code></pre>

<p>Check <a href=""https://codesandbox.io/s/YEo1LvmWO"" rel=""nofollow noreferrer"">codesandbox</a> here.</p>
","4425849","","4425849","","2017-08-04 10:32:07","2017-08-04 10:32:07","Issues/Questions extending a react component","<javascript><reactjs><ecmascript-6>","1","1","1","",""
"45657321","1","","","2017-08-13 05:14:49","","0","568","<p>Okay so I've gotten pretty far in creating the React Component for ChartJS, however when testing I get the following error:</p>

<pre><code>FAIL  lib\chart\chart.test.tsx
  ● renders without crashing

    TypeError: Cannot read property 'length' of null

      at Object.acquireContext (node_modules/chart.js/src/platforms/platform.dom.js:189:19)
      at Chart.construct (node_modules/chart.js/src/core/core.controller.js:72:27)
      at new Chart (node_modules/chart.js/src/core/core.js:7:8)
      at Chart.Object.&lt;anonymous&gt;.Chart.renderChart (lib/chart/chart.tsx:233:26)
      at Chart.Object.&lt;anonymous&gt;.Chart.componentDidMount (lib/chart/chart.tsx:42:10)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:264:25
      at measureLifeCyclePerf (node_modules/react-dom/lib/ReactCompositeComponent.js:75:12)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:263:11
      at CallbackQueue.notifyAll (node_modules/react-dom/lib/CallbackQueue.js:76:22)
      at ReactReconcileTransaction.close (node_modules/react-dom/lib/ReactReconcileTransaction.js:80:26)
      at ReactReconcileTransaction.closeAll (node_modules/react-dom/lib/Transaction.js:209:25)
      at ReactReconcileTransaction.perform (node_modules/react-dom/lib/Transaction.js:156:16)
      at batchedMountComponentIntoNode (node_modules/react-dom/lib/ReactMount.js:126:15)
      at ReactDefaultBatchingStrategyTransaction.perform (node_modules/react-dom/lib/Transaction.js:143:20)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:26)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:27)
      at Object._renderNewRootComponent (node_modules/react-dom/lib/ReactMount.js:319:18)
      at Object._renderSubtreeIntoContainer (node_modules/react-dom/lib/ReactMount.js:401:32)
      at Object.render (node_modules/react-dom/lib/ReactMount.js:422:23)
      at Object.&lt;anonymous&gt; (lib/chart/chart.test.tsx:7:12)
          at Promise (&lt;anonymous&gt;)
      at Promise.resolve.then.el (node_modules/p-map/index.js:42:16)
          at &lt;anonymous&gt;
      at process._tickCallback (internal/process/next_tick.js:169:7)

  × renders without crashing (275ms)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.314s, estimated 3s
Ran all test suites related to changed files.
</code></pre>

<p>However, I've spent a long time looking over the code and haven't been able to figure out why it refuses to work properly. The error starts at the <code>renderChart()</code> function at creating a new chart instance. My first guess would be the for some reason it's not registering the canvas element despite being called by its id.  But when the content of renderChart is moved into the render() function it still gives the same error. Here's the code being tested:</p>

<pre><code>import * as React from 'react'
import * as ClassNames from 'classnames'
import * as ChartJS from 'chart.js'
const IsEqual = require('lodash.isequal')
const Find = require('lodash.find')
const subChart = require('chart.js')

interface IChartProps {
  /** The user-defined classes */
  readonly className?: string
  readonly width?: number
  readonly height?: number
  readonly reRender?: boolean

  readonly type: ChartJS.ChartType
  readonly data: ChartJS.ChartData
  readonly options: ChartJS.ChartOptions
  readonly getDatasetAtEvent?: Function
  readonly getElementAtEvent?: Function
  readonly getElementsAtEvent?: Function
  readonly onElementsClick?: Function
  readonly datasetKeyProvider?: Function
}

interface IChartState {
  /** Add your states here */
}

export class Chart extends React.Component&lt;IChartProps, IChartState&gt; {
  // tslint:disable-next-line
  private chartInstance: any
  private shadowData: {}
  constructor(props: IChartProps) {
    super(props)
  }

  public componentWillMount() {
    // this.chartInstance = undefined
  }

  public componentDidMount() {
    this.renderChart()
  }

  // public componentWillReceiveProps(nextProps: IChartProps) {}

  public shouldComponentUpdate(nextProps: IChartProps, nextState: IChartState) {
    const props = this.props
    if (nextProps.reRender === true) {
      return true
    }

    if (props.height !== nextProps.height || props.width !== nextProps.width) {
      return true
    }

    if (props.type !== nextProps.type) {
      return true
    }

    if (!IsEqual(props.options, nextProps.options)) {
      return true
    }

    const nextData = this.transformDataProp(nextProps)

    if (!IsEqual(this.shadowData, nextData)) {
      return true
    }

    return false
  }

  // public componentWillUpdate(nextProps: IChartProps, nextState: IChartState) {}

  public componentDidUpdate(prevProps: IChartProps, prevState: IChartState) {
    if (this.props.reRender) {
      this.chartInstance.destroy()
      this.renderChart()
      return
    }
    this.updateChart()
  }

  public transformDataProp(props: IChartProps) {
    const data = props.data
    if (typeof data === 'function') {
      const node = document.getElementById('bar-chart') as HTMLCanvasElement
      return data(node)
    } else {
      return data
    }
  }

  public memoizeDataProps(props?: IChartProps) {
    if (!this.props.data) {
      return
    }
    const data = this.transformDataProp(this.props)

    this.shadowData = {
      ...data,
      datasets:
        data.datasets &amp;&amp;
        data.datasets.map((set: string[]) =&gt; {
          return { ...set }
        })
    }
    return data
  }

  public updateChart() {
    const options = this.props.options

    const data = this.memoizeDataProps(this.props)

    if (!this.chartInstance) {
      return
    }

    if (options) {
      this.chartInstance.options = subChart.helpers.configMerge(
        this.chartInstance.options,
        options
      )
    }

    let currentDatasets =
      (this.chartInstance.config.data &amp;&amp;
        this.chartInstance.config.data.datasets) ||
      []
    const nextDatasets = data.datasets || []

    const currentDatasetKeys = currentDatasets.map(
      this.props.datasetKeyProvider
    )
    const nextDatasetKeys = nextDatasets.map(this.props.datasetKeyProvider)
    const newDatasets = nextDatasets.filter(
      (d: object) =&gt;
        currentDatasetKeys.indexOf(this.props.datasetKeyProvider(d)) === -1
    )

    for (let idx = currentDatasets.length - 1; idx &gt;= 0; idx -= 1) {
      const currentDatasetKey = this.props.datasetKeyProvider(
        currentDatasets[idx]
      )
      if (nextDatasetKeys.indexOf(currentDatasetKey) === -1) {
        // deleted series
        currentDatasets.splice(idx, 1)
      } else {
        const retainedDataset = Find(
          nextDatasets,
          (d: object) =&gt; this.props.datasetKeyProvider(d) === currentDatasetKey
        )
        if (retainedDataset) {
          // update it in place if it is a retained dataset
          currentDatasets[idx].data.splice(retainedDataset.data.length)
          retainedDataset.data.forEach((point: number, pid: number) =&gt; {
            currentDatasets[idx].data[pid] = retainedDataset.data[pid]
          })
          // const { data, ...otherProps } = retainedDataset
          currentDatasets[idx] = {
            data: currentDatasets[idx].data,
            ...currentDatasets[idx],
            ...retainedDataset.otherProps
          }
        }
      }
    }
    // finally add any new series
    newDatasets.forEach((d: object) =&gt; currentDatasets.push(d))
    const { datasets, ...rest } = data

    this.chartInstance.config.data = {
      ...this.chartInstance.config.data,
      ...rest
    }

    this.chartInstance.update()
  }

  public componentWillUnmount() {
    this.chartInstance.destroy()
  }

  public onClickEvent = (event: React.MouseEvent&lt;HTMLCanvasElement&gt;) =&gt; {
    // this.props.getDatasetAtEvent &amp;&amp;
    this.props.getDatasetAtEvent(
      this.chartInstance.getDatasetAtEvent(event),
      event
    )

    // this.props.getElementAtEvent &amp;&amp;
    this.props.getElementAtEvent(
      this.chartInstance.getElementAtEvent(event),
      event
    )

    // this.props.getElementsAtEvent &amp;&amp;
    this.props.getElementsAtEvent(
      this.chartInstance.getElementsAtEvent(event),
      event
    )

    // this.props.onElementsClick &amp;&amp;
    this.props.onElementsClick(
      this.chartInstance.getElementsAtEvent(event),
      event
    )
  }

  public render() {
    const className = ClassNames('chart', this.props.className)

    // bar.update()
    return (
      &lt;div className={className}&gt;
        &lt;canvas
          id=""chart-instance""
          width={this.props.width ? this.props.width : '400'}
          height={this.props.height ? this.props.height : '400'}
          onClick={this.onClickEvent}
        /&gt;
      &lt;/div&gt;
    )
  }

  public renderChart() {
    const { options, type, data } = this.props
    const node = document.getElementById('chart-instance') as HTMLCanvasElement
    // const data = this.memoizeDataProps()

    this.chartInstance = new ChartJS(node, {
      type,
      data,
      options
    })
  }
}
</code></pre>

<p>can someone help me figure out why this won't work properly?</p>
","5198972","","","","","2017-08-13 08:27:07","TypeError: Cannot read property 'length' of null in react component","<reactjs><typescript><chart.js><jest>","1","2","","",""
"45669020","1","","","2017-08-14 07:00:21","","0","508","<p>Iam doing an app in react-redux and i want to hold my redux store on page refresh and thought to not make use of predefined libraries and hence i set the redux state to local state and making the api call in <code>componentWillUnmount</code> to restore redux state on page refresh.But i couldnt do that. Is their any approch to acheive this:</p>

<p>And my code is:</p>

<pre><code>componentWillMount(){
    this.setState({
        activeUser:this.props.activeUser
    })
}
componentWillUnmount(){
    this.props.loginUser(this.state.activeUser.user);
}
</code></pre>

<p>activeUser is my redux state and <code>this.props.loginUser()</code> makes api call.And i tried of using event handlers as:</p>

<pre><code>componentDidMount(){
    window.addEventListener('onbeforeunload', this.saveStore)
}

componentWillUnmount(){
    window.removeEventListener('beforeunload', this.saveStore)
}

saveStore(){
    this.props.loginUser(this.state.activeUser.user);
}
</code></pre>

<p>but it didn't worked for me.</p>
","6365567","","","","","2017-08-14 09:47:19","how to call a function on page refresh in react-redux?","<api><reactjs><redux>","1","2","1","",""
"37433800","1","","","2016-05-25 10:02:24","","2","449","<p>I am using <code>Animated.Image</code> inside a <code>scrollView</code>. I apply a pan <code>responder</code> to the <code>Animated.Image</code>.</p>

<p>The problem: when I move the image for big distance, it disappears.</p>

<p>The question: how can I adjust the <code>Animated.Image</code> to stay within specific boundaries when i move it?</p>

<p>My code:</p>

<pre><code>import React, { Component } from 'react';
import {
    AppRegistry,
    StyleSheet,
    Text,
    View,
    Image,
    Animated,
    PanResponder,
    ScrollView
} from 'react-native';
var xPosition, yPosition;
var position;
export default class AvatarEditor extends Component {
    constructor(props) {
        super(props);
        this.state = {
            pan: new Animated.ValueXY(), // inits to zero
            image: this.props.image,
            border: this.props.border,
            width: this.props.width,
            height: this.props.height,
            viewWidth: this.props.width + 2 * this.props.border,
            viewHeight: this.props.height + 2 * this.props.border,
            first: true,
            left: 0,
            top: 0,
            xPosition: 0,
            yPosition: 0,
            translateX: 0,
            translateY: 0
        };
    }

    componentWillMount() {
        this._animatedValueX = 0;
        this._animatedValueY = 0;
        this.state.pan.x.addListener((value) =&gt; this._animatedValueX = value.value);
        this.state.pan.y.addListener((value) =&gt; this._animatedValueY = value.value);
        this._panResponder = PanResponder.create({
            onMoveShouldSetResponderCapture: () =&gt; true, //Tell iOS that we are allowing the movement
            onMoveShouldSetPanResponderCapture: () =&gt; true, // Same here, tell iOS that we allow dragging
            onPanResponderGrant: (e, gestureState) =&gt; {
                this.state.pan.setOffset({ x: this._animatedValueX, y: this._animatedValueY });
                this.state.pan.setValue({ x: 0, y: 0 }); //Initial value
            },
            onPanResponderMove: (evt, gestureState) =&gt; {
                // Animated.event([
                //     null, { dx: this.state.pan.x, dy: this.state.pan.y }
                // ]) // Creates a function to handle the movement and set offsets

                newdx = gestureState.dx;
                newdy = gestureState.dy;
                Animated.event([
                    null, { dx: this.state.pan.x, dy: this.state.pan.y },
                ])(evt, { dx: newdx, dy: newdy });

            },
            onPanResponderRelease: () =&gt; {
                this.state.pan.flattenOffset(); // Flatten the offset so it resets the default positioning
            }
        });
    }
    componentDidMount() {

    }

    componentWillUnmount() {
        this.state.pan.x.removeAllListeners();
        this.state.pan.y.removeAllListeners();
    }

    render() {

        var imageStyle = {
            width: this.state.width,
            height: this.state.height,
            resizeMode: 'stretch',
            top: this.state.top,
            left: this.state.left,
            transform: [
                { translateX: this.state.pan.x },//this.state.pan.x
                { translateY: this.state.pan.y },
                { scale: this.props.scale }
            ]
        };
        return (
            &lt;View
                style={[this.props.style, { backgroundColor: 'gray' }]}
                &gt;
                &lt;ScrollView
                    style={{
                        width: this.state.viewWidth,
                        height: this.state.viewHeight,
                        borderWidth: this.state.border,
                        borderColor: 'rgba(100, 100, 100, 0.5)',
                        overflow: 'hidden',
                    }}
                    scrollEnabled={false}
                    &gt;
                    &lt;Animated.Image
                        style={imageStyle}
                        source={{ uri: this.state.image }}
                        {...this._panResponder.panHandlers}
                        &gt;
                    &lt;/Animated.Image&gt;
                &lt;/ScrollView&gt;
            &lt;/View&gt;
        );
    }
}

AvatarEditor.propTypes = {
    scale: React.PropTypes.number,
    image: React.PropTypes.string,
    border: React.PropTypes.number,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    style: React.PropTypes.object
};

AvatarEditor.defaultProps = {
    scale: 1,
    border: 25,
    width: 200,
    height: 200,
    style: {
        top: 50,
        left: 25,
        position: 'absolute',
    },
    image: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQesv5ucRQ1KUNtDipnrhS6Gn9yMn7GOqFdQGTeLMG1fCKGvudEUji_Aw',
};
</code></pre>
","6380499","","5520354","","2016-05-25 11:41:27","2016-05-25 11:41:27","Animated.Image with PanResponder 'react-native","<react-native>","0","1","1","",""
"45667996","1","","","2017-08-14 05:37:25","","0","90","<p>I'm currently developing Preact for my small project. One of my page is Master Detail page. Left side is detail page and right side is list page. Problem is whenever I click link on right side list page, detail page not rendered as getting stuck but render correctly when reload page. Please help me how to solve it.</p>

<p><strong>left side</strong></p>

<pre><code>fetchAPI(url) {
    return fetch(url)
        .then((response) =&gt; {
            if (response.status &gt;= 400) {
                throw new Error('Bad response from server');
            }
            return response.json();
        });
}

componentDidMount() {
    const that = this;
    const url = 'https://blah.com/' + this.props.courseId;
    const instituteUrl = 'https://blah.com/';

    this.fetchAPI(url).then((data) =&gt; {
        this.fetchAPI(instituteUrl + data.institute_id).then((instituteData) =&gt; {
            that.setState({
                result: data,
                institute: data.institute,
                courses: instituteData.courses.rows
            });
        });
    });
}

componentWillUnmount() {

}

render({ }, { result={}, institute={}, courses=['', '', '', '', '', '', '', '', '', ''] }) {
    return (
        &lt;div class={style.category}&gt;
            &lt;div class={style.content}&gt;
                &lt;Title title={result.title} /&gt;
                &lt;SubTitle subtitle={institute.name} /&gt;
                &lt;Description description={result.html_description} /&gt;
            &lt;/div&gt;
            &lt;div class={style.listContent}&gt;
                { courses.map( result =&gt; (
                    &lt;CoursesList result={result} target=""_parent"" /&gt;
                )) }
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p><strong>right list</strong></p>

<pre><code>export default class CoursesList extends Component {
    render() {
        if (this.props.result.title &amp;&amp; this.props.result.title !== '') {
            return (
                &lt;div class={style.coursesList}&gt;
                    &lt;div class={style.withpreview}&gt;
                        &lt;Link href={'/course/' + changeSlug(this.props.result.title) + '/' + this.props.result.id}&gt;{this.props.result.title}&lt;/Link&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            );
        } else {
            return (
                &lt;div class={style.coursesList}&gt;
                    &lt;div class={style.withoutpreview}&gt;&lt;/div&gt;
                &lt;/div&gt;
            );
        }
    }
}
</code></pre>
","2555911","","","","","2018-02-06 00:54:45","preact-router not working properly whenever click hyper link","<reactjs><preact>","1","0","","",""
"45680436","1","","","2017-08-14 18:06:55","","0","49","<p>I am building a component in react - inside of this component first I make an Ajax call to a service and then take a part of the response (and other variables) and use those inside of another function to get an advertisement through DFP.  My calls to DFP are working as expected without any problems - my problem is in the Ajax response and sending the correct data over to DFP.</p>

<p>I need to get lineItem set inside the fetch and passed into setPageLevelTargeting()</p>

<pre><code>import React from 'react';
import PropTypes from 'prop-types';
import { GPT, applyGPTAttributes, getMediaMapping } from './dfpHelper';

class PubAdRecs extends React.Component {
constructor(props) {
super(props);
// iu_szs in REQUEST HEADER
this.sizeMapping =
  this.props.sizeMapping || getMediaMapping(this.props.adSize || this.props.adName);
this.setGPTAttributes();
this.state = {
    myData: [],
    adRecs: false
};


this.setPageLevelTargeting = this.setPageLevelTargeting.bind(this);
this.lineItem = '123';
}

componentDidMount() {
const channelFF = 'firefly';
const size = 'fluidx1200x100x728x90x970x90';
const apiUrl = 'https://api.mysite.com';
const adRecs = 'ad_recommendations/v1/recommendations';

fetch(`${apiUrl}/${adRecs}`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    placements: [{ page_location: this.props.adName, placement_size: size }],
    channel_id: '015D9E6B2E320201BEC36788CB9A61D2',
    channel_type: channelFF,
    page_type: this.props.pageType,
    search_term: '/c/55b0t',
    category_id: this.props.page,
    page_id: this.props.pageType
  })
})
.then( (data) =&gt;  data.json() )
.then( (response) =&gt; 
    this.setState({
        myData: response,
        adRecs: true
    }),
this.lineItem = 'testing' // **** GET THIS VALUE ****
// this.lineItem = this.state.myData.map( (myData) =&gt; myData.page_location)
)}


// In case the component is removed stop attempting to make Ajax Call!
componentWillUnmount() {
// this.adRecsFetch.abort();
}

// applying GPT methods
setGPTAttributes() {
  applyGPTAttributes();
  this.setPageLevelTargeting(this.props.page);
}

// scp in REQUEST HEADER
getSlotTargetingParams() {
  return {
    as: `${this.props.page}${this.props.adName}`,
    pos: this.props.adName
  };
}

// iu in REQUEST HEADER
getAdUnitPath() {
  const networkId = this.props.networkCode;
  const adUnitCode = this.props.adUnitCode;
  const adUnitPage = this.props.pageCategory
    ? `${this.props.pageType}/${this.props.pageCategory}`
    : this.props.page;
return `/${networkId}/${adUnitCode}/${adUnitPage}`;
}

// cust_param in REQUEST HEADER

setPageLevelTargeting() {
const customParams = this.props.customParams || {};

const pageTarget = Object.assign(
  {},
  {
    n_cat: this.props.page,
    fly: this.props.fly,
    pt: this.props.pageType,
    line_item_id: this.lineItem // **** PUT THE VALUE HERE ****
  },
  customParams
);
Object.keys(pageTarget).map(key =&gt; GPT.setTargeting(key, pageTarget[key]));
}

render() {
console.log(this.lineItem);
  if (!this.state.adRecs) {
      return null
  }
return (
  &lt;div&gt;

    &lt;h2 className=""h-sr-only"" aria-hidden=""true""&gt;third party advertisement&lt;/h2&gt;
    &lt;GPT
      adUnitPath={this.getAdUnitPath()}
      sizeMapping={this.sizeMapping}
      targeting={this.getSlotTargetingParams()}
    /&gt;
    &lt;p style={{ margin: '20px' }}&gt;
      Ad Recs Text {this.state.myData.map( (myData) =&gt; myData.page_location)}
    &lt;/p&gt;
  &lt;/div&gt;
);
}
}



PubAdRecs.propTypes = {
  adName: PropTypes.string.isRequired,
  adSize: PropTypes.string,
  networkCode: PropTypes.string.isRequired,
  adUnitCode: PropTypes.string.isRequired,
  page: PropTypes.string,
  pageType: PropTypes.string.isRequired,
  pageCategory: PropTypes.string,
  fly: PropTypes.string.isRequired,
  sizeMapping: PropTypes.arrayOf(PropTypes.object),
  customParams: PropTypes.object // eslint-disable-line react/forbid-prop-types
};

export default PubAdRecs;
</code></pre>
","3037513","","","","","2017-08-14 18:06:55","Passing variables inside react components then to DFP","<ajax><reactjs>","0","0","","",""
"29069639","1","29069827","","2015-03-16 04:26:30","","41","33201","<p>I want to bind to close the active react bootstrap popover on <code>escape</code> press .Here is the code</p>

<pre><code>_handleEscKey:function(event){
         console.log(event);
        if(event.keyCode == 27){
          this.state.activePopover.hide();
        }
   },

  componentWillMount:function(){
     BannerDataStore.addChangeListener(this._onchange);
     document.addEventListener(""click"", this._handleDocumentClick, false);
     document.addEventListener(""keyPress"", this._handleEscKey, false);
   },


   componentWillUnmount: function() {
     BannerDataStore.removeChangeListener(this._onchange);
      document.removeEventListener(""click"", this._handleDocumentClick, false);
      document.removeEventListener(""keyPress"", this._handleEscKey, false);
   },
</code></pre>

<p>But nothing is getting logged in the console when I press any key. I have tried to listen that on window also and with different cases .'keypress','keyup' etc but it seem I am doing something wrong .</p>
","1754098","","","","","2017-02-18 09:43:42","Listen to keypress for document in reactjs","<reactjs><react-jsx><react-bootstrap>","2","1","5","",""
"45477449","1","","","2017-08-03 07:21:32","","2","477","<p>As doc mentioned I ve initialized video js in react by doing something like this ...</p>

<pre><code>    import React from 'react';
    import videojs from 'video.js'

    export default class VideoPlayer extends React.Component {
      componentDidMount() {
        // instantiate video.js
        this.player = videojs(this.videoNode, this.props, function onPlayerReady() {
          console.log('onPlayerReady', this)
        });
      }

      // destroy player on unmount
      componentWillUnmount() {
        if (this.player) {
          this.player.dispose()
        }
      }

      // wrap the player in a div with a `data-vjs-player` attribute
      // so videojs won't create additional wrapper in the DOM
      // see https://github.com/videojs/video.js/pull/3856
      render() {
        return (
          &lt;div data-vjs-player&gt;
            &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js""&gt;&lt;/video&gt;
          &lt;/div&gt;
        )
      }
    }
</code></pre>

<p>I want to integrate VideoJs Overlay plugin in this... 
so i ve done something like this...</p>

<pre><code>import React from 'react';
import videojs from 'video.js'

export default class VideoPlayer extends React.Component {
  componentDidMount() {
    // instantiate video.js
    this.player = videojs(this.videoNode, this.props, function onPlayerReady() {

player.overlay({
            content: 'Default overlay content',
            debug: true,
            overlays: [{
              content: 'The video is playing!',
              start: 'play',
              end: 'pause'
            }, {
              start: 0,
              end: 15,
              align: 'bottom-left'
            }, {
              start: 15,
              end: 30,
              align: 'bottom'
            }, {
              start: 30,
              end: 45,
              align: 'bottom-right'
            }, {
              start: 20,
              end: 'pause'
            }]
          });
            });
      }

  // destroy player on unmount
  componentWillUnmount() {
    if (this.player) {
      this.player.dispose()
    }
  }

  render() {
    return (
      &lt;div data-vjs-player&gt;
        &lt;video ref={ node =&gt; this.videoNode = node } className=""video-js"" id=""videojs-overlay-player""&gt;&lt;/video&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>While doing this it give me error like player.overlay is not function...</p>

<p>and if i do     <code>videojs.registerPlugin('overlay', overlay);</code></p>

<p>and call overlay function it gives me error like <code>component Overlay is undefined</code></p>

<p>How to workout videojs plugins in react way????</p>
","3048483","","","","","2017-08-08 10:24:18","use videojs plugins in react Video JS","<reactjs><overlay><video.js>","0","3","0","",""
"46417498","1","46417681","","2017-09-26 03:44:15","","0","54","<p>I have created a timer module from react in which there is one input and three button 1-Start(which starts the timer) 2-Pause(pause the timer) 3-Stop(Stops the timer), Now the problem is that when i input any value and starts the timer and when i press ""Stop"" button the value becomes 0 but when i again hit the 
""Start"" button the counter starts from the previous value which i clicked at the time of Stop button rather it should start from the value which is written on input field previously. Please check it if you are not understanding what i'm telling.</p>

<p>Code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!Doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;React 1&lt;/title&gt;
        &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.0.2/react.js""&gt;&lt;/script&gt;
		&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.0.2/react-dom.js""&gt;&lt;/script&gt;
        &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js""&gt;&lt;/script&gt;  
        &lt;script src=""https://unpkg.com/react-form-with-constraints/dist/react-form-with-constraints.js""&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=""text/jsx""&gt;
            var styles = {
                margin: '2em auto',
                width: '300px',
                height: '300px',
                backgroundColor: '#DD4814',
                color: '#ffffff',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'space-around'
            };
            var inputs = {
                position: 'relative',
                bottom: '17%',
                left: '20%'
            }
            var btns = {
                position: 'relative',
                bottom: '7%'
            }
            var btn = {
                backgroundColor: '#ffffff',
                color: '#000000',
                borderColor: '#DEB887',
                borderRadius: '0.4em',
                cursor: 'pointer',
                margin: '0 1em',
                padding: '0.5em',
                display: 'inline-block'
            }
            class Timer extends React.Component {
                constructor (props) {
                    super(props)
                    this.state = 
                        {
                            count: 0,
                            customNumber: 0
                        }
                }
				handleChange (e) {
                    this.setState({	customNumber: e.target.value});
                }
                componentWillUnmount () {
                    clearInterval(this.timer)
                }
                tick () {
                    if (this.state.customNumber) {
						this.setState({
							count: (this.state.customNumber--)
						})
						if (this.state.customNumber &lt;= 0) {
							this.setState({	count: 0})
							clearInterval(this.timer)
							this.setState({ disabled: false })
						}
                    } else {
                        this.setState({count: (this.state.count - 1)})
                    }
                }
				
				display () {
                    return ('0' + this.state.count % 100).slice(-2)
                }
				
                startTimer () {
                    if (this.state.customNumber == """" || isNaN(this.state.customNumber)) 
                    {
                        alert(""Please give some value in number"");
                    } else {
                        clearInterval(this.timer)
                        this.timer = setInterval(this.tick.bind(this), 1000)
                        this.setState({ disabled: true })
                    }
                }
                stopTimer () {
                    clearInterval(this.timer)
                }
                resetTimer () {
                    clearInterval(this.timer)
                    this.setState({count: 0})
                    this.setState({ disabled: false })
                }
                render () {
                    return (
                    &lt;div style={styles} className='timer'&gt;
                        &lt;h1 style={{fontSize: '4em'}}&gt;{this.display()}&lt;/h1&gt;
						&lt;div className=""input_text"" style={inputs}&gt;
							&lt;label htmlFor=""custom_number""&gt;Enter number to start timer&lt;/label&gt;
							&lt;input type=""text"" name=""custom_number"" id=""custom_number"" value={this.state.inputValue} onChange={this.handleChange.bind(this)} disabled={this.state.disabled} placeholder=""Enter b/w 1-100"" /&gt;
						&lt;/div&gt;
                        &lt;div style={btns} className=""buttons""&gt;
							&lt;button style={btn} type=""button"" name=""start_btn"" id=""start_btn"" onClick={this.startTimer.bind(this)}&gt;Start&lt;/button&gt;
							&lt;button style={btn} type=""button"" name=""stop_btn"" id=""stop_btn"" onClick={this.stopTimer.bind(this)}&gt;Pause&lt;/button&gt;
							&lt;button style={btn} type=""button"" name=""reset_btn"" id=""reset_btn"" onClick={this.resetTimer.bind(this)}&gt;Stop&lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    )
                }
            }
            ReactDOM.render( &lt;Timer /&gt;, document.getElementById('root') )
        &lt;/script&gt;
        &lt;div id=""root""&gt;&lt;/div&gt;
    &lt;/body&gt;    
&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","","user8079593","","","","2017-09-26 13:46:37","Start Stop button not working in sync in react","<javascript><reactjs><timer>","1","2","","",""
"45637699","1","","","2017-08-11 14:30:42","","0","90","<p>I'm trying to implement some react components for a grid system.
The current implementation uses jQuery, so I need to completely reimplement the JS functionality...
The grid system adds a class to all elements that wrap to row 2 or more.</p>

<p>I also want to identify if the element is in the rows first and/or last column..</p>

<p>I'm currently using <code>ReactDOM.findDOMNode(this)</code> to get the <code>offsetTop</code> and <code>parentElement.offsetTop</code></p>

<pre><code>export default class Cell extends Component {
  static propTypes = {
    children: PropTypes.node,
  };

  static defaultProps = {
    children: '',
  };

  constructor(props){
    super(props);
    this.checkMargin = this.checkMargin.bind(this)
  }

  checkMargin() {
    this.newRow = false
    const _elm = ReactDOM.findDOMNode(this)
    this.newRow = (_elm.offsetTop &gt; _elm.parentElement.offsetTop)
  }

  componentDidMount() {
    window.addEventListener('resize', this.checkMargin)
    this.checkMargin()
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.checkMargin)
  }

  render() {
    const { children } = this.props
    return (&lt;div className={this.newRow ? 'margin-top' : ''}&gt;{children}&lt;/div&gt;)
  }
}
</code></pre>

<p>The wrapping parent looks as follows:</p>

<pre><code>export default class Grid extends Component {

  static propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,
  }

  static defaultProps = {
    children: '',
    className: '',
  }

  static childContextTypes = {
    cell: PropTypes.object.isRequired,
  }

  render() {
    const className = classNames(
        'grid-wrapper',
        this.props.className
    )
    const { children } = this.props

    return (
      &lt;div className={className}&gt;
        {children}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p>The columns can be specified with classes on either the parent or the individual cell with a <code>child-width-1-3</code> on the parent or <code>width-2-3</code> on the cell.
There are a number of issues with this implementation though...</p>

<p>The question is Two-fold:</p>

<ul>
<li>It uses findDOMNode - I haven't found a case that shows to use <code>ref</code> in this context, but the recommendation is to use ref instead of <code>findDOMNode</code>.. but all examples I have seen relates to referencing other elements.</li>
<li>It wont actually update on resize .. since the <code>margin-top</code> class adds to the offset, and thus causes the element to still have a greater offset than it's parent, even if it have moved to the first row. Is there any way I can solve this without hardcoding the css values for the margin-top in to the component, or have the user supply it each time they want to use the component (as the user might change the value of <code>margin-top</code> in their less code variable).</li>
</ul>
","1203957","","1203957","","2017-08-11 21:44:01","2017-08-11 21:44:01","Get react component offset to direct parent","<javascript><reactjs><react-dom>","0","1","","",""
"45116946","1","","","2017-07-15 10:04:24","","0","119","<p>I have two component like app.js and SetInterval.js. The function will be called when calling the setinterval.js. Now i want to call the timeinterval function from app.js. I'm sharing the below code for your reference. </p>

<pre><code>//App.js
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
import SetInterval from './SetInterval';

export default class App extends Component {

  render() {

    return (
      &lt;div className=""App""&gt;
        &lt;SetInterval /&gt;
        &lt;div className=""App-header""&gt;
          &lt;img src={logo} className=""App-logo"" alt=""logo"" /&gt;
          &lt;h2&gt;Welcome to React&lt;/h2&gt;
        &lt;/div&gt;
        &lt;p className=""App-intro""&gt;
          To get started, edit &lt;code&gt;src/App.js &lt;/code&gt; sadfsdfasdf and save to reload.
        &lt;/p&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>Setinterval.js</p>

<pre><code>import React, { Component } from 'react';

export default class SetInterval extends Component {
    constructor() {
    super();

    this.state = {
        secondsElapsed:0
    }; 
    this.tick = this.tick.bind(this);
}
getInitialState(){
    return {secondsElapsed:0};
 }
  tick() {
      let secondsElapsed = parseInt(this.state.secondsElapsed) + 1;
    this.setState({secondsElapsed: this.state.secondsElapsed + 1});
    console.log(this.state.secondsElapsed)
    if(this.state.secondsElapsed == 10){
        alert(1)
    }
  }
  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }
  componentWillUnmount() {
    clearInterval(this.interval);
  }
}
</code></pre>

<p>I have to get the secondsElapsed value on each call of tick function.</p>
","8311590","","8311590","","2017-07-15 10:17:13","2017-07-15 10:17:13","How to call the timeinterval function from another component in reactJs?","<reactjs>","1","2","","",""
"37050805","1","","","2016-05-05 12:36:49","","10","3319","<p>I have done a component with a store using react, redux and react-redux.
bundling of the code is done with webpack.(please check the codes attached below)</p>

<p>when i wanted to use the webpack build component inside another react project i faced the following issues.</p>

<ul>
<li><blockquote>
  <p>Warning: React.createElement: type should not be null, undefined,
  boolean, or number. It should be a string (for DOM elements) or a
  ReactClass (for composite components).</p>
</blockquote></li>
<li><blockquote>
  <p>Uncaught Invariant Violation: Element type is invalid: expected a
  string (for built-in components) or a class/function (for composite
  components) but got: undefined.</p>
</blockquote></li>
</ul>

<p>Then i went on and do the following modification in the code, earlier i had a destructuring assignment like below for <strong>connect</strong> and <strong>bindActionCreators</strong> </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {connect} from 'react-redux';
import  {bindActionCreators} from 'redux';
import  actions from '../app/redux/actions';</code></pre>
</div>
</div>
</p>

<p>Then i changed it like below, by removing the curly braces around connect and bindActionCreators</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';

import connect from 'react-redux';
import  bindActionCreators from 'redux';
import  actions from '../app/redux/actions';

import postal from 'postal';

const channel = postal.channel(""msplayer"");

class Player extends React.Component {</code></pre>
</div>
</div>
</p>

<p>But after that i'm facing the below error, as i guess this is something to do with babel transpiling ES6 to ES5 , but not sure what steps to follow to resolve this, would like to get an answer or some pointers to get this resolved?</p>

<ul>
<li><blockquote>
  <p>Uncaught TypeError: (0 , _reactRedux2.default) is not a function</p>
</blockquote></li>
<li><blockquote>
  <p>Uncaught TypeError: Cannot read property 'PlayerWrapper' of undefined</p>
</blockquote></li>
</ul>

<p><strong>component code</strong> </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';

import {connect} from 'react-redux';
import  {bindActionCreators} from 'redux';
import  actions from '../app/redux/actions';

import postal from 'postal';

const channel = postal.channel(""msplayer"");

class Player extends React.Component {


    constructor() {
        super();
        this.state = {
            userData: {},
            uiStates: {
                panelClosed: true,
                submissionSelected: false
            },
            selectedSubmission: {}
        };
        this.subSelectChannel = null;
        this.tabSelectChannel = null;
    }


    componentWillMount() {
        require('!style!css!../app/styles/player.css');
    }

    componentDidMount() {
        var _that = this;
        var _msData = {
            piToken: this.props.piToken,
            sectionId: this.props.sectionId,
            assignmentId: this.props.assignmentId,
            userId: this.props.userId
        };

        this.props.actions.getAssignmentData(msData);
        this.props.actions.getPeerSubmissionData(msData);

        this.subSelectChannel = channel.subscribe(""submission.selected"", function (data, envelope) {
            _that.setState({
                    uiStates: Object.assign({}, _that.state.uiStates, {
                        ""submissionSelected"": true
                    })
                }
            );
            _that.setState({
                    selectedSubmission: data.submission
                }
            );
        });

        this.tabSelectChannel = channel.subscribe(""tab.selected"", function (data, envelope) {
            if (data.submitted) {
                _that.showSubmissionDetailPanel(data.data);
            } else {
                _that.hideSubmissionDetailPanel()
            }
        });
    }

    closePanel() {

        postal.publish({
            channel: ""notifier"",
            topic: ""notifier.notify"",
            data: {
                type: ""warning"",
                message: ""warning message""
            }
        });


        if (this.state.uiStates.panelClosed) {

            this.setState({
                    uiStates: Object.assign({}, this.state.uiStates, {
                        ""panelClosed"": false
                    })
                }
            );
        } else {


            postal.publish({
                channel: ""msplayer"",
                topic: ""close.selected"",
                data: {}
            });

            this.setState({
                    uiStates: Object.assign({}, this.state.uiStates, {
                        ""panelClosed"": true,
                        ""submissionSelected"": false
                    })
                }
            );
        }
    }


    hideSubmissionDetailPanel() {
        console.log(""inside hide submission panel"");
        this.setState({
                uiStates: Object.assign({}, this.state.uiStates, {
                    ""submissionSelected"": false
                })
            }
        );
    };

    showSubmissionDetailPanel(data) {
        console.log(""inside show submission panel"");
        this.setState({
                uiStates: Object.assign({}, this.state.uiStates, {
                    ""submissionSelected"": true
                })
            }
        );

        this.setState({
            selectedSubmission: data
        });
    };


    loadUserAssignmentData(submission) {

        this.setState({
                uiStates: Object.assign({}, this.state.uiStates, {
                    ""submissionSelected"": true
                })
            }
        );

        postal.publish({
            channel: ""msplayer"",
            topic: ""submission.selected"",
            data: {
                submission: submission
            }
        });

    }

    componentWillUnmount() {
        postal.unsubscribe(this.subSelectChannel);
        postal.unsubscribe(this.tabSelectChannel);
    }

    render() {

        var _that = this;
        var _submittedKey = 0;
        var _unsubmittedKey = 0;
        return (
            &lt;div className=""player-container col-sm-12""&gt;
                &lt;div className=""row""&gt;
                &lt;/div&gt;
                &lt;div className=""row""&gt;
                    &lt;div className={_that.state.uiStates.panelClosed?""col-sm-12"":""col-sm-8""}&gt;
                        &lt;div className=""top-actions-panel""&gt;
                            &lt;div className=""pull-right""&gt;

                            &lt;/div&gt;


                        &lt;/div&gt;
                        &lt;div className=""common-view""&gt;
                            &lt;div className=""breadcrumb-panel""&gt;
                                &lt;ol className=""breadcrumb arrow-left""&gt;
                                    &lt;li&gt;&lt;a href=""#""&gt;Communication 220&lt;/a&gt;&lt;/li&gt;
                                    &lt;li className=""active""&gt;TED Topics for an Informative Speech&lt;/li&gt;
                                &lt;/ol&gt;
                            &lt;/div&gt;
                            &lt;div className=""description-panel""&gt;
                                &lt;p className=""title""&gt;
                                    &lt;b&gt;Title&lt;/b&gt;:
                                    &lt;span&gt;{_that.props.assignment.title}&lt;/span&gt;
                                &lt;/p&gt;
                                &lt;p className=""dueDates font-light""&gt;
                                    &lt;b&gt;Due &lt;/b&gt;:&lt;span&gt;{_that.props.assignment.startDate}&lt;/span&gt;
                                    &lt;b&gt; - &lt;/b&gt;&lt;span&gt;{_that.props.assignment.endDate}&lt;/span&gt;
                                &lt;/p&gt;
                                &lt;p&gt;
                                    &lt;b&gt;Learning Objective: &lt;/b&gt;
                                    &lt;span&gt;{_that.props.assignment.learningObjective}&lt;/span&gt;
                                &lt;/p&gt;
                                &lt;p&gt;
                                    &lt;b&gt;Description: &lt;/b&gt;
                                    &lt;span&gt;
                                       {_that.props.assignment.description}
                                    &lt;/span&gt;
                                &lt;/p&gt;
                            &lt;/div&gt;

                            &lt;div
                                className={_that.state.uiStates.submissionSelected?""row submission-info col-sm-12"":""hidden""}&gt;
                                &lt;div&gt;
                                    &lt;span className=""student-avatar""&gt;
                                        &lt;img
                                            src={(_that.state.selectedSubmission &amp;&amp; _that.state.selectedSubmission.userDetails &amp;&amp; _that.state.selectedSubmission.userDetails.avatar &amp;&amp; _that.state.selectedSubmission.userDetails.avatar!=="""")?_that.state.selectedSubmission.userDetails.avatar:""../app/images/avatar.svg""}/&gt;
                                    &lt;/span&gt;

                                    &lt;p&gt;
                                        &lt;b&gt; &lt;span
                                            className=""font-light mediaTile""&gt;&lt;strong&gt;{(_that.state.selectedSubmission.title &amp;&amp; _that.state.selectedSubmission.title !== null &amp;&amp; _that.state.selectedSubmission.title !== """" ) ? _that.state.selectedSubmission.title : "".""}&lt;/strong&gt;&lt;/span&gt;
                                        &lt;/b&gt;
                                    &lt;/p&gt;
                                    &lt;br/&gt;
                                    &lt;p&gt;
                                        &lt;span
                                            className=""font-light ""&gt;{(_that.state.selectedSubmission.description &amp;&amp; _that.state.selectedSubmission.description !== null &amp;&amp; _that.state.selectedSubmission.description !== """") ? _that.state.selectedSubmission.description : "".""}&lt;/span&gt;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;

                            &lt;div className=""common-functionality-panel col-sm-12""&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div
                        className={_that.state.uiStates.panelClosed?""hidden"":""col-sm-4 no-padding peer-review-panel""}&gt;

                        &lt;div className=""review-section""&gt;
                            &lt;button className=""btn btn-link pull-left close-panel""
                                    onClick={_that.closePanel.bind(_that)}&gt;
                                &lt;span className=""reader-only""&gt;Close Student Submission Panel&lt;/span&gt;
                                &lt;i className=""fa fa-times""&gt;&lt;/i&gt;
                            &lt;/button&gt;

                            &lt;div className=""submission-tabs""&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

}

function mapStateToProps(state) {
    return state
}

function mapDispatchToProps(dispatch) {
    return {
        actions: bindActionCreators(actions, dispatch)
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(Player)</code></pre>
</div>
</div>
</p>

<p><strong>component wrapper code</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import Player from './app';

import bb from './redux/store'
import Provider from 'react-redux';

class PlayerWrapper extends React.Component {


    constructor(props) {
        super(props);
    }

    render() {
        return (
            &lt;Provider store={bb.store}&gt;&lt;Player piToken={this.props.piToken} sectionId={this.props.sectionId}
                                               assignmentId={this.props.assignmentId}
                                               userId={this.props.userId}/&gt;&lt;/Provider&gt;
        )
    }
}

export default PlayerWrapper;</code></pre>
</div>
</div>
</p>

<p><strong>webpack build file</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var webpack = require('webpack');

module.exports = {
    devtool: 'inline-source-map',
    entry: [
        'webpack-hot-middleware/client',
        './app/PlayerWrapper.js'
    ],
    output: {
        path: require(""path"").resolve(""./dist/app""),
        filename: 'index.js',
        publicPath: '/'
    },
    plugins: [
        new webpack.optimize.OccurrenceOrderPlugin(),
        new webpack.HotModuleReplacementPlugin(),
        new webpack.NoErrorsPlugin()
    ],
    module: {
        loaders: [{
            test: /\.js?$/,
            exclude: /node_modules/,
            loader: 'babel-loader',
            query: {
                presets: ['react', 'es2015']
            }
        },
        { test: /\.css$/, loader: [""css-loader"",""style-loader""] },
        { test: /\.scss$/, loader: ""sass-loader"" },
        { test: /\.(ttf|eot|svg|eot|woff|otf|png|gif)(\?v)*/, loader: ""file-loader?name=fonts/[name].[ext]"" }
        ]
    }
};</code></pre>
</div>
</div>
</p>
","202313","","202313","","2016-05-05 13:43:42","2017-11-08 17:23:35","Error using component done with react,redux and react-redux and build with webpack in react application","<reactjs><webpack><babeljs><redux><react-redux>","3","4","1","",""
"45473309","1","","","2017-08-03 01:22:09","","0","1891","<p>I am using react modal to set up a pop up in on one of my components.  I have a component that renders a div wrapped with react modal.  My parent component renders the modal component on load with the isOpen set to false.  Clicking a link on the parent sets isOpen to true and causes the modal popup to open.  </p>

<p>I make changes to my data within the open popup and then save the changes and close the model when the close button is clicked.</p>

<p>I am using a redux set up with actions and reducers handling the data changes and state changes. </p>

<p>Conceptually, how would I update the parent to show the changes made from the popup? Shouldn't changes to my data using an action cause the store to regenerate and hence update the data in my components or do I have to explicitly ""refresh"" my store after saving? My issue is that right now when the popup closes it is not tirggering any kind of ""refresh"" on the DataView component. </p>

<p>Components below:</p>

<p>DataView component</p>

<pre><code>import React from 'react';
import DataView from './MonthView.js';
import DataViewPopup from './MonthViewPopup.js';
import { connect } from 'react-redux';
import { getAction } from '../actions/actions.js';
import { getActionAll } from '../actions/actions.js';
import { getPopupData } from '../actions/actions.js';

class DataViewContainer extends React.Component {
  constructor() {
    super();

    this.popupCategory = undefined;
    this.popupMonth = undefined;

    this.state = {
      detailPopup : false,
      refreshView: false
    }

  this.handleAddYear = this.handleAddYear.bind(this);
  this.handleSubtractYear = this.handleSubtractYear.bind(this);
  this.handleGetDetail = this.handleGetDetail.bind(this);

  }

  componentDidMount() {
   this.props.getAction(2016);
   this.props.getActionAll(2016);
  }

  render() {

     return (
        &lt;div className=""row""&gt;
          &lt;div className=""col-sm-8""&gt;
              &lt;MonthView transactions={this.props.storeData.storeData} selectedYear={this.props.storeData.selectedYear} onAddYear={this.handleAddYear} onSubtractYear={this.handleSubtractYear} onHandleGetDetail={this.handleGetDetail} /&gt;
          &lt;/div&gt;
          &lt;div className=""col-sm-4""&gt;
              &lt;MonthViewPopup modalActive={this.state.detailPopup} transactions={this.props.storePopupData.getPopupData} selectedYear={this.props.storeTransactions.selectedYear} category={this.popupCategory} month={this.popupMonth}/&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ) 

  }

  handleGetDetail(category,month) {

    console.log(""props inside handleGetDetail:  "", this.props);

    this.popupCategory = category;
    this.popupMonth = month;
    let popupYear = this.props.storeTransactions.selectedYear

    this.props.getPopupData(popupYear, month, category);

    this.setState({ detailPopup: true}, function () {});

  }

}


const mapStateToProps = (state) =&gt; ({
  storeData: state.storeData,
  storePopupData: state.storePopupData,
  storeDataAll: state.storeDataAll
});

export default connect(mapStateToProps, {getAction,getActionAll,getPopupData})(DataViewContainer);
</code></pre>

<p>DataViewPopup component</p>

<pre><code>import React from 'react';
import Modal from 'react-modal';
import { connect } from 'react-redux';

import { saveAction } from '../actions/actions.js';
import { getActionAll } from '../actions/actions.js';

class DataViewPopup extends React.Component {

  constructor (props) {
    super(props)

    this.editedData = new Map(); 

    this.state = {
      modalIsOpen: false
    };

    this.openModal = this.openModal.bind(this);
    this.afterOpenModal = this.afterOpenModal.bind(this);
    this.closeModal = this.closeModal.bind(this);

    this.renderFilteredTransactions = this.renderFilteredTransactions.bind(this);

  }

 openModal() {
    this.setState({modalIsOpen: true});
  }

  afterOpenModal () {
    console.log(""inside afterOpenModal"");
  }

  closeModal () {

    this.props.saveTransactions(this.editedData);

    this.editedData = new Map();

    this.setState({  modalIsOpen: false }, function () {});

  }
  componentWillUnmount() {

    this.props.getDataAll(); // i tried this but it does not work because the component (modal popup) is still mounted, but just not visible

    //this.props.refreshParent();

  }


   componentWillReceiveProps(nextProps){

    if (nextProps.modalActive === true) {
         this.openModal();
         return;
      }

    }

    render () {
        return  &lt;div&gt;
            &lt;Modal
            isOpen={this.state.modalIsOpen}
            //isOpen={this.modalActive}//not needed as is currently setup
            onAfterOpen={this.afterOpenModal}
            onRequestClose={this.closeModal}
            //style={customStyles}
            contentLabel=""Example Modal""
            &gt;

            &lt;button onClick={this.closeModal}&gt;close&lt;/button&gt;

            {this.renderFilteredTransactions(this.props.data,this.props.category,this.props.month)};
            &lt;/Modal&gt;
        &lt;/div&gt;
    } 

    renderFilteredTransactions(trans,category,month){
        return &lt;div&gt;
            &lt;table&gt;
                &lt;tbody className=""mo-tblBody""&gt;
                    {trans &amp;&amp; trans.map((data,index) =&gt;
                        &lt;tr key={data.transid}&gt;
                            &lt;td&gt;{data.transid}&lt;/td&gt;
                            &lt;td&gt;
                              {this.renderCategory(data.category,index,data.transid)}
                            &lt;/td&gt;
                        &lt;/tr&gt;
                    )}
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;

    }

    handleCategoryChange(value,transIndex,transId){

      let trans = JSON.parse(JSON.stringify(this.props.transactions));

      //add or updated transaction to this.editedTransactions based on whether or not the transid already exists
      trans.filter(item =&gt; item.transid === transId)
      .map(item =&gt; this.editedData.set(transId, 
                  Object.assign({}, item, { category: value })));

    }

}

const mapStateToProps = (state) =&gt; {
  return {storeDataAll: state.storeDataAll,
    storeSaveData: state.storeSaveData
  }
};

export default connect(mapStateToProps, {getDataAll,saveData})(DataViewPopup);
</code></pre>
","1991118","","1991118","","2017-08-04 15:29:14","2017-08-04 15:29:14","Reactjs refresh parent after react modal popup changes data","<reactjs><redux><react-modal>","1","4","","",""
"29686138","1","","","2015-04-16 21:16:46","","1","834","<p>I'm using alt with React 0.13.1. In my component below, <code>unlisten</code> doesn't work on <code>componentWillUnmount</code>. </p>

<p>The component unmounts but I can see the polling still happening. Is there something I'm not understanding about how to unlisten? I don't have binds, because React 0.13 includes autobinding. Any help would be greatly appreciated.</p>

<pre class=""lang-js prettyprint-override""><code>'use strict';

import React from 'react';
import SitesList from './SitesList';
import SiteStore from '../stores/SiteStore';
import SiteActions from '../actions/SiteActions';

// Next line is necessary for exposing React to browser for
// the React Developer Tools: http://facebook.github.io/react/blog/2014/01/02/react-chrome-developer-tools.html
// require(""expose?React!react"");

var SitesBox = React.createClass({
  displayName: 'SitesBox',

  propTypes: {
    url: React.PropTypes.string.isRequired,
    pollInterval: React.PropTypes.number.isRequired
  },

  getStoreState() {
    return {
      sites: SiteStore.getState()
    };
  },

  getInitialState() {
    return this.getStoreState();
  },

  componentDidMount() {
    SiteStore.listen(this.onChange);
    SiteActions.fetchSites(this.props.url, true);
    setInterval(SiteActions.fetchSites,
                this.props.pollInterval,
                this.props.url,
                false);
  },

  componentWillUnmount() {
    SiteStore.unlisten(this.onChange);
  },

  onChange() {
    this.setState(this.getStoreState());
  },

  render() {
    return (
      &lt;div className=""siteBox row""&gt;
        &lt;div className=""col-md-12""&gt;
          &lt;div className=""panel panel-inverse""&gt;
              &lt;div className=""panel-body""&gt;
                  &lt;SitesList sites={this.state.sites.sites} /&gt;
              &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

export default SitesBox;
</code></pre>
","1857730","","1740264","","2015-08-12 11:36:40","2015-08-12 11:36:40","React unlisten doesn't work on componentWillUnmount","<reactjs><flux><react-alt>","1","0","","",""
"37180938","1","","","2016-05-12 08:09:10","","0","222","<p>I'm wondering, what's the best practice to add an event listener to a DOM element, which is NOT rendered by react (a radio button)
I have a given html form and I want to use the advantages of react.js instead of playing around with jQuery ajax stuff.</p>

<p>With jQuery I would do something like that:</p>

<pre><code> $('input[type=radio][name=bedStatus]').change(function() {....}
</code></pre>

<p>Should I use something like this with react ()</p>

<pre><code>componentDidMount: function() {
    if (this.props.onWindowScroll) window.addEventListener(""scroll"", this.handleScroll);
},

componentWillUnmount: function() {
    if (this.props.onWindowScroll) window.removeEventListener(""scroll"", this.handleScroll);
}
</code></pre>

<p>Could someone push me in the right direction?</p>

<p>Cheers Kai </p>
","540982","","","","","2016-05-12 11:31:29","react.js event listener on none react elements","<reactjs>","1","0","","",""
"46473829","1","","","2017-09-28 16:14:05","","1","242","<p>Typical react-bootstrap navigation scenario. I've built a custom dropdown (collapse) as I didn't like the bootstrap version. The issue I'm having is in capturing the Navbar onToggle 'event' associated with the screen changing from desktop to mobile 768px. I don't even know if there is such an event as the docs don't say anything about it.</p>

<p>GitHub: <a href=""https://github.com/haldous2/node_react_login_bootstrap_custom"" rel=""nofollow noreferrer"">https://github.com/haldous2/node_react_login_bootstrap_custom</a></p>

<p>Demo: <a href=""http://node-two.n2local.com/"" rel=""nofollow noreferrer"">node-two.n2local.com</a></p>

<p>What I ended up doing: Added a 'resize' event listener to detect screen sizes mobile and desktop. When desktop is detected is sets display state for the nav_menu_links div to none and also turns off scroll lock.</p>

<p>What I would like to do: Capture and use the bootstrap navbar toggle event to change display and scroll locks instead of using an event listener. </p>

<p>The following is the mobile half of my render. You can see the menu in question 'nav_menu_links' .. it floats around and hides sometimes.</p>

<pre><code>updateDimensions() {
    this.setState({ width: window.innerWidth, height: window.innerHeight });
    this.isMobile();
}
componentDidMount() {
    this.updateDimensions();
    window.addEventListener(""resize"", this.updateDimensions.bind(this));
    document.body.addEventListener('click', this.bodyClick.bind(this));
}
componentWillUnmount() {
    window.removeEventListener(""resize"", this.updateDimensions.bind(this));
    document.body.removeEventListener('click', this.bodyClick.bind(this));
}
render(){
    return(
        &lt;div&gt;
            &lt;Mobile&gt;
                &lt;div style={{ paddingTop: '71px' }}&gt;&lt;/div&gt;
                &lt;Navbar
                    fixedTop
                    collapseOnSelect
                    onToggle={collapsed=&gt;this.navMenuToggle(collapsed)}
                    style={{ maxHeight:'50px', minWidth:'300px' }}
                &gt;
                    &lt;Navbar.Header&gt;
                        &lt;Navbar.Brand&gt;
                            &lt;a href=""/""&gt;Node React Login&lt;/a&gt;
                        &lt;/Navbar.Brand&gt;
                        &lt;Navbar.Toggle /&gt;
                    &lt;/Navbar.Header&gt;
                &lt;/Navbar&gt;
                &lt;div
                    id='nav_menu'
                    style={{
                    position:'fixed',
                    minWidth:'300px',
                    zIndex:'100',
                    top:'52px',
                    right:'0',
                    left:'0'
                }}&gt;
                    &lt;div className=""container""&gt;
                        &lt;div
                            id='nav_menu_links'
                            ref={(input) =&gt; { this.navBarLinks = input; }}
                            style={{
                                display:this.state.nav_menu_links_display,
                                width:'300px',
                                float:'right',
                                backgroundColor:'#FFF',
                                border:'1px solid #CCC'
                            }}
                        &gt;
                            {this.state.navMobile}
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div
                        id='nav_menu_search'
                        ref={(input) =&gt; { this.navBarSearch = input; }}
                        style={{
                            display:this.state.nav_menu_search_display,
                            width:'300px',
                            float:'right',
                            backgroundColor:'#FFF',
                            border:'1px solid #CCC'
                        }}
                    &gt;
                    Search
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/Mobile&gt;
            &lt;Desktop&gt;
                ...
            &lt;/Desktop&gt;
</code></pre>
","3167138","","3167138","","2017-09-30 00:46:25","2017-10-27 20:48:58","react-bootstrap navbar onToggle capture event","<reactjs><addeventlistener><collapse><react-bootstrap>","1","0","","",""
"46567602","1","","","2017-10-04 14:35:31","","0","35","<p>i am working on an open source rails project which use react with rails, there is a feature called follow suggestion which shows users to follow, it has a refresh button to refresh new users but the refresh button is  not working, i checked everything and it looks good plus the server is also not giving any warning or error.</p>

<p><strong>followsuggestioncontainer.es6.jsx</strong></p>

<pre><code>class FollowSuggestionsContainer extends React.Component {
  constructor(props) {
    super(props);

    this.state = { 
      users: [],
      activeUsers: []
    };
  }

  componentWillMount() {
    this.fetchUsers();
    this.token = PubSub.subscribe('UserFollowButton:onClick', (message, data) =&gt; {
      this.removeUser(data.followed_id)
    });
  }

  componentWillUnmount() {
    PubSub.unsubscribe(this.token);
  }

  fetchUsers() {
    $.ajax({
      url: '/api/follow_suggestions.json',
      method: 'GET', 
      dataType: 'json',
      success: (data) =&gt; {
        const newActives = data.slice(0, 3)
        this.setState({ 
          activeUsers: newActives,
          users: [ ...data.slice(3), ...newActives ]
        });
      }
    });
  }

  render () {
    return (
      &lt;div className=""follow-suggestions-container border-top""&gt;
        &lt;div className=""suggestions-header""&gt;
          &lt;h4 className=""small-heading""&gt;People to follow&lt;/h4&gt;
          &lt;a className=""refresh-link pull-right"" onClick={this.refreshActiveUsers.bind(this)}&gt;Refresh&lt;/a&gt;
        &lt;/div&gt;
        &lt;div&gt;
          {this.renderSuggestions()}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  renderSuggestions() {
    if (this.state.users.length === 0) {
      return &lt;h5&gt;You are following all users!&lt;/h5&gt;
    }
    return this.state.activeUsers.map(user =&gt; {
      return (
        &lt;React.addons.CSSTransitionGroup
          key={user.id}
          transitionName=""suggestion""
          transitionAppear={true}
          transitionAppearTimeout={500}
          transitionEnterTimeout={500}
          transitionLeaveTimeout={300}
        &gt;
          &lt;SuggestionItem key={user.id} {...user} /&gt;
        &lt;/React.addons.CSSTransitionGroup&gt;
      )
    });
  }

  refreshActiveUsers() {
    const newActives = this.state.users.slice(0, 3);
    this.setState({
      activeUsers: newActives,
      users: [ ...this.state.users.slice(3), ...newActives ]
    });
  }

  removeUser(id) {
    const filteredUsers = this.state.users.filter(user =&gt; {
      if (user.id === id) {
        removedUser = user;
      }
      return user.id !== id;
    });

    this.setState({
      users: filteredUsers
    });
  }

}
</code></pre>
","7237147","","","","","2017-10-04 14:35:31","react es6 not working","<ruby-on-rails><reactjs>","0","4","","",""
"46810808","1","46828100","","2017-10-18 13:00:51","","0","135","<p>I'm trying to have my page change background color, so that the initialisation page has a different background. </p>

<p>My LogoPage component: </p>

<pre><code>import PropTypes from ""prop-types"";
import React from ""react"";

import ReactOnRails from ""react-on-rails"";
import LocationContainer from ""../containers/LocationContainer"";

const LogoPage = () =&gt; {
  return (
    &lt;div className=""logoPage""&gt;
      &lt;h1&gt;Name&lt;/h1&gt;
      &lt;LocationContainer /&gt;
    &lt;/div&gt;
  );
};

LogoPage.propTypes = {};

export default LogoPage;
</code></pre>

<p>This is shown when the app is trying to fetch the users gps location called by the landingPage component: </p>

<pre><code>import PropTypes from ""prop-types"";
import React from ""react"";

import ReactOnRails from ""react-on-rails"";
import NikelesContainer from ""../containers/NikelesContainer"";
import LogoPageContainer from ""../containers/LogoPageContainer"";

const Landing = props =&gt; {
  if (props.latitude &amp;&amp; props.longitude) {
    return (
      &lt;div className=""body""&gt;
        &lt;NikelesContainer /&gt;
      &lt;/div&gt;
    );
  } else {
    return (
      &lt;div className=""body""&gt;
        &lt;LogoPageContainer /&gt;
      &lt;/div&gt;
    );
  }
};

Landing.propTypes = {
  latitude: PropTypes.number,
  longitude: PropTypes.number
};

export default Landing;
</code></pre>

<p>The LogoPageContainer: </p>

<pre><code>import { connectWithLifecycle } from ""react-lifecycle-component"";

import LogoPage from ""../components/LogoPage"";
import setRedBackground from ""../actions/backgroundActions""
import setTransparentBackground from ""../actions/backgroundActions""

// Which part of the Redux global state does our component want to receive as props?
const mapStateToProps = (state, props) =&gt; {
  return {};
};

const componentWillMount = () =&gt; {
  setRedBackground();
};

const componentWillUnmount = () =&gt; {
  setTransparentBackground();
};

// const actions = Object.assign(locationActions, lifecycleMethods);
export default connectWithLifecycle(mapStateToProps, {
  componentWillMount,
  componentWillUnmount
})(LogoPage);
// export default connectWithLifecycle(mapStateToProps)(LogoPage);
</code></pre>

<p>the backgroundActions: </p>

<pre><code>const setBackground = backgroundClass =&gt; {
  return document.body.className = backgroundClass;
}

const setRedBackground = () =&gt; {
  return function(dispatch) {
    dispatch(setBackground(""red-background""));
  };
};

const setTransparentBackground = () =&gt; {
  return function(dispatch) {
    dispatch(setBackground(null));
  };
};

export { setRedBackground, setTransparentBackground };
</code></pre>

<p>This doesn't even work, as I'd have to make up also redux actions, This to me seems to be a total overkill to have a dispatch for when I change the background color, and I don't need to have the background class stored in the redux repo. </p>

<p>But if I put the <code>document.body.className = ..</code> directly in the callback: </p>

<pre><code>const componentWillMount = () =&gt; {
  document.body.className = ""red-background"";
};
</code></pre>

<p>I get an error saying that </p>

<blockquote>
  <p>Actions must be plain objects. Use custom middleware for async actions</p>
</blockquote>

<p>What would be a more straightforward way to accomplish this? </p>

<p>EDIT: </p>

<p>my store.jsx</p>

<pre><code>import { compose, combineReducers, applyMiddleware, createStore } from ""redux"";
import thunkMiddleware from ""redux-thunk"";

import nikeles from ""../reducers/nikeles"";
import location from ""../reducers/location"";
import page from ""../reducers/page"";

const store = railsProps =&gt; {
  const composedStore = compose(
    applyMiddleware(thunkMiddleware),
    window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()
  );

  const combinedReducers = combineReducers({
    location,
    nikeles,
    page
  });
  return composedStore(createStore)(combinedReducers, railsProps);
};

export default store;
</code></pre>
","1089494","","1089494","","2017-10-18 13:10:51","2017-10-19 10:43:53","react - redux - thunk changing background of the page the concise way","<javascript><reactjs><redux><thunk>","1","4","","",""
"37418573","1","","","2016-05-24 16:01:17","","1","433","<p>I'm using meteor and react with meteor packages:
  <code>accounts-ui accounts-password</code></p>

<p>I want to execute a function client side and maybe server side, whenever the current user is logging out or leaving the page.</p>

<p>How can I do that ?</p>

<p>EDIT: I added code I'm using for the login. It's simply the react-meteor tutoral
Code on Login Systems. I need an event handler for log out events.  </p>

<pre><code>export default class AccountsUIWrapper extends Component {

componentDidMount() {
  // Use Meteor Blaze to render login buttons
  this.view = Blaze.render(Template.loginButtons,
    ReactDOM.findDOMNode(this.refs.container));


}

componentWillUnmount() {
  // Clean up Blaze view
  Blaze.remove(this.view);
}

render() {
  // Just render a placeholder container that will be filled in
  return &lt;span ref=""container"" /&gt;;
 }
}
</code></pre>
","3701098","","3701098","","2016-05-24 19:57:30","2016-05-24 19:57:30","Meteor react logout event","<meteor><reactjs><logout><meteor-accounts>","1","1","","",""
"37152825","1","","","2016-05-11 03:54:12","","5","645","<p>Is there a way to detect when a react-native application will terminate? </p>

<p>I was thinking of <code>componentWillUnmount</code> at the main component level, do you think that's best way to do it?</p>

<p>I would like to send a ""Save"" request to the server before. I'm not sure if that's appropriate while the application in terminating, any better suggestion?</p>

<p>Thanks</p>
","1096161","","","","","2017-06-12 13:57:46","Detect application termination with react native","<javascript><react-native>","2","1","","",""
"45821987","1","","","2017-08-22 15:42:22","","0","37","<p>The code snippet is found on the <a href=""https://facebook.github.io/react/"" rel=""nofollow noreferrer"">react webpage</a></p>

<p>Scrolling down to <strong>A Stateful Component</strong></p>

<p>Copy+Pasted into my codepen, this console error comes up</p>

<pre><code>Uncaught SyntaxError: Unexpected token &lt;
</code></pre>

<p>Here is the <a href=""https://codepen.io/gebrutommy/pen/rzvQxm?editors=0010"" rel=""nofollow noreferrer"">codepen link</a></p>

<p>Also here is the code itself:</p>

<pre><code>class Timer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {secondsElapsed: 0};
    }

    tick() {
        this.setState((prevState) =&gt; ({
          secondsElapsed: prevState.secondsElapsed + 1
        }));
    }

    componentDidMount() {
        this.interval = setInterval(() =&gt; this.tick(), 1000);
    }

    componentWillUnmount() {
        clearInterval(this.interval);
    } 

    render() {
        return (
          &lt;div&gt;Seconds Elapsed: {this.state.secondsElapsed}&lt;/div&gt;
        );
    }

}
ReactDOM.render(&lt;Timer /&gt;, mountNode);
</code></pre>
","3657227","","2587646","","2017-08-22 16:21:53","2017-08-22 16:21:53","console error for react example webpage - a stateful component","<javascript><reactjs><debugging><ecmascript-6><jsx>","1","1","","",""
"45983549","1","45984192","","2017-08-31 14:09:35","","1","296","<p>My first time using react/redux and I'm trying to bind a simple action <code>addClick</code> to the 'click' event, but when I click I receive the error:</p>

<p><code>Uncaught TypeError: Cannot read property 'props' of undefined</code></p>

<p>My (stripped down) code is:</p>

<pre class=""lang-js prettyprint-override""><code>import {addClick} from './actions'
const mapDispatchToProps = {addClick}
class App extends Component {
    componentDidMount() {
        document.addEventListener('click', this.props.addClick)
    }
    componentWillUnmount() {
        document.removeEventListener('click', this.props.addClick)
    }
}
export default connect(mapStateToProps, mapDispatchToProps)(App)
</code></pre>

<p>Before I had it implemented without <code>mapDispatchToProps</code> using an action creator defined within the class and bound to <code>this</code> in the constructor. But I thought part of the point of <code>mapDispatchToProps</code> was to bind the action creator to <code>this</code> (as well as wrapping it in a <code>dispatch</code>)</p>

<p>What am I missing?</p>

<p>Thanks!</p>
","2666216","","4763083","","2017-08-31 14:18:54","2017-08-31 14:47:15","react redux props undefined on event listener when using mapDispatchToProps","<reactjs><redux>","2","3","1","",""
"46826558","1","","","2017-10-19 09:17:53","","0","226","<p>Will react automatically remove eventlisteners when a component unmounts, or do I have to remove them in <code>componentWillUnmount()</code> ?</p>

<p>I specifically mean event listeners registered to rendered contents of the actual component.</p>

<p>Is it bad practice not to remove them manually?</p>

<p>Example:</p>

<pre><code>import React, { Component } from 'react';
import { render } from 'react-dom';

class App extends Component {
  constructor() {
    super();
  }

  componentDidMount() {
    this.content.addEventListener('click', () =&gt; alert('Hello'));
  }

  setRef = ref =&gt; {
    this.content = ref;
  }

  render() {
    return (
      &lt;div ref={this.setRef}&gt;
        &lt;p&gt;Hello World&lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
","7780607","","","","","2017-10-19 09:45:16","Will react automatically remove eventlisteners when a component unmounts?","<reactjs>","3","6","","",""
"46041769","1","","","2017-09-04 17:25:47","","1","57","<p>I tried to use reactjs work with C# MVC, and i want to use reactjs ajax to get json array from controller,then show the array elements into select options. But if i use local array, it could show in the select options. I can print out the array element when i use ajax query server method. I do not what happenend.</p>

<p>My view: </p>

<pre><code>&lt;div class=""col-md-12""&gt;
      &lt;div class=""col-md-2"" id=""select""&gt;
      &lt;/div&gt;
&lt;/div&gt;

&lt;script type=""text/babel""&gt;

            var Groups = React.createClass({
                getInitialState: function () {
                    return {
                        data: []
                    };
                },

            componentDidMount: function(){
                this.serverRequest = $.get(this.props.rout, function(response){
                    this.setState({
                        data: response
                    });
                }.bind(this));
            },

            componentWillUnmount: function(){
                this.serverRequest.abort();
            },

            render () {

                return (&lt;select className=""selectpicker"" multiple=""multiple"" title=""Choose 2-4 colors"" data-live-search=""true""&gt;
                    {this.state.data.map(function (x) {
                            console.log(x);
                    return &lt;ABC value={x}  /&gt;;


                    })}
                    &lt;/select&gt;);
                }
            });

            var ABC = React.createClass({
                render: function(){
                    console.log(""Option"");
                    console.log(this.props.value);
                    return &lt;option value={this.props.value}&gt;{this.props.value}&lt;/option&gt;;
                }
            });

            ReactDOM.render(
                    &lt;Groups rout=""/CodingManagement/Notification/GroupName"" /&gt;,
                document.getElementById('select')
            )

    &lt;/script&gt;
</code></pre>

<p>I could see the console result, but it does not show in view. But if i pass the array to {data}, it could show in the view.</p>

<p>Like this one, it works. I do not know why</p>

<pre><code>&lt;script type=""text/babel""&gt;

var Groups = React.createClass({
    getInitialState: function () {
        return {
            data: this.props.rout
        };
    },

    render () {
        console.log(""Groups"");
        console.log(this.state.data);
        return (&lt;select className=""selectpicker"" multiple=""multiple"" title=""Choose 2-4 colors""
                        data-live-search=""true""&gt;
            {this.state.data.map(function (x) {
                return &lt;ABC value={x}/&gt;;


            })}
        &lt;/select&gt;);
    }
});

var ABC = React.createClass({
    render: function () {
        console.log(""Option"");
        console.log(this.props.value);
        return (
                &lt;option value={this.props.value}&gt;{this.props.value}&lt;/option&gt;
        );
    }
});

ReactDOM.render(
        &lt;Groups rout={[""Group4"", ""Group1"", ""Group11""]}/&gt;
    ,
    document.getElementById('select')
);
</code></pre>

<p></p>

<p>This is server code</p>

<pre><code>public JsonResult GroupName()
    {

        string[] group = new string[] { ""Group4"", ""Group2"", ""Group3"" };
        return Json(group, JsonRequestBehavior.AllowGet);
    }
</code></pre>
","7017769","","7017769","","2017-09-04 17:34:08","2017-09-04 17:34:08","reactjs ajax DOES NOT show options","<c#><ajax><reactjs>","0","6","","",""
"37647087","1","37654600","","2016-06-05 21:44:54","","7","6829","<p>I'm using the <a href=""https://facebook.github.io/react-native/docs/navigator.html"" rel=""noreferrer"">Navigator</a> in order to navigate between pages.</p>

<p>When <a href=""https://facebook.github.io/react-native/docs/navigator.html#push"" rel=""noreferrer"">Navigator.push()</a> method is called, the ""componentWillUnmount"" method isn't called on the page we're navigating from.</p>

<p>It's a little bit problematic because I want to unsubscribe from listeners, etc.</p>

<p>Is it a normal behavior? 
When the ""componentWillUnmount"" is actually called?</p>
","1624422","","","","","2017-11-08 18:47:15","React Native - When ""componentWillUnmount"" will be called?","<react-native>","1","1","","",""
"46578873","1","","","2017-10-05 06:04:42","","2","237","<p><em>I am loading Three.JS Model using WebView in my react-native app. After loading the Model the memory is increased.</em></p>

<p><em>Now when i tap on button i want to deallocate the webView Component and want release the memory.</em></p>

<p><em>OR when i go to next screen i would like to release the memory.</em></p>

<p><em>Below is my code.</em></p>

<pre><code>{this.state.showWebview &amp;&amp;
        &lt;WebView
            ref={(wbref) =&gt; {
              this.webview = wbref;
            }}
            style={styles.middleview}
            source={{
              uri: this.state.showWebview &amp;&amp; this.props.isCurrentScreenOnTop
              ? '3DMODEL/vechicle.html'
              : null,
            }}
            onLoadStart={this.onLoadStart}
            onLoad={this.onLoad}
            onLoadEnd={this.onLoadEnd}
            onError={this.onError}
            renderError={this.renderError}
            onMessage={this.handleMessageFromBuilder}
            cacheEnabled={false}
            cookiesEnabled={false}
        /&gt;}

componentWillUnmount() {
    this.webview = null;
}
</code></pre>

<p><em>Below is the memory graph.</em></p>

<p><a href=""https://i.stack.imgur.com/XbvPy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XbvPy.png"" alt=""enter image description here""></a></p>
","3647770","","","","","2017-10-05 06:04:42","How to release react-native webview memory","<react-native><three.js><uiwebview>","0","0","","",""
"38025653","1","38025746","","2016-06-25 06:24:01","","0","1975","<p>When I use react with es6 and jquery's ajax function, I got <code>this.setState() is not a function</code> error. I tried bind this within constructor using <code>this.componentDidmount = this.componentDidmount.bind(this);</code>, but still not working. </p>

<p>Can any one help me? Thanks! </p>

<p>Here is my code:</p>

<pre><code>import React from 'react';
import $ from 'jquery';

class UserGist extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userName: '',
      lastGistUrl: ''
    };
  }

  componentDidMount() {
    this.serverRequest = $.get(this.props.source, function(result) {
      let lastGist = result[0];
      this.setState({
        userName: lastGist.owner.login,
        lastGistUrl: lastGist.html_url
      });
    });
  }

  componentWillUnmount() {
    this.serverRequest.abort();
  }

  render() {
    return(
      &lt;div&gt;
        {this.state.userName}'s last gist is
        &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.
      &lt;/div&gt;
    )
  }
}

export default UserGist;
</code></pre>
","2148710","","1698143","","2016-06-25 08:29:57","2016-06-25 08:29:57","this.setState() is not a function when using react with jquery inside componentDidmount","<jquery><reactjs><ecmascript-6><this>","1","0","1","2016-06-25 09:53:06",""
"46240004","1","46241723","","2017-09-15 12:49:14","","-1","398","<p>I use <a href=""https://reactnavigation.org/"" rel=""nofollow noreferrer"">react navigation</a>. I have a <code>TabNavigator</code>. Each <code>Tab</code> contains a <code>StackNavigator</code>. From one <code>StackNavigator</code>, it is possible to open a <code>Modal</code>. 
The <code>Modal</code> is opened when I click on a <code>Button</code> in a certain <code>Component</code>.</p>

<pre><code>export default class CallModalComponent extends Component {
    constructor(props) {
        super(props)
    ...
    }

    ...

    render() {
    const { navigate } = this.props.navigation;
         return (
              &lt;Button
               ....
               onPress={() =&gt; navigate(""Modal"")}/&gt;
</code></pre>

<p>The in the <code>TabNav</code> registered screen <code>&lt;MyModal /&gt;</code> is a stateful <code>Component</code>.
On close of the <code>Modal</code> I need the <code>state</code> of <code>&lt;MyModal /&gt;</code> to be passed down to <code>&lt;CallModalComponent /&gt;</code>.</p>

<p>The problem I am having is how that might work with <code>react navigation</code> in between... I know that I can use <code>redux</code> and send/retrieve it through the <code>global store</code>. But I wonder if its possible with only <code>react native</code>. 
Any suggestions?</p>

<p><strong>EDIT</strong></p>

<p>I implemented the Code from answer</p>

<pre><code>export default class CallModalComponent extends Component {
    constructor(props) {
        super(props)
    ...
    }

    ...
    onModalDismis(childVar) {
      console.log('modal is closing');
      console.log(childVar);
    }
    render() {
    const { navigate } = this.props.navigation;
         return (
              &lt;Button
               ....
               onPress={(childVar) =&gt; navigate(""Modal"", {onModalDismis: this.onModalDismis()})}/&gt;

// Then in your modal component

componentWillUnmount () {
    console.log('unmount');
    this.props.navigation.state.params.onModalDismis('here we go');
}
</code></pre>

<p>The following gets logged:
When the <code>Modal Component</code> is mounted I get: </p>

<p><code>modal is closing</code>
<code>undefined</code></p>

<p>Then, when I actually close the <code>Modal</code>, I get: </p>

<p><code>unmount</code></p>

<p>and then the error:</p>

<blockquote>
  <p>Cannot read property of onModalDismiss of undefined.</p>
</blockquote>

<p>I expected to be nothing logged on mounting of the <code>Modal</code>. And then, when I close the <code>Modal</code> I expected</p>

<p><code>unmount</code>, <code>modal is closing</code> and <code>here we go</code> to be logged.</p>
","3935035","","3935035","","2017-09-15 14:02:06","2017-09-15 14:16:03","Pass props from Modal to other Component react navigation","<javascript><react-native><react-navigation>","2","0","","",""
"46266868","1","","","2017-09-17 17:24:29","","0","59","<p>I know there are many articles out there on validation but I haven't found any solution for my case. I just have one input text and want to validate it, but didn't make any progress. Validation must be in react. Please help me in making it or guide me.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var styles = {
  margin: '2em auto',
  width: '300px',
  height: '300px',
  backgroundColor: '#DD4814',
  color: '#ffffff',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'space-around'
};
var inputs = {
  position: 'relative',
  bottom: '17%',
  left: '20%'
}
var btns = {
  position: 'relative',
  bottom: '7%'
}
var btn = {
  backgroundColor: '#ffffff',
  color: '#000000',
  borderColor: '#DEB887',
  borderRadius: '0.4em',
  cursor: 'pointer',
  margin: '0 1em',
  padding: '0.5em',
  display: 'inline-block'
}
class Timer extends React.Component {
  constructor (props) {
    super(props)
    this.state = {count: 0, customNumber: 0}
  }
  handleChange (e) {
    this.setState({ customNumber: e.target.value});
  }
  componentWillUnmount () {
    clearInterval(this.timer)
  }
  tick () {
    if (this.state.customNumber) {
      this.setState({
        count: (this.state.customNumber--)
      })
      if (this.state.customNumber &lt;= 0) {
        this.setState({ count: 0})
        clearInterval(this.timer)
        this.setState( {disabled: !this.state.disabled} )
      }
    } else {
      this.setState({count: (this.state.count + 1)})
    }
  }
  
  display () {
    return ('0' + this.state.count % 100).slice(-2)
  }
  
  startTimer () {
    clearInterval(this.timer)
    this.timer = setInterval(this.tick.bind(this), 1000)
    this.setState( {disabled: !this.state.disabled} )
  }
  stopTimer () {
    clearInterval(this.timer)
  }
  resetTimer () {
    clearInterval(this.timer)
    this.setState({count: 0})
    this.setState( {disabled: !this.state.disabled} )
  }
  render () {
    return (
      &lt;div style={styles} className='timer'&gt;
        &lt;h1 style={{fontSize: '4em'}}&gt;{this.display()}&lt;/h1&gt;
        &lt;div className=""input_text"" style={inputs}&gt;
          &lt;label htmlFor=""custom_number""&gt;Enter number to start timer&lt;/label&gt;
          &lt;input type=""text"" name=""custom_number"" id=""custom_number"" value={this.state.inputValue} onChange={this.handleChange.bind(this)} disabled = {(this.state.disabled)? ""disabled"" : """"}  placeholder=""Enter b/w 1-100"" /&gt;
        &lt;/div&gt;
        &lt;div style={btns} className=""buttons""&gt;
          &lt;button style={btn} type=""button"" name=""start_btn"" id=""start_btn"" onClick={this.startTimer.bind(this)}&gt;Start&lt;/button&gt;
          &lt;button style={btn} type=""button"" name=""stop_btn"" id=""stop_btn"" onClick={this.stopTimer.bind(this)}&gt;Pause&lt;/button&gt;
          &lt;button style={btn} type=""button"" name=""reset_btn"" id=""reset_btn"" onClick={this.resetTimer.bind(this)}&gt;Stop&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
}
ReactDOM.render(&lt;Timer /&gt;, document.getElementById('root') )</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;div id=""root""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","","user8079593","577088","","2017-09-17 17:49:27","2017-09-17 19:00:43","How to validate a input field in react","<javascript><reactjs><validation>","1","3","","",""
"46292915","1","46293661","","2017-09-19 06:01:23","","0","219","<p>I'm using <code>native-base</code>, <code>redux</code> and <code>react-native</code>, It seems that switching between tabs doesn't call the method <code>componentWillUnmount</code>, I want to do some actions when the tab is switched and the component is removed:</p>

<p><strong>Main.js</strong></p>

<pre><code>export class Main extends Component {
  render() {
    return (
    &lt;Container style={styles.containerStyle}&gt;
        &lt;Tabs initialPage={0}  &gt;
        &lt;Tab heading=""Tab1""&gt;
            &lt;Tab1 /&gt;
          &lt;/Tab&gt;
          &lt;Tab heading=""Tab2""&gt;
            &lt;Tab2 /&gt;
          &lt;/Tab&gt;
        &lt;/Tabs&gt;
      &lt;/Container&gt;
    )
  }
}
</code></pre>

<p><strong>Tab1.js</strong></p>

<pre><code>export class Tab1 extends Component {

  constructor(props) {
    super(props);
}

  componentWillMount(){   
    //called 
  }

  componentWillUnmount(){
    //not called when switching tabs
  }


  render() {
    return (
      &lt;Container style={styles.containerStyle}&gt;
        &lt;Content&gt;
          &lt;Text&gt;Tab1&lt;/Text&gt;
        &lt;/Content&gt;
    &lt;/Container&gt;
    );
  }
}
</code></pre>

<p>How to call actions when the tab is switched and the component is removed?  </p>
","5856332","","8388820","","2017-09-19 06:07:12","2017-09-19 14:16:47","native-base tabs doesn't call lifecycle method componentWillUnmount","<android><reactjs><react-native><native-base>","1","3","","",""
"37791188","1","37792325","","2016-06-13 13:34:06","","0","1073","<p>Problem Summary:</p>

<blockquote>
  <p>React component SLTree reads (ajax) a JSON, converts to string and
  passes it as property to two 'contained' components - Editor and
  TNode. Editor component (which encapsulates CodeMirror) works OK, but
  the TNode component event after JSON.parse() of the received property
  keeps interpreting the returned object as a string, instead of Object.</p>
</blockquote>

<p>JSON file (validated):</p>

<pre><code>""x"":  {
            ""id"": 1,
            ""content"": ""Hello, world!\n""
        },
""y"":  {
            ""id"": 2,
            ""content"": ""React is awesome.\n""
        },
""z"":  {
            ""id"": 3,
            ""content"": ""Robots are pretty cool.\n""
        },
""l"":  {
            ""id"": 4,
            ""content"": ""Monkeys.\nWho doesn't love monkeys?\n""
        }
}
</code></pre>

<p>React Components:</p>

<ul>
<li>Parent: SLTree (reads above JSON using JQuery ajax)</li>
<li>Child: Editor - works correctly)</li>
<li>TNode - fails to 'Object'ify the passed string property.

<ul>
<li>JSON.parse(prop-passed-by-parent) </li>
<li>JSON.parse(JSON.stringify(prop-passed-by-parent)) - some answers on
stackoverflow suggest using explicit stringify, before parse</li>
</ul></li>
</ul>

<p>Some reference indicated explicitly doing a stringify before parse.
So I also tried:</p>

<p><code>let expectObj_gettingString = JSON.parse(JSON.stringify(this.props.node))</code></p>

<p>Code for parent component - SLTree:</p>

<pre><code>import Editor from './Editor.jsx';
import TNode from './TNode.jsx';    
var $ = require('jquery');
const lstyle = {
  border: ""solid navy 1px""
}
export default React.createClass({

  getInitialState: function() {
    return {
      displayText: ''
    }
  },
  componentDidMount: function() {
    this.serverRequest = $.ajax({
      url: ""./sltree/sample.json"",
      dataType: 'json',
      cache: false,
      success: function(data) {
        console.log(data);
        this.setState({displayText: JSON.stringify(data, null, ' ')});
      }.bind(this),
      error: function(xhr, status, err) {
        // console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  componentWillUnmount: function() {
    this.serverRequest.abort();
  },
  render() {
    return (
      &lt;div className=""row""&gt;
        &lt;div style={lstyle} className=""col-lg-6 col-md-6 col-sm-6 col-xs-6""&gt;
          &lt;Editor displayText={this.state.displayText} /&gt;
        &lt;/div&gt;
        &lt;div style={lstyle} className=""col-lg-6 col-md-6 col-sm-6 col-xs-6""&gt;
          &lt;TNode node={this.state.displayText} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
});
</code></pre>

<p>Editor component works correctly.</p>

<blockquote>
  <p>TNode component below fails to convert this.props.node to a JSON
  object - and keeps interpreting it as a string - as evident from
  console logs below and display on the browser (not shown here)</p>
</blockquote>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
var $ = require('jquery');

export default React.createClass({
  render() {
    let n = this.props.node;
    console.log(""node type:(""+ typeof n + "")"")
    let s = """";
    for (var k in n) {
      s += k + "" : "" + n[k] + "" : typeof n[k](""+typeof n[k]+"")\n"";
      console.log(s);
    }
    return (
      &lt;div&gt;{s}&lt;/div&gt;
    );
  }
});
</code></pre>

<p>Here's the sample console log - note how 'node' is interpreted as string, instead of object.  Note that index(key) is integer and value is character in the string.</p>

<pre><code>    node type:(string)
bundle.js:70 document ready in sltree/main.js: dependencies loaded.
bundle.js:20470 Object {x: Object, y: Object, z: Object, l: Object}l: Objectcontent: ""Monkeys.↵Who doesn't love monkeys?↵""id: 4__proto__: Objectx: Objectcontent: ""Hello, world!↵""id: 1__proto__: Objecty: Objectz: Object__proto__: Object
bundle.js:41476 node type:(string)
bundle.js:41480 0 : { : typeof n[k](string)

bundle.js:41480 1 : 
 : typeof n[k](string)

bundle.js:41480 2 :   : typeof n[k](string)

bundle.js:41480 3 : "" : typeof n[k](string)

bundle.js:41480 4 : x : typeof n[k](string)

bundle.js:41480 5 : "" : typeof n[k](string)

bundle.js:41480 6 : : : typeof n[k](string)

bundle.js:41480 7 :   : typeof n[k](string)

bundle.js:41480 8 : { : typeof n[k](string)

bundle.js:41480 9 : 
 : typeof n[k](string)

bundle.js:41480 10 :   : typeof n[k](string)

bundle.js:41480 11 :   : typeof n[k](string)

bundle.js:41480 12 : "" : typeof n[k](string)

bundle.js:41480 13 : i : typeof n[k](string)

bundle.js:41480 14 : d : typeof n[k](string)

bundle.js:41480 15 : "" : typeof n[k](string)

bundle.js:41480 16 : : : typeof n[k](string)

bundle.js:41480 17 :   : typeof n[k](string)

bundle.js:41480 18 : 1 : typeof n[k](string)

bundle.js:41480 19 : , : typeof n[k](string)

bundle.js:41480 20 : 
 : typeof n[k](string)

bundle.js:41480 21 :   : typeof n[k](string)

bundle.js:41480 22 :   : typeof n[k](string)

bundle.js:41480 23 : "" : typeof n[k](string)

bundle.js:41480 24 : c : typeof n[k](string)

bundle.js:41480 25 : o : typeof n[k](string)

bundle.js:41480 26 : n : typeof n[k](string)

bundle.js:41480 27 : t : typeof n[k](string)

bundle.js:41480 28 : e : typeof n[k](string)

bundle.js:41480 29 : n : typeof n[k](string)

bundle.js:41480 30 : t : typeof n[k](string)

bundle.js:41480 31 : "" : typeof n[k](string)

bundle.js:41480 32 : : : typeof n[k](string)

bundle.js:41480 33 :   : typeof n[k](string)

bundle.js:41480 34 : "" : typeof n[k](string)

bundle.js:41480 35 : H : typeof n[k](string)

bundle.js:41480 36 : e : typeof n[k](string)

bundle.js:41480 37 : l : typeof n[k](string)

bundle.js:41480 38 : l : typeof n[k](string)

bundle.js:41480 39 : o : typeof n[k](string)

bundle.js:41480 40 : , : typeof n[k](string)

bundle.js:41480 41 :   : typeof n[k](string)

bundle.js:41480 42 : w : typeof n[k](string)

bundle.js:41480 43 : o : typeof n[k](string)

bundle.js:41480 44 : r : typeof n[k](string)

bundle.js:41480 45 : l : typeof n[k](string)
</code></pre>
","3213604","","","","","2016-06-13 14:27:10","String prop passed to react child component from parent - unable to conver to Object with JSON.parse()","<javascript><json><ajax><reactjs><jsx>","1","0","1","",""
"46354089","1","46354970","","2017-09-21 22:29:23","","0","44","<p>It looks pretty simple but I am stuck here. I just want to load the ajax content and render it in the table. I am able to render it using static content</p>

<pre><code>class ObjectDataExample extends React.Component {
    constructor(props) {
        super(props);
        this.state = {appData: {}};

 }




    componentDidMount() {
        axios.get('http://test.json')
            .then((result)=&gt; {

                //const thisData = result.data;
                this.setState({appData: result.data});
            })
    }

    componentWillUnmount() {
        this.serverRequest.abort();
    }



// Render your table
    render()
    {
            console.log(this.state.appData);
            //I can see the above console logs
        return (
            //this is not coming 
&lt;Table className=""react-listing-table table"" data={this.state.appData} sortable={[
                    'Address',
                    'Suburb',
                    'Sale Date'
                ]}




                   defaultSort={{column: 'Sale Date', direction: 'asc'}}
                   defaultSortDescending&gt;
//static content like below are rendered
                    &lt;Tr className=""react-listing-table table""
                        data={ [
                            {'Address':'address','Suburb':'suburb','Postc.':'2153','Sale Date':'21\/08\/17','Sale Price':'$640500','Comm':'$19200','LA':'($3545)','BA':'($2540)','Settelement':'12\/02\/2018'},
                            {'Address':'address','Suburb':'test','Postc.':'2153','Sale Date':'21\/08\/17','Sale Price':'$640500','Comm':'$19200','LA':'($3545)','BA':'TL($2540)','Settelement':'12\/02\/2018'},

                        ]} /&gt;



            &lt;/Table&gt;
        );
    }
}

module.exports = ObjectDataExample;

window.WB.react.renderListingDataTable = function() {
    render(
        &lt;Provider store={store}&gt;
            &lt;ObjectDataExample/&gt;
        &lt;/Provider&gt;,
        document.getElementById('listing-table-wrapper')
    );
}
</code></pre>

<p>I got the weird error <strong>Uncaught TypeError: this.data.concat is not a function</strong></p>

<p>I AM  using <a href=""https://github.com/glittershark/reactable"" rel=""nofollow noreferrer"">https://github.com/glittershark/reactable</a></p>
","1355249","","13302","","2017-09-30 15:14:02","2017-09-30 15:14:02","Loading ajax content on reactable - reactjs","<javascript><ajax><reactjs>","1","9","","",""
"46203907","1","","","2017-09-13 17:49:56","","0","54","<p>I'm with problem in my project.</p>

<p><a href=""https://i.stack.imgur.com/ujkr2.jpg"" rel=""nofollow noreferrer"">Animated Node with tag 7 not exists</a></p>

<p><a href=""https://i.stack.imgur.com/RjKc2.jpg"" rel=""nofollow noreferrer"">type error: expected dynamic type 'double' but had type 'null'</a></p>

<p>Before rendering this form the app appears the errors from time to time, it is not always that the error appears. I think only when the internet is not very good. But I wanted to be able to handle this error so it did not appear to the user.</p>

<p>My code below.</p>

<p>FormPrincipal.js</p>

<pre><code>import React, { Component } from 'react';
import { View, Text, ScrollView, Alert, BackHandler } from 'react-native';
import RNExitApp from 'react-native-exit-app';
import ScrollableTabView from 'react-native-scrollable-tab-view';
import { Actions } from 'react-native-router-flux';
import axios from 'axios';
import { connect } from 'react-redux';
import { modificaToken, modificaConsultas, modificaScene } from '../actions/AutenticacaoActions';

import FormFaturamento from './FormFaturamento';
import FormListaConsultas from './FormListaConsultas';

class formPrincipal extends Component {

    componentWillMount() {
        BackHandler.addEventListener('hardwareBackPress', this.handleAndroidBack)
    }

    componentWillUnmount() {
        BackHandler.removeEventListener('hardwareBackPress', this.handleAndroidBack)
    }

    handleAndroidBack = () =&gt; {

        if(Actions.currentScene === 'formPrincipal') {
            Alert.alert(
                'Sair',
                'Deseja sair do app?',
                [
                    { text: 'NÃO', onPress: () =&gt; {} },
                    { text: 'SIM', onPress: () =&gt; RNExitApp.exitApp() },
                ]
            );
            return true;   
        }
    }

    render() {
        return(
                &lt;ScrollableTabView&gt;
                    {this.props.consultas.map( item =&gt; &lt;FormListaConsultas tabLabel={item.Grupo} key={item.Grupo} item={item}/&gt;)}
                &lt;/ScrollableTabView&gt;
        ) 
    }
}

const mapStateToProps = state =&gt; (
    {
        token: state.AutenticacaoReducer.token,
        consultas: state.AutenticacaoReducer.consultas,
        scene: state.AutenticacaoReducer.scene,
        listaConsultas: state.AutenticacaoReducer.listaConsultas
    }
)

export default connect(mapStateToProps, {modificaToken, modificaConsultas, modificaScene})(formPrincipal);
</code></pre>
","8429243","","8429243","","2017-09-13 17:56:25","2017-09-13 17:56:25","react-native Animated node error","<react-native>","0","2","","",""
"37978610","1","","","2016-06-22 21:31:09","","0","595","<p>I have a react native app and I want to prompt users to save a form if they hit the back button. I was thinking of using componentWillUnmount function and redirect them back if they confirm that they would like to save their information. How do I redirect them to the view or is there another way of going about this</p>

<pre><code>  componentWillUnmount(){
    //check if user has updated the form and ask if they really want to leave
  }
</code></pre>
","1050053","","","","","2016-06-22 22:58:05","cancel component unmount in react native","<react-native>","1","0","","",""
"45642492","1","","","2017-08-11 19:26:28","","1","193","<p>To put it simple, I want a user to be able to see a certain set of markers based on the radius they put. So if they put 200 then it will show all markers within 200 mile radius. </p>

<p>I am using the react-google-maps package and am getting the markers to update, but it is not re-rendering the map so only the first initial marker array shows up.</p>

<p>EDIT: I should probably add where to look. If you look at the <code>CreateRadius</code> component that is where the I am changing the state. It is in the render function</p>

<p>Map.js</p>

<pre><code>/* global google */
import { default as React, Component } from 'react';
import raf from 'raf';
import canUseDOM from 'can-use-dom';
import { connect } from 'react-redux';
import { Link } from 'react-router';
import { withGoogleMap, GoogleMap, Circle, InfoWindow, Marker } from 'react-google-maps';
import withScriptjs from 'react-google-maps/lib/async/withScriptjs';
import geolib from 'geolib';
import CreateRadius from './CreateRadius';

const googleMapURL =
  'https://maps.googleapis.com/maps/api/js?v=3.27&amp;libraries=places,geometry&amp;key=AIzaSyA7XEFRxE4Lm28tAh44M_568fCLOP_On3k';

const geolocation =
  canUseDOM &amp;&amp; navigator.geolocation
    ? navigator.geolocation
    : {
      getCurrentPosition(success, failure) {
        failure(""Your browser doesn't support geolocation."");
      },
    };

const GeolocationExampleGoogleMap = withScriptjs(
  withGoogleMap(props =&gt;
    &lt;GoogleMap defaultZoom={6} center={props.center}&gt;
      {props.center &amp;&amp;
        &lt;InfoWindow position={props.center}&gt;
          &lt;div&gt;User's Location&lt;/div&gt;
        &lt;/InfoWindow&gt;}
      {props.center &amp;&amp;
        &lt;Circle
          center={props.center}
          radius={props.radius}
          options={{
            fillColor: 'red',
            fillOpacity: 0.2,
            strokeColor: 'red',
            strokeOpacity: 1,
            strokeWeight: 1,
          }}
        /&gt;}
      &gt;
      {props.markers.map((marker, index) =&gt; {
        const onClick = () =&gt; props.onMarkerClick(marker);
        const onCloseClick = () =&gt; props.onCloseClick(marker);

        return (
          &lt;Marker
            key={index}
            position={marker.position}
            title={(index + 1).toString()}
            onClick={onClick}
          &gt;
            {marker.showInfo &amp;&amp;
              &lt;InfoWindow onCloseClick={onCloseClick}&gt;
                &lt;div&gt;
                  &lt;strong&gt;
                    &lt;h2&gt;
                      {marker.content}
                    &lt;/h2&gt;
                  &lt;/strong&gt;
                  &lt;br /&gt;
                  &lt;h3&gt;Where we can add offer details!&lt;/h3&gt;
                  &lt;Link to=""/items""&gt;
                    Click here for item: {marker.number}
                  &lt;/Link&gt;
                &lt;/div&gt;
              &lt;/InfoWindow&gt;}
          &lt;/Marker&gt;
        );
      })}
    &lt;/GoogleMap&gt;,
  ),
);

function generateInitialMarkers(items, userRadius) {
  console.log('items', items);
  console.log(`generateInitialMarkers called with radius of: ${userRadius}`);
  const markers = [];
  items.map((item, i) =&gt; {
    const newGeoArr = item.geolocation.split(',');
    if (
      newGeoArr.length &gt; 1 &amp;&amp;
      newGeoArr !== '' &amp;&amp;
      newGeoArr[0] !== undefined &amp;&amp;
      newGeoArr[0] !== null
    ) {
      item.position = { lat: Number(newGeoArr[0]), lng: Number(newGeoArr[1]) };
      item.distance = { latitude: Number(newGeoArr[0]), longitude: Number(newGeoArr[1]) };
      geolocation.getCurrentPosition((position) =&gt; {
        const currentLocation = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };
        const distanceArr = geolib.orderByDistance(currentLocation, [item.distance]);
        const miles = (distanceArr[0].distance / 1609.34).toFixed(2);
        if (miles &lt;= userRadius) {
          console.log('added marker');
          markers.push({
            position: item.position,
            number: i,
            content: item.description,
            showInfo: false,
          });
        }
      });
    }
  });
  console.log(markers);
  return markers;
}

class OfferMap extends Component {
  constructor(props) {
    super(props);
    this.state = {
      center: null,
      content: null,
      radius: 100000,
      markers: generateInitialMarkers(this.props.items, 5) || [],
    };

    const isUnmounted = false;

    this.handleMarkerClick = this.handleMarkerClick.bind(this);
    this.handleCloseClick = this.handleCloseClick.bind(this);
  }

  handleMarkerClick(targetMarker) {
    this.setState({
      markers: this.state.markers.map((marker) =&gt; {
        if (marker === targetMarker) {
          return {
            ...marker,
            showInfo: true,
          };
        }
        return marker;
      }),
    });
  }

  handleCloseClick(targetMarker) {
    this.setState({
      markers: this.state.markers.map((marker) =&gt; {
        if (marker === targetMarker) {
          return {
            ...marker,
            showInfo: false,
          };
        }
        return marker;
      }),
    });
  }

  componentDidMount() {
    const tick = () =&gt; {
      if (this.isUnmounted) {
        return;
      }
      this.setState({
        radius: Math.max(this.state.radius - 200, 0),
      });

      if (this.state.radius &gt; 100) {
        raf(tick);
      }
    };

    geolocation.getCurrentPosition(
      (position) =&gt; {
        if (this.isUnmounted) {
          return;
        }
        this.setState({
          center: {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          },
          content: 'Location found using HTML5.',
        });

        raf(tick);
      },
      (reason) =&gt; {
        if (this.isUnmounted) {
          return;
        }

        this.setState({
          center: {
            lat: 60,
            lng: 105,
          },
          content: `Error: The Geolocation service failed (${reason}).`,
        });
      },
    );
  }

  componentWillUnmount() {
    this.isUnmounted = true;
  }

  submitRadius(userRadius) {
    this.setState({
      markers: generateInitialMarkers(this.props.items, userRadius) || [],
    });
    console.log(this.state.markers, 'changed marker state');
  }

  render() {
    return (
      &lt;div style={{ width: '500px', height: '500px' }}&gt;
        &lt;GeolocationExampleGoogleMap
          googleMapURL={googleMapURL}
          loadingElement={&lt;div style={{ height: '100%' }}&gt;loading...&lt;/div&gt;}
          containerElement={&lt;div style={{ height: '100%' }} /&gt;}
          mapElement={&lt;div style={{ height: '100%' }} /&gt;}
          center={this.state.center}
          content={this.state.content}
          radius={this.state.radius}
          onMarkerClick={this.handleMarkerClick}
          onCloseClick={this.handleCloseClick}
          markers={this.state.markers}
        /&gt;
        &lt;div style={{ float: 'right' }}&gt;
          &lt;CreateRadius radiusChange={this.submitRadius.bind(this)} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

function mapStateToProps({ browser }) {
  return { browser };
}

export default connect(mapStateToProps)(OfferMap);
</code></pre>

<p>CreateRadius.js</p>

<pre><code>import React, { Component } from 'react';

class CreateRadius extends Component {
  constructor() {
    super();
    this.state = {
      markerRadius: 0,
    };
  }

  updateRadius(event) {
    const radius = Number(event.target.value);
    if (typeof radius !== 'number' || isNaN(radius)) {
      alert('must put in a number for radius');

      return;
    }
    this.setState({
      markerRadius: radius,
    });
  }

  submitRadius() {
    this.props.radiusChange(this.state.markerRadius);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h4&gt;Change Radius&lt;/h4&gt;
        &lt;input
          type=""number""
          onChange={this.updateRadius.bind(this)}
          id=""radius""
          placeholder=""radius""
        /&gt;
        &lt;button onClick={this.submitRadius.bind(this)}&gt;Change Radius&lt;/button&gt;
        &lt;br /&gt;
      &lt;/div&gt;
    );
  }
}

export default CreateRadius;
</code></pre>
","","user7366497","","user7366497","2017-08-11 20:08:41","2017-08-11 20:08:41","Using react-google-maps,not able to add/subtract markers dynamically","<google-maps><reactjs>","0","1","","",""
"46155229","1","","","2017-09-11 11:58:32","","0","143","<p>I'm making an app with react-native that needs to update users location based on the distance they moved. I'm using <code>navigator.geolocation.watchPosition</code> for the event listener but it's not behaving as expected. Here's my test code :  </p>

<pre><code>export default class geoApp extends Component {
constructor() {
    super();
    this.state = {
        lastPos: 'unknown',
    }
    this.watchID = null;
}

componentDidMount() {
    this.watchID = navigator.geolocation.watchPosition(
        (pos) =&gt; {
            const lastPos = JSON.stringify(pos.coords)
            this.setState({ lastPos: lastPos });
        },
        (error) =&gt; {
            alert(JSON.stringify(error))
        },
        { enableHighAccuracy: true, timeout: 20000, maximumAge: 0, distanceFilter: 1 }
    );
}

componentWillUnmount() {
    navigator.geolocation.clearWatch(this.watchID);
}

render() {
    return (
        &lt;View style={styles.container}&gt;
            &lt;Text style={styles.welcome}&gt;
                {this.state.lastPos}
            &lt;/Text&gt;
        &lt;/View&gt;
    );
  }
}
</code></pre>

<p>I've tried removing the options object or just changing the data but nothing works.  </p>

<p>If I don't put the options object the callback will fire ony once and usally it will be after 20 seconds , if I leave the options object as is it won't even fire.  </p>

<p>I thought it would be because of the <code>maximumAge</code> but I tried to put different data in it and nothing worked.</p>

<p>I even tried <code>navigator.geolocation.getCurrentLocation</code> and wrapping it inside a <code>setInterval</code>but it returns me always the same information.</p>

<p>Any help would be appreceated, thank you !</p>

<p>Notes: I have <code>&lt;uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION"" /&gt;</code> in my manifest</p>

<p>react and react-native versions are as follows:
<code>""react"": ""16.0.0-alpha.12"",
""react-native"": ""0.47.2""</code></p>

<p>I am trying to run on a android Huawei P9 lite.</p>
","7185997","","8342742","","2017-09-11 12:08:12","2017-09-11 12:08:12","react-native - navigator.geolocation.watchPosition not firing when expected - android","<javascript><android><ios><mobile><react-native>","0","0","0","",""
"46702344","1","","","2017-10-12 05:53:58","","0","519","<p>I am learning React and following <a href=""https://reactjs.org/docs/integrating-with-other-libraries.html"" rel=""nofollow noreferrer"">integrating other Libraries chapter</a> and tried the same  they have suggested but getting below error</p>

<pre><code>TypeError: this.$el.chosen is not a function
Chosen.componentDidMount
src/App.js:18

  componentDidMount() {
    this.$el = $(this.el);
&gt;   this.$el.chosen();
  }
</code></pre>

<p>react website provides <a href=""https://codepen.io/gaearon/pen/qmqeQx?editors=0010"" rel=""nofollow noreferrer"">example codepen</a> where they have added the jquery and chosen plugin js in dependencies and I have added jquery and chosen library js file in <strong>index.html</strong> and also added jquery using <code>npm install jquery --save</code> so that it can be imported in <strong>App.js</strong></p>

<h3>index.html</h3>

<pre><code>&lt;!doctype html&gt;
&lt;html lang=""en""&gt;
  &lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1, shrink-to-fit=no""&gt;
    &lt;meta name=""theme-color"" content=""#000000""&gt;
    &lt;link rel=""manifest"" href=""%PUBLIC_URL%/manifest.json""&gt;
    &lt;link rel=""shortcut icon"" href=""%PUBLIC_URL%/favicon.ico""&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js""&gt;&lt;/script&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/chosen/1.6.2/chosen.jquery.min.js""&gt;&lt;/script&gt;
    &lt;title&gt;React App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=""root""&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>App.js</h3>

<pre><code>import React, { Component } from 'react';

import $ from 'jquery';

class Chosen extends Component {

  componentDidMount() {
    this.$el = $(this.el);
    this.$el.chosen();
  }

  componentWillUnmount() {
    this.$el.chosen('destroy');
  }

  render() {
    return (
      &lt;div &gt;
        &lt;select className=""Chosen-select"" ref={el =&gt; this.el = el}&gt;
          {this.props.children}
        &lt;/select&gt;
      &lt;/div&gt;
    );
  }
}

function Example() {
  return (
    &lt;Chosen &gt;
      &lt;option &gt;vanila&lt;/option&gt;
      &lt;option &gt;strawberry&lt;/option&gt;
      &lt;option &gt;chocolate&lt;/option&gt;
    &lt;/Chosen&gt;
    );
}


class App extends Component {
  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;header className=""App-header""&gt;
          &lt;img src={logo} className=""App-logo"" alt=""logo"" /&gt;
          &lt;h1 className=""App-title""&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;section&gt;
          &lt;Example/&gt;
        &lt;/section&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>

<h3>index.js</h3>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>

<p>Why I am getting this error and how to fix it?</p>
","6339952","","","","","2018-02-09 05:35:51","adding jquery plugin is not working in react app; TypeError: this.$el.chosen is not a function","<reactjs><jquery-plugins>","2","1","1","",""
"46833274","1","46833578","","2017-10-19 15:15:13","","1","3061","<p>I implement checking internet on my react-native v0.49 app.
I'm using NetInfo of react-native.
I add eventListener when any change happen it will call to function.
but when i test it in emulator and real device I get only the first change but if I disconnect from Wifi I don't see any change.</p>

<p>internetConnectionPopUp</p>

<pre><code>    import React, { Component } from 'react';
import {
    View,
    Text,
    NetInfo
} from 'react-native';

// styles
import { style } from './style';
import { globalStyle } from '../../assets/styles/globalStyle';

// redux
import {connect} from 'react-redux';
import * as actions from '../../actions';

class InternetConnectionPopUp extends Component {
    constructor(props){
        super(props);
        this.state = { 
            connectionInfo : ''

         }
         this.handleFirstConnectivityChange = this.handleFirstConnectivityChange.bind(this);

    }  
    handleFirstConnectivityChange(connectionInfo) {
        this.setState({
            connectionInfo: connectionInfo.type
        })
        console.log('First change, type: ' + connectionInfo.type + ', effectiveType: ' + connectionInfo.effectiveType);

      }

    componentWillMount () {
        NetInfo.getConnectionInfo().then((connectionInfo) =&gt; {
            this.setState({
                connectionInfo: connectionInfo.type
            })
            //console.log('Initial, type: ' + connectionInfo.type + ', effectiveType: ' + connectionInfo.effectiveType);
          });

          NetInfo.addEventListener(
            'connectionChange',
            this.handleFirstConnectivityChange
          );
    }
    componentWillUnmount() {
        NetInfo.removeEventListener(
            'connectionChange',
            handleFirstConnectivityChange
          );
    }




    render() {


        return (
            &lt;View&gt;
                &lt;Text&gt; ComponentName component &lt;/Text&gt;
                &lt;Text&gt; { this.state.connectionInfo } &lt;/Text&gt;
            &lt;/View&gt;    
        );
    }
}


export default InternetConnectionPopUp;
</code></pre>
","6455516","","","","","2017-10-19 15:31:16","react native check internet connection with NetINFO","<react-native>","1","0","","",""
"46720506","1","","","2017-10-12 23:47:13","","0","628","<p>Sorry I couldn't come up with a more specific title for this question. When I execute the below snippet I get the following warning:</p>

<blockquote>
  <p>Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Typewriter component.</p>
</blockquote>

<p>However, if the render() in MyComponent is changed to the following, I get no such warning:</p>

<pre><code>render() {
  return (
    &lt;div&gt;
      &lt;h1&gt;
        &lt;Typewriter /&gt;
        { this.state.render == 1 &amp;&amp; ""Render 1"" }
        { this.state.render == 2 &amp;&amp; ""Render 2"" }
        { this.state.render == 3 &amp;&amp; ""Render 3"" }
      &lt;/h1&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>How do I properly unmount this rendered Typewriter component that itself is performing some mounting and unmounting actions? Thanks!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Typewriter extends React.Component {
  constructor(props) {
    super();
    this.state = {
      finalText: ''
    }
    this.typeWriter = this.typeWriter.bind(this);
  }

  typeWriter(text, n) {
    if (n &lt; (text.length)) {
      if (n + 1 == (text.length)) {
        let j = text.substring(0, n+1);
        this.setState({ finalText: j });
        n++;
      }
      else {
        let k = text.substring(0, n+1) + '|';
        this.setState({ finalText: k });
        n++;
      }
      setTimeout( () =&gt; { this.typeWriter(text, n) }, 100 );
    }
  }

  componentDidMount() {
    this.typeWriter('testing_typewriter', 0);
  }

  render() {
    return (
      &lt;div&gt;
        { this.state.finalText }
      &lt;/div&gt;
    );
  }
}

class MyComponent extends React.Component {
  constructor(props) {
    super();
    this.state = {
      render: 1,
      update: false
    };
    this.interval = null;
  }

  componentDidMount() {
    this.interval = setTimeout( () =&gt;
      this.rendering(), 1700
    );
  }

  componentWillUpdate(nextProps, nextState) {
    if (this.state.render &lt; 3) {
      this.interval = setTimeout( () =&gt;
        this.rendering(), 1200
      );
    }
  }

  componentWillUnmount() {
      clearInterval(this.interval);
      this.interval = null;
  }

  rendering() {
    if (this.state.render &lt; 3) {
      if (this.interval) {
        this.setState({ render: this.state.render + 1 });
      }
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;
          { this.state.render == 1 &amp;&amp; ""Render 1"" }
          { this.state.render == 2 &amp;&amp; &lt;Typewriter /&gt; }
          { this.state.render == 3 &amp;&amp; ""Render 3"" }
        &lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}



ReactDOM.render(&lt;MyComponent /&gt;, app);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;

&lt;div id=""app""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","7460467","","","","","2017-10-13 02:03:17","Properly unmounting a react component","<javascript><reactjs><ecmascript-6>","1","4","1","",""
"38686233","1","","","2016-07-31 16:43:49","","0","36","<p>I am currently working with react and I have runned into a problem this morning that i do not understand.</p>

<p>I am trying to handle a form submit from my component with a function by passing it in the onSubmit property but it does not trigger it. I then added a button to trigger a mock function with its onClick property, and i still got the same problem; it appears than I can't trigger my function and I cannot find any solution on the Google.</p>

<p>Here is my code so you can check it out:</p>

<pre><code>import React from 'react';
import AgentsStore from '../stores/AgentsStore';
import AgentsActions from '../actions/AgentsActions';

class Agents extends React.Component {

constructor(props) {
    super(props);
    this.state = AgentsStore.getState();
    this.onChange = this.onChange.bind(this);
}

componentDidMount() {
    AgentsStore.listen(this.onChange);
}

componentWillUnmount() {
    AgentsStore.unlisten(this.onChange);
}

onChange(state) {
    this.setState(state);
}

handleSubmit(event) {
    event.preventDefault();

    var user = {};

    user.name = this.state.newUser.name.trim();
    user.lastname = this.state.newUser.lastname.trim();

    if (user.name &amp;&amp; user.lastname) {
        AgentsActions.createUser(user);
    }
}

onClick() {
    console.log('clicked');
}

render() {

    return (
        &lt;div /*className='container'*/&gt;
            &lt;div className='alert alert-info'&gt;
                Hello from Agents
            &lt;/div&gt;

            &lt;div className='panel panel-default'&gt;
                &lt;div className='panel-heading'&gt;Create User&lt;/div&gt;
                &lt;div className='panel-body'&gt;
                    &lt;form onSubmit={this.handleSubmit.bind(this)}&gt;
                        &lt;div className='form-group'&gt;
                            &lt;label className='control-label'&gt;Name&lt;/label&gt;
                            &lt;input type='text'
                                   className='form-control'
                                   ref='nameTextField'
                                   value={this.state.newUser.name}
                                   onChange={AgentsActions.updateName} /&gt;
                        &lt;/div&gt;
                        &lt;div className='form-group'&gt;
                            &lt;label className='control-label'&gt;Lastname&lt;/label&gt;
                            &lt;input type='text'
                                   className='form-control'
                                   ref='lastnameTextField'
                                   value={this.state.newUser.lastname}
                                   onChange={AgentsActions.updateLastname} /&gt;
                        &lt;/div&gt;
                        &lt;h4&gt;Address&lt;/h4&gt;
                        &lt;button type='submit' className='btn btn-primary'&gt;Submit&lt;/button&gt;
                    &lt;/form&gt;
                    &lt;button  onClick={this.onClick} className='btn btn-primary'&gt;Submit&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    )
}
}

export default Agents;
</code></pre>

<p>I do not know if I am missing something in my code or there is an error but i am kind of desperate. Also I am basing my code on another file that i have which is working just fine...</p>

<p>Thank you in advance for your time</p>
","6660497","","6660497","","2016-07-31 16:52:28","2016-07-31 16:52:28","Cannot trigger component's function in my react app","<reactjs><onclick>","0","2","","",""
"38862512","1","","","2016-08-10 00:39:14","","5","9261","<p>I'm trying to get a basic timer going in react-native, but it's not working. I get no errors in the console. It just simply ignores the <code>setInterval</code>. I read the <a href=""https://facebook.github.io/react-native/docs/timers.html"" rel=""noreferrer"">TimerMixin</a> issue with ES6 (not supported). So what is the alternative if you want to use just a basic <code>setInterval</code> timer?, as it simply does not work in its simplest form shown here...</p>

<pre><code>import React, { Component } from 'react';
import { AppRegistry, Text } from 'react-native';

class HelloWorldApp extends Component {

componentDidMount() {
      console.log('COMPONENTDIDMOUNT')
   //this.timer=     &lt;--//This doesn't work either 
     var timer = setInterval(() =&gt; {
      console.log('I do not leak!');
    }, 5000);
  }
componentWillUnmount() {
    console.log('COMPONENTWILLUNMOUNT')
  clearInterval(timer); 
}
  render() {
    return (
      &lt;Text&gt;Hello world!&lt;/Text&gt;
    );
  }
}

AppRegistry.registerComponent('HelloWorldApp', () =&gt; HelloWorldApp);
</code></pre>

<p><a href=""https://i.stack.imgur.com/28jsg.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/28jsg.png"" alt=""enter image description here""></a>
<a href=""https://i.stack.imgur.com/E1P4x.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/E1P4x.png"" alt=""enter image description here""></a></p>
","354992","","354992","","2016-08-10 01:54:52","2016-08-10 21:32:08","Neither setInterval nor setTimeout works react-native ES6","<javascript><react-native>","2","21","","",""
"46742658","1","","","2017-10-14 08:50:51","","1","553","<pre><code>componentWillReceiveProps(nextProps) {
        if (nextProps.seconds !== 0) {
            this.setState({ seconds: nextProps.seconds });
            setInterval(() =&gt; this.getStopTimer(this.state.seconds - 1), 1000);
        }
    }
</code></pre>

<p>I have this piece of code to make a stopwatch in reactjs.</p>

<p>So in each second it calls a method <code>getStopTimer</code> and decrease the second by one and then show in the browser using <code>{this.state.seconds}</code>.</p>

<p>I have only a mere idea about lifecycle hooks in react as I am new to this.</p>

<p>The countdown timer is working on my first input, but when I gave another time for it to begin without reloading, the timer is running double the previous time. Like for the first run, the stopwatch was for a 1-second timer, but the next input runs the same by 2 seconds.</p>

<p>Can  you please explain why this is happening?</p>

<pre><code>getStopTimer(seconds) {
        console.log(seconds);
        if (seconds &gt;= 0) {
            this.setState({ seconds });
        }
    }
</code></pre>

<p>here is the stopwatch child component;</p>

<pre><code>import React, { Component } from 'react';

class Stopwatch extends Component {
    constructor(props) {
        super(props);
        this.state = {
            hour: 0,
            minute: 0,
            second: 0,
            seconds: 0
        };
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.seconds !== 0) {
            this.setState({ seconds: nextProps.seconds });
            setInterval(() =&gt; this.getStopTimer(this.state.seconds - 1), 1000);
        }
    }

    componentWillUnmount() {}

    getStopTimer(seconds) {
        console.log(seconds);
        if (seconds &gt;= 0) {
            this.setState({ seconds });
        }
    }

    render() {
        return (
            &lt;div&gt;
                &lt;p&gt;{this.state.seconds} seconds remains!&lt;/p&gt;
            &lt;/div&gt;
        );
    }
}

export default Stopwatch;
</code></pre>
","8437740","","8437740","","2017-10-14 09:04:18","2017-10-14 09:46:05","count down timer in react","<reactjs><lifecycle>","1","8","","",""
"38755616","1","","","2016-08-04 00:15:52","","0","279","<p>I'm trying to set a <code>react-sidebar</code> using the example for the component <a href=""https://github.com/balloob/react-sidebar#installation"" rel=""nofollow"">here</a> and I'm running into the following error message on compile:</p>

<pre><code>36:16  warning  Handler function for onSetOpen prop key must begin with 'handle'  react/jsx-handler-names
</code></pre>

<p>Here is my Leftbar.js file:</p>

<pre><code>import React from 'react';
import { Sidebar } from 'react-sidebar';
import './Leftbar.css';


var Leftbar = React.createClass({
  getInitialState() {
    return {sidebarOpen: false, sidebarDocked: false};
  },

  onSetSidebarOpen: function(open) {
    this.setState({sidebarOpen: open});
  },

  componentWillMount: function() {
    var mql = window.matchMedia(`(min-width: 800px)`);
    mql.addListener(this.mediaQueryChanged);
    this.setState({mql: mql, sidebarDocked: mql.matches});
  },

  componentWillUnmount: function() {
    this.state.mql.removeListener(this.mediaQueryChanged);
  },

  mediaQueryChanged: function() {
    this.setState({sidebarDocked: this.state.mql.matches});
  },

  render: function() {
    var sidebarContent = &lt;b&gt;Sidebar content&lt;/b&gt;;

    return (
      &lt;Sidebar sidebar={sidebarContent}
               open={this.state.sidebarOpen}
               docked={this.state.sidebarDocked}
               onSetOpen={this.onSetSidebarOpen}&gt;
        &lt;b&gt;Main content&lt;/b&gt;
      &lt;/Sidebar&gt;
    );
  }
});

export default Leftbar;
</code></pre>

<p>This is being passed into my Home.js:</p>

<pre><code>import React from 'react';
import { Row } from 'react-bootstrap';
import Leftbar from './components/Leftbar/Leftbar';
import Widgets from './components/Widgets/Widgets'
import './Home.css'


var Home = React.createClass({
    render: function() {
        return (
            &lt;div className=""container""&gt;
                &lt;Row&gt;
                    &lt;Leftbar/&gt;
                    &lt;Widgets/&gt;
                &lt;/Row&gt;
            &lt;/div&gt;
        );
    }
});

export default Home;
</code></pre>
","2977876","","","","","2016-08-04 01:10:09","36:16 warning Handler function for onSetOpen prop key must begin with 'handle' react/jsx-handler-names","<javascript><reactjs><react-native>","1","0","","",""
"38044989","1","38045429","","2016-06-27 02:11:23","","0","439","<p>I'm trying to hand build a react/flux app, roughly following:
<a href=""https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture"" rel=""nofollow"">https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture</a></p>

<p>I've got most of it working but when I update the state the component doesn't re-render. Can anyone help?</p>

<p>Thanks. :)</p>

<hr>

<p>Repo is <a href=""https://github.com/jmsherry/flux_hand"" rel=""nofollow"">https://github.com/jmsherry/flux_hand</a></p>

<p><strong>CounterStore.js</strong></p>

<pre><code>import Dispatcher from 'Flux';
import AppDispatcher from './../dispatcher/AppDispatcher';
import CounterConstants from '../constants/constants';
import { EventEmitter } from 'events';
import assign from 'object-assign';


let _count = 5;

function increment() {
  _count +=1;
}

function decrement() {
  _count -=1;
}

let CounterStore = assign({}, EventEmitter.prototype, {

  getCount() {
    return _count;
  },

  emitChange() {
    this.emit(CounterConstants.CHANGE_EVENT);
  },

  /**
   * @param {function} callback
   */
  addChangeListener(callback) {
    this.on(CounterConstants.CHANGE_EVENT, callback);
  },

  /**
   * @param {function} callback
   */
  removeChangeListener(callback) {
    this.removeListener(CounterConstants.CHANGE_EVENT, callback);
  },

  dispatcherIndex: AppDispatcher.register(function(payload) {
    console.log('blah', arguments);
    var action = payload.action;
    var text;

    switch(action.actionType) {
      case CounterConstants.INCREMENT:
          console.log('inc', _count);
          increment();
          console.log(_count);
          CounterStore.emitChange();
        break;

      case CounterConstants.DECREMENT:
      console.log('dec', _count);
        decrement();
        console.log(_count);
        CounterStore.emitChange();
        break;
    }

    return true; // No errors. Needed by promise in Dispatcher.
  })

});

export default CounterStore;
</code></pre>

<p><strong>AppDispatcher.js</strong></p>

<pre><code>import { Dispatcher } from 'Flux';

const AppDispatcher = new Dispatcher();

AppDispatcher.handleViewAction = function(action) {
  console.log('in', arguments);
  this.dispatch({
    source: 'VIEW_ACTION',
    action
  });
}

export default AppDispatcher;
</code></pre>

<p><strong>constants.js</strong></p>

<pre><code>import keyMirror from 'keymirror';

const CounterConstants = keyMirror({
  INCREMENT: null,
  DECREMENT: null
});

CounterConstants.CHANGE_EVENT = 'change';

export default CounterConstants;
</code></pre>

<p><strong>actions.js</strong></p>

<pre><code>import AppDispatcher from '../dispatcher/AppDispatcher';
var CounterConstants = require('../constants/constants');

const CounterActions = {

  /**
   * @param  {string} text
   */
  increment() {
    AppDispatcher.handleViewAction({
      actionType: CounterConstants.INCREMENT
    });
  },

  decrement() {
    AppDispatcher.handleViewAction({
      actionType: TodoConstants.DECREMENT
    });
  }

};

export default CounterActions;
</code></pre>

<p><strong>counter.js &lt;-- parent view</strong></p>

<pre><code>import React,{Component} from 'react';
import ReactDOM from 'react-dom';
import CounterConstants from './../constants/constants';
import AppDispatcher from './../Dispatcher/AppDispatcher.js';
import Controls from './Controls';
import Display from './Display';

class Counter extends Component {
  render(){
    return (
      &lt;div className=""counter""&gt;
        &lt;h1&gt;My counter&lt;/h1&gt;
        &lt;Display /&gt;
        &lt;Controls /&gt;
      &lt;/div&gt;
    )
  }
}

export default Counter;
</code></pre>

<p><strong>controls.js</strong></p>

<pre><code>import React,{Component} from 'react';
import ReactDOM from 'react-dom';
import CounterConstants from './../constants/constants';
import AppDispatcher from './../dispatcher/AppDispatcher';
import CounterActions from './../actions/actions';

class Controls extends Component {
  render(){
    console.log('here', AppDispatcher);
    return (
      &lt;div className=""controls""&gt;
        &lt;button onClick={CounterActions.increment}&gt;+&lt;/button&gt;
        &lt;button onClick={CounterActions.decrement}&gt;-&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

export default Controls;
</code></pre>

<p><strong>display.js</strong></p>

<pre><code>import React,{Component} from 'react';
import ReactDOM from 'react-dom';
import CounterConstants from './../constants/constants';
import CounterStore from './../stores/CounterStore';

// Method to retrieve application state from store
function getAppState() {
  console.log('getting app state...');
  return {
    count: CounterStore.getCount()
  };
}

class Display extends Component {
  constructor(props) {
    super(props);
    this.state = getAppState();
  }

  // Update view state when change event is received
  _onChange() {
    console.log('prechange', this.state);
    const newState = getAppState();
    console.log('newState', newState);
    (newState) =&gt; this.setState;
  }

  // Listen for changes
  componentDidMount() {
    CounterStore.addChangeListener(this._onChange.bind(this));
  }

  // Unbind change listener
  componentWillUnmount() {
    CounterStore.removeChangeListener(this._onChange.bind(this));
  }

  shouldComponentUpdate( newProps, newState ) {
    console.log('shouldComponentUpdate', arguments);
  }

  render() {
    let count = getAppState().count;
    console.log('rendering', count, this.state);
    return (
      &lt;div className = ""display"" &gt;
        &lt;p&gt;State: { this.state.count }&lt;/p&gt;
        &lt;p&gt;count: { count }&lt;/p&gt;
      &lt;/div&gt;
    )
  }
}

export default Display;
</code></pre>
","1775718","","1775718","","2016-06-27 03:07:16","2016-06-27 03:48:09","react component state not updating (FLUX App)","<reactjs><reactjs-flux>","3","0","","",""
"47184515","1","","","2017-11-08 16:13:20","","0","51","<p>So I am using this react-bubble-chart <a href=""https://github.com/kauffecup/react-bubble-chart"" rel=""nofollow noreferrer"">component</a> in my application. It is on the home/main route. On initial page load it works fine. However, if one navigates away and then back again (react-router) it will not load and throws an error:</p>

<pre><code>Uncaught Error
    at extendBasis (enclose.js:41)
    at ./node_modules/d3-hierarchy/src/pack/enclose.js.__webpack_exports__.a (enclose.js:9)
    at packEnclose (siblings.js:104)
    at index.js:63
    at Node../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js.__webpack_exports__.a [as eachAfter] (eachAfter.js:10)
    at ReactBubbleChartD3.pack [as bubble] (index.js:24)
    at ReactBubbleChartD3.update (bubble-chart-d3.js:255)
    at new ReactBubbleChartD3 (bubble-chart-d3.js:85)
    at BubbleChart.componentDidMount (index.jsx:163)
    at commitLifeCycles (react-dom.development.js:11505)
    at commitAllLifeCycles (react-dom.development.js:12294)
    at HTMLUnknownElement.callCallback (react-dom.development.js:1299)
    at Object.invokeGuardedCallbackDev (react-dom.development.js:1338)
    at invokeGuardedCallback (react-dom.development.js:1195)
    at commitAllWork (react-dom.development.js:12415)
    at workLoop (react-dom.development.js:12687)
    at HTMLUnknownElement.callCallback (react-dom.development.js:1299)
    at Object.invokeGuardedCallbackDev (react-dom.development.js:1338)
    at invokeGuardedCallback (react-dom.development.js:1195)
    at performWork (react-dom.development.js:12800)
    at scheduleUpdateImpl (react-dom.development.js:13185)
    at scheduleUpdate (react-dom.development.js:13124)
    at Object.enqueueSetState (react-dom.development.js:9646)
    at Router../node_modules/react/cjs/react.development.js.ReactComponent.setState (react.development.js:218)
    at Router.js:70
    at listener (createTransitionManager.js:54)
    at createTransitionManager.js:73
    at Array.forEach (&lt;anonymous&gt;)
    at Object.notifyListeners (createTransitionManager.js:72)
    at setState (createBrowserHistory.js:95)
    at createBrowserHistory.js:120
    at Object.confirmTransitionTo (createTransitionManager.js:44)
    at handlePop (createBrowserHistory.js:118)
    at handlePopState (createBrowserHistory.js:102)
</code></pre>

<p>As you can see something is causing d3-hierarchy to error. As far as I can see everything is the same as when it runs on page load as in it is getting the same data. </p>

<p>The <code>react-bubble-chart</code> module has two parts - the react component and a es6 class that deals with all the D3 code. The react component runs <code>this.bubbleChart = new ReactBubbleChartD3()</code> on <code>componentDidMount</code> and does run a destroy method of the bubblechart class on componentWillUnmount <code>this.bubbleChart.destroy()</code> but this method is empty in the code. Is it likely to be this that is causing the issue?</p>

<p>I have tried adding code to remove the html in the bubblechart container in that destroy method but it makes no difference.</p>

<p>Any ideas?</p>

<p>I have added the files here - <a href=""https://gist.github.com/garytokyo/64982a5210c3a269f341d8934bb9a1ff"" rel=""nofollow noreferrer"">https://gist.github.com/garytokyo/64982a5210c3a269f341d8934bb9a1ff</a></p>

<p>In <code>bubble-chart-d3.js</code> it is the following code that causes the error (line 254 or there abouts):</p>

<pre><code>const circles = this.svg
    .selectAll('circle')
    .data(this.bubble(nodes).descendants(), d =&gt; 'g' + d.data._id);
</code></pre>

<p>To be more specific it is <code>this.bubble(nodes)</code></p>
","4423792","","4423792","","2017-11-08 17:44:25","2017-11-08 17:44:25","D3 error when using with react and react-router","<reactjs><d3.js><react-router-v4><react-router-dom>","0","2","","",""
"38928525","1","38928560","","2016-08-13 02:08:22","","1","175","<p>Given this component : </p>

<pre><code>import React, { Component } from 'react';
import TrackerReact from 'meteor/ultimatejs:tracker-react';

export default class SubscriptionView extends TrackerReact(Component) {

  constructor(props) {
    super(props);

    let params = props.params || [];

    if (!Array.isArray(params)) {
      params = [params];
    }

    this.state = {
      subscription: {
        collection: Meteor.subscribe(props.subscription, ...params)
      }
    };
  }

  componentWillUnmount() {
    this.state.subscription.collection.stop();
  }


  render() {
    let loaded = this.state.subscription.collection.ready();

    if (!loaded) {
      return (
        &lt;section className=""subscription-view""&gt;
          &lt;h3&gt;Loading...&lt;/h3&gt;
        &lt;/section&gt;
      );
    }

    return (
      &lt;section className=""subscription-view""&gt;
        { this.props.children }
      &lt;/section&gt;
    );
  }
};
</code></pre>

<p>And another component :</p>

<pre><code>import SubscriptionView from './SubscriptionView.jsx';

export const Foo = () =&gt; (
  &lt;SubscriptionView subscription=""allFoo""&gt;
    &lt;SubscriptionView subscription=""singleBar"" params={ 123 }&gt;
      &lt;div&gt;Rendered!&lt;/div&gt;
    &lt;/SubscriptionView&gt;
  &lt;/SubscriptionView&gt;
);
</code></pre>

<p>The first <code>Subscription</code> is re-rendered when the data is available, however the second one is rendered only once and nothing more. If I place a <code>console.log(this.props.subscription, ready);</code> inside the render function of <code>SubscriptionView</code>, I see</p>

<pre><code>allFoo false
allFoo true
singleBar false
</code></pre>

<p>and that's it.</p>

<p>On the server side, both publish methods are</p>

<pre><code>Meteor.publish('allFoo', function () {
  console.log(""Subscribing foos"");
  return Foos.find();
});

Meteor.publish('singleBar', function (id) {
  console.log(""Subscribing bar"", id);
  return Bars.find({ _id: id });
});
</code></pre>

<p>Both of the publish methods are being called.</p>

<p>Why isn't the second <code>SubscriptionView</code> reactive?</p>

<hr>

<h3><strong>* Solution *</strong></h3>

<p>This is based on <a href=""https://stackoverflow.com/questions/38928525/react-does-not-render-recursive-reactive-components/38928560?noredirect=1#comment65214011_38928560"">alexi2</a>'s comment :</p>

<pre><code>import React, { Component } from 'react';
import TrackerReact from 'meteor/ultimatejs:tracker-react';

export default class SubscriptionLoader extends TrackerReact(Component) {

  constructor(props) {
    super(props);

    let params = props.params || [];

    if (!Array.isArray(params)) {
      params = [params];
    }

    this.state = {
      done: false,
      subscription: {
        collection: Meteor.subscribe(props.subscription, ...params)
      }
    };
  }

  componentWillUnmount() {
    this.state.subscription.collection.stop();
  }

  componentDidUpdate() {
    if (!this.state.done) {
      this.setState({ done: true });

      this.props.onReady &amp;&amp; this.props.onReady();
    }
  }


  render() {
    let loaded = this.state.subscription.collection.ready();

    if (!loaded) {
      return (
        &lt;div&gt;Loading...&lt;/div&gt;
      );
    }

    return null;
  }
};
</code></pre>

<p>Then, inside the parent component's <code>render</code> method :</p>

<pre><code>&lt;section className=""inventory-item-view""&gt;
  &lt;SubscriptionLoader subscription='singleBar' params={ this.props.id } onReady={ this.setReady.bind(this, 'barReady') } /&gt;
  &lt;SubscriptionLoader subscription='allFoos' onReady={ this.setReady.bind(this, 'foosReady') } /&gt;
  { content }
&lt;/section&gt;
</code></pre>

<p>Where <code>setReady</code> merely sets the component's state, and <code>content</code> has a value only if <code>this.state.barReady &amp;&amp; this.state.foosReady</code> is true.</p>

<p>It works!</p>
","320700","","-1","","2017-05-23 11:44:24","2016-08-13 03:36:22","React does not render recursive reactive components","<javascript><reactjs><ecmascript-6>","1","0","","",""
"46078154","1","","","2017-09-06 14:41:35","","4","480","<p>I am building a react native app and I am fairly new to this. I am using <a href=""https://github.com/react-community/react-navigation"" rel=""nofollow noreferrer"">React navigation</a> for moving from one page to another. Currently, I am using stack navigator.</p>

<p>I have two screens, A and B. In screen B I have a search input that uses the keyboard. When the back button in the header is pressed whilst the keyboard is open I navigate to screen A but there is a significant delay before the keyboard dismisses. I have put Keyboard.dismiss(); in componentWillUnmount in Screen B and componentWillMount in screen A. Unsure as to how or wether or not it's possible to add an onClick event to the back button as I believe it's inside the header component.</p>

<pre><code>  export default class Locations extends Component {
   static navigationOptions = {
     title: 'Search Location',
   } 

  renderHeader = () =&gt; {
    return &lt;SearchBar onChangeText={(text) =&gt;this.handleSearch(text)} 
      placeholder=""Type Here..."" lightTheme round /&gt;;
  }
  componentWillUnmount(){
    Keyboard.dismiss();
  }
</code></pre>

<p>Any one had this issue before?</p>
","8569453","","8569453","","2017-09-06 15:46:33","2017-09-06 16:36:18","Delay in keyboard dismiss react-native","<javascript><reactjs><react-native>","1","1","","",""
"46253360","1","","","2017-09-16 11:23:33","","0","75","<p>I have an app working with tabbed navigation but it seems that I need to interact with the components in the tabs that aren't active when the app starts, before they'll display data. </p>

<p>I have 3 tabs in my app, a map that displays restaurants nearby, a list of different ingredients and also a list of additives. </p>

<p>All these data sets are being sourced from a server (salesforce) when the page is loaded that holds the tab nav -- the homescreen component. The only thing this component is doing is loading my three other components. </p>

<p>Now, when I click into the other tabs, the screen is blank until i scroll or click in the page somewhere and then the UI loads. I think this is due to the fact that the setState call has already run, but when the 1st component in the tab nav was visible to the user. </p>

<p>How can I fire a call to update the UI when someone clicks on the newly active tab? (i'm setting state still in the component, not using redux yet.. this will come with time!).. </p>

<p>component below: </p>

<pre><code>import React, {Component} from 'react';
import {
    View,
    FlatList,
    ActivityIndicator
} from 'react-native';
import {Icon, List, ListItem, SearchBar} from 'react-native-elements';
import {oauth, net} from 'react-native-force';
// todo - implement... import {StackNavigator} from 'react-navigation';

export default class Ingredients extends Component {

    static navigationOptions = {
        tabBarLabel: 'Ingredients',
        title: 'Ingredients',
        tabBarIcon: ({tintColor}) =&gt; (
            &lt;Icon
                name='blur-linear'
                color={tintColor}
            /&gt;
        )
    };

    constructor(props) {
        super(props);
        this.state = {
            ingredients: [],
            refreshing: false
        };
    }

    componentDidMount() {
        oauth.getAuthCredentials(
            () =&gt; this.fetchData(), // already logged in
            () =&gt; {
                oauth.authenticate(
                    () =&gt; this.fetchData(),
                    (error) =&gt; console.log('Failed to authenticate:' + error)
                );
            });
    }

    componentWillUnmount() {
        this.setState({
            ingredients: [],
            refreshing: false
        })
    };

    fetchData = () =&gt; {
        this.setState({
            refreshing: true
        });
        net.query('SELECT Id, Ingredient__c, CA_GF_Status_Code__c, CA_Ingredient_Notes__c FROM Ingredient__c ORDER BY Ingredient__c',
            (response) =&gt; this.setState({
                ingredients: response.records,
                refreshing: false
            })
        );
    };

    renderHeader = () =&gt; {
        //todo - make this actually search something
        return &lt;SearchBar placeholder=""Type Here..."" lightTheme round/&gt;;
    };

    renderFooter = () =&gt; {
        if (!this.state.loading) return null;

        return (
            &lt;View
                style={{
                    paddingVertical: 20,
                    borderTopWidth: 1,
                    borderColor: ""#CED0CE""
                }}
            &gt;
                &lt;ActivityIndicator animating size=""large""/&gt;
            &lt;/View&gt;
        );
    };

    selectIcon = (statusCode) =&gt; {
        switch (statusCode) {
            case 0:
                return &lt;Icon type='font-awesome' name='close' color='#80A33F'/&gt;;
            case 1:
                return &lt;Icon type='font-awesome' name='check' color='#80A33F'/&gt;;
            case 2:
                return &lt;Icon type='font-awesome' name='asterisk' color='#80A33F'/&gt;;
            case 3:
                return &lt;Icon type='font-awesome' name='sign-out' color='#80A33F'/&gt;;
            case 4:
                return &lt;Icon type='font-awesome' name='question-circle' color='#80A33F'/&gt;;
            default:
                return &lt;Icon type='font-awesome' name='close' color='#80A33F'/&gt;;
        }
    };

    render() {
        return (
            &lt;List&gt;
                &lt;FlatList
                    data={this.state.ingredients}
                    renderItem={({item}) =&gt; (
                        &lt;ListItem
                            title={item.Ingredient__c}
                            subtitle={item.CA_Ingredient_Notes__c}
                            chevronColor='#025077'
                            avatar={this.selectIcon(item.CA_GF_Status_Code__c)}
                            onPress={() =&gt; {window.alert('this is being pressed')}}
                        /&gt;
                    )}
                    keyExtractor={(item, index) =&gt; index}
                    ListHeaderComponent={this.renderHeader}
                    ListFooterComponent={this.renderFooter}
                    refreshing={this.state.refreshing}
                    onRefresh={this.fetchData}
                /&gt;
            &lt;/List&gt;
        );
    }
}
</code></pre>
","3500209","","","","","2017-09-16 11:23:33","Tabbed navigation react native react-navigation","<react-native><react-navigation><react-native-ios>","0","2","","",""
"38296563","1","","","2016-07-10 21:20:12","","1","56","<p>UPDATE: after restart it works now. However it stills shows the logged out component first then the logged in one. Why is this because the user is logged in I just refresh the page?</p>

<p>UPDATE 2:
It has gone back to the flashing of the logged out => then then what it should be and then to white again, after no changes just restarting meteor.</p>

<p>UPDATE 3:
So it works then I navigate to this page but not others.It seems because the registration page subscribes to the items collection so that is how it picks it up. I thought it should not refresh the Box component when changing pages and should be subscribed to the items collection from the Box component itself. This page is loaded via flow router and is inputted into the content area of the site see below:</p>

<pre><code>import Items from '/imports/collections/items/items.js';



export default class Registration extends TrackerReact(React.Component){

    constructor(){
            super();
            this.state = {
                    subscription: {
                            items: Meteor.subscribe(""allStarterItems"")
                    }
            }
    }
</code></pre>

<p>The main page is here, the issues lies within the LeftNavbar area as this contains the boxes:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import TrackerReact from 'meteor/ultimatejs:tracker-react';
import LeftNavbar from './LeftNavbar';

export const MainLayout = ({content}) =&gt; (

&lt;div className=""main-layout""&gt;


        &lt;LeftNavbar /&gt;

        &lt;div className=""right content-page""&gt;
                          &lt;main&gt;
                  {content}
            &lt;/main&gt; 

        &lt;/div&gt;


&lt;/div&gt;
)
</code></pre>

<p>Here is the left navbar page:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import TrackerReact from 'meteor/ultimatejs:tracker-react';
import Box from '/imports/ui/left_navbar/Box';

export default class LeftNavbar extends TrackerReact(React.Component){

    constructor(){
     super();   
    }

    render(){       
     return (  
                    &lt;div className=""left side-menu""&gt;    
                            &lt;div className=""body rows scroll-y""&gt;    
                                    &lt;div className=""sidebar-inner ""&gt;
                                            &lt;Box /&gt;
                                    &lt;/div&gt;
                            &lt;/div&gt;
                    &lt;/div&gt;   
         ) 
    }
 }
</code></pre>

<hr>

<p>Hey everyone I have an issue in my project.</p>

<p>I have an area where I have a stack of images stacked on top of each other and are overlayed. I know the css etc work as I have it on another page just not loading from a db.</p>

<p>Here the the file that checks if the user is logged in or not to decide what component to render:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import TrackerReact from 'meteor/ultimatejs:tracker-react';
import BoxSignedIn from     '/BoxSignedIn';
import BoxSignedOut from '/BoxSignedOut';


 export default class Box extends TrackerReact(React.Component){

    constructor(){
     super();   
    }



    render(){
        var layout;
        if (Meteor.user()) {
            layout = &lt;BoxSignedIn /&gt;;
        } else {
            layout = &lt;BoxSignedOut /&gt;;
        }


     return (   
                layout                          
            ) 

    }
}
</code></pre>

<p>Here is the component that is loaded. However when I reload the page it shows the logged out component for a split second, then it shows nothing. On the source of the page it shows no src from the images. In the console it sometimes shows 2 of the image sources, sometimes 3</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import TrackerReact from 'meteor/ultimatejs:tracker-react';
import Items from '/imports/collections/items/items.js';



export default class BoxSignedIn extends TrackerReact(React.Component){

    constructor(){
        super();
        this.state = {
                subscription: {
                        items: Meteor.subscribe(""allStarterItems"")
                },
                layers: {
                    layer1: Meteor.user().profile.layer.1,
                    layer2: Meteor.user().profile.layer.2,
                    layer3: Meteor.user().profile.layer.3
                }
        }
    }


    componentWillUnmount(){
        this.state.subscription.items.stop();
    }



    getItemSource(itemKey){


        var itemer = Items.findOne({key: itemKey});
        if(!itemer){
                return """";
        }else{
                console.log(itemer.srcEntire); // shows src correctly
                return itemer.srcEntire;
        }
    }


    render(){   

     return (   

        &lt;div className=""media""  &gt;
                &lt;div className=""Area""&gt;
                    &lt;div className=""container-on-top box-small"" &gt;
                        &lt;img id=""layer1"" className=""on-top img-responsive center-block on-top"" name=""layer1"" src={this.getItemSource(this.state.layers.layer1)} /&gt;
                        &lt;img id=""layer2"" className=""on-top img-responsive center-block on-top"" name=""layer2"" src={this.getItemSource(this.state.layers.layer2)} /&gt;
                        &lt;img id=""layer3"" className=""on-top img-responsive center-block on-top"" name=""layer3"" src={this.getItemSource(this.state.layers.layer3)} /&gt;

                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;    

            ) 
    }
}
</code></pre>
","6551801","","6551801","","2016-07-10 23:05:19","2016-07-10 23:05:19","Meteor react Issue with flashing image - shows logged out then logged in","<javascript><meteor><reactjs>","0","4","2","",""
"46305768","1","","","2017-09-19 16:44:59","","0","145","<p>First of all, I would like to provide a gif animation and description of the goal.<br>
<a href=""https://i.stack.imgur.com/TvWMu.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TvWMu.gif"" alt=""enter image description here""></a></p>

<p>I'd like to see elements running their own animation when the user enters or leaves particular page. For example, some elements on the page may come from the right side and some from the left side, when the user leaves page - their position would be transitioned in reverse direction.</p>

<p>In other words - flow could look like this:</p>

<ol>
<li>User enters page</li>
<li>Elements animation runs.</li>
<li>Animation finished.</li>
<li>User clicks some link which leads to another page.</li>
<li>Specific ""onLeave"" animation runs for each particular element.</li>
<li>When animation is over - user gets navigated to desired location described in the link.</li>
</ol>

<p>Source: <a href=""https://github.com/eko24ive/react-router-animate-childrens"" rel=""nofollow noreferrer"">react-router-animate-childrens</a><br>
Demo: <a href=""https://eko24ive.github.io/react-router-animate-childrens/"" rel=""nofollow noreferrer"">https://eko24ive.github.io/react-router-animate-childrens/</a></p>

<p>For gif demonstration example I've created two dummy pages. react-router v4 is for routing, react-motion take care of animations. I was wondering if there was any way to run these animations by the means of react router.</p>

<p>According to their <a href=""https://github.com/ReactTraining/react-router/blob/c60af989573d023b58311c3ab1153043de3efe9f/packages/react-router/docs/guides/migrating.md#on-properties"" rel=""nofollow noreferrer"">documentation</a> regarding events for entering/leaving page was available for v3 as <code>onEnter</code> and <code>onLeave</code>. For v4 they say:</p>

<blockquote>
  <p>With v4, you should use the lifecycle methods of the component rendered by a <code>&lt;Route&gt;</code>. Instead of <code>onEnter</code>, you would use componentDidMount or componentWillMount. Where you would use <code>onUpdate</code>, you can use <code>componentDidUpdate</code> or <code>componentWillUpdate</code> (or possibly <code>componentWillReceiveProps</code>). <code>onLeave</code> can be replaced with <code>componentWillUnmount</code>.</p>
</blockquote>

<p>I've tried that, but react life-cycle methods don't provide any ability to postpone/prevent component mount/unmount even with help of react-router.</p>

<p>Furtherly searching through my issue I've discovered that it is possible to block <code>history</code> of react-router which results in preventing component unmount. One of unpleasant side effects - it prompt confirmation message for user (asking if user wants to leave currently opened page), so I've tried to search something on customizing prompt message and found this <a href=""https://github.com/ReactTraining/react-router/issues/4635"" rel=""nofollow noreferrer"">issue</a> where collaborator of react-router <a href=""https://github.com/ReactTraining/react-router/issues/4635#issuecomment-287197704"" rel=""nofollow noreferrer"">posted</a> link to codepen demonstrating ability to <a href=""http://codepen.io/pshrmn/pen/MpOpEY"" rel=""nofollow noreferrer"">change prompt message</a>.</p>

<p>So using codepen example code, I've modified custom <code>&lt;Prompt/&gt;</code> element to make it hidden and fire callback to accept location change with the timeout of few milliseconds. In my code I'm using state with boolean flag <code>willUnmount</code> to decide should Page run animation for it's childrens in forward or in reverse. This state of page changed right before creating timeout for Prompt component via custom event. </p>

<p>And the problem is - when I navigate through this two pages several times I get this error:
<code>
Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the SubPage component.
</code></p>

<p>At this point - whatever I tried to fix this I couldn't succeed further. So my question is what I'm doing in this case or maybe there is another way to achieve such animations ?</p>

<p>Many thanks in advance !</p>
","3472702","","","","","2017-09-19 16:44:59","Animate children components of page with react-router v4","<reactjs><animation><react-router-v4><react-motion>","0","0","","",""
"47104177","1","","","2017-11-03 20:47:43","","0","204","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","2359997","","2359997","","2017-11-03 21:41:59","2017-11-03 21:50:29","Error while using react-virtualized-select","<javascript><node.js><reactjs><react-redux>","2","10","","",""
"47149181","1","","","2017-11-07 02:46:47","","0","32","<p>I am trying to implement this feature in react from <a href=""https://hypebeast.com/"" rel=""nofollow noreferrer"">https://hypebeast.com/</a>. 
Notice how if we scroll past the main nav header a second one slides into place. 
How would I do this using react ? </p>

<p>The bug I am getting is that when window.offsetY is greater than 150 it is alternating between two values without any scroll. </p>

<p>Here is my attempt:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class NavContainer extends React.Component {
  constructor(props) {
    super(props)
    this.state = { showFixedNav: false, defaultHeight: null }
    this.showNav = this.showNav.bind(this)
  }

  componentDidMount() {
    const defaultHeight = document.getElementById('default').clientHeight
    this.setState({ defaultHeight: defaultHeight})
    window.addEventListener('scroll', this.showNav)
  }

  componentWillUnmount() {
    window.removeEventListener('scroll', this.showNav)
  }

  showNav() {
    let { showFixedNav, defaultHeight } = this.state
    console.log('scrolly ' + window.scrollY)
    console.log('default ' + defaultHeight)
    if (window.scrollY &gt; defaultHeight) {
      this.setState({ showFixedNav: true })
    } else {
      this.setState({ showFixedNav: false })
    }
    console.log(this.state.showFixedNav)
  }

  render () {
    let nav = (
      &lt;div&gt;&lt;/div&gt;
    )
    if (this.state.showFixedNav) {
      nav = &lt;div&gt;
              &lt;Nav3 /&gt;
            &lt;/div&gt;
    } else {
      nav = &lt;div id=""default""&gt;
              &lt;Nav2 /&gt;
            &lt;/div&gt;
    }
    return (
      &lt;div&gt;
        {nav}
      &lt;/div&gt;
    )
  }
}</code></pre>
</div>
</div>
</p>
","4960378","","4960378","","2017-11-07 03:51:10","2017-11-07 03:51:10","How to have a react component display when past another component's bottom position?","<reactjs><styled-components>","0","0","","",""
"30251957","1","","","2015-05-15 05:15:19","","1","1215","<p>I'm trying to test out React functionality by creating a notes webapp.  In the left sidebar I have a list of all the notes for the currently logged in user.  When one of the notes is selected I want it to appear in the main area of the webpage.</p>

<p>This works the first time I select the note but not after this, unless I manually refresh the page.  I think the component mounts the first time and retrieves the note but when I select another note it's not updating the component.</p>

<p>I am using react-router, so when I select a note it traverses to /notes/:note_id based on the note selected.  This always changes but the content doesn't refresh.</p>

<p>Here is my NoteItem code:</p>

<pre><code>var React = require('react');
var WebAPIUtils = require('../../utils/WebAPIUtils.js');
var NoteStore = require('../../stores/NoteStore.react.jsx');
var NoteActionCreators = require('../../actions/NoteActionCreators.react.jsx');
var Router = require('react-router');
var State = require('react-router').State;

var NoteItem = React.createClass({
  mixins: [ State ],

  getInitialState: function() {
    return {
      note: NoteStore.getNote(),
      errors: []
    };
  },

  componentDidMount: function() {
    NoteStore.addChangeListener(this._onChange);
    NoteActionCreators.loadNote(this.getParams().noteId);
  },

  componentWillUnmount: function() {
    NoteStore.removeChangeListener(this._onChange);
  },

  _onChange: function() {
    this.setState({
      note: NoteStore.getNote(),
      errors: NoteStore.getErrors()
    });
  },

  render: function() {  
    return (
      &lt;div className=""row""&gt;
      &lt;div className=""note-title""&gt;{this.state.note.title}&lt;/div&gt;
        &lt;div className=""note-body""&gt;{this.state.note.body}&lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

module.exports = NoteItem;
</code></pre>

<p>And here's how I'm linking to NoteItem from my sidebar using react-router:</p>

<pre><code>&lt;Link to=""note"" params={ {noteId: this.props.note.id} }&gt;{this.props.note.title}&lt;/Link&gt;
</code></pre>

<p>And my routes:</p>

<pre><code>&lt;Route name=""app"" path=""/"" handler={NotesApp}&gt;
  &lt;DefaultRoute /&gt;
  &lt;Route name=""login"" path=""/login"" handler={LoginPage}/&gt;
  &lt;Route name=""signup"" path=""/signup"" handler={SignupPage}/&gt;
  &lt;Route name=""notes"" path=""/notes"" handler={NotesSidebar}/&gt;
  &lt;Route name=""note"" path=""/notes/:noteId"" handler={NoteItem} /&gt;
&lt;Route&gt;
</code></pre>

<p>Any help would be appreciated.</p>

<p>Thanks!</p>
","4262792","","","","","2015-05-15 06:36:29","Refresh component when new item selected using react-router","<javascript><reactjs><reactjs-flux><react-router>","1","0","1","",""
"47213527","1","","","2017-11-09 23:45:55","","0","25","<p>I'm trying to use React Virtualized Select <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> for drop down and my react component code is here We are not able to select the option from drop down</p>

<p>this is before selecting the option 
<a href=""https://i.stack.imgur.com/KvPqD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KvPqD.png"" alt=""enter image description here""></a></p>

<p>this is after selecting the option 
<a href=""https://i.stack.imgur.com/ZIMG8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZIMG8.png"" alt=""enter image description here""></a></p>

<p>please find my react component code below</p>

<pre><code>var React = require('react');
var ReactDOM = require('react-dom');
var SearchActions = require('../actions/SearchActions');
var AppStore = require('../stores/AppStore');
var AppActions = require('../actions/AppActions');
var Utils = require('../utils/Utils');
var SearchAccountSelector = require('./SearchAccountSelector');
var queryString = require('query-string');
var SearchHint = require('./SearchHint');
var VirtualizedSelect = require('react-virtualized-select').default;
module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: [],
            selectedPartner: null

        };
    },

    componentDidMount () {
        let self = this;
        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
        var qS = queryString.parse(location.search);
        AppActions.getPartnersAllowed();
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

    },
    componentDidUpdate: function () {
        let self = this;
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

    [AppStore.events.onSecurityCheck] () {
        console.log('onSecurityCheck', arguments);
        this.setState(function (prev, cur) {
            var st = {
                authenticated: AppStore.authenticated
            };
            if (!AppStore.authenticated) {
                st.async = false;
            }
            return st;
        });
    },

    [AppStore.events.onAccountSearch] (data) {

        var accountsNum = data.errorMessage ? 0 : this.numberOfAccountsFound(data);
        var state = {
            async: false,
            data: data.errorMessage ? {} : data,
            showAccountSelection: false,
            selected: null,
            error: null
        };
        console.log('[' + accountsNum + '] accounts found when search completed', data);

        if (accountsNum == 0) {
            state.error = data.errorMessage ? data.errorMessage : 'No accounts found';

        } else if (accountsNum == 1) {
            // if there is single account found selecting it and closing search panel
            state.selected = this.getFirstKey(data);
            state.visible = false;
            AppActions.selectAccount(state.selected);// auto select account if there is no ambiguites
            SearchActions.cDVR({query: state.selected});
        } else {
            // if multiple account found lets user select a correct one
            state.showAccountSelection = true;

        }

        this.setState(state);
    },

    [AppStore.events.onSelectAccount]() {
        if (AppStore.isValidUserProfile()) {
            this.setState({
                visible: false
            });
        }
    },

    [AppStore.events.onLogin]() {
        //Handling properly case when session is timed out so user will return to previos screen
        if (!this.state.selected) {
            this.setState({
                visible: true
            });
        }
    },

    [AppStore.events.onLogout](event) {
        if(!event || !event.byTimeout){
            this.setState({   data: null,
                showAccountSelection: false,
                selected: null,
                search: ''
            });
        }
    },
    [AppStore.events.onResized](windowSize){
        this.setState({width: windowSize.innerWidth, height: innerHeight})
    },


    numberOfAccountsFound(data) {
        var size = 0, key;
        if (!data) {
            return size;
        }
        for (key in data) {
            if (data.hasOwnProperty(key)) size++;
        }
        return size;
    },

    getFirstKey(data){
        for (let key in data) {
            if (data.hasOwnProperty(key)) return key;
        }
    },

    handleClick(event) {
        event.preventDefault();
        this.refs.searchHint.removePopover();
        console.log('clicked event', event);
        this.setState({
                data: null,
                async: true,
                error: null
            }
        );
        var query = this.refs.inputSearch.value.trim();
        this.setState({search: query});
        if (query &amp;&amp; this.state.selectedPartner) {
            //extract receiver Id from Recording Id, by extracting string between V&amp;L or A&amp;L
            let selectedPartner = this.state.selectedPartner;
            AppActions.resetFieldsForNewSearch();
            var receiverIdPattern = new RegExp('(V|A)(.*?)L');
            var parsedReceiverId = receiverIdPattern.exec(query);
            if (parsedReceiverId != null &amp;&amp; parsedReceiverId[2] != null) {
                let receiverId = parsedReceiverId[2];
                AppActions.setSearchQuery(query);
                //use receiverId to perform search
                query = receiverId;
            } else {
                AppActions.clearRecIdSearch();
            }
            SearchActions.cDVR({query: query});
            AppStore.selectedPartner = selectedPartner.value;
            SearchActions.search({query: query, selectedPartner: selectedPartner.value});
            Utils.updateQueryString('search', query);
        } else {
            this.setState({async: false, error: 'Invalid Input'});
        }
    },

    openNav(){
        this.setState({visible: true});
        AppActions.hideBodyScrollBar();
    },
    closeNav(){
        this.refs.searchHint.refs.popover.close();
        this.setState({visible: false});
        AppActions.showBodyScrollBar();
    },

    searchIcon(){
        if (this.state.authenticated) {
            return (&lt;span id=""search"" onClick={this.openNav}&gt;&lt;i className=""fa fa-search search-icon pointer"" style={{fontSize: '1.4em'}}/&gt;&lt;/span&gt;);
        }
    },

    setPartnerList(partnerList) {
        let partnerOptionsList = this.getOptions(partnerList);
        this.setState({optionPartnerList : partnerOptionsList})

    },

    getOptions(partnerList) {
        let options = partnerList.map( x =&gt; ({value :x,label: x}));
        return options;
    },

    errorRender() {
        let style = this.state.error ? {visibility: 'visible'} : {visibility: 'hidden'};
        return (
            &lt;div style={style} className=""alert alert-danger"" role=""alert""&gt;
                &lt;i className=""fa fa-exclamation-triangle""&gt;&lt;/i&gt; {this.state.error}
            &lt;/div&gt;);
    },

    toggleOverlayStyle(state){
        this.setState({overlayOverflowY : state});
    },
    [AppStore.events.onResized](windowSize) {
        let state = AppStore.innerHeight &lt; 900 &amp;&amp; this.refs.searchHint &amp;&amp; this.refs.searchHint.state.showSearchHint ? 'auto' : 'hidden';
        this.toggleOverlayStyle(state);
    },
    [AppStore.events.onPartnersAllowedUpdated](partnerList) {
        this.setPartnerList(partnerList);
    },

    render: function () {
        var self= this;


        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (
            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                        &lt;VirtualizedSelect
                            placeholder=""Select Partner""
                            options={self.state.optionPartnerList}
                            onChange={(selectValue) =&gt; this.setState({selectedPartner: selectValue})}
                            value={this.state.selectedPartner}
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
});
</code></pre>

<p>Except for the highlighted part i don't know what the issue is whether css or js 
<a href=""https://i.stack.imgur.com/CtSor.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CtSor.png"" alt=""enter image description here""></a></p>
","2359997","","2359997","","2017-11-10 14:26:41","2017-11-10 14:26:41","react-virtualized: Drop down is unresponsive suddenly with no error code in the console","<javascript><css><reactjs><react-native><react-redux>","0","0","","",""
"39050775","1","","","2016-08-20 05:27:41","","2","1893","<p>I'm trying to create a small react component, however, I am unable to set the state. Below is my code. In the <code>_onChange</code> function, I am trying to set an array of length 10 to State and <code>console.log</code> the same. I am getting an empty array in the console.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var Home = React.createClass({

    getInitialState: function () {
        return ({
            reviewData: []
        });
    },

    componentWillMount: function() {
        ReviewStore.addChangeListener(this._onChange);
        ReviewAction.getRatings();
        console.log(this.state.reviewData);
    },

    _onChange: function() {
        var res = ReviewStore.getRating();
        console.log(res); //Here I am getting array of length 10
        this.setState({reviewData: ReviewStore.getRating()});
        console.log(this.state.reviewData); //Here I am getting array of length 0
    },

    componentWillUnmount: function () {
        ReviewStore.removeChangeListener(this._onChange);
    },

    ratingChanged : function(newRating) {
        console.log(newRating)
    },

    render: function() {
        return(
            &lt;div&gt;
                &lt;h2&gt;Rating of Arlo Smart Home 1 HD Camera&lt;/h2&gt;
                &lt;hr/&gt;
                &lt;h4&gt;Average Rating: &lt;/h4&gt;&lt;ReactStars half={false} onChange={this.ratingChanged} size={24}/&gt;
            &lt;/div&gt;
        )
    }
});</code></pre>
</div>
</div>
</p>
","5853291","","4165377","","2017-10-05 22:15:20","2017-10-05 22:15:20","setState in react is not working in react component","<reactjs><state><setstate>","1","0","3","",""
"39034875","1","","","2016-08-19 08:52:33","","1","740","<p>I have a component like:</p>

<pre><code>import React, { PropTypes, Component } from 'react'


class MyView extends Component {

    render() {

        return (
            &lt;div&gt;
                Something
            &lt;/div&gt;
        )
    }
    componentWillUnmount() {
        console.log(""Hellooww world"")
        actions.store_state() 
    }

}

export default MyView
</code></pre>

<p>Here when I refresh the page I want to call <code>actions.store_state()</code> funciton.</p>

<p>But when I refresh the page <code>componentWillUnmount()</code> is not called. How can I call any function or store the state to localStorage when page is refreshed.</p>
","4192691","","","","","2016-08-19 10:07:23","Reactjs redux store state on page refresh. componentWillUnmount not working","<javascript><reactjs><redux>","1","3","2","",""
"39398993","1","39399439","","2016-09-08 19:41:49","","2","1097","<p>After the component is unmounted, I get errors when I resize the window. I know <code>window.removeEventListener</code> is being called, but it is acting as if it never gets called. The error says:</p>

<blockquote>
  <p>warning.js:36 Warning: setState(...): Can only update a mounted or
  mounting component. This usually means you called setState() on an
  unmounted component. This is a no-op. Please check the code for the
  HeaderMain component.</p>
</blockquote>

<p>I even tried using a code example from the React docs, and it does the same thing my class was doing. From <a href=""https://facebook.github.io/react/tips/dom-event-listeners.html"" rel=""nofollow"">https://facebook.github.io/react/tips/dom-event-listeners.html</a>:</p>

<pre><code>import React from ""react"";

var HeaderMain = React.createClass({
  getInitialState: function() {
    return {windowWidth: window.innerWidth};
  },

  handleResize: function(e) {
    this.setState({windowWidth: window.innerWidth});
  },

  componentDidMount: function() {
    window.addEventListener('resize', this.handleResize);
  },

  componentWillUnmount: function() {
    window.removeEventListener('resize', this.handleResize);
  },

  render: function() {
    return &lt;div&gt;Current window width: {this.state.windowWidth}&lt;/div&gt;;
  }
});

module.exports = HeaderMain;
</code></pre>

<p>I've tried messing around with <code>bind()</code>, I've tried it in <code>ES6</code>, and tried different versions of <code>React.js</code>. I can't get rid of the error.</p>

<p>How do I make sure my event listener will get removed?</p>
","1253298","","","user6613600","2016-09-08 19:56:38","2017-03-06 17:26:51","In React.js, using componentWillUnmount to remove an event listener, how can I make sure the event listener gets removed?","<javascript><reactjs>","2","2","2","",""
"39071690","1","","","2016-08-22 05:00:53","","3","1830","<p>I have a component like:</p>

<pre><code>import React, { PropTypes, Component } from 'react'


class MyView extends Component {

    componentDidMount() {
        window.addEventListener('onbeforeunload', this.saveState())
    }

    componentWillUnmount() {
        window.removeEventListener('beforeunload', this.saveState())
    }

    saveState() {
        alert(""exiting"")
    }

    render() {

        return (
            &lt;div&gt;
                Something
            &lt;/div&gt;
        )
    }

}

export default MyView
</code></pre>

<p>Here when a user refresh the page I want to call a specific funtion and when call is finished I want the page to be refreshed. Same when user closes the page.</p>

<p>In my above code I am adding an event listener <code>onbeforeunload</code> and calling a <code>saveState</code> function. </p>

<p>But here my <code>componentDidMount</code> is working normally. <code>onbeforeunload</code> and <code>saveState</code> function is called normally when page is loaded not when page is refreshed or exited.</p>

<p>What is wrong in here and how can I call specific funcitn or give alert when someone exits or refresh the page in react ?</p>

<p>In the above code</p>
","4192691","","","","","2016-08-22 07:11:56","reactjs call specific function when page refreshed or closed","<javascript><reactjs>","2","1","1","",""
"47485689","1","47485780","","2017-11-25 11:56:41","","0","307","<p>I am trying to make a react messaging app where the channel page is composed a channel bar <code>Channel.js</code> (Parent Component) with a general and random channel and a message-list <code>ChannelMessage.js</code> (Child Component).</p>

<p>Currently, I can click on the channel bar and it changes the url and <code>this.props.channelName</code>, but the child component displays the same text, regardless of <code>Link</code> clicked. I believe it is because <code>ComponentDidMount</code> does not get called in the child component. How would I go about updating/rerendering the child component to get ComponentDidMount to reload?</p>

<p>Channel.js</p>

<pre><code>export default class Channel extends React.Component {
constructor(props) {
    super(props);
    this.state = {
        channelName: 'general'
    };
    this.handleSignOut = this.handleSignOut.bind(this);
}

...

render() {
    return (
        &lt;div className=""container""&gt;
            &lt;div className=""row""&gt;
                &lt;div className=""channel-list col-lg-2""&gt;
                    &lt;h2&gt;Channels&lt;/h2&gt;
                    &lt;ul className=""list-group""&gt;
                        &lt;li&gt;&lt;Link to=""/channel/general""
                            onClick={() =&gt; this.setState({ channelName: 'general' })}&gt;General&lt;/Link&gt;&lt;/li&gt;
                        &lt;li&gt;&lt;Link to=""/channel/random""
                            onClick={() =&gt; this.setState({ channelName: 'random' })}&gt;Random&lt;/Link&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                    &lt;div className=""footer-segment""&gt;
                        ...
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;ChannelMessages channelName={this.state.channelName} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>ChannelMessages.js</p>

<pre><code>export default class ChannelMessages extends React.Component {
constructor(props) {
    super(props);
    this.state = {
        channelName: this.props.channelName,
        message: '',
        messages: [],
        textValue: ''
    }
    ...
}

componentWillReceiveProps(nextProps) {
    this.setState({channelName: nextProps.channelName})
}

componentDidMount() {
    this.messageRef = firebase.database().ref('messages/' + this.state.channelName);
    this.messageRef.limitToLast(500).on('value', (snapshot) =&gt; {
        let messages = snapshot.val();
        if (messages !== null) {
            let newMessages = [];
            for (let message in messages) {
                newMessages.push({
                    author: {
                        displayName: messages[message].author.displayName,
                        photoURL: messages[message].author.photoURL,
                        uid: messages[message].author.uid
                    },
                    body: messages[message].body,
                    createdAt: messages[message].createdAt,
                    id: message
                });
            }
            this.setState({ messages: newMessages, textValue: newMessages.body });
        }
        console.log(this.state.textValue)
    });
}

componentWillUnmount() {
    this.messageRef.off('value');
}

handleSubmitMessage(event) {
    event.preventDefault();
    let user = firebase.auth().currentUser;
    this.messageRef.push().set({
        author: {
            displayName: user.displayName,
            photoURL: user.photoURL,
            uid: user.uid
        },
        body: this.state.message,
        createdAt: firebase.database.ServerValue.TIMESTAMP
    });
    this.setState({ message: '' });
}

...

render() {
    return (...);
}
</code></pre>

<p>}</p>
","","user8896885","","","","2017-11-25 12:13:15","react child component not updating after parent state changed","<reactjs>","1","1","","",""
"47562821","1","47563198","","2017-11-29 22:21:52","","0","612","<p>I have a React/Redux application with two components. I need to clear a portion of redux state when the first component unmounts, because the second component will error with the state in that form. I've tried to dispatch an action clearing the chunk of state when the first component unmounts, but the second component begins mounting before the first components <code>componentWillUnmount</code> method is called. When I view dispatched actions in redux-logger, I see the second component dispatching actions from <code>componentWillMount</code> and then <code>componentWillUnmount</code> actions from the previous component called.</p>

<p>This is not the expected behavior is it? I am also using react-router v4. Thanks!</p>
","1939008","","","","","2017-11-30 02:08:14","Why is componentWillUnmount firing after next components componentWillMount?","<reactjs><redux><react-router-v4>","1","5","","",""
"39885009","1","39888356","","2016-10-05 23:05:15","","0","1012","<p>When I look at the following line in this <a href=""https://github.com/clauderic/react-sortable-hoc"" rel=""nofollow"">example</a>:</p>

<p><code>const SortableItem = SortableElement(({value}) =&gt; &lt;li&gt;{value}&lt;/li&gt;);</code></p>

<p>then I don't understand <strong>where is the lambda function</strong> <code>({value}) =&gt; &lt;li&gt;{value}&lt;/li&gt;</code> <strong>used</strong> in <a href=""https://github.com/clauderic/react-sortable-hoc/blob/master/src/SortableElement/index.js"" rel=""nofollow"">SortableElement</a> ?</p>

<p>Can someone please enlighten me ?</p>

<p>SortableElement's code:</p>

<pre><code>import React, {Component, PropTypes} from 'react';
import {findDOMNode} from 'react-dom';
import invariant from 'invariant';

// Export Higher Order Sortable Element Component
export default function SortableElement (WrappedComponent, config = {withRef: false}) {
    return class extends Component {
        static displayName = (WrappedComponent.displayName) ? `SortableElement(${WrappedComponent.displayName})` : 'SortableElement';
        static WrappedComponent = WrappedComponent;
        static contextTypes = {
            manager: PropTypes.object.isRequired
        };
        static propTypes = {
            index: PropTypes.number.isRequired,
            collection: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            disabled: PropTypes.bool
        };
        static defaultProps = {
            collection: 0
        };
        componentDidMount() {

            let {collection, disabled, index} = this.props;

            if (!disabled) {
                this.setDraggable(collection, index);
            }
        }
        componentWillReceiveProps(nextProps) {
            const {index} = this.props;
            if (index !== nextProps.index &amp;&amp; this.node) {
                this.node.sortableInfo.index = nextProps.index;
            }
            if (this.props.disabled !== nextProps.disabled)
            {
                let {collection, disabled, index} = nextProps;
                if (disabled) {
                    this.removeDraggable(collection);
                }
                else {
                    this.setDraggable(collection, index);
                }
            }
        }
        componentWillUnmount() {
            let {collection, disabled} = this.props;

            if (!disabled) this.removeDraggable(collection);
        }
        setDraggable(collection, index){
            let node = this.node = findDOMNode(this);

            node.sortableInfo = {index, collection};

            this.ref = {node};
            this.context.manager.add(collection, this.ref);
        }
        removeDraggable(collection) {
            this.context.manager.remove(collection, this.ref);
        }
        getWrappedInstance() {
            invariant(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call');
            return this.refs.wrappedInstance;
        }
        render() {
            const ref = (config.withRef) ? 'wrappedInstance' : null;
            return (
                &lt;WrappedComponent ref={ref} {...this.props} /&gt;
            );
        }
    }
}
</code></pre>
","1198559","","","","","2016-10-06 08:47:16","function argument in component's constructor in react.js","<reactjs>","3","0","","",""
"47324056","1","","","2017-11-16 07:38:13","","1","129","<p>I just have a question regarding react-navigation.</p>

<p>I understand that the navigation props becomes accessible when a screen is rendered from the stacknavigator. </p>

<p>But how do you access the navigation props if the screen is not rendered by the stacknavigator?</p>

<p>Like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import {
  StyleSheet,
  Text,
  View,
} from 'react-native';

import Swiper from 'react-native-swiper';

import Menu from './Menu';

class HomeSwiper extends Component {
    static propTypes = {
      navigation: PropTypes.object,
    };

render() {
  return (
    &lt;Swiper showsButtons&gt; 
      &lt;View&gt;
        &lt;Menu
          navigationProps={this.props.navigation}
        /&gt;
      &lt;/View&gt;
      &lt;View&gt;
        &lt;Text&gt;Hello Swiper&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/Swiper&gt;
  );
}
}


export default HomeSwiper;</code></pre>
</div>
</div>
</p>

<p>Wherein Menu is:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { AsyncStorage, TouchableOpacity, Text, BackHandler, Alert } from 'react-native';

import { StandardContainerIOS } from '../components/Container';
import { StandardButton } from '../components/Buttons/';

class Menu extends Component {
  static propTypes = {
    navigation: PropTypes.object,
  };


  static navigationOptions = ({ navigation }) =&gt; {
    const { params = {} } = navigation.state;
    const headerLeft = (
      &lt;TouchableOpacity
        onPress={params.handleRedirect ? params.handleRedirect : () =&gt; null}
      &gt;
        &lt;Text&gt;Logout&lt;/Text&gt;
      &lt;/TouchableOpacity&gt;
    );
    return {
      headerLeft,
    };
  };

  constructor(props) {
    super(props);
    this.state = {
      email: '',
      petName: [],
      numberOfPets: '',
    };
  }

  getInitialState() {
    return {
      petName: ['No Name'],
    };
  }

  async componentWillMount() {
    try {
      const value = await AsyncStorage.getItem('email');
      if (value !== null) {
        // We have data!!
      }
    } catch (error) {
      // Error retrieving data
    }
    this.props.navigation.setParams({
      handleRedirect: this.handlePressLogout,
    });
    this.getEmail();
    BackHandler.addEventListener('hardwareBackPress', this.handleBackButton);
  }

  componentWillUnmount() {
    BackHandler.removeEventListener('hardwareBackPress', this.handleBackButton);
  }

render() {
  return (
    &lt;StandardContainerIOS&gt;
      &lt;StandardButton backgroundColor=""#6D4C41"" title=""View Pet"" onPress={this.handleIndexView} /&gt;
      &lt;StandardButton backgroundColor=""#6D4C41"" title=""Register Pet"" onPress={this.handlePressRegisterPets} /&gt;
      &lt;StandardButton backgroundColor=""#6D4C41"" title=""Logout"" onPress={this.handlePressLogout} /&gt;
    &lt;/StandardContainerIOS&gt;
  );
}
}

export default Menu;</code></pre>
</div>
</div>
</p>

<p>I've removed the other function definition to cut the post a little shorter. The Menu screen was working fine when it was rendered from the stacknavigator. Im trying to incorporate swiping in my app.</p>

<p>Any suggestions?</p>
","3099549","","","","","2017-11-16 07:38:13","Accessing navigation props - react-navigation","<react-native><react-navigation>","0","2","","",""
"47201133","1","","","2017-11-09 11:50:35","","0","173","<p>I've followed the docs and did the necessary settings but the app crashes while launch. I'm not able to figure out the problem as to why this is occurring. any one who worked with rnfirebase? facing this issue?</p>

<pre><code>import React, { Component } from 'react';
import { View, Button, Text, TextInput, Image } from 'react-native';

import firebase from 'react-native-firebase';

const successImageUri = 'https://cdn.pixabay.com/photo/2015/06/09/16/12/icon-803718_1280.png';

export default class App extends Component {
  constructor(props) {
    super(props);
    this.unsubscribe = null;
    this.state = {
      user: null,
      message: '',
      codeInput: '',
      phoneNumber: '+44',
      confirmResult: null
    };
    firebase.initializeApp({
      apiKey: 'AIzaSyAvKPtsqqqGjkGLkXD8BeqOR6GwJaI2AcE',
      appId: '1:170852024080:ios:9bb19d2f74715186',
      messagingSenderId: '170852024080',
      projectId: 'chatapp-7c693',
      authDomain: 'chatapp-7c693.firebaseapp.com',
      databaseURL: 'https://chatapp-7c693.firebaseio.com',
      storageBucket: 'chatapp-7c693.appspot.com'
    });
  }

  componentDidMount() {
    this.unsubscribe = firebase.auth().onAuthStateChanged(user =&gt; {
      if (user) {
        this.setState({ user: user.toJSON() });
      } else {
        // User has been signed out, reset the state
        this.setState({
          user: null,
          message: '',
          codeInput: '',
          phoneNumber: '+44',
          confirmResult: null
        });
      }
    });
  }

//This is the example from the docs, so it must work

  componentWillUnmount() {
    if (this.unsubscribe) this.unsubscribe();
  }

  signIn = () =&gt; {
    const { phoneNumber } = this.state;
    this.setState({ message: 'Sending code ...' });

    firebase
      .auth()
      .signInWithPhoneNumber(phoneNumber)
      .then(confirmResult =&gt; this.setState({ confirmResult, message: 'Code has been sent!' }))
      .catch(error =&gt;
        this.setState({ message: `Sign In With Phone Number Error: ${error.message}` })
      );
  };

  confirmCode = () =&gt; {
    const { codeInput, confirmResult } = this.state;

    if (confirmResult &amp;&amp; codeInput.length) {
      confirmResult
        .confirm(codeInput)
        .then(user =&gt; {
          this.setState({ message: 'Code Confirmed!' });
        })
        .catch(error =&gt; this.setState({ message: `Code Confirm Error: ${error.message}` }));
    }
  };

  signOut = () =&gt; {
    firebase.auth().signOut();
  };

  renderPhoneNumberInput() {
    const { phoneNumber } = this.state;

    return (
      &lt;View style={{ padding: 25 }}&gt;
        &lt;Text&gt;Enter phone number:&lt;/Text&gt;
        &lt;TextInput
          autoFocus
          style={{ height: 40, marginTop: 15, marginBottom: 15 }}
          onChangeText={value =&gt; this.setState({ phoneNumber: value })}
          placeholder={'Phone number ... '}
          value={phoneNumber}
        /&gt;
        &lt;Button title=""Sign In"" color=""green"" onPress={this.signIn} /&gt;
      &lt;/View&gt;
    );
  }

  renderMessage() {
    const { message } = this.state;

    if (message.length) return null;

    return &lt;Text style={{ padding: 5, backgroundColor: '#000', color: '#fff' }}&gt;{message}&lt;/Text&gt;;
  }

  renderVerificationCodeInput() {
    const { codeInput } = this.state;

    return (
      &lt;View style={{ marginTop: 25, padding: 25 }}&gt;
        &lt;Text&gt;Enter verification code below:&lt;/Text&gt;
        &lt;TextInput
          autoFocus
          style={{ height: 40, marginTop: 15, marginBottom: 15 }}
          onChangeText={value =&gt; this.setState({ codeInput: value })}
          placeholder={'Code ... '}
          value={codeInput}
        /&gt;
        &lt;Button title=""Confirm Code"" color=""#841584"" onPress={this.confirmCode} /&gt;
      &lt;/View&gt;
    );
  }

  render() {
    const { user, confirmResult } = this.state;
    return (
      &lt;View style={{ flex: 1 }}&gt;
        {!user &amp;&amp; !confirmResult &amp;&amp; this.renderPhoneNumberInput()}

        {this.renderMessage()}

        {!user &amp;&amp; confirmResult &amp;&amp; this.renderVerificationCodeInput()}

        {user &amp;&amp; (
          &lt;View
            style={{
              padding: 15,
              justifyContent: 'center',
              alignItems: 'center',
              backgroundColor: '#77dd77',
              flex: 1
            }}
          &gt;
            &lt;Image
              source={{ uri: successImageUri }}
              style={{ width: 100, height: 100, marginBottom: 25 }}
            /&gt;
            &lt;Text style={{ fontSize: 25 }}&gt;Signed In!&lt;/Text&gt;
            &lt;Text&gt;{JSON.stringify(user)}&lt;/Text&gt;
            &lt;Button title=""Sign Out"" color=""red"" onPress={this.signOut} /&gt;
          &lt;/View&gt;
        )}
      &lt;/View&gt;
    );
  }
}
</code></pre>

<blockquote>
  <p>can someone help? ive checked the docs again ..but no help ?idk
  what more details I should add..this is my first question on stack
  over flow..didnt know it was this annoying to ask a question...
      I tried the web firebase sdk and can use the anonymous signin.. but I need phone auth which I'm not able to accomplish as it has different setups for ios and android ...rnfirebase is suppose to same as the web sdk</p>
</blockquote>
","8443936","","2745995","","2017-11-09 12:42:47","2017-11-14 16:39:25","App crashes in ios simulator when trying to use Phone auth in react-native firebase","<react-native><react-native-firebase>","1","3","","",""
"47598868","1","","","2017-12-01 17:50:44","","0","48","<p>I am trying out featherjs and nextjs. Right now somehow i can get initial data from server using nextjs SSR, and subscribing to my api using feathersjs.</p>

<p>I don't really now why it works and what really happen here. Maybe someone has better implementation about this ? Or did i using these library in a wrong way ?</p>

<p>The idea is for component to render the initial props that get rendered by server on first load, and then for next request use observable to fetch the state.</p>

<p>This my code for books page. It just showing list of books :</p>

<pre><code>import React from 'react';

import Main from '../layouts/Main';
import client from '../scripts/feathers-client';

const clientService = client.service('api/books');

export default class Books extends React.Component {
  constructor (props) {
    super(props);
    if (this.props &amp;&amp; this.props.books) {
      this.state = {books: this.props.books};
    } else {
      this.obs = clientService.watch().find().subscribe(books =&gt; {
        this.setState({books: books});
      });
    }
  }

  static async getInitialProps ({ req }) {
    if (req) {
      let service = req.app ? req.app.service('api/books') : {};
      return { books: await service.find() };
    } else {
      return { books: ''};
    }
  }

  componentWillUnmount () {
    if (this.obs) {
      this.obs.unsubscribe();
    }
  }

  render () {
    const renderBooks = this.state ?
      &lt;ol&gt;
        {this.state.books.data.map(book =&gt; (
          &lt;li key={book._id}&gt;{book.author}, {book.title}, liked: {book.liked}&lt;p&gt;{book.synopsis}&lt;/p&gt;&lt;/li&gt;
        ))}
      &lt;/ol&gt;
      :
      '';
    return (
      &lt;Main&gt;
        &lt;p&gt;List of books :&lt;/p&gt;
        {renderBooks}
      &lt;/Main&gt;
    );
  }
}
</code></pre>

<p>Any help would be appreciated.</p>
","6623388","","6623388","","2017-12-01 17:58:36","2017-12-01 17:58:36","Need better logic for data initiation using nextjs, featherjs, and feather-reactive","<javascript><observable><serverside-rendering><feathersjs><nextjs>","0","4","","",""
"46910655","1","","","2017-10-24 12:29:55","","0","210","<p>I have a react native TextInput with numeric keyboard, and it is working fine, except that the keyboard shows up again after the submit button has been clicked and it navigates to the next page (ShouldNotHaveKeyboardScreen). The next page has no text input and the keyboard should never show on that page. I want to make sure the keyboard doesn't show on the next screen, but I can't figure out how to do it. I attempted to dismiss the keyboard on submitting the textInput, but that doesn't work. I've also tried to dismiss it on the next screen as it loads, but that does't fully work either. The best I can do is to hide it after it pops up, but that is not ideal, I want it to be never shown.</p>

<p>I am using an android device (Android v.6.0.1) with react-native v0.48.3. </p>

<p>Here is the code, I've tried to remove any irrelevant parts.</p>

<pre><code>// The screen that should not have keyboard

import { Keyboard } from 'react-native';

class ShouldNotHaveKeyboardScreen extends Component {
  componentDidMount() {
    Keyboard.dismiss();  // &lt; that doesn't seem to work
    Keyboard.addListener('keyboardDidShow', this._keyboardDidShow);

  }
  componentWillUnmount() {
    Keyboard.removeListener('keyboardDidShow', this._keyboardDidShow);
  }

  _keyboardDidShow()  {
    console.warn(""keyboard did show"");
    Keyboard.dismiss();  //  &lt; this works, but the keyboard pops up first
  }

  // other stuff
}


// The screen with numeric text input
class TextInputScreen extends Component {
  componentDidMount() {
    Keyboard.addListener('keyboardDidHide', this._keyboardDidHide);
  }

  componentWillUnmount() {
    Keyboard.removeListener('keyboardDidHide', this._keyboardDidHide);
  }

  _keyboardDidHide() {
    console.warn(""keyboard did hide oh yeah"");
    Keyboard.dismiss();  // This doesn't help, the event happens but the next screen still shows keyboard
  }

  handleSendReadCommand(value) {
      // some stuff
      this.props.navigation.navigate('ShouldNotHaveKeyboardScreen');
    }
  }

  render() {
    return (
      &lt;ScrollView style={styles.mainContainer}&gt;
        &lt;View style={styles.contentContainer}&gt;
          &lt;View style={styles.Container}&gt;
            &lt;View&gt;
              &lt;Text style={styles.Title}&gt;Text here&lt;/Text&gt;
              &lt;ColoredTextInput inFocus={true}
                                value={this.props.setting_id}
                                returnKey={""search""}
                                onChangeText={(text) =&gt; { someAction(text)}}
                                onSubmitEditing={(event) =&gt; { 
                                  Keyboard.dismiss();  // This doesn't help
                                  this.handleSendReadCommand(event.nativeEvent.text)}}
              /&gt;  
            &lt;/View&gt;
          &lt;/View&gt;
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    );
  }
}

// numeric text input component
export default class ColoredTextInput extends Component {

  constructor(props) {
    super(props);
    this.state = {style: props.inFocus ? styles.text_input_in_focus : styles.text_input_not_focused};
    this.onFocus = () =&gt; this.setState({ style: styles.text_input_in_focus });
    this.onBlur = () =&gt; this.setState({ style: styles.text_input_not_focused });
  }

  static propTypes = {
    inFocus: PropTypes.bool.isRequired,
    onChangeText: PropTypes.func,
    onSubmitEditing: PropTypes.func,
    returnKey: PropTypes.string,
  };

  render() {
    let return_key = 'done';
    if (this.props.returnKey) {
      return_key = this.props.returnKey;
    }
    return (
      &lt;TextInput
        style={[styles.text_input, this.state.style]}
        autoFocus={this.props.inFocus}
        returnKeyType={return_key}
        keyboardType=""numeric""
        underlineColorAndroid=""transparent""
        onBlur={() =&gt; this.onBlur()}
        onFocus={() =&gt; this.onFocus()}
        value={this.props.value}
        onChangeText={ this.props.onChangeText }
        onSubmitEditing={ this.props.onSubmitEditing }
      /&gt;
    );
  }
}
</code></pre>

<p>How can I hide the keyboard?</p>
","4892779","","","","","2017-10-24 12:29:55","How to prevent numeric keyboard showing on Android after navigating - react native TextInput","<android><react-native>","0","7","","",""
"39094138","1","39094299","","2016-08-23 06:47:42","","18","11984","<p>I have a react component like :</p>

<pre><code>import React, { PropTypes, Component } from 'react'


class MyComponent extends Component {

    componentDidMount() {
       window.addEventListener(""beforeunload"", function (event) {
            console.log(""hellooww"")
            event.returnValue = ""Hellooww""
        })
    }

    componentWillUnmount() {
        window.removeEventListener(""beforeunload"", function (event) {
            console.log(""hellooww"")
            event.returnValue = ""Hellooww""
        })
    }

    render() {

        return (
            &lt;div&gt;
                Some content
            &lt;/div&gt;
        )
    }

}

export default MyComponent
</code></pre>

<p>Here event lister is added to the component. When I refresh the page it gives me pop up asking to leave the page. </p>

<p>But when I go to another page and do refresh it again shows the same pop up.</p>

<p>I am removing the <code>eventListener</code> from the component on <code>componentWillUnmount</code> . Then why it is not being removed</p>

<p>How can I remove the <code>beoreunload</code> event on other pages ?</p>
","3858177","","","","","2018-01-10 16:42:52","reactjs event listener beforeunload added but not removed","<javascript><reactjs><addeventlistener><event-listener>","2","0","7","",""
"39249816","1","","","2016-08-31 12:33:58","","0","82","<p>I have an issue with ReactJS. Specifically componentWillUnmount is not being called across the project at all (a semi-large corporate website). I will list the steps I have taken to diagnose and pinpoint the issue:</p>

<ul>
<li>I am using a simple console.log message to test, to exclude problems inside the function</li>
<li>I have placed it in different jsx files in the project, to exclude function positioning problems</li>
<li>I have checked against switching pages in the app and loading a different website altogether</li>
<li>I checked to see whether the function is called from parents, siblings or children, since I've found competing lifecycle calls can cause neither to work, but it's the only one in the project so far</li>
<li>I tried it on a different branch with no effect</li>
<li>I tried it on a colleague's computer with no effect</li>
<li>A different lifecycle function (componentWillMount) works fine</li>
</ul>

<p>I am using ES6 with react 15.1.0, react-bootstrap and react-validation. The relevant code is below, but keep in mind I have placed the function in numerous places and it does not appear to get called anywhere.</p>

<pre><code>export default class YourData extends React.Component {

constructor(props){
    super(props);
    this.getMainBookers = this.getMainBookers.bind(this);

    this.bookingTravelCompanyForms = this.props.your_data.bookings.map(
        (booking, i) =&gt; {
            var mainBookers = i &gt; 0 ? this.getMainBookers : false;
            return (
                &lt;BookingTravelCompanyForm booking={booking} key={i}
                                          mainBookers={mainBookers}
                                          onInputChange={this.props.onInputChange}/&gt;
            );
        }
    );
}
componentWillMount(){
    this.props.initializeInput();
}
componentWillUnmount(){
    console.log('willunmount yourdata');
    this.props.saveInput();
}
getMainBookers() {
    var mainform = this.bookingTravelCompanyForms[0];
    return mainform.props.booking.company;
}

handleSubmit(event) {
    event.preventDefault();

    // Emulate async API call
    setTimeout(() =&gt; {
        this.refs.form.showError('username', &lt;span onClick={this.removeApiError.bind(this)}
                                                   className='form-error is-visible'&gt;API Error. Click to hide out.&lt;/span&gt;);
    }, 1000);
}

copyTravelCompany() {
    var travelCompany = this.bookingTravelCompanyForms[0];
    this.setState({
        travelCompany: travelCompany
    });
}


render() {
</code></pre>
","5986162","","5986162","","2016-09-02 09:43:18","2016-09-02 09:43:18","ReactJS: componentWillUnmount not working across project","<reactjs>","0","2","1","",""
"39504104","1","","","2016-09-15 06:07:51","","0","418","<p>react-native-router-flux v3.30.0
react-native v0.31.0</p>

<pre><code>constructor(props){
  super(props);
  this.handleBackAndroid = this.handleBackAndroid.bind(this);
  }

  componentWillUnmount() {
    BackAndroid.removeEventListener('hardwareBackPress',this.handleBackAndroid);
  }

  componentDidMount() {
    BackAndroid.addEventListener('hardwareBackPress',this.handleBackAndroid);
  }

  handleBackAndroid() {
    try {
      Actions.mainPage();
      return true;
    } catch (err) {
      if (onExitApp) {
        return onExitApp();
      }
    return false;
  }}
</code></pre>

<p>when i press BackAndroidButton then it's call handleBackAndroid function and app exit.</p>
","5513898","","","","","2016-12-30 14:42:30","BackAndroid not working with react-native-router-flux","<android><react-native><react-native-router-flux>","1","1","0","",""
"30561352","1","30561809","","2015-05-31 18:52:46","","0","209","<p>I try to get used to reflux and forked a example repo. My full code is here [ <a href=""https://github.com/svenhornberg/react-starterkit"" rel=""nofollow"">https://github.com/svenhornberg/react-starterkit</a> ]</p>

<p>I want to create a timer component which gets the current time from a timestore, but it is not working. The DevTools does not show any errors. This must be some newbie mistakes, but I do not find them. </p>

<p><strong>Edit1</strong>: I added a line in home //edit1</p>

<p><strong>Edit2</strong>: I think the mistake may be in componentDidMount in home.jsx</p>

<p><strong>FIXED</strong> I need to trigger my time, see my answer.</p>

<p><strong>Store</strong></p>

<pre><code>import Reflux from 'reflux';
import TimeActions from '../actions/timeActions';

var TimeStore = Reflux.createStore({
    listenables: timeActions,

    init() {
        this.time = '';
    },

    onCurrenttime() {
        this.time = '13:47';
    }
});
</code></pre>

<p>export default TimeStore;</p>

<p><strong>Actions</strong></p>

<pre><code>import Reflux from 'reflux';

var TimeActions = Reflux.createActions([
  'currenttime'
]);

export default TimeActions;
</code></pre>

<p><strong>Component</strong></p>

<pre><code>import React from 'react';

class Timer extends React.Component {

  constructor(){
    super();    
  }

  render() {
    var time = this.props.time;

    return (
      &lt;div&gt;
        { time }
      &lt;/div&gt;
    );
  }

}

Timer.propTypes = {
  time : React.PropTypes.string
}

export default Timer;
</code></pre>

<p>I wanted to use the timer component in the <strong>home.jsx</strong></p>

<pre><code>import React from 'react';
import ItemList from '../components/itemList.jsx';
import ItemStore from '../stores/itemStore';
import ItemActions from '../actions/itemActions';

import Timer from '../components/timer.jsx';
import TimeStore from '../stores/timeStore';
import TimeActions from '../actions/timeActions';

class Home extends React.Component {

  constructor(props){
    super(props);
    this.state = {
      items : [],
      loading: false,
      time : '' //edit1
    };
  }

  componentDidMount() {
    this.unsubscribe = ItemStore.listen(this.onStatusChange.bind(this));
    this.unsubscribe = TimeStore.listen(this.onStatusChange.bind(this));

    ItemActions.loadItems();
    TimeActions.currenttime();
  }

  componentWillUnmount() {
    this.unsubscribe();
  }

  onStatusChange(state) {
    this.setState(state);
  }

  render() {

    return (
      &lt;div&gt;
        &lt;h1&gt;Home Area&lt;/h1&gt;
        &lt;ItemList { ...this.state } /&gt;
        &lt;Timer { ...this.state } /&gt;
      &lt;/div&gt;
    );
  }
}

export default Home;
</code></pre>
","1584115","","1584115","","2015-05-31 19:35:10","2015-05-31 19:35:10","own timer component with react, reflux not working","<javascript><reactjs><refluxjs>","1","0","","",""
"47343088","1","","","2017-11-17 04:02:10","","1","324","<h1>Project</h1>

<p>I am developing draw navigation with reactive navigation. (using redux)</p>

<p>Stack and tap nested navigation work fine</p>

<h1>Error</h1>

<p>If I add nested drawer navigation, the reducer throws an error.</p>

<p>The error screen is shown below.</p>

<p><a href=""https://i.stack.imgur.com/A53Lm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/A53Lm.png"" alt=""enter image description here""></a></p>

<h1>This is my full code</h1>

<p><a href=""https://bitbucket.org/byunghyunpark/luxlab-user-2/commits/all"" rel=""nofollow noreferrer"">https://bitbucket.org/byunghyunpark/luxlab-user-2/commits/all</a></p>

<h1>Error related code</h1>

<h2>src/navigation/index.js</h2>

<pre><code>import React, { Component } from ""react"";
import { BackHandler } from ""react-native"";
import { connect } from ""react-redux"";
import { StackNavigator, DrawerNavigator, addNavigationHelpers, NavigationActions } from ""react-navigation"";

import NavigationStack from ""./navigationStack"";


class AppNavigation extends Component {
    componentDidMount() {
        BackHandler.addEventListener(""hardwareBackPress"", this.onBackPress);
    }

    componentWillUnmount() {
        BackHandler.removeEventListener(""hardwareBackPress"", this.onBackPress);
    }

    onBackPress = () =&gt; {
        const { dispatch, navigationState } = this.props;
        if (navigationState.stateForLoggedIn.index &lt;= 1) {
            BackHandler.exitApp();
            return;
        }
        dispatch(NavigationActions.back());
        return true;
    };

    render() {
        const { navigationState, dispatch, isLoggedIn } = this.props;
        const state = isLoggedIn
            ? navigationState.stateForLoggedIn
            : navigationState.stateForLoggedOut;
        return (
            &lt;NavigationStack navigation={addNavigationHelpers({ dispatch, state })}/&gt;
        );
    }
}

const mapStateToProps = state =&gt; {
    return {
        isLoggedIn: state.loginReducer.isLoggedIn,
        navigationState: state.navigationReducer
    };
};

export default connect(mapStateToProps)(AppNavigation);
</code></pre>

<h2>src/navigation/navigationStack.js</h2>

<pre><code>import { Platform, StyleSheet, Text, View, AsyncStorage, ScrollView } from 'react-native';
import { StackNavigator, TabNavigator, DrawerNavigator, DrawerItems } from 'react-navigation';

import MyRepairWait from '../components/repair/myRepairWait';
import MyRepairProgress from '../components/repair/myRepairProgress';
import MyRepairComplete from '../components/repair/myRepairComplete';
import MySalesWait from '../components/sales/mySalesWait';
import MySalesComplete from '../components/sales/mySalesComplete';
import Home from '../components/home';
import ProductList from '../components/buy/productList';
import PartnerList from '../components/map/partnerList';
import Login from '../components/member/login';


const MyRepairListTab = TabNavigator({
    wait: { screen: MyRepairWait, navigationOptions: { tabBarLabel: '문의중' } },
    progress: { screen: MyRepairProgress, navigationOptions: { tabBarLabel: '진행중' } },
    complete: { screen: MyRepairComplete, navigationOptions: { tabBarLabel: '완료' } }
    },
    {
        tabBarPosition: 'top',
        swipeEnabled: true,
        animationEnabled: false,
        tabBarOptions: {
            activeTintColor: '#e91e63',
        },
        backBehavior: 'none',
    }
)

const MySalesListTab = TabNavigator({
    wait: { screen: MySalesWait, navigationOptions: { tabBarLabel: '문의중' } },
    complete: { screen: MySalesComplete, navigationOptions: { tabBarLabel: '완료' } }
    },
    {
        tabBarPosition: 'top',
        swipeEnabled: true,
        animationEnabled: false,
        tabBarOptions: {
            activeTintColor: '#e91e63',
        },
        backBehavior: 'none',
    }
)


const baseRoutes = {
    home: { screen: Home },
    productList: { screen: ProductList },
    myRepairList: { screen: MyRepairListTab },
    mySalesList: { screen: MySalesListTab },
    partnerList: { screen: PartnerList },
    login: { screen: Login },
};


const DrawerRoutes = {
    Home: {
        name: 'Home',
        screen: StackNavigator(baseRoutes, { initialRouteName: 'home' })
        },
    ProductList: {
        name: 'ProductList',
            screen: StackNavigator(baseRoutes, { initialRouteName: 'productList' })
            },
    MyRepairList: {
        name: 'MyRepairList',
            screen: StackNavigator(baseRoutes, { initialRouteName: 'myRepairList' })
            },
    MySalesList: {
            name: 'MySalesList',
            screen: StackNavigator(baseRoutes, { initialRouteName: 'mySalesList' })
            },
};


const DrawerNavigatorConfig = {
    drawerWidth: 300,
    drawerPosition: 'right',
    contentComponent: props =&gt; &lt;ScrollView&gt;&lt;DrawerItems {...props} /&gt;&lt;/ScrollView&gt;,
    contentOptions: {
        activeTintColor: '#e91e63',
        itemsContainerStyle: {
            marginVertical: 0,
        },
        iconContainerStyle: {
            opacity: 1
        }
    }
}

const navigator =
    StackNavigator(
        {
            Drawer: {
                name: 'Drawer',
                screen: DrawerNavigator(
                    DrawerRoutes,
                    DrawerNavigatorConfig
                ),
            },
            ...navigator
        },
        {
            headerMode: 'none'
        }
    );


export default navigator;
</code></pre>

<h2>src/reducers/index.js</h2>

<pre><code>import { combineReducers } from 'redux';
import navigationReducer from './navigationReducer';
import loginReducer from './loginReducer';


const AppReducer = combineReducers({
    navigationReducer,
    loginReducer
});

export default AppReducer;
</code></pre>

<h2>src/reducers/navigationReducer.js</h2>

<pre><code>import { NavigationActions } from ""react-navigation"";

import AppNavigator from ""../navigation/navigationStack"";
import { Login, Logout } from ""../actions/actionTypes"";


const ActionForLoggedOut = AppNavigator.router.getActionForPathAndParams(
    ""login""
);

const ActionForLoggedIn = AppNavigator.router.getActionForPathAndParams(
    ""home""
);

const stateForLoggedOut = AppNavigator.router.getStateForAction(
    ActionForLoggedOut
);

const stateForLoggedIn = AppNavigator.router.getStateForAction(
    ActionForLoggedIn
);

const initialState = { stateForLoggedOut, stateForLoggedIn };



const navigationReducer = (state = initialState, action) =&gt; {
    switch (action.type) {
        case ""@@redux/INIT"":
            return {
                ...state,
                stateForLoggedIn: AppNavigator.router.getStateForAction(
                    ActionForLoggedIn,
                    stateForLoggedOut
                )
            };
    case Login:
        return {
            ...state,
            stateForLoggedIn: AppNavigator.router.getStateForAction(
                ActionForLoggedIn,
                stateForLoggedOut
            )
        };

    case Logout:
        return {
            ...state,
            stateForLoggedOut: AppNavigator.router.getStateForAction(
                NavigationActions.reset({
                    index: 0,
                    actions: [NavigationActions.navigate({ routeName: ""login"" })]
                })
            )
        };

    default:
        return {
            ...state,
            stateForLoggedIn: AppNavigator.router.getStateForAction(
                action,
                state.stateForLoggedIn
            )
        };
    }
};

export default navigationReducer;
</code></pre>

<h1>src/components/home.js</h1>

<pre><code>import React, { Component } from 'react';
import { Platform, StyleSheet, Text, View, Button, ImageBackground, TouchableHighlight, Image, ScrollView, Alert, CameraRoll, AsyncStorage } from 'react-native';
import { NavigationActions } from ""react-navigation"";
import Icon from 'react-native-vector-icons/FontAwesome';
import { connect } from 'react-redux';


const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    mainPhoto: {
        flex: 1,
        margin: 10,
        marginBottom: 0,
        justifyContent: 'center',
    },
    mainPhotoEnd: {
        marginBottom: 10
    },
    mainOpacity: {
        flex: 1,
        backgroundColor: 'rgba(0,0,0,0.5)',
    },
    mainTitle: {
        color: 'white',
        fontSize: 30,
        marginTop: 20,
        marginLeft: 20,
        marginRight: 20,
        fontWeight: '700',
    },
    mainDescription: {
        flex: 2.3,
        marginTop: 5,
        marginLeft: 20,
        marginRight: 20,
        color: 'white',
        fontSize: 15,
        fontWeight: '400',
    },
    alignRight: {
        textAlign: 'right'
    },
    backgroundWhite: {
        flex: 1,
        backgroundColor: 'white'
    },
    headerRight: {
        padding: 10
    },
    headerLeft: {
        padding: 20
    }
});


class HomeScreen extends React.Component {
    navigate1 = () =&gt; {
        console.log('click navigate1');
        const navigate1 = NavigationActions.navigate({
            routeName: ""partnerList"",
            params: { name: ""Shubhnik"" }
        });
        this.props.navigation.dispatch(navigate1);
    };

    navigate2 = () =&gt; {
        console.log('click navigate2');
        const navigate2 = NavigationActions.navigate({
            routeName: ""myRepairList"",
            params: { name: ""Shubhnik"" }
        });
        this.props.navigation.dispatch(navigate2);
    };

    static navigationOptions = ({navigation}) =&gt; ({
        drawerLabel: () =&gt; null,
        title: 'LUXLAB',

        headerStyle: {
            backgroundColor: '#fff',
            borderBottomWidth: 0,
            elevation: 0,
        },
        headerTitleStyle: {
            color: '#000',
            fontSize: 20,
            textAlign: 'center',
            alignSelf: 'center',
        },
        headerRight: &lt;Icon name=""bars"" size={30} color=""#333"" onPress={() =&gt; navigation.navigate('DrawerOpen')} style={styles.headerRight}/&gt;,
        headerLeft: &lt;Icon name=""map-marker"" size={30} color=""#333"" onPress={() =&gt; navigation.navigate('partnerList')} style={styles.headerLeft} /&gt;
    })

    async componentDidMount() {
        let user_info = await AsyncStorage.getItem('user_info');
        user_info = JSON.parse(user_info).key;
        console.log('storage1', user_info.key);
        console.log('isloggedIn', this.props.isLoggedIn);
    }

    render() {
        return (
            &lt;View style={styles.backgroundWhite}&gt;
                &lt;TouchableHighlight
                    style={styles.container}
                    underlayColor=""#fff""
                    onPress={this.navigate1}&gt;
                    &lt;ImageBackground
                        source={require('../assets/imgs/main1.jpg')}
                        style={[styles.mainPhoto, styles.mainOpacity]}&gt;
                        &lt;View style={styles.mainOpacity}&gt;
                            &lt;Text style={styles.mainTitle}&gt;중고 명품 구매&lt;/Text&gt;
                            &lt;Text style={styles.mainDescription}&gt;검증받은 다양한 명품들을{""\n""}간편하게 볼 수 있습니다&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/ImageBackground&gt;
                &lt;/TouchableHighlight&gt;
                &lt;TouchableHighlight
                    style={styles.container}
                    underlayColor=""#fff""
                    onPress={this.navigate2}&gt;
                    &lt;ImageBackground
                        source={require('../assets/imgs/main2.jpg')}
                        style={styles.mainPhoto}&gt;
                        &lt;View style={styles.mainOpacity}&gt;
                            &lt;Text style={[styles.mainTitle, styles.alignRight]}&gt;수선 견적 문의&lt;/Text&gt;
                            &lt;Text style={[styles.mainDescription, styles.alignRight]}&gt;몇 가지 정보 입력으로{""\n""}수선 견적을 받아보세요&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/ImageBackground&gt;
                &lt;/TouchableHighlight&gt;
                &lt;TouchableHighlight
                    style={styles.container}
                    underlayColor=""#fff""
                    onPress={this.navigate1}&gt;
                    &lt;ImageBackground
                        source={require('../assets/imgs/main3.jpg')}
                        style={[styles.mainPhoto, styles.mainPhotoEnd]}&gt;
                        &lt;View style={styles.mainOpacity}&gt;
                            &lt;Text style={styles.mainTitle}&gt;중고 명품 판매&lt;/Text&gt;
                            &lt;Text style={styles.mainDescription}&gt;몇 가지 정보 입력으로{""\n""}매매 견적을 받아보세요&lt;/Text&gt;
                        &lt;/View&gt;
                    &lt;/ImageBackground&gt;
                &lt;/TouchableHighlight&gt;
            &lt;/View&gt;
        )
    }
}


const mapStateToProps = state =&gt; ({
    isLoggedIn: state.loginReducer.isLoggedIn
});

const Home = connect(mapStateToProps, null)(HomeScreen);

export default Home;
</code></pre>

<p>Thanks!</p>
","7824862","","","","","2017-11-17 04:02:10","react-navigation Cannot read property 'type' of null error in reducer","<react-native><redux><navigation-drawer><react-navigation>","0","2","","",""
"47649508","1","47651921","","2017-12-05 08:53:23","","0","132","<p>I'm using react native v0.51.
I get this error when I navigate to the component again in the second page.</p>

<pre><code>can only update a mounted or mounting component. 
</code></pre>

<p>I found where it happen but I don't understand why.</p>

<pre><code>    /*
 * Default Android example
 */

'use strict';

import React, { Component } from 'react';

import {
  AppRegistry,
  StyleSheet,
  Text,
  Navigator,
  TouchableOpacity,
  Linking,
  View,
  Image,
  Geolocation   
} from 'react-native';

// third party library
import QRCodeScanner from 'react-native-qrcode-scanner';
import I18n from '../../i18n'
import branch from 'react-native-branch'

// import styles
import { style } from './style';
const { centerText, textBold, buttonTouchable, camera, topViewStyleQR, QRcontainer, customMarkerStyle, imageScanStyle, textScanStyle, sloganScan, viewSlogan, buttonText } = style;

class QrScan extends Component {
  constructor(props) {
    super(props);
    this.state = {
      barcodeText: '',
      scan: {
        glassHash: '',
        latitude: 0,
        longitude: 0,
        isReedeemScan: true,
      },
    }
  }
  componentDidMount() {
    this._unsubscribeFromBranch = branch.subscribe(({ error, params }) =&gt; {
      if (error) {
        console.error(""Error from Branch: "" + error)
        return
      }

      console.log(""Branch params: "" + JSON.stringify(params))
      if (params) {


      }
      // if (!params['+clicked_branch_link']) return

      // // Get title and url for route
      // let title = params.$og_title
      // let url = params.$canonical_url
      // let image = params.$og_image_url

      // // Now push the view for this URL
      // this.navigator.push({ title: title, url: url, image: image })
    })
  }

  componentWillUnmount() {
    if (this._unsubscribeFromBranch) {
      this._unsubscribeFromBranch()
      this._unsubscribeFromBranch = null
    }
  }

  _getCurrentPosition(){
    navigator.geolocation.getCurrentPosition(
      (position) =&gt; {
         const initialPosition = JSON.stringify(position);
         console.log(initialPosition)
         //this.setState({ initialPosition });
      },
      (error) =&gt; alert(error.message),
      { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }
   );
   this.watchID = navigator.geolocation.watchPosition((position) =&gt; {
      const lastPosition = JSON.stringify(position);
     this.setState({scan:{...this.state.scan,latitude:position.latitude,longitude:position.longitude}})


   });
  }

  onSuccess(e) {
    this._getCurrentPosition();


    // Linking
    //   .openURL(e.data)
    //   .catch(err =&gt; console.error('An error occured', err));
    this.setState({ barcodeText: e.data });
    console.log(e);
  }
  _renderMaker() {
    return (
      &lt;View style={customMarkerStyle}&gt;
        &lt;Image
          style={imageScanStyle}
          source={require('../../assets/images/iconScanP.png')} /&gt;

        &lt;Text style={textScanStyle}&gt;{I18n.t('_scanDrink')}&lt;/Text&gt;
        &lt;View style={viewSlogan}&gt;
          &lt;Text style={sloganScan}&gt;SCANDIT&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    )
  }

  render() {
    return (
      &lt;QRCodeScanner
        onRead={this.onSuccess.bind(this)}
        showMarker={true}
        camType='front'
        topViewStyle={topViewStyleQR}
        containerStyle={QRcontainer}
        cameraStyle={camera}
        customMarker={this._renderMaker()}
        bottomContent={(
          &lt;TouchableOpacity style={buttonTouchable}&gt;
            &lt;Text style={buttonText}&gt;{this.state.barcodeText ? this.state.barcodeText : ''}&lt;/Text&gt;
          &lt;/TouchableOpacity&gt;
        )}
      /&gt;
    );
  }
}




export default QrScan;
</code></pre>

<p>when I comment this line into the function _getCurrentPosition it's not happening and it works without this issue.</p>

<pre><code>     // this.setState({scan:{...this.state.scan,latitude:position.latitude,longitude:position.longitude}})
</code></pre>

<p>is anything I do wrong with this line? I can't update the state into the scope of this function, if yes why?</p>
","6455516","","","","","2017-12-05 10:57:32","react native can only update a mounted or mounting component","<reactjs><react-native>","1","0","","",""
"30974746","1","30982091","","2015-06-22 08:00:00","","3","6111","<p>I have the following react component which will be used to toggle a menu:</p>

<pre><code>var MenuToggle = React.createClass({
    render: function() {
        return(
            &lt;a id=""menu-toggle"" href=""javascript:void(0);""&gt;
                &lt;i id=""closed"" className=""fa fa-bars""&gt;&lt;/i&gt;
                &lt;i id=""open"" className=""fa fa-times""&gt;&lt;/i&gt;
            &lt;/a&gt;
        )
    }
});
</code></pre>

<p>When this component is clicked, I need to toggle it's state so the 'hamburger' icon becomes an 'x' icon. I also need to add a prop to the component so that the parent menu's state can be updated by listening for 'MenuToggle' component to receive the prop. Since I need to do both based on the same click event, I have tried:</p>

<pre><code>var MenuToggle = React.createClass({
    getInitialState: function() {
        return {open: false}
    },
    handleClick: function() {
        var that = this;
        function setTheState() {
            that.setState({open: !that.state.open})
        }
        function setTheProps() {
            that.props.whenClicked
        }
        setTheState()
        setTheProps()
    },
    render: function() {
        return(
            &lt;a id=""menu-toggle"" href=""javascript:void(0);"" onClick={this.handleClick} className={(this.state.open ? 'open' : '')}&gt;
                &lt;i id=""closed"" className=""fa fa-bars""&gt;&lt;/i&gt;
                &lt;i id=""open"" className=""fa fa-times""&gt;&lt;/i&gt;
            &lt;/a&gt;
        )
    }
});
</code></pre>

<p>Basically, I am calling the single function 'handleClick' which should set / toggle the state of 'MenuToggle', and add the 'whenClicked' prop.</p>

<p>The result is that the state is toggled but 'whenClicked' is not set. whenClicked needs to be set because the parent component, 'Menu' listens for 'whenClicked' in 'menuToggle'. When 'Menu' hears 'whenClicked', it fires 'handleClick' which toggles it's own state:</p>

<pre><code>var Menu = React.createClass({

    getInitialState: function() {
        return {open: false, mobi: false}
    },
    handleClick: function() {
        this.setState({open: !this.state.open})
    },
    closeOnMobiScroll: function() {
        /*
        if(this.state.mobi === false) {
            this.setState({open: false})
        }
        */
    },
    updateDimensions: function() {
        $(window).width() &gt;= 767 ? this.setState({mobi: true}) : this.setState({mobi: false});
    },
    componentWillMount: function() {
        this.updateDimensions();
    },
    componentDidMount: function() {
        $(window).on(""resize"", this.updateDimensions);
    },
    componentWillUnmount: function() {
        $(window).on(""resize"", this.updateDimensions);
    },
    render: function() {
        return (
            &lt;div id=""menu-wrap""&gt;
                &lt;MenuToggle whenClicked={this.handleClick} /&gt;
                &lt;div id=""menu"" className={(this.state.open ? 'open' : '')} &gt;
                    &lt;MenuTitle /&gt;
                    &lt;MenuList whenClicked={this.handleClick}/&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

});
</code></pre>

<p>Is there a way to toggle the state and set the 'whenClicked' prop with one click event? </p>
","3422159","","3422159","","2015-06-22 08:09:07","2017-08-09 11:49:03","How to set state and props on a single click event in reactjs","<javascript><reactjs>","2","4","","",""
"39635398","1","","","2016-09-22 09:35:46","","2","1708","<p>I've followed the example pattern for handling the android back button in the react-native <a href=""https://facebook.github.io/react-native/docs/backandroid.html"" rel=""nofollow"">docs</a> and it works well. I can use the hardware back button to pop my navigation stack.  </p>

<p>At the point that there's only 1 view in the stack though I don't pop it (just like the example), and I return <em>false</em> from my <code>hardwareBackPress</code> event listener.  At this point it I see the <code>componentWillUnmount</code> method being called in my final view, at which point my app shuts down.</p>

<p>If I return <em>true</em> then nothing happens at all obviously.</p>

<p>What I want to happen is that the app merely gets ""backgrounded"" instead of exiting completely.</p>
","3346628","","","","","2017-08-05 05:00:23","background a react-native android app using back button","<android><react-native><back-button>","1","2","","",""
"30583519","1","30606174","","2015-06-01 21:21:40","","4","3609","<p>I am using react-router with the flux architecture (facebook's flux implementation).</p>

<p>Currently in my system I have route that says ""chat/:topic"".</p>

<p>When the user is entering this component, I am creating a subscription (using action creation, on componentWillMount) to a websocket server, and I am removing the subscription on componentWillUnmount.</p>

<p>When the user is moving to another route the whole workflow works alright - because react-router is unmounting my component.</p>

<p>When I transition inside my route (from ""chat/games"" to ""chat/tv""), the component isn't mounted and I need to clear my state of the components.</p>

<p>I read about different actions that I can take and this on transition to dispatch an action ""TRANSITION"" and every relevant store will clear it's store.</p>

<p>In my opinion, this kind of action - is wrong, it couples my stores and my router.</p>

<p>How would you solve this problem? Is this an issue that I should raise to react-router and ask them to unmount inside my route?</p>
","385882","","","","","2015-06-23 13:24:26","react-router and flux - clearing state while transition","<reactjs><reactjs-flux><flux><react-router>","3","0","2","",""
"30549214","1","30551122","","2015-05-30 17:28:27","","2","516","<p>I am making a web application which I intend to make as modular as possible using reactjs. </p>

<p>The application consists of a <code>menu</code> and an associated shopping <code>cart</code>, which keeps a track of what items are put into the <code>cart</code> from the <code>menu</code>. </p>

<p>My code is:</p>

<pre><code>React.render(
                &lt;div className=""row""&gt;
                &lt;div className=""col-md-7""&gt;
                    &lt;MainMenu /&gt;
                &lt;/div&gt;
                &lt;div className=""col-md-4""&gt;
                &lt;CartView /&gt;
                &lt;/div&gt;
                &lt;/div&gt;
   , mountpoint
    );
</code></pre>

<p>As it is visible, there is no hierarchical relationship between my these two components, so clearly I can't communicate by passing <code>props</code>. </p>

<p>I read on the official React documentation:</p>

<blockquote>
  <p>For communication between two components that don't have a
  parent-child relationship, you can set up your own global event
  system. Subscribe to events in componentDidMount(), unsubscribe in
  componentWillUnmount(), and call setState() when you receive an event.
  Flux pattern is one of the possible ways to arrange this</p>
</blockquote>

<p>However, I do not currently want to use Flux in my application. </p>

<p>So, my question is:</p>

<p><strong>Is there any way of setting up a message passing system between the components without using Flux?</strong></p>

<p>P.S: I know jQuery. I am having trouble understanding the ToDo example given on the Flux website so was just wondering if there is an alternative way of doing this.</p>

<p>Thanks. </p>
","3763293","","","","","2015-05-30 20:35:39","Communicate between two components reactjs","<jquery><reactjs>","1","1","1","",""
"47726904","1","","","2017-12-09 08:49:16","","1","876","<p>I get an error: 
""Error using newLatLngBounds(LatLngBounds, int): Map size can't be zero. Most likely layout has not yet occured for the map view. Either wait until layout has occurred or use newLatLngBounds(LatLngBounds, int, int, int) which allows you to specify the map's dimensions"".</p>

<p>But I set up an alert for getCurrentPosition and I'm receiving coordinates from getCurrentPosition().</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { View, Dimensions } from 'react-native';
import MapView from 'react-native-maps';


const {width, height} = Dimensions.get('window')

const SCREEN_HEIGHT = height
const SCREEN_WIDTH = width
const ASPECT_RATIO = width / height
const LATITUDE_DELTA = 0.0922
const LONGITUDE_DELTA = LATITUDE_DELTA * ASPECT_RATIO


class Map extends Component {
	
	constructor(props) {
		super(props)

		this.state = {
			isMapReady: false,
			initialPosition: {
				longitude: 0,
				latitude: 0,
				longitudeDelta: 0,
				latitudeDelta: 0
			},

			markerPosition: {
				longitude: 0,
				latitude: 0
			}

		}
	}

	watchID: ?number = null

	componentDidMount() {
		navigator.geolocation.getCurrentPosition((position) =&gt; {

			alert(JSON.stringify(position))

			var lat = parseFloat(position.coords.latitude)
			var long = parseFloat(position.coords.longitude)

			var initialRegion = {
				latitude: lat,
				longitude: long,
				latitudeDelta: LATITUDE_DELTA,
				longitudeDelta: LONGITUDE_DELTA
			}

			this.setState({initialPosition: initialRegion})
			this.setState({markerPosition: initialRegion})			
		},

		(error) =&gt; alert(JSON.stringify(error)))

		this.watchID = navigator.geolocation.watchPosition((position) =&gt; {
			var lat = parseFloat(position.coords.latitude)
			var long = parseFloat(position.coords.longitude)
			
			var lastRegion = {
				latitude: lat,
				longitude: long,
				longitudeDelta: LONGITUDE_DELTA,
				latitudeDelta: LATITUDE_DELTA
			}

			this.setState({initialPosition: lastRegion})
			this.setState({markerPosition: lastRegion})
		})

	}

	componentWillUnmount() {
		navigator.geolocation.clearWatch(this.watchID)
	}

	onMapLayout = () =&gt; {
    this.setState({ isMapReady: true });
  }

	render() {

		return (

			&lt;View style={styles.containerStyle}&gt;
				&lt;MapView style={styles.mapStyle} initialRegion={this.state.initialPosition} onLayout={this.onMapLayout}&gt;
					{ this.state.isMapReady &amp;&amp;
						&lt;MapView.Marker coordinate={this.state.markerPosition}&gt;
						&lt;/MapView.Marker&gt;
					}
				&lt;/MapView&gt;
			&lt;/View&gt;

			)

	}

}

const styles = {
	containerStyle: {
		flex:1,
		justifyContent: 'center',
		alignItems: 'center',
		backgroundColor: 'lightblue'
	},

	mapStyle: {
		left: 0,
		right: 0,
		top: 0,
		bottom: 0,
		position: 'absolute'
	}

}

export default Map;</code></pre>
</div>
</div>
</p>

<p>I have no idea what's going wrong to be honest... would really appreciate some help! Thank you!!</p>
","7306964","","7306964","","2017-12-09 14:28:56","2017-12-10 10:14:50","""Error using newLatLngBounds(LatLngBounds, int): Map size can't be zero...."" using react-native-maps on Android","<android><reactjs><react-native><react-native-android><react-native-maps>","3","0","","",""
"47657486","1","47657675","","2017-12-05 15:44:38","","1","40","<p>I am very interested in learning Reactjs, i watched some tutorials on YouTube.</p>

<p>I also followed some other tutorials on the internet like this <a href=""https://tutorialzine.com/2014/07/5-practical-examples-for-learning-facebooks-react-framework"" rel=""nofollow noreferrer"">tutorial</a>.</p>

<p>My main issue is when i try to run the first example from the tutorial mentioned above, the code gives no result, have i missed something ? (i use IntelliJ IDEA.)</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=""UTF-8"" /&gt;
    &lt;title&gt;React tutorial&lt;/title&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js""&gt;&lt;/script&gt;

    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js""&gt;&lt;/script&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=""content""&gt;&lt;/div&gt;

&lt;script type=""text/jsx""&gt;

    var TimerExample = React.createClass({

        getInitialState: function(){

            // This is called before our render function. The object that is
            // returned is assigned to this.state, so we can use it later.

            return { elapsed: 0 };
        },

        componentDidMount: function(){

            // componentDidMount is called by react when the component
            // has been rendered on the page. We can set the interval here:

            this.timer = setInterval(this.tick, 50);
        },

        componentWillUnmount: function(){

            // This method is called immediately before the component is removed
            // from the page and destroyed. We can clear the interval here:

            clearInterval(this.timer);
        },

        tick: function(){

            // This function is called every 50 ms. It updates the
            // elapsed counter. Calling setState causes the component to be re-rendered

            this.setState({elapsed: new Date() - this.props.start});
        },

        render: function() {

            var elapsed = Math.round(this.state.elapsed / 100);

            // This will give a number with one digit after the decimal dot (xx.x):
            var seconds = (elapsed / 10).toFixed(1);

            // Although we return an entire &lt;p&gt; element, react will smartly update
            // only the changed parts, which contain the seconds variable.

            return &lt;p&gt;This example was started &lt;b&gt;{seconds} seconds&lt;/b&gt; ago.&lt;/p&gt;;
        }
    });


    ReactDOM.render(
            &lt;TimerExample start={Date.now()} /&gt;,
        document.getElementById('content')
    );
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
","8208766","","1079354","","2017-12-05 15:46:13","2017-12-05 16:01:00","No output from my react app","<reactjs>","1","4","","",""
"48059208","1","","","2018-01-02 10:22:59","","0","36","<p>I have an app using an import statement to load <code>scss</code> file. it builds fine but when loading in browser it errors</p>

<pre><code>VM148 transformed.js:19714 Uncaught ReferenceError: menuIcon is not defined
    at Sidebar.render (VM148 transformed.js:19714)
   ...
VM148 transformed.js:13839 The above error occurred in the &lt;Sidebar&gt; component:
    in Sidebar (created by App)
    in div (created by App)
    in App
</code></pre>

<p>I am using the code from the following url <a href=""https://ashiknesin.com/blog/build-custom-sidebar-component-react/"" rel=""nofollow noreferrer"">https://ashiknesin.com/blog/build-custom-sidebar-component-react/</a></p>

<p><strong>New error</strong> after appending empty string to <code>src</code></p>

<pre><code>VM279 transformed.js:831 Warning: Failed context type: The context `router` is marked as required in `Link`, but its value is `undefined`.
    in Link (created by Sidebar)
    in li (created by Sidebar)
    in ul (created by Sidebar)
    in nav (created by Sidebar)
    in Sidebar (created by App)
    in div (created by App)
    in App
...
VM279 transformed.js:418 Uncaught Error: You should not use &lt;Link&gt; outside a &lt;Router&gt;
...
(anonymous) @ VM279 transformed.js:66
VM279 transformed.js:13839 The above error occurred in the &lt;Link&gt; component:
    in Link (created by Sidebar)
    in li (created by Sidebar)
    in ul (created by Sidebar)
    in nav (created by Sidebar)
    in Sidebar (created by App)
    in div (created by App)
    in App
</code></pre>

<p><strong>sidebar.js</strong></p>

<pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { IndexLink, Link } from 'react-router'
//import { BrowserRouter, IndexLink, Link, Route } from 'react-router-dom'
import './Sidebar.scss'
import classNames from 'classnames'

class Sidebar extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            showMenu: false
        }
        this.toggleMenu = this.toggleMenu.bind(this)
    }
    componentDidMount() {
        document.addEventListener('click', this.handleClickOutside.bind(this), true);
    }

    componentWillUnmount() {
        document.removeEventListener('click', this.handleClickOutside.bind(this), true);
    }
    toggleMenu() {
        this.setState({ showMenu: !this.state.showMenu })
    }
    handleClickOutside(event) {
        const domNode = ReactDOM.findDOMNode(this);

        if ((!domNode || !domNode.contains(event.target))) {
            this.setState({
                showMenu: false
            });
        }
    }

    render() {

        const showMenu = this.state.showMenu;
        const sidebarClass = classNames({
            'sidebar': true,
            'sidebar-menu-expanded': showMenu,
            'sidebar-menu-collapsed': !showMenu
        });

        const elementsClass = classNames({
            'expanded-element': true,
            'is-hidden': !showMenu,
        });



    return (
      &lt;nav className={sidebarClass}&gt;
        &lt;img
          className=""menuIcon""
          src=""""
          onClick={this.toggleMenu}
        /&gt;
        &lt;ul&gt;
          &lt;li&gt;
            &lt;Link className=""expandable"" to=""/setting"" title=""Setting""&gt;
              &lt;img
                src={'https://png.icons8.com/setting/ffffff'}
                alt=""""
              /&gt;
              &lt;span className={elementsClass}&gt;Setting&lt;/span&gt;
            &lt;/Link&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;

        )
    }
}


export default Sidebar
</code></pre>
","1164789","","1164789","","2018-01-02 11:19:23","2018-01-02 11:19:23","menuIcon is not defined in react app when loading scss file","<reactjs><sass><class-names>","0","8","","",""
"48413104","1","","","2018-01-24 00:35:00","","0","18","<p>My goal is that when I click on a Marker the react-scroll will go to the selected list element. I am not getting any errors. From my research, it is because the react-scroll isn't moving the div with scroll attribute.</p>

<p>Instead, it is moving the window scroll instead of the list item scroll bar. </p>

<p>Help </p>

<pre><code>componentDidMount () {

     Events.scrollEvent.register('begin', function(to, element) {
         console.log(""begin"", arguments, to, element);
     });

     Events.scrollEvent.register('end', function(to, element) {
         console.log(""end"", arguments, to, element);
     });

     scrollSpy.update();

 }

 componentWillUnmount () {
     Events.scrollEvent.remove('begin');
     Events.scrollEvent.remove('end');
 }


    ScrollToId = (id) =&gt; {

        scroller.scrollTo(id, {
          smooth: true,
          offset: 50
        })
    }
</code></pre>

<p><a href=""https://i.stack.imgur.com/JGe7t.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JGe7t.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/jLAMg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jLAMg.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/PjDoe.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PjDoe.png"" alt=""enter image description here""></a></p>
","4672324","","","","","2018-01-24 00:35:00","How to make a div with scroll attribute how can I make react-scroll scroll in there?","<reactjs><scrollbar>","0","0","","",""
"48419132","1","48420015","","2018-01-24 09:39:32","","0","536","<p>I am following this documentation for receiving push notification on react native android <a href=""https://github.com/evollu/react-native-fcm"" rel=""nofollow noreferrer"">https://github.com/evollu/react-native-fcm</a>, I am able to receive the device token id, but I am not able to receive any notification when I am using sending manually from firebase using that device id:</p>

<p>This is the code on my react native app:</p>

<pre><code>import {Platform} from 'react-native';
import FCM, {FCMEvent, RemoteNotificationResult, WillPresentNotificationResult, NotificationType} from 'react-native-fcm';

// this shall be called regardless of app state: running, background or not running. Won't be called when app is killed by user in iOS
FCM.on(FCMEvent.Notification, async (notif) =&gt; {
    // there are two parts of notif. notif.notification contains the notification payload, notif.data contains data payload
    if(notif.local_notification){
      //this is a local notification
    }
    if(notif.opened_from_tray){
      //iOS: app is open/resumed because user clicked banner
      //Android: app is open/resumed because user clicked banner or tapped app icon
    }
    // await someAsyncCall();

    if(Platform.OS ==='ios'){
      //optional
      //iOS requires developers to call completionHandler to end notification process. If you do not call it your background remote notifications could be throttled, to read more about it see https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623013-application.
      //This library handles it for you automatically with default behavior (for remote notification, finish with NoData; for WillPresent, finish depend on ""show_in_foreground""). However if you want to return different result, follow the following code to override
      //notif._notificationType is available for iOS platfrom
      switch(notif._notificationType){
        case NotificationType.Remote:
          notif.finish(RemoteNotificationResult.NewData) //other types available: RemoteNotificationResult.NewData, RemoteNotificationResult.ResultFailed
          break;
        case NotificationType.NotificationResponse:
          notif.finish();
          break;
        case NotificationType.WillPresent:
          notif.finish(WillPresentNotificationResult.All) //other types available: WillPresentNotificationResult.None
          break;
      }
    }
});
FCM.on(FCMEvent.RefreshToken, (token) =&gt; {
    console.log(token)
    // fcm token may not be available on first load, catch it here
});

class App extends Component {
    componentDidMount() {
        // iOS: show permission prompt for the first call. later just check permission in user settings
        // Android: check permission in user settings
        FCM.requestPermissions().then(()=&gt;console.log('granted')).catch(()=&gt;console.log('notification permission rejected'));

        FCM.getFCMToken().then(token =&gt; {
            console.log(token)
            // store fcm token in your server
        });

        this.notificationListener = FCM.on(FCMEvent.Notification, async (notif) =&gt; {
            // optional, do some component related stuff
        });

        // initial notification contains the notification that launchs the app. If user launchs app by clicking banner, the banner notification info will be here rather than through FCM.on event
        // sometimes Android kills activity when app goes to background, and when resume it broadcasts notification before JS is run. You can use FCM.getInitialNotification() to capture those missed events.
        // initial notification will be triggered all the time even when open app by icon so send some action identifier when you send notification
        FCM.getInitialNotification().then(notif =&gt; {
           console.log(notif)
        });
    }

    componentWillUnmount() {
        // stop listening for events
        this.notificationListener.remove();
    }
</code></pre>

<p>Android Manifest file looks as below:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;manifest package=""fi.rogerstudio.possis""
          xmlns:android=""http://schemas.android.com/apk/res/android""&gt;

  &lt;uses-permission android:name=""com.google.android.gms.permission.ACTIVITY_RECOGNITION""/&gt;
  &lt;uses-permission android:name=""com.example.healthgps.permission.MAPS_RECEIVE"" /&gt;
  &lt;uses-permission android:name=""android.permission.INTERNET"" /&gt;
  &lt;uses-permission android:name=""android.permission.ACCESS_COARSE_LOCATION"" /&gt;
  &lt;uses-permission android:name=""android.permission.ACCESS_FINE_LOCATION"" /&gt;
  &lt;uses-permission android:name=""android.permission.RECEIVE_BOOT_COMPLETED""/&gt;
  &lt;uses-permission android:name=""android.permission.VIBRATE"" /&gt;
  &lt;uses-permission android:name=""android.permission.RECEIVE_BOOT_COMPLETED"" /&gt;


  &lt;uses-feature android:name=""android.hardware.location.gps"" /&gt;

  &lt;application
    android:name="".MainApplication""
    android:allowBackup=""true""
    android:icon=""@mipmap/ic_launcher""
    android:label=""@string/app_name""
    android:supportsRtl=""true""&gt;
    &lt;activity android:name="".MainActivity""
              android:configChanges=""keyboard|keyboardHidden|orientation|screenSize""
              android:theme=""@style/Theme.Exponent.Light""
              android:windowSoftInputMode=""adjustResize""
              android:launchMode=""singleTop""&gt;
      &lt;intent-filter&gt;
        &lt;action android:name=""android.intent.action.MAIN""/&gt;

        &lt;category android:name=""android.intent.category.LAUNCHER""/&gt;
      &lt;/intent-filter&gt;

      &lt;intent-filter&gt;
        &lt;data android:scheme=""exp6a747c4f7f604b89a93d9f3d281cbb77""/&gt;

        &lt;action android:name=""android.intent.action.VIEW""/&gt;

        &lt;category android:name=""android.intent.category.DEFAULT""/&gt;
        &lt;category android:name=""android.intent.category.BROWSABLE""/&gt;
      &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;service
        android:name=""io.invertase.firebase.messaging.MessagingService""
        android:enabled=""true""
        android:exported=""true""&gt;
      &lt;intent-filter&gt;
        &lt;action android:name=""com.google.firebase.MESSAGING_EVENT"" /&gt;
      &lt;/intent-filter&gt;
    &lt;/service&gt;

    &lt;service android:name=""io.invertase.firebase.messaging.InstanceIdService"" android:exported=""false""&gt;
      &lt;intent-filter&gt;
        &lt;action android:name=""com.google.firebase.INSTANCE_ID_EVENT""/&gt;
      &lt;/intent-filter&gt;
    &lt;/service&gt;

    &lt;service android:name=""com.evollu.react.fcm.MessagingService"" android:enabled=""true"" android:exported=""true""&gt;
      &lt;intent-filter&gt;
      &lt;action android:name=""com.google.firebase.MESSAGING_EVENT""/&gt;
      &lt;/intent-filter&gt;
      &lt;/service&gt;

    &lt;service android:name=""com.evollu.react.fcm.InstanceIdService"" android:exported=""false""&gt;
    &lt;intent-filter&gt;
    &lt;action android:name=""com.google.firebase.INSTANCE_ID_EVENT""/&gt;
    &lt;/intent-filter&gt;
    &lt;/service&gt;

    &lt;!-- The Facebook SDK runs FacebookInitProvider on startup and crashes if there isn't an ID here --&gt;
    &lt;meta-data android:name=""com.facebook.sdk.ApplicationId"" android:value=""fb0""/&gt;
    &lt;!-- react-native-background-geolocation licence --&gt;
    &lt;meta-data android:name=""com.transistorsoft.locationmanager.license"" android:value=""14ef777231a8412c8b2d109443999356a2c13e62c07e2868345f5e13f01b3c83"" /&gt;
    &lt;meta-data android:name=""com.google.firebase.messaging.default_notification_icon"" android:resource=""@mipmap/ic_launcher""/&gt;
    &lt;receiver android:name=""com.evollu.react.fcm.FIRLocalMessagingPublisher""/&gt;
    &lt;receiver android:enabled=""true"" android:exported=""true""  android:name=""com.evollu.react.fcm.FIRSystemBootEventReceiver""&gt;
     &lt;intent-filter&gt;
             &lt;action android:name=""android.intent.action.BOOT_COMPLETED""/&gt;
                 &lt;action android:name=""android.intent.action.QUICKBOOT_POWERON""/&gt;
                  &lt;action android:name=""com.htc.intent.action.QUICKBOOT_POWERON""/&gt;
                  &lt;category android:name=""android.intent.category.DEFAULT"" /&gt;
    &lt;/intent-filter&gt;
    &lt;/receiver&gt;

  &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
","8956187","","5996134","","2018-01-24 10:19:20","2018-01-24 10:21:17","cannot receive any push notification on react native android app","<android><firebase><react-native><firebase-cloud-messaging><react-native-android>","1","1","","",""
"47361511","1","","","2017-11-18 01:20:06","","0","483","<p>I'm trying to do auth sign-out with react-native and am experiencing an issue where I want to reset the state of the redux store but, because I am using react-navigation, I have a bunch of redux-connected screens that are still mounted that re-render when the state tree is reset to it's initialState causing a bunch of exception errors. I tried to unmount them on sign-out with a react-navigation reset which redirects the user to the signup/login screen but I have no way of knowing when these screens are actually unmounted in order to call the <code>RESET_STATE</code> action. Initially I was dispatching the action via saga. </p>

<p><strong>sagas/logout.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { LOGOUT, RESET_STATE } from 'Actions/user';

// clear localstorage once user logs out.
const clearData = function* clearData(action) {
  AsyncStorage.removeItem('user');
  
  yield put(
    NavigationActions.reset({
      index: 0, 
      actions: [ 
        NavigationActions.navigate({ routeName: 'SignedOut' })
      ],
    })
  );
  // causes re-renders, screens still mounted
  yield put({type: RESET_STATE});
}

export default function* logoutSaga () {
  yield all([
    yield takeEvery(LOGOUT, clearData),
  ]);
}</code></pre>
</div>
</div>
</p>

<p>I also tried to reset once user reaches the SignedOut screen in it's componentDidMount cycle but unfortunately the screens unmount at some point well after componentDidMount is triggered:</p>

<p><strong>screens/SignedOut.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { resetState } from 'Actions/user';
import ActionButton from 'Components/FormElements/ActionButton';

class SignedOut extends Component {
  // screens are still mounted, causing screens from
  // previous screens to throw exception errors
  componentDidMount() {
    this.props.dispatch(resetState());
  }

  componentWillUnmount() {
    // never called
  }

  handleSignup = () =&gt; {
    this.props.navigation.navigate('Signup');
  }

  handleLogin = () =&gt; {
    this.props.navigation.navigate('Login');
  }

  render() {
    return(
      &lt;Container&gt;
        &lt;ActionButton
          text=""Sign Up""
          handleButtonPress={this.handleSignup}
        /&gt;
        &lt;ActionButton
          text=""Log In""
          handleButtonPress={this.handleLogin}
        /&gt;
      &lt;/Container&gt;
    );
  }
}

export default connect()(SignedOut);</code></pre>
</div>
</div>
</p>

<p>My question is, can anyone think of a way to reset state of redux store after all of my screens have finally unmounted by the react-navigation reset action?</p>
","3629584","","3629584","","2017-11-18 17:05:58","2017-11-19 03:43:02","How to reset state of redux store while using react-navigation when react-navigation reset does not immediately unmount screens from stack?","<react-native><redux><react-navigation><redux-saga>","3","0","","",""
"47606784","1","","","2017-12-02 10:15:42","","0","367","<p>i've static website using react selly-midtrans.herokuapp.com but as you can see there is some eksternal js that located in index.html, but the probelm is when we change the route to another menu the those external do not load as we first visit the page.</p>

<p>i've read some my friend advice using <code>componentDidMount/ComponentWillMount</code> and <code>componentWillUnmount</code> but i'm still bit confused to use that method for append my js and fix my problem</p>

<p>here'is my index.html code </p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=""en""&gt;
  &lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1, shrink-to-fit=no""&gt;
    &lt;meta name=""theme-color"" content=""#000000""&gt;
    &lt;link rel=""stylesheet"" href=""https://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css""&gt;
    &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1""&gt;
    &lt;script type=""application/x-javascript""&gt; addEventListener(""load"", function() { setTimeout(hideURLbar, 0); }, false); function hideURLbar(){ window.scrollTo(0,1); } &lt;/script&gt;
    &lt;link href='https://fonts.googleapis.com/css?family=Lato:100,300,400,700,900' rel='stylesheet' type='text/css'&gt;
    &lt;!--
      manifest.json provides metadata used when your web app is added to the
      homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
    --&gt;
    &lt;link rel=""manifest"" href=""%PUBLIC_URL%/manifest.json""&gt;
    &lt;link rel=""shortcut icon"" href=""%PUBLIC_URL%/favicon.ico""&gt;
    &lt;script async="""" defer="""" src=""https://apis.google.com/js/platform.js?publisherid=105038212373502490985"" type=""text/javascript""&gt;&lt;/script&gt;
    &lt;!--Google analytic--&gt;
    &lt;script&gt;
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-106169293-1', 'auto'); ga('send', 'pageview');
    &lt;/script&gt;
    &lt;title&gt;Sell Easily With Selly | Selly&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=""root""&gt;&lt;/div&gt;
    &lt;script src=""%PUBLIC_URL%/js/jquery.min.js""&gt;&lt;/script&gt;
    &lt;script src=""%PUBLIC_URL%/js/bootstrap.min.js""&gt;&lt;/script&gt;
    &lt;script src=""%PUBLIC_URL%/js/owl.carousel.js""&gt;&lt;/script&gt;
    &lt;script src=""%PUBLIC_URL%/js/main.js""&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
","5241456","","","","","2017-12-02 15:46:47","why external javascript in react do not load after first page change / redirect to another route","<javascript><reactjs><react-router>","1","2","","",""
"46761715","1","","","2017-10-16 01:18:26","","1","449","<p>I made a page by using nodejs+react+redux.
I made a edit button in the page and want to edit my data.</p>

<p>Now I select KUMAMOTO-CTI and change the priority from 5 to 10.I use ajax to get data from database to fill the blank.Before I submit it I can get the right data from database.But when I change priority and click to edit it again.The filled data will be wrong.I have to refresh it to get the right data.</p>

<p>And sometimes it will become like this:<a href=""https://i.stack.imgur.com/0O90j.png"" rel=""nofollow noreferrer"">Error</a></p>

<p>Could anybody tell me how to solve it?</p>

<p>Here is the pic:<a href=""https://i.stack.imgur.com/KDRD8.png"" rel=""nofollow noreferrer"">progress</a></p>

<p>Here is my code.</p>

<p>server.js</p>

<pre><code>const Koa = require('koa')
const Router = require('koa-router')
const cors = require('koa2-cors')
const app = new Koa()
const router = new Router()
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import serversReducer from '../client/reducers/reducer'
import { renderToString } from 'react-dom/server'

const store = createStore(serversReducer)

const views = require('koa-views')
const co = require('co')
const convert = require('koa-convert')
const json = require('koa-json')
const onerror = require('koa-onerror')
const bodyparser = require('koa-bodyparser')
const logger = require('koa-logger')
const debug = require('debug')('koa2:server')
const path = require('path')
//const ReactDOMServer = require('react-dom/server')
const React = require('react')
const config = require('./config')
const routes = require('./routes')
const mongoose = require('mongoose')
const stateSchema = require('./models/State')
const mission = require('./models/port')
const port = process.env.PORT || config.port

import Main from '../client/containers/Main'

mongoose.connect('mongodb://127.0.0.1:27017/monitor', {
    useMongoClient: true
});
mongoose.Promise = global.Promise;

var State = mongoose.model(""State"", stateSchema);

// error handler
onerror(app)
// middlewares
app.use(bodyparser())
    .use(json())
    .use(logger())
    .use(cors())
    .use(require('koa-static')(__dirname + '/public'))
    .use(views(path.join(__dirname, '/views'), {
        options: {
            settings: {
                views: path.join(__dirname, 'views')
            }
        },
        map: {
            'ejs': 'ejs'
        },
        extension: 'ejs'
    }))
    .use(router.routes())
    .use(router.allowedMethods())

// logger
app.use(async(ctx, next) =&gt; {
    const start = new Date()
    await next()
    const ms = new Date() - start
    console.log(`${ctx.method} ${ctx.url} - $ms`)
})

router.get('/', async(ctx, next) =&gt; {

    const staticMarkup = await renderToString(
        &lt;Provider store={store}&gt;
            &lt;Main /&gt;
        &lt;/Provider&gt;
    )

    const preloadedState = store.getState();
    //console.log(preloadedState);

    await ctx.render('index', {
        reduxData: preloadedState,
        helloComponentMarkup: staticMarkup
    })
})

router.post('/show', async(ctx, next) =&gt; {

    ctx.body = 'ok';
    let newArray = [];

    await State.find({}, function(err, doc) {
        if (err) {
            return;
        }
        doc.forEach(function(element, index) {
            newArray.push(element);
        })
        ctx.response.body = JSON.stringify(newArray);
    }).sort({
        priority: 1
    })
})

router.post('/edit', async(ctx, next) =&gt; {

    ctx.body = 'ok'

    await State.update({
        _id: ctx.request.body.querymark
    }, {
        $set: {
            server_name: ctx.request.body.servername,
            jp_name: ctx.request.body.jpname,
            ip_address: ctx.request.body.ipaddress,
            port: ctx.request.body.port,
            priority: ctx.request.body.priority
        }
    }, function(err, doc) {
        if (err) {
            return;
        }
    })
})

router.post('/create', async(ctx, next) =&gt; {

    ctx.body = 'ok'

    await new State({
        server_name: ctx.request.body.servername,
        jp_name: ctx.request.body.jpname,
        ip_address: ctx.request.body.ipaddress,
        port: ctx.request.body.port,
        priority: ctx.request.body.priority
    }).save(function(err) {
        if (err)
            console.log(err.toString());
    })
})

router.post('/delete', async(ctx, next) =&gt; {

    ctx.body = 'ok'

    await State.remove({
        _id: ctx.request.body.id
    }, function(err, doc) {
        if (err) {
            return;
        }
    });
})

routes(router)

app.on('error', function(err, ctx) {
    console.log(err)
    logger.error('server error', err, ctx)
})

module.exports = app.listen(config.port, () =&gt; {
    console.log(`Listening on http://localhost:${config.port}`)
    console.log(__dirname);
})
</code></pre>

<p>ListContainer.js</p>

<pre><code>import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { connect } from 'react-redux'
import { Router, Route, hashHistory } from 'react-router'
import { Segment, Icon, Table, Modal, Button, Form } from 'semantic-ui-react'
const axios = require('axios')
class ListContainer extends Component {
    static propTypes = {
        test_data: PropTypes.object.isRequired,
        post_data: PropTypes.object.isRequired,
        onDeleteServer: PropTypes.func,
        onEditServer: PropTypes.func,
        initServers: PropTypes.func,
        index: PropTypes.number
    }

    constructor(props) {
        super(props)
        this.state = ({
            servername: props.post_data.server_name,
            jpname: props.post_data.jp_name,
            ipaddress: props.post_data.ip_address,
            port: props.post_data.port,
            priority: props.post_data.priority
        })
    }

    static defaultProps = {
        servers: []
    }

    handleDeleteServer(index) {
        if (this.props.onDeleteServer) {
            this.props.onDeleteServer(this.props.index)
        } else {
            console.log(""error"")
        }
    }

    /*handleEditServer(index) {
        if (this.props.onEditServer) {
            this.props.onEditServer(this.props.index)
        } else {
            console.log(""error"")
        }
        this.setState({
            open: false
        })
    }*/

    handleServerNameChange(event) {
        this.setState({
            servername: event.target.value
        })
    }

    handleJPNameChange(event) {
        this.setState({
            jpname: event.target.value
        })
    }

    handleIPChange(event) {
        this.setState({
            ipaddress: event.target.value
        })
    }

    handlePORTChange(event) {
        this.setState({
            port: event.target.value
        })
    }

    handlePriorityChange(event) {
        this.setState({
            priority: event.target.value
        })
    }

    handleSubmit(index) {
        axios.post('/edit', {
            querymark: this.props.post_data._id,
            servername: this.state.servername,
            jpname: this.state.jpname,
            ipaddress: this.state.ipaddress,
            port: this.state.port,
            priority: this.state.priority
        }).then((response) =&gt; {
            var new_data;
            if (response.data.success === false) {
                alert(""error"")
            } else {
                window.location.reload();
                //console.log(this.props.post_data)
                dispatch(onEditServer(index, {
                    querymark: this.props.post_data._id,
                    servername: this.state.servername,
                    jpname: this.state.jpname,
                    ipaddress: this.state.ipaddress,
                    port: this.state.port,
                    priority: this.state.priority
                }))
            }
        }).catch(() =&gt; {
        })
        this.setState({
            open: false
        })
    }

    state = {
        open: false
    }

    show = (size, dimmer) =&gt; () =&gt; this.setState({
        size,
        dimmer,
        open: true
    })
    close = () =&gt; this.setState({
        open: false
    })

    render() {
        const {open, size, dimmer} = this.state
        const post_data = this.props.post_data
        var updated_time = (new Date(post_data.updated_at)).toLocaleString().replace('/T/', '').replace('/\../+', '')
        var state_color = (post_data.state == ""green"") ? ""green"" : ""red""
        var icon_name = (post_data.state == ""green"") ? ""smile"" : ""warning sign""
        return (
            &lt;Table.Row&gt;
                &lt;Table.Cell&gt;&lt;Icon name={icon_name} color={state_color}/&gt;&lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;{post_data.jp_name}&lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;{post_data.ip_address}&lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;{post_data.port}&lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;{updated_time}&lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;{post_data.priority}&lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;
                    &lt;div&gt;
                        &lt;Icon link name='settings' color='purple' onClick={this.show('small', 'blurring')} /&gt;
                        &lt;Modal size={size} dimmer={dimmer} open={open} onClose={this.close} closeIcon&gt;
                        &lt;Modal.Header&gt;Edit&lt;/Modal.Header&gt;             
                        &lt;Modal.Content&gt;
                            &lt;Modal.Description&gt;
                                &lt;Form&gt;
                                &lt;Form.Group width='equal'&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;Server Name&lt;/label&gt;
                                    &lt;input value={this.state.servername} onChange={this.handleServerNameChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;JP Name&lt;/label&gt;
                                    &lt;input value={this.state.jpname} onChange={this.handleJPNameChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;/Form.Group&gt;
                                &lt;Form.Group width='equal'&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;IP Address&lt;/label&gt;
                                    &lt;input value={this.state.ipaddress} onChange={this.handleIPChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;Priority&lt;/label&gt;
                                    &lt;input value={this.state.priority} onChange={this.handlePriorityChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;/Form.Group&gt;
                                &lt;Form.Group&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;Port&lt;/label&gt;
                                    &lt;input value={this.state.port} onChange={this.handlePORTChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;/Form.Group&gt;
                                &lt;/Form&gt;
                            &lt;/Modal.Description&gt;
                        &lt;/Modal.Content&gt;
                        &lt;Modal.Actions&gt;
                        &lt;Button color='black' onClick={this.close}&gt;
                            Nope
                        &lt;/Button&gt;
                        &lt;Button positive icon='checkmark' labelPosition='right' content=""Submit"" onClick={this.handleSubmit.bind(this)} /&gt;
                        &lt;/Modal.Actions&gt;
                        &lt;/Modal&gt;
                    &lt;/div&gt;
                &lt;/Table.Cell&gt;
                &lt;Table.Cell&gt;&lt;Icon link name='trash' color='purple' onClick={this.handleDeleteServer.bind(this)} /&gt;&lt;/Table.Cell&gt;
            &lt;/Table.Row&gt;
        )
    }
}

const mapStateToProps = (state) =&gt; {
    return {
        servers: state.servers
    }
}

const mapDispatchToProps = (dispatch) =&gt; {
    return {
        onEditServer: (index, data) =&gt; {
            dispatch(editServer(index, data))
        },
    }
}

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(ListContainer)
</code></pre>

<p>SegmentContainer.js</p>

<pre><code>import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { connect } from 'react-redux'
import { Container, Loader, Table, Grid, Icon, Button, Modal, Form } from 'semantic-ui-react'
import SegmentList from '../components/SegmentContainer'
import { initServers, deleteServer, editServer } from '../reducers/reducer'
import MenuFix from '../components/Menu'
const axios = require('axios')

class SegmentContainer extends Component {
    static propTypes = {
        servers: PropTypes.array,
        initServers: PropTypes.func,
        onDeleteServer: PropTypes.func,
        onAddServer: PropTypes.func
    }

    constructor() {
        super()
        //this._loadData()
        this.state = {
            servername: '',
            jpname: '',
            ipaddress: '',
            priority: ''
        }
    }

    componentWillMount() {
        this._loadData()
    }

    componentDidMount() {
        if (this.timer) {
            clearInterval(this.timer)
        }
        this.timer = setInterval(() =&gt; {
            this._loadData()
        }, 3000)
    }

    componentWillUnmount() {
        clearInterval(this.timer)
    }

    _loadData() {
        let sorted_data = [];
        let posts_data = [];
        let response = axios.post('/show')
            .then((response) =&gt; {
                Object.keys(response.data).forEach(function(index) {
                    sorted_data.push(response.data[index]);
                })

                function _dataCompare(a, b) {
                    if (a.priority &gt; b.priority)
                        return 1;
                    if (a.priority &lt; b.priority)
                        return -1;
                    return 0;
                }

                sorted_data.forEach((item, index) =&gt; {
                    posts_data.push(item);
                })
                posts_data.sort(_dataCompare);
                this.props.initServers(posts_data)
            //dispatch(initServers(posts_data))
            }).catch(() =&gt; {
        })

    }

    handleDeleteServer(index) {
        const {servers} = this.props
        axios.post('/delete', {
            id: servers[index]._id
        }).then((response) =&gt; {
            if (response.data.success === false) {
                alert(""error"");
            } else {
                window.location.reload();
            }
        }).catch(() =&gt; {
        })
        if (this.props.onDeleteServer) {
            this.props.onDeleteServer(index)
        }
    }

    /*handleEditServer(index) {
        const {servers} = this.props
        axios.post('/edit', {
            querymark: this.props.servers._id,
            servername: this.state.servername,
            jpname: this.state.jpname,
            ipaddress: this.state.ipaddress,
            port: this.state.port,
            priority: this.state.priority
        }).then((response) =&gt; {
            if (response.data.success === false) {
                alert(""error"")
            } else {
                //window.location.reload();
                dispatch(onEditServer(index, {
                    querymark: this.props.servers._id,
                    servername: this.state.servername,
                    jpname: this.state.jpname,
                    ipaddress: this.state.ipaddress,
                    port: this.state.port,
                    priority: this.state.priority
                }))
            }
        }).catch(() =&gt; {
        })
        this.setState({
            open: false
        })
    }*/

    handleCreate(server) {
        axios.post('/create', {
            servername: this.state.servername,
            jpname: this.state.jpname,
            ipaddress: this.state.ipaddress,
            port: this.state.port,
            priority: this.state.priority
        }).then((response) =&gt; {
            if (response.data.success === false) {
                alert(""error"");
            } else {
                window.location.reload()
                dispatch(onAddServer(index, {
                    servername: this.state.servername,
                    jpname: this.state.jpname,
                    ipaddress: this.state.ipaddress,
                    port: this.state.port,
                    priority: this.state.priority
                }))
            }
        }).catch(() =&gt; {
        })
        this.setState({
            open: false
        })
    }

    handleServerNameChange(event) {
        this.setState({
            servername: event.target.value
        })
    }

    handleJPNameChange(event) {
        this.setState({
            jpname: event.target.value
        })
    }

    handleIPChange(event) {
        this.setState({
            ipaddress: event.target.value
        })
    }

    handlePORTChange(event) {
        this.setState({
            port: event.target.value
        })
    }

    handlePriorityChange(event) {
        this.setState({
            priority: event.target.value
        })
    }

    state = {
        open: false
    }
    show = (size, dimmer) =&gt; () =&gt; this.setState({
        size,
        dimmer,
        open: true
    })

    close = () =&gt; this.setState({
        open: false
    })

    render() {
        const {open, size, dimmer} = this.state
        return (
            &lt;Grid&gt;
            &lt;MenuFix /&gt; 
            &lt;Container style = {{
                marginTop: '6em'
            }}&gt;
                &lt;Table unstackable&gt;
                    &lt;Table.Header&gt;
                        &lt;Table.Row&gt;
                        &lt;Table.HeaderCell colSpan='8'&gt;
                            &lt;Button basic color='violet' floated='right' icon labelPosition='left' primary size='tiny' onClick={this.show('small', 'blurring')}&gt;
                                &lt;Icon link color='violet' name='add' /&gt;Add
                            &lt;/Button&gt;
                            &lt;Modal size={size} dimmer={dimmer} open={open} onClose={this.close} closeIcon&gt;
                            &lt;Modal.Header&gt;Add&lt;/Modal.Header&gt;
                            &lt;Modal.Content&gt;
                                &lt;Modal.Description&gt;
                                    &lt;Form&gt;
                                &lt;Form.Group width='equal'&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;Server Name&lt;/label&gt;
                                    &lt;input value={this.state.servername} onChange={this.handleServerNameChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;JP Name&lt;/label&gt;
                                    &lt;input value={this.state.jpname} onChange={this.handleJPNameChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;/Form.Group&gt;
                                &lt;Form.Group width='equal'&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;IP Address&lt;/label&gt;
                                    &lt;input value={this.state.ipaddress} onChange={this.handleIPChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;Priority&lt;/label&gt;
                                    &lt;input value={this.state.priority} onChange={this.handlePriorityChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;/Form.Group&gt;
                                &lt;Form.Group&gt;
                                &lt;Form.Field&gt;
                                    &lt;label&gt;Port&lt;/label&gt;
                                    &lt;input value={this.state.port} onChange={this.handlePORTChange.bind(this)} /&gt;
                                &lt;/Form.Field&gt;
                                &lt;/Form.Group&gt;
                                &lt;/Form&gt;
                                &lt;/Modal.Description&gt;
                            &lt;/Modal.Content&gt;
                            &lt;Modal.Actions&gt;
                                &lt;Button color='black' onClick={this.close}&gt;
                                    Nope
                                &lt;/Button&gt;
                                &lt;Button positive icon='checkmark' labelPosition='right' content=""Submit"" onClick={this.handleCreate.bind(this)} /&gt;
                            &lt;/Modal.Actions&gt;
                            &lt;/Modal&gt;
                        &lt;/Table.HeaderCell&gt;
                        &lt;/Table.Row&gt;
                        &lt;Table.Row&gt;
                            &lt;Table.HeaderCell&gt;State&lt;Loader active inline size='small' /&gt;&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;Server Name&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;IP Address&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;Port&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;Updated&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;Priority&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;Edit&lt;/Table.HeaderCell&gt;
                            &lt;Table.HeaderCell&gt;Delete&lt;/Table.HeaderCell&gt;
                        &lt;/Table.Row&gt;
                    &lt;/Table.Header&gt;
                    &lt;SegmentList posts_data = {this.props.servers} onDeleteServer={this.handleDeleteServer.bind(this)} /&gt;
                &lt;/Table&gt;
            &lt;/Container&gt;
            &lt;/Grid&gt;
        )
    }
}

const mapStateToProps = (state) =&gt; {
    return {
        servers: state.servers
    }
}

const mapDispatchToProps = (dispatch) =&gt; {
    return {
        initServers: (servers) =&gt; {
            dispatch(initServers(servers))
        },
        onDeleteServer: (index) =&gt; {
            dispatch(deleteServer(index))
        },
        onEditServer: (index, data) =&gt; {
            dispatch(editServer(index, data))
        },
        onAddServer: (server) =&gt; {
            dispatch(addServer(server))
        }
    }
}

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(SegmentContainer)
</code></pre>

<p>reducer.js</p>

<pre><code>//action types
const INIT_SERVERS = 'INIT_SERVERS'
const ADD_SERVER = 'ADD_SERVER'
const DELETE_SERVER = 'DELETE_SERVER'
const EDIT_SERVER = 'EDIT_SERVER'

//reducer

export default function(state, action) {
    if (!state) {
        state = {
            servers: []
        }
    }
    switch (action.type) {
    case INIT_SERVERS:
        return {
            servers: action.servers
        }
    case ADD_SERVER:
        return {
            servers: [...state.servers, action.server]
        }
    case EDIT_SERVER:
        return {
            servers: [...state.servers.slice(0, action.index), Object.assign({}, state.servers[action.index], {
                done: true
            }), ...state.servers.slice(action.index + 1)]
        /*servers: Object.assign([...state.servers], {
            [index]: action.data
        })*/
        //servers: Object.assign({}, state[action.index], action.data)
        }
    case DELETE_SERVER:
        return {
            servers: [
                ...state.servers.slice(0, action.index),
                ...state.servers.slice(action.index + 1)
            ]
        }
    default:
        return state
    }
}

// action creators
export const initServers = (servers) =&gt; {
    return {
        type: INIT_SERVERS,
        servers
    }
}

export const addServer = (server) =&gt; {
    return {
        type: ADD_SERVER,
        server
    }
}

export const deleteServer = (index) =&gt; {
    return {
        type: DELETE_SERVER,
        index
    }
}

export const editServer = (index, data) =&gt; {
    return {
        type: EDIT_SERVER,
        index,
        data
    }
}
</code></pre>

<p>SegmentList.js</p>

<pre><code>import React, { Component, PropTypes } from 'react'
import ListContainer from '../containers/ListContainer'


export default class SegmentList extends Component {
    static propTypes = {
        posts_data: PropTypes.array,
        onDeleteServer: PropTypes.func,
    //onEditServer: PropTypes.func
    }
    static defaultProps = {
        posts_data: []
    }

    handleDeleteServer(index) {
        if (this.props.onDeleteServer) {
            this.props.onDeleteServer(index)
        }
    }

    /*handleEditServer(index) {
        if (this.props.onEditServer) {
            this.props.onEditServer(index)
        }
    }*/

    render() {
        return (
            &lt;div&gt;
                {this.props.posts_data.map((data, i) =&gt; &lt;ListContainer
                post_data={data}
                key={i}
                index={i} onDeleteServer={this.handleDeleteServer.bind(this)} /&gt;
            )}
            &lt;/div&gt;
        )
    }
}
</code></pre>
","8763651","","8763651","","2017-10-18 06:17:49","2017-10-18 06:17:49","How can I get the right data from database with react","<javascript><node.js><ajax><reactjs><react-redux>","1","0","","",""
"39671054","1","39671333","","2016-09-23 23:47:47","","0","284","<p>I'm attempting to capture the window height and pass it to child components in react.</p>

<p>I'm referring to this guide from the manual: <a href=""https://facebook.github.io/react/tips/dom-event-listeners.html"" rel=""nofollow"">https://facebook.github.io/react/tips/dom-event-listeners.html</a>.</p>

<p>This is how my code is looking but I'm getting a 'setState is not a function' error.</p>

<pre><code>import React from 'react';
import jsonp from 'jsonp';
import Gallery from './Gallery.jsx';

export const MF = 'http://auryn/modern-frontend/public_html';

export default class App extends React.Component {

    constructor(props) {
        super(props);

        this.state = {
            images: [ 'DSCF1176.jpg' ],
            height: window.innerHeight+'px'
        };
        var self = this;

        // get images
        var url = MF+'/api/posts';
        jsonp(url, {}, function (err, data) {
            const blogs = data.data.blogs.map(item =&gt; {    
                return {
                    'images': item.image
                }
            });
            var images = [];
            blogs.forEach(b =&gt; {
                b.images.forEach(i =&gt; {
                    images.push(i.filename);
                });
            });
            //console.log(JSON.stringify(images));
            //self.images = images;
            self.setState({ images });
        });
    }

    componentDidMount() {
        window.addEventListener('resize', this.handleResize);
    }

    handleResize(e) {
        this.setState({height: window.innerHeight+'px'});
    }

    componentWillUnmount() {
        window.removeEventListener('resize', this.handleResize);
    }

    render() {   
        return (
              &lt;Gallery images={this.state.images} height={this.state.height} /&gt;
        );
    }
}
</code></pre>
","6108127","","6108127","","2016-09-24 00:06:13","2016-09-24 00:33:41","Simple window resize react","<javascript><reactjs>","2","0","","",""
"39746375","1","","","2016-09-28 11:39:13","","0","645","<p>I am developing a react native app. I am using <a href=""https://github.com/aksonov/react-native-router-flux"" rel=""nofollow"">react-native-router-flux</a> library for navigation in the app.</p>

<p>The library is working fine but while back navigating no react lifecycle method is getting called.</p>

<p>suppose for e.g. I pressed back button on page 2, It gets navigate to page 1 and the componentWillUnmount() of page 2 gets called but <strong>no lifecycle methods of page 1 gets called</strong>.</p>

<p>I want to refresh the page 1 according to new state.</p>

<p>Any help would be greatly appreciated.</p>
","3908895","","","","","2016-09-28 16:57:11","react-native-router-flux : No React lifecycle method is getting called on back navigation","<reactjs><react-native><react-router><navigator><react-native-router-flux>","1","1","1","",""
"47359612","1","","","2017-11-17 21:32:34","","2","434","<p>After updating react native from 0.45.x to 0.50.3 (and renaming index.ios.js to index.js as indicated) I get this error in index.js (previous index.ios.js): 
""Object is not a constructor (evaluating 'new _app2.default()')""</p>

<p>Here is my index.js file</p>

<pre><code>import { AppRegistry } from 'react-native';
import App from './app/';

const app = new App();

AppRegistry.registerComponent('airand', () =&gt; app);
</code></pre>

<p>And here is my app/index.js file:</p>

<pre><code>import { Platform, Linking } from 'react-native'
import { Provider } from ""react-redux""
import allReducers from ""./reducers""
import { Navigation } from 'react-native-navigation'
import RCTSFSafariViewController from 'react-native-sfsafariviewcontroller'
import FontAwesome from 'react-native-vector-icons/FontAwesome'

import registerScreens from './screens/'
import Token from './services/token'
import Api from './services/api'
import configureStore from './store/configureStore'
// import { login, logout } from './reducers/app-root/actions'
import defaultFitlerData from './constants/nearby-cte.js'

const store = configureStore();

registerScreens(store, Provider);

export default class App {

    constructor() {
        this._populateTabBarIcons().then(() =&gt; {
            this._startApp();
            this._checkUserLoggedIn();
            store.subscribe(() =&gt; this._actionListener());
        });
        // handle linking
        Linking.getInitialURL().then((url) =&gt; {
            if (url) {
                this._handleOpenURL(url);
            }
        }).catch((e) =&gt; {})
        Linking.addEventListener('url', (event) =&gt; this._handleOpenURL(event.url));
    };
    _populateTabBarIcons () {
        return new Promise((resolve, reject) =&gt; {
            Promise.all([
                    FontAwesome.getImageSource('map-marker', 30),
                    FontAwesome.getImageSource('map-marker', 30),
                    FontAwesome.getImageSource('ellipsis-h', 30),
                    FontAwesome.getImageSource('ellipsis-h', 30),
                    FontAwesome.getImageSource('plus-square-o', 30),
                    FontAwesome.getImageSource('plus-square', 30),
                    FontAwesome.getImageSource('comment-o', 30),
                    FontAwesome.getImageSource('comment', 30),
                    FontAwesome.getImageSource('user-o', 30),
                    FontAwesome.getImageSource('user', 30)
            ]).then((values) =&gt; {
                this.tabBarIcons = [];
                this.selectedTabBarIcons = [];
                for (var i = 0; i &lt; values.length; i += 2) {
                    this.tabBarIcons.push(values[i]);
                    this.selectedTabBarIcons.push(values[i+1]);
                }
                resolve(true);
            }).catch((error) =&gt; {
                reject(error);
            }).done();
        });
    };
    componentWillUnmount() {
        // TODO: find a way to call this
        Linking.removeEventListener('url', (event) =&gt; this._handleOpenURL(event.url));
    };
    _getParameterByName(name, url) {
        name = name.replace(/[\[\]]/g, ""\\$&amp;"");
        var regex = new RegExp(""[?&amp;]"" + name + ""(=([^&amp;#]*)|&amp;|#|$)""),
        results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return decodeURIComponent(results[2].replace(/\+/g, "" ""));
    };
    async _handleOpenURL(url) {
        const pathName = url.split('://')[1].split('?')[0];
        if (pathName.indexOf('login_successful') != -1) {
            const code = this._getParameterByName('code', url);
            if (code) {
                let response = await Api.getTokenFromCode(code);
                if (response.status == 200) {
                    this._checkUserLoggedIn();
                }
            }
        }
        RCTSFSafariViewController.close();
    };
    async _checkUserLoggedIn() {
        let isValid = await Token.isValidRefreshToken();
        if (isValid) {
          this._startApp('logged-in')
        } else {
          this._startApp('logged-out')
        }
    };
    _actionListener() {
        let currentRoot = store.getState().appRoot.root;
        if (currentRoot != lastRoot)
        this._startApp(currentRoot);
    };
    _getTabs() {
        const tabLabel = ['Nearby', 'Pending', 'New', 'Chat', 'Profile'];
        const screens = [
            'airand.NearbyServices',
            'airand.PendingServicesScreen',
            'airand.NewServiceScreen',
            'airand.ChatScreen',
            'airand.Profile'
        ];
        var tabs = [];
        for (var i = 0; i &lt; screens.length; i++) {
            tabs.push({
                icon: this.tabBarIcons[i],
                selectedIcon: this.selectedTabBarIcons[i],
                screen: screens[i]
            });
        };
        return tabs;
    };
    async _startApp(root = null) {
      lastRoot = root
        switch(root) {
            case 'logged-in':
                self.logged_in = true
                Navigation.startTabBasedApp({
                    tabs: this._getTabs(),
                    animationType: 'slide-down',
                    title: 'Redux Example',
                    tabsStyle: {
                        tabBarButtonColor: '#979797',
                        tabBarSelectedButtonColor: '#f79100',
                    }
                });
                return
            case 'logged-out':
                Navigation.startSingleScreenApp({
                    screen: { screen: 'airand.LoginScreen' }
                });
                return
            default:
                Navigation.startSingleScreenApp({
                    screen: { screen: 'airand.LoadingScreen' }
                });
                return
        }
    };
}
</code></pre>

<p>It seems like a stupid error but I've spent hours on this so please any help would be appreciated, I have tried commenting some stuff to almost everything in app/index.js but no luck.</p>

<p>Thank you!</p>
","5925985","","","","","2017-11-17 22:25:50","Object is not a constructor after react-native 0.49 update","<javascript><react-native>","1","0","","",""
"47933175","1","","","2017-12-21 21:49:10","","1","867","<p>I'm trying to add an event listener for <code>keydown</code> event in an image (or div) tag. It works if I add it to the document with <code>document.addEventListener</code>, but it doesn't when I try to put it into the specific element that I create in react (I noted in the code what works and what doesn't). Also <code>handleClick</code> works and <code>handleKey</code> does not, no matter which format I put it into the tag with.</p>

<pre><code>class PrescriptionImage extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null,
      isLoaded: false,
      patient: """",
      rotation: 0
    };
    this.handleKey = this.handleKey.bind(this);
  }

  handleClick() {
    this.setState({rotation: this.state.rotation + 270})
  }

  handleKey(e) {
    e.preventDefault();
    console.log(e);
    if (e.code == 'ArrowLeft') {
      if (e.ctrlKey) {
        this.setState({rotation: this.state.rotation + 270})
      }
    }
  }

  componentDidMount() {
//    document.getElementById(""left"").addEventListener(""keydown"", this.handleKey, true); This doesn't work (no error)
//    this.RxImage.addEventListener(""keydown"", this.handleKey, false); This doesn't work, (can't find addEventListener of ""undefined"")
//    document.addEventListener(""keydown"", this.handleKey, false); This works.
    fetch(""http://localhost:3333/patientAddress.json"")
      .then(res =&gt; res.json())
      .then(
        result =&gt; {
          this.setState({
            isLoaded: true,
            patient: result.order.patient
          });
        },
        error =&gt; {
          this.setState({
            isLoaded: true,
            error
          });
        }
      );
  }

  componentWillUnmount(){
    document.removeEventListener(""keydown"", this.handleKey, false);
  }

  render() {
    const { error, isLoaded, patient, rotation } = this.state;
    if (error) {
      return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    } else if (!isLoaded) {
      return &lt;div&gt;Loading...&lt;/div&gt;;
    } else {
      return &lt;img className=""prescription-image"" style={{width: ""98%"", height: ""98%"", transform: `rotate(${rotation}deg)`}} src={""data:image/png;base64,"" + patient.rx.imageData} onClick={() =&gt; this.handleClick()} onKeyDown={this.handleKey} /&gt;;
    }
  }
}

ReactDOM.render(&lt;PrescriptionImage /&gt;, document.getElementById(""left""));
</code></pre>
","275780","","275780","","2017-12-21 22:41:14","2017-12-21 23:23:28","adding event listener for keydown to react element","<javascript><reactjs>","1","4","","",""
"47952405","1","","","2017-12-23 12:14:41","","0","70","<p>For a dashboard component i've been working has been having some issues recently. I'm using react-router to handle url routes client-side, and recently I started loading in components asynchronously for each route.</p>

<p>Whenever I make a http requests from route components I keep getting a warning message in the console. The warning says that setState cannot the state of a unmounted component. So far I have been able to deduce that a mounting loop could be causing setState to unsuccessfully set the state of the component. Other than that I am not sure what is causing this issue top occur. </p>

<p>Has anyone else have this issue before? Any advice on this issue is appreciated.</p>

<p><strong>console screenshot</strong>:
<a href=""https://i.stack.imgur.com/wxcnD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wxcnD.png"" alt=""enter image description here""></a></p>

<p><strong>asyncLoader.js</strong>:</p>

<pre><code> import React from 'react';

 export default (getComponent, extraProps=null) =&gt; {
     return class asyncComponent extends React.Component {
         static Component = null;

         constructor(props){
             super(props);

             this.state = {Component: asyncComponent.Component};
         }
         componentWillMount(){
             const {Component} = this.state;

             if (Component === null) getComponent().then((component) =&gt; {
                asyncComponent.Component = component;

                if (this.mounted) this.setState({Component: component});

             });
         }
         componentDidMount(){
             this.mounted = true;
         }
         componentWillUnmount(){
             this.mounted = false;
         }
         render(){
             const {Component} = this.state;

             return Component !== null ? &lt;Component {...this.props} {...extraProps} /&gt; : null;

         }
     };
};
</code></pre>

<p><strong>route-container.js</strong>:</p>

<pre><code>import React from 'react';
import {Switch, Route, Redirect} from 'react-router-dom';
import asyncComponent from './asyncLoader';

export default class Container extends React.Component{
    constructor(props){
        super(props);

        this.state = {loadingScreen: true};

        this.handleStateChange = this.handleStateChange.bind(this);
    }
    handleStateChange(){
        this.setState((prevState) =&gt; ({loadingScreen: !prevState.loadingScreen}));
    }
    render(){
        const {user, getUserCallback} = this.props,
              {loadingScreen} = this.state,
              UserSettings = asyncComponent(() =&gt; import('./user').then((module) =&gt; module.UserSettings), {user: {...user}, getUserCallback: getUserCallback, loadingScreenCallback: this.handleStateChange}),
              TransactionHistory = asyncComponent(() =&gt; import('./transactions').then((module) =&gt; module.TransactionHistory), {user: {...user}, loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              PaymentMethods = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.PaymentMethods), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              UserBillCreator = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.UserBillCreator), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance}),
              UserBillPaymentSender = asyncComponent(() =&gt; import('./billing').then((module) =&gt; module.UserBillPaymentSender), {loadingScreenCallback: this.handleStateChange, axiosInstance: this.props.axiosInstance, getUserCallback: getUserCallback, accountBalance: !user.admin ? user.account_balance : 0});

        return(
            &lt;div className=""d-flex flex-column col dashboard-app-container""&gt;
                &lt;div ref=""loadingScreen"" className={loadingScreen ? ""row justify-content-center react-loading-screen"" : ""row justify-content-center react-loading-screen hide""}&gt;
                    &lt;div className=""d-flex flex-column justify-content-center react-loading-container""&gt;
                        &lt;i className=""fa fa-spin fa-circle-o-notch"" /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;Switch&gt;
                   &lt;Route path=""/settings"" component={UserSettings} /&gt;
                   &lt;Route path=""/transactions/history"" component={TransactionHistory} /&gt;
                   &lt;Route path=""/transactions/paymentMethods"" component={PaymentMethods} /&gt;
                   &lt;Route path=""/transactions/billing/create"" component={UserBillCreator} /&gt;
                   &lt;Route path=""/transactions/billing/pay"" component={UserBillPaymentSender} /&gt;
                   &lt;Redirect from=""/"" to=""/transactions/history"" /&gt;
                &lt;/Switch&gt;
            &lt;/div&gt;
        );
    }

}
</code></pre>

<p>Component example for route <strong>""/transactions/history""</strong></p>

<p><strong>transactions.js</strong>:</p>

<pre><code>import React from 'react';
import _ from 'lodash';
import moment from 'moment';
import {Link} from 'react-router-dom';
import {AgGridReact} from 'ag-grid-react';
import DayPickerInput from 'react-day-picker/DayPickerInput';
import 'react-day-picker/lib/style.css';


export class TransactionHistory extends React.Component{
    constructor(props){
        super(props);

        this.state = {
            activity_day_period: '30 days',
            date_filter: {
                start: '',
                end: ''
            },
            dateAccordianOpen: false,
            data_grid: {
                columns: [
                    {headerName: 'Bill ID', field: 'id'},
                    {headerName: 'Created On', field: 'created_on'},
                    {headerName: 'Paid on', field: 'transaction_created_on'},
                    {headerName: 'Amount', field: 'billed_amount'},
                    {headerName: 'Item', field: 'item_name'},
                    {headerName: 'Description', field: 'description'}

                ],
                rows: [],
                filtered_rows: [],
                raw_data: []
            }
        };

        this.handleDateChangeStart = this.handleDateChangeStart.bind(this);
        this.handleDateChangeEnd = this.handleDateChangeEnd.bind(this);
        this.onGridReady = this.onGridReady.bind(this);
        this.handGridResize = this.handleGridResize.bind(this);
        this.getTransactionData = this.getTransactionData.bind(this);

    }
    componentDidMount(){
        this.getTransactionData();
        setTimeout(this.props.loadingScreenCallback, 600);
    }
    componentWillUnmount(){
        this.props.loadingScreenCallback();
    }
    handleDateChangeStart(date){
        this.setState((prevState) =&gt; ({date_filter: {...prevState.date_filter, start: moment.utc(date).format('YYYY-MM-DD')}}));

    }
    handleDateChangeEnd(date){
        this.setState((prevState) =&gt; ({date_filter: {...prevState.date_filter, end: moment.utc(date).format('YYYY-MM-DD')}}));
    }
    onGridReady(params){
        this.api = params.api;
        this.columnApi = params.columnApi;

        this.api.sizeColumnsToFit();

    }
    handleGridResize(){
        this.api.sizeColumnsToFit();

    }
    getTransactionData(){
        const {activity_day_period} = this.state;
        let api_url = window.location.origin;

        switch (activity_day_period) {
            case '30 days':
                api_url = `${api_url}/api/user/billing?days=30`;
                break;

            case '3 months':
                api_url = `${api_url}/api/user/billing?months=3`;
                break;

            case '6 months':
                api_url = `${api_url}/api/user/billing?months=6`;
                break;

            case '1 year':
                api_url = `${api_url}/api/user/billing?years=1`;
                break;

            case 'All':
                api_url = `${api_url}/api/user/billing`;
                break;

        }

        this.props.axiosInstance.get(api_url).then((response) =&gt; {
            if (response.data.code == 200) {
                // The warning seems to pop up when setState in this method is called...
                this.setState((prevState) =&gt; ({
                    data_grid: {
                        ...prevState.data_grid,
                        rows: response.data.bills.map((data) =&gt; {
                            if (data.bill_paid) {
                                return {
                                    id: data.id,
                                    created_on: moment.utc(data.created_on).format('YYYY-MM-DD'),
                                    transaction_created_on: moment.utc(data.transaction.date).format('YYYY-MM-DD'),
                                    billed_amount: `$${data.billed_amount.toFixed(2)}`,
                                    item_name: data.item_name,
                                    description: data.description
                                };
                            }
                        }), 
                        raw_data: response.data.bills
                    }
                }));

            }
        }).catch((error) =&gt; {
            if (error.response) {
                if (error.response.data.code == 401) {
                 //Here another http request is made to my api in order to get new auth tokens before retrying the original request. 
                }

        });
    }
    render(){
        const {user} = this.props,
              {activity_day_period, date_filter, dateAccordianOpen, data_grid} = this.state,
              start_date_obj = new Date(),
              end_date_obj = new Date();
              start_date_obj.setDate(start_date_obj.getDate() - 1);

        return(
            &lt;div className=""container pl-0 pr-0""&gt;
                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-6""&gt;
                        &lt;h2&gt;Transaction History&lt;/h2&gt;
                        &lt;p&gt;You can check past and pending tranactions here.&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-7 ml-5 mt-3""&gt;
                        &lt;h4&gt;Account Balance&lt;/h4&gt;
                        &lt;h1 className=""display-3 text-muted text-center""&gt;${user.account_balance &gt; 0 ? user.account_balance.toFixed(2) : '0.00'}&lt;/h1&gt;
                        {user.account_balance &gt; 0 ? (&lt;div className=""row""&gt;&lt;Link className=""ml-auto"" to=""/transactions/billing/pay""&gt;Pay Now &lt;i className=""fa fa-chevron-right"" /&gt;&lt;/Link&gt;&lt;/div&gt;) : (&lt;p className=""text-right text-muted""&gt;&lt;em&gt;No balances to pay right now. HOORAY!&lt;/em&gt;&lt;/p&gt;)}
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row mt-4""&gt;
                    &lt;div className=""col-md-3 form-group""&gt;
                        &lt;label htmlFor=""activity""&gt;Activity&lt;/label&gt;
                        &lt;select id=""activity"" name=""activity_day_period"" className=""form-control"" value={activity_day_period} onChange={(e) =&gt; this.setState({activity_day_period: e.target.value}, this.getTransactionData)}&gt;
                            &lt;option key=""1""&gt;30 days&lt;/option&gt;
                            &lt;option key=""2""&gt;3 months&lt;/option&gt;
                            &lt;option key=""3""&gt;6 months&lt;/option&gt;
                            &lt;option key=""4""&gt;1 year&lt;/option&gt;
                            &lt;option key=""5""&gt;All&lt;/option&gt;
                        &lt;/select&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row pb-3""&gt;
                    &lt;div className=""ag-blue dashboard-transaction-grid""&gt;
                        &lt;AgGridReact columnDefs={data_grid.columns} 
                                     rowData={data_grid.rows} 
                                     groupHeaders=""true"" 
                                     onGridReady={this.onGridReady}
                                     onGridSizeChanged={this.handleGridResize}/&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>
","5765090","","","","","2017-12-23 12:14:41","dynamic component shows warning in console when making http requests react-router v4","<javascript><reactjs><axios><react-router-v4><webpack-3>","0","2","","",""
"47435750","1","","","2017-11-22 13:18:43","","0","29","<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>

<p>I'm practicing with <a href=""https://reactjs.org/docs/state-and-lifecycle.html"" rel=""nofollow noreferrer"">react docs - state and lifecycle</a> that makes ticking clock. 
However, I can't understand why <strong>() => this.tick</strong> is used instead of just <strong>this.tick()</strong> in <strong>componentDidMount()</strong> function. It seems that just <strong>this.tick()</strong> does not make clock tick. What's the reason?</p>
","3858358","","","","","2017-11-22 13:18:43","making ticking clock with react","<javascript><reactjs>","0","0","","2017-11-22 13:20:17",""
"47983010","1","","","2017-12-26 19:40:29","","5","388","<p>I am trying to use <code>p5</code> (<a href=""https://p5js.org/"" rel=""nofollow noreferrer"">https://p5js.org/</a>) in a react application and the performance of some sketches is really bad (same in development as after building the app). I'm using <code>create-react-app</code> for the project scaffold, without any changes to the build setup. </p>

<p>The sketches run around 50-60fps when running them directly in the browser, but when loaded into react they drops to about 1-2fps.</p>

<p>I am connecting the sketches with react like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// React Component to interface the sketches
class P5Wrapper extends React.Component {

  componentDidMount() {
    const { sketch, ...rest } = this.props;
    this.canvas = new p5(sketch(rest), this.wrapper);
  }

  componentWillReceiveProps(newProps) {
    const { sketch, ...rest } = newProps;

    if (this.props.sketch !== newProps.sketch) {
      this.canvas.remove();
      this.canvas = new p5(newProps.sketch(rest), this.wrapper);
    }

    if (typeof this.canvas.onNewProps === ""function"") {
      this.canvas.onNewProps(newProps);
    }
  }

  componentWillUnmount() {
    this.canvas.remove();
  }

  render() {
    return &lt;div ref={(wrapper) =&gt; this.wrapper = wrapper} /&gt;;
  }
}

// you can watch the sketch in action here (https://p5js.org/examples/simulate-game-of-life.html)
const gameOfLife = (props) =&gt; (p) =&gt; {
  let w;
  let columns;
  let rows;
  let board;
  let next;

  p.setup = () =&gt; {
    p.createCanvas(1024, 768);
    p.background(255);
    p.noStroke();
    w = 20;

    columns = p.floor(p.width / w);
    rows = p.floor(p.height / w);

    board = new Array(columns);
    for (let i = 0; i &lt; columns; i++) {
      board[i] = new Array(rows);
    }

    next = new Array(columns);
    for (let i = 0; i &lt; columns; i++) {
      next[i] = new Array(rows);
    }
    init();
  };

  p.draw = () =&gt; {
    generate();
    for (let i = 0; i &lt; columns; i++) {
      for (let j = 0; j &lt; rows; j++) {
        if ((board[i][j] === 1)) p.fill(0);
        else p.fill(255);
        p.rect(i * w, j * w, w - 1, w - 1);
      }
    }
  };

  p.mousePressed = () =&gt; {
    init();
  };

  const init = () =&gt; {
    for (let i = 0; i &lt; columns; i++) {
      for (let j = 0; j &lt; rows; j++) {
        if (i === 0 || j === 0 || i === columns - 1 || j === rows - 1) board[i][j] = 0;
        else board[i][j] = p.floor(p.random(2));
        next[i][j] = 0;
      }
    }
  };

  const generate = () =&gt; {
    for (let x = 1; x &lt; columns - 1; x++) {
      for (let y = 1; y &lt; rows - 1; y++) {
        let neighbors = 0;
        for (let i = -1; i &lt;= 1; i++) {
          for (let j = -1; j &lt;= 1; j++) {
            neighbors += board[x + i][y + j];
          }
        }
        neighbors -= board[x][y];
        if ((board[x][y] === 1) &amp;&amp; (neighbors &lt; 2)) next[x][y] = 0;
        else if ((board[x][y] === 1) &amp;&amp; (neighbors &gt; 3)) next[x][y] = 0;
        else if ((board[x][y] === 0) &amp;&amp; (neighbors === 3)) next[x][y] = 1;
        else next[x][y] = board[x][y];
      }
    }
    const temp = board;
    board = next;
    next = temp;
  };
};

// render the wrapper and the sketch
ReactDOM.render(&lt;P5Wrapper sketch={gameOfLife} /&gt;, document.getElementById(""root""));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react-dom.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/p5.js""&gt;&lt;/script&gt;
&lt;div id=""root""/&gt;</code></pre>
</div>
</div>
</p>

<p>What could be causing the slowdown?</p>
","3595357","","8923816","","2018-02-10 22:24:09","2018-02-10 22:24:09","Slow performance, using p5 in react","<javascript><performance><reactjs><create-react-app><p5.js>","0","2","1","",""
"47426348","1","47426485","","2017-11-22 03:31:59","","1","275","<p>I'm making a personal website in react, and I wanted to do some tricks with scrolling, but ya know how it goes, getting stuck on step one. All I have in my react is</p>

<pre><code>  class App extends Component {
  makeTextLarger(e) {
    console.log(e)
    console.log(""scrolling"")
  }
  componentDidMount() {
      const list = ReactDOM.findDOMNode(this.refs.test)
      console.log(list)

      list.addEventListener('scroll', this.makeTextLarger);
  }
  componentWillUnmount() {
      const list = ReactDOM.findDOMNode(this.refs.test)
      list.removeEventListener('scroll', this.makeTextLarger);
  }
  render() {
    var style = {
      height: '10000px',
      fontSize: 200,
      background: 'blue'
    };
    return (
      &lt;div className=""App""&gt;
        &lt;header className=""App-header""&gt;
          &lt;img src={logo} className=""App-logo"" alt=""logo"" /&gt;
          &lt;h1 className=""App-title""&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className=""App-intro""&gt;
          text to be made bigger at some point
        &lt;/p&gt;
        &lt;div ref=""test"" style={style}&gt;
          Pls
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>In which nothing fires as I scroll. If I instead look at use window instead of the specific div, it works. When I console.log the list, it does indeed return an html object, so Im not sure why my binding is working selectively. Any thoughts?</p>
","6431038","","","","","2017-11-22 03:57:56","onScroll in react only works on the window?","<reactjs>","2","0","","",""
"32092020","1","","","2015-08-19 09:47:43","","3","1521","<p>I'm writing a very simple Nodejs app. I use React + Socket.io. </p>

<p>There's a root element which immediately renders another react component (you may wonder why I have this root element. The reason is that I want to be able to mount one of the two components after receiving a message from server, but for the start I render a preselected component). 
In this root component , I define a socket in <code>componentDidMount</code> . Now the problem is that I want to pass this socket to all of the children (so they can listen and communicate with the server messages.) But if I connect to the server in <code>componentDidMount</code> of the root, during the rendering there is no socket as it's not connected yet and <code>null</code> will be passed to the child components. </p>

<pre><code>'use strict';

var React = require('react');
var ioClient = require('socket.io-client');
var UsersList = require('./usersList');
var Game = require('./game');
var socket;

var Snake = React.createClass({

    displayName: 'Snake',

    propTypes: {},

    getDefaultProps: function() {
        return {};
    },

    mixins: [],

    getInitialState: function() {
        return ({
            usersList: true,
            game: false
        });
    },

    componentWillMount: function() {
    },

    componentWillUnmount: function() {
        this.socket.close();
    },
    componentDidMount: function() {
        socket = ioClient.connect(); // this happens after render
    },
    render: function() {
        var result = null;
        if (this.state.usersList) {
            result = &lt;UsersList socket={socket}/&gt; // therefore this one is passed as null
        } else { //game : true
            result = &lt;Game socket={socket}/&gt;
        }
        return (&lt;div&gt;
            {result}
        &lt;/div&gt;)
    }
});

module.exports = Snake;

'use strict';

var React = require('react');

    var UsersList = React.createClass({

        displayName: 'UsersList',

        propTypes: {},

        getDefaultProps: function() {
            return {};
        },

        mixins: [],

        getInitialState: function() {
            return ({
                usersList:[]
            });
        },
        componentWillReceiveProps: function(){
        },
        componentWillMount: function() {
        },

        componentWillUnmount: function() {
        },

        componentDidMount: function(){ 
            var socket = this.props.socket; // this one was passed into the component as null
            socket.on('usersList', function(data){ // so this one returns an error
                this.setState({
                    usersList: data.usersList
                });
            });
        },
        render: function() {
            var users = [];
            for (var i = 0 ; i &lt; this.state.usersList.length ; i++){
                users.push(&lt;span&gt;{this.state.usersList[i]}&lt;/span&gt;);
            }
            return(&lt;div&gt;{users}&lt;/div&gt;);
        }
    });

    module.exports = UsersList;
</code></pre>

<p>So , now you may ask why I don't put <code>io.connect()</code> in <code>componentWillMount</code> or at the top of the file. Well , it doesn't work ! it returns this error : <code>Cannot find property ""protocol"" ...</code>. 
I cannot put it in <code>render</code> , <code>componentWillMount</code> , top of the file ...</p>

<p>Any idea on how to do this ? </p>
","1664315","","","","","2015-08-21 00:16:55","socket.io-client + react, where to connect to the server?","<node.js><socket.io><reactjs>","1","1","1","",""
"48062682","1","48510063","","2018-01-02 14:24:34","","5","533","<p>I'm trying to query the server to get list of nav items so I can build my menu on init. I've so far managed to create a static page with 3 contents on the home page, which includes header, sidebar and content. The sidebar is the menu which is different for different type of users so I need to retrieve the menu items on load. </p>

<p>Error I receive is </p>

<blockquote>
  <p>Can only update a mounted or mounting component. This usually means you called setState, replaceState, or forceUpdate on an unmounted component. This is a no-op</p>
</blockquote>

<p><strong>Update 4</strong></p>

<p>so i moved my api requests to <code>index.js</code> file and tried to add the condition as mentioned in the <a href=""https://react-cn.github.io/react/tips/if-else-in-JSX.html"" rel=""nofollow noreferrer"">comment</a>. Now it just renders <code>Loading...</code> with the same error</p>

<pre><code>    import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'core-js/fn/promise';

import SideBar from './components/sidebar';
import Header from './components/header';
import HomeContent from './components/home';


function getJSON(url) {
  return get(url).then(JSON.parse);
}

function get(url) {
  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // This is called even on 404 etc
      // so check the status
      if (req.status == 200) {
        // Resolve the promise with the response text
        resolve(req.response);
      }
      else {
        // Otherwise reject with the status text
        // which will hopefully be a meaningful error
        reject(Error(req.statusText));
      }
    };

    // Handle network errors
    req.onerror = function() {
      reject(Error(""Network Error""));
    };

    // Make the request
    req.send();
  });
}

class App extends Component {
    constructor(props){
        super(props);
        this.state = {
                        username: '',
                        user,
                        loading1: true ,
                        menuList : [],
                        loading2: true
        };
    }

    componentDidMount() {
        let currentComponent = this;

        getJSON('/api/user/get/user/method/user/format/json?quiet=1').then((response) =&gt; {
            //console.log(JSON.stringify(response));
            //currentComponent.state.username = response.body.recordset.record[0].name;
            //currentComponent.state.user = response.body.recordset.record[0];
            currentComponent.setState({
                username: response.body.recordset.record[0].name,
                loading1: false
            });
        }).catch(error =&gt; {
            console.log('Error', error);
        });

        getJSON('/api/user/get/user/method/menu/format/json?quiet=1').then((response) =&gt; {
            console.log(JSON.stringify(response));
            let menuData = response.body.recordset.record;
            let menuList = [];
            var i = 0;
            menuData.container.forEach(menus =&gt; {
                menus.sub_modules.forEach(submenu =&gt; {
                    menuList.push(&lt;li className=""menu"" key={i}&gt;{ submenu.title }&lt;/li&gt;);
                    i++
                    if (submenu.menuitem.length) {
                        submenu.menuitem.forEach(menuitem =&gt; {
                            menuList.push(&lt;li key={i}&gt;&lt;a href={menuitem.link}&gt;{ menuitem.title }&lt;/a&gt;&lt;/li&gt;);
                            i++;
                        })
                    }
                })
            });
            currentComponent.setState({
                menuList: menuList,
                loading2: false
            });
        }).catch(error =&gt; {
            console.log(""Failed!"", error);
            $('#myModalError .modal-body').html(error);
            $('#myModalError').modal('show');
        });
    }

    componentWillUnmount() {}

    render() {
        let content = '';
        console.log(this.state);
        if(this.state.loading1 || this.state.loading2) {
            content = &lt;div&gt;Loading...&lt;/div&gt;
        }else{
            content =
                &lt;div id=""wrapper"" className=""toggled""&gt;
                    &lt;Header username={this.state.username}/&gt;
                    &lt;SideBar menuList={this.state.menuList}/&gt;
                    &lt;HomeContent /&gt;
                &lt;/div&gt;

        }
        return &lt;div&gt;
                   {content}
               &lt;/div&gt;
    }
};

ReactDOM.render(&lt;App/&gt;,  document.getElementById(""app""));
</code></pre>

<p><a href=""https://i.stack.imgur.com/5Yn9E.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5Yn9E.png"" alt=""enter image description here""></a></p>

<p><strong>here is IE error</strong></p>

<p><a href=""https://i.stack.imgur.com/qMVri.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qMVri.png"" alt=""IE console error""></a></p>

<p><a href=""https://i.stack.imgur.com/B67Uc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B67Uc.png"" alt=""detailed ie error""></a></p>

<p><strong>sidebar.js</strong></p>

<pre><code>import React, { Component } from 'react';

let menuList = [];
class SideBar extends Component {
    constructor(props){
        super(props);
    }

    render () {
        return (
            &lt;div id=""sidebar-wrapper"" className=""hidden-print""&gt;
                &lt;ul className=""sidebar-nav""&gt;
                {this.props.menuList}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }
}

export default SideBar;
</code></pre>

<p>I have created a <a href=""https://jsfiddle.net/shorif2000/gabgc28e/"" rel=""nofollow noreferrer"">jsfiddle</a></p>

<p>webpack</p>

<pre><code>var HTMLWebpackPlugin = require('html-webpack-plugin');
var HTMLWebpackPluginConfig = new HTMLWebpackPlugin({
    template: __dirname + '/app/index.html',
    filename: 'index.html',
    inject: 'body'
});

const ExtractTextPlugin = require(""extract-text-webpack-plugin"");

const extractSass = new ExtractTextPlugin({
    filename: ""[name].[contenthash].css"",
    disable: process.env.NODE_ENV === ""development""
});

module.exports = {
    entry : [__dirname + '/app/index.js'],
    module: {
         rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            } ,
            {
                test: /\.scss$/,
                use: [{
                    loader: ""style-loader""
                }, {
                    loader: ""css-loader""
                }, {
                    loader: ""sass-loader"",
                }]
            }
        ],
    },
    output: {
        filename: 'transformed.js',
        path: __dirname + '/docs'
    },
    plugins: [
        HTMLWebpackPluginConfig
    ]
}


{
  ""name"": ""ccp-react"",
  ""version"": ""1.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""start"": ""webpack-dev-server"",
    ""build"": ""webpack""
  },
  ""private"": true,
  ""dependencies"": {
    ""babel-helper-bindify-decorators"": ""^6.24.1"",
    ""babel-plugin-lodash"": ""^3.3.2"",
    ""babel-plugin-syntax-dynamic-import"": ""^6.18.0"",
    ""babel-plugin-syntax-flow"": ""^6.18.0"",
    ""babel-plugin-transform-class-properties"": ""^6.24.1"",
    ""babel-plugin-transform-decorators"": ""^6.24.1"",
    ""babel-plugin-transform-react-display-name"": ""^6.25.0"",
    ""babel-plugin-transform-react-jsx"": ""^6.24.1"",
    ""babel-polyfill"": ""^6.26.0"",
    ""babel-preset-env"": ""^1.6.1"",
    ""babel-preset-es2015"": ""^6.24.1"",
    ""babel-preset-es2016"": ""^6.24.1"",
    ""babel-preset-es2017"": ""^6.24.1"",
    ""babel-preset-flow"": ""^6.23.0"",
    ""babel-preset-react-optimize"": ""^1.0.1"",
    ""babel-preset-stage-1"": ""^6.24.1"",
    ""babel-preset-stage-3"": ""^6.24.1"",
    ""bootstrap"": ""^3.3.7"",
    ""classnames"": ""^2.2.5"",
    ""commander"": ""^2.12.2"",
    ""create-react-class"": ""^15.6.2"",
    ""cross-env"": ""^5.1.3"",
    ""gulp"": ""^3.9.1"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""ng"": ""0.0.0-rc6"",
    ""ng-cli"": ""^0.7.0"",
    ""react"": ""^16.2.0"",
    ""react-dom"": ""^16.2.0"",
    ""react-icons-kit"": ""^1.0.7"",
    ""react-redux"": ""^5.0.6"",
    ""react-router"": ""^4.2.0"",
    ""react-router-dom"": ""^4.2.2"",
    ""react-side-bar"": ""^0.3.5"",
    ""react-sidenav"": ""^2.1.2"",
    ""redux"": ""^3.7.2"",
    ""rxjs"": ""^5.5.6"",
    ""systemjs"": ""^0.20.19"",
    ""web-animations-js"": ""^2.3.1"",
    ""zone.js"": ""^0.8.19""
  },
  ""devDependencies"": {
    ""@types/jasmine"": ""~2.5.53"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^6.0.95"",
    ""babel-core"": ""^6.26.0"",
    ""babel-loader"": ""^7.1.2"",
    ""babel-preset-react"": ""^6.24.1"",
    ""core-js"": ""^2.5.3"",
    ""css-loader"": ""^0.28.8"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""html-webpack-plugin"": ""^2.30.1"",
    ""jasmine-core"": ""~2.6.2"",
    ""jasmine-spec-reporter"": ""~4.1.0"",
    ""karma"": ""~1.7.0"",
    ""karma-chrome-launcher"": ""~2.1.1"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^1.3.3"",
    ""karma-jasmine"": ""^1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""node-sass"": ""^4.7.2"",
    ""protractor"": ""~5.1.2"",
    ""sass-loader"": ""^6.0.6"",
    ""style-loader"": ""^0.19.1"",
    ""ts-node"": ""~3.2.0"",
    ""tslint"": ""~5.7.0"",
    ""typescript"": ""~2.4.2"",
    ""webpack"": ""^3.10.0"",
    ""webpack-bundle-analyzer"": ""^2.8.2"",
    ""webpack-dev-server"": ""^2.9.7""
  }
}
</code></pre>

<p>setstate issue still exists even with same code as the one in the fiddle. the fiddle works</p>

<p><a href=""https://i.stack.imgur.com/dWsXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dWsXf.png"" alt=""setstate""></a></p>
","1164789","","1164789","","2018-01-10 10:54:38","2018-01-29 21:13:06","react warning cannot set state when using promises","<javascript><reactjs><webpack><promise><babel-polyfill>","7","9","1","",""
"32014655","1","","","2015-08-14 16:27:35","","1","276","<p>I'm using react and backbone models in my app. To communicate with each other I use higher order components (<a href=""https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750"" rel=""nofollow"">https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750</a>). </p>

<p>Let say I have a backbone model:</p>

<pre><code>class Item extends Backbone.Model {
  defaults() {
    return {
      id: null,
      name: 'item',
      subItems: [],
      link: null
    };
  }

  // This is sample API response to GET /item/1
  {
    id: 1,
    name: 'item1',
    link: '/item/1',
    subItems: [{
      id: 2,
      name: 'item2',
      link: '/item/2', 
      subItems: []
    }, {
      id: 3,
      name: 'item3',
      link: '/item/3', 
      subItems: []
    }]
  }

  // This is sample API response to GET /item/2
  {
    id: 2,
    name: 'item2',
    link: '/item/2', 
    subItems: []
  }
}
</code></pre>

<p>and react component:</p>

<pre><code>class ItemComponent extends React.Component {
  constructor(props, context) {
    super(props, context);
  }

  onClickLink(link, e) {
    e.preventDefault();
    this.context.router.transitionTo(link);
  }

  render() {
    const itemData = this.props.data.toJSON();
    const itemNodes = itemData.map(function(item) {
      return (
        &lt;li&gt;&lt;a href='' onClick={this.onClickLink.bind(this, item.link)}&gt;{item.name}&lt;/a&gt;&lt;/li&gt;
      );
    });

    return (
      &lt;div&gt;
        &lt;span&gt;{itemData.name}&lt;/span&gt;
        &lt;ul&gt;{itemNodes}&lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

ItemComponent.contextTypes = {
  router: React.PropTypes.func.isRequired
};
</code></pre>

<p>and I have my higher order component</p>

<pre><code>const item = new Item();
const NewComponent = connectToModel(ItemComponent, item);
</code></pre>

<p>where</p>

<pre><code>function connectToModel(Component, model) {
  class ComponentConnection extends React.Component {
    constructor(props, context) {
      super(props, context);
      this.state = {
        data: model
      };
    }

    componentDidMount() {
      model.on('add remove change', this.onModelChange.bind(this));
    }

    componentWillUnmount() {
      model.off(null, null, this.onModelChange.bind(this));
    }

    onModelChange() {
      this.setState({
        data: model 
      });
    }

    render() {
      return (
        &lt;Component
          {...this.state}
          {...this.props}
        /&gt;
      );
    }
  }
}
</code></pre>

<p>my routes:</p>

<pre><code>const Routes = (
    &lt;Route handler={App} path=""/""&gt;
      &lt;Route name=""item"" path=""item/:id"" handler={Item} /&gt;
    &lt;/Route&gt;
);
</code></pre>

<p>My questions:</p>

<ol>
<li><p>How can I call the API to fetch data before rendering when user requesting url <code>/item/1</code> so instead of <code>const item = new Item();</code> I would call something like <code>const item = new Item({id: 1});</code>.</p></li>
<li><p>When user click on a subitem, react router will get him to e.g <code>/item/2</code>, but then how I can tell to my react component that the route param has change therefore fetch new model override my current one and render new data.</p></li>
</ol>
","2728962","","","","","2015-08-25 13:02:59","react + backbone + react-router, fetching models","<javascript><backbone.js><reactjs><react-router>","1","0","","",""
"40868171","1","","","2016-11-29 14:19:43","","1","441","<p>I am struggling a bit with some react fundamentals, mainly the flow of data and the jsx syntax, sorry about the noob question.</p>

<p>I have two json that I am making chained api calls to in Main.js, the data is then passed down to SensorList.js. In this component I have a function that renders a list of sensors, each Sensor.js has it key set to an id specified in the json and has its props set based on the data in the json. </p>

<p>Currently I am able to grab the first corresponding piece of data for each sensor and pass this down to the relevant child components. I need to pass down the whole array of the corresponding data to a child Graph.js component, currently my map function is grabbing only the first element in each array. </p>

<p>My question is how do I actually pass down the whole arrays of the value and time data of each sensor to it's child graph component?</p>

<p>Thanks in advance.</p>

<p>sensors.json</p>

<pre><code>[
  {
    ""id"": ""46c634d04cc2fb4a4ee0f1596c5330328130ff80"",
    ""name"": ""external""
  },
{
    ""id"": ""d823cb4204c9715f5c811feaabeea45ce06736a0"",
    ""name"": ""office""
  },
{
    ""id"": ""437b3687100bcb77959a5fb6d0351b41972b1173"",
    ""name"": ""common room""
  }
]
</code></pre>

<p>Sample of data.json</p>

<pre><code>[
  {
    ""sensorId"": ""437b3687100bcb77959a5fb6d0351b41972b1173"",
    ""time"": 1472120033,
    ""value"": 25.3
  },
{
   ""sensorId"": ""437b3687100bcb77959a5fb6d0351b41972b1173"",
   ""time"": 1472119853,
   ""value"": 25.1
 },
{
  ""sensorId"": ""437b3687100bcb77959a5fb6d0351b41972b1173"",
  ""time"": 1472119673,
  ""value"": 25.1
},
</code></pre>

<p>SensorList.js</p>

<pre><code>var SensorList = React.createClass({
  render: function() {
    var {data, sensors} = this.props;

    var renderSensors = () =&gt; {
      return sensors.map((sensor) =&gt; {
        return &lt;Sensor key={sensor.id} name={sensor.name} value={data.get(sensor.id)}/&gt;
        });
    };

    return (
      &lt;div&gt;
        {renderSensors()}
      &lt;/div&gt;
    );
  }
});
</code></pre>

<p>Main.js</p>

<pre><code>var Main = React.createClass({
  getInitialState: function() {
    return {
      sensors: [],
      sensorsData: []
    };
  },

  componentDidMount: function() {
    var _this = this;
    this.serverRequest =
      axios
        .get(""http://localhost:3000/sensors.json"")
        .then(function(result) {
          _this.setState({
            sensors: result.data
          });
        })
      axios
        .get(""http://localhost:3000/data.json"")
        .then(function(result) {
          var sensorDataToId = new Map();
          for(var i = 0; i &lt; result.length; i++) {
            var datum = result[i];
            var sensorId = datum.sensorId;
            if (sensorDataToId.get(sensorId) === undefined) {
              sensorDataToId.set(sensorId, []);
            }

            sensorDataToId.get(sensorId).push(datum)
          }
          _this.setState({
            sensorsData: result.data
          });
        })
  },

  componentWillUnmount: function() {
    this.serverRequest.abort();
  },

  render: function() {
    var {sensors, sensorsData} = this.state;

    return (
      &lt;div className=""sensorList""&gt;
        &lt;SensorList sensors={sensors} data={sensorsData}/&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
","6156930","","6156930","","2016-11-30 11:50:16","2016-11-30 11:50:16","Using the map function in react and parsing data down to child components","<javascript><reactjs>","2","0","","",""
"29977799","1","29981486","","2015-04-30 21:10:16","","27","21761","<p>I was wondering if anyone could provide some insight about how they handle leave animations in React.js. I have been using Greensock TweenMax and the enter animations work fine on <code>componentDidMount</code>, but I haven't found a reliable way to animate a component out.</p>

<p>My feeling is that it should go in <code>componentWillUnmount</code>, but React provides no callback mechanism for you to indicate when you are ready to let go of a component. Therefore the transition animation never completes since the animations are asynchronous to React. Instead, you see a tiny fraction of a second of animation, the component disappears, and is replaced by the next component animating in.</p>

<p>This is a problem I have struggled with since I started using React 9 months ago. I can't help but think there has to be a solution out there other than <code>ReactCSSTransitionGroup</code> which I find to be cumbersome and finicky, especially with react-router.</p>
","3833591","","64046","","2015-04-30 23:03:20","2017-01-26 17:02:29","How should I handle a leave animation in componentWillUnmount in React?","<javascript><animation><reactjs><tweenmax>","2","1","23","",""
"47884059","1","47884589","","2017-12-19 09:45:04","","0","394","<p>I have a react component which take a dom reference when mounting (I know this is an edge case). I would like to know if it is necessary set to <code>null</code> the property which host the dom. Or does react take care of it?</p>

<pre><code>componentDidMount() {
   this.elm = document.getElementById('foo')
}

componentWillUnmount(){
   this.elm = null
}
</code></pre>
","6426229","","","","","2017-12-19 10:11:57","Should I remove a reference to a DOM element when a component unmount in react?","<javascript><reactjs><dom>","1","3","","",""
"47961072","1","","","2017-12-24 13:41:35","","2","144","<p>I would like to load data automatically every seconds.</p>

<p>I use <strong>setinterval</strong> but it always said error like this</p>

<p><strong>""TypeError: undefined is not a function (near '...this.state.forumContentData.map...')""</strong></p>

<p>Here is what I tried:</p>

<pre><code>constructor(props) {
  super(props);
  this.state = {
    forumContentData: []
  }
}

componentDidMount() {
  // Set timer before going to the Next Action - Every Seconds
  this._interval = setInterval(() =&gt; {
    this.getForumContent();
  }, 1000);
}

componentWillUnmount() {
    clearInterval(this._interval);
}

getForumContent() {
  return fetch('http://' + ipAddress() + ':' + portAddress() + '/api/forum/view_thread', {
    method: 'GET',
    headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    }
  })
  .then((response) =&gt; response.json())
  .then((responseJson) =&gt; {
    this.setState({forumContentData: responseJson}); // Get the data from API
  })
  .catch((error) =&gt; {
    //console.error(error);

    alert(error);
  });
}

render() {

  let forumContentResult = this.state.forumContentData.map((forumContentDataDetail, index) =&gt; {
      var forum_title = forumContentDataDetail.title;

      return (
        &lt;Text&gt;{forum_title}&lt;/Text&gt;
      );
  });


}
</code></pre>

<p>What would be the best way to load data every seconds automatically in react native?</p>
","2534161","","","","","2017-12-25 23:16:49","How to load data every seconds automatically in react native?","<javascript><react-native>","1","2","1","",""
"32033711","1","32046636","","2015-08-16 09:41:35","","2","994","<p>I'm try to test my ReactJS mixin for drag and drop functionality using jasmine, karma and React TestUtils.</p>

<p>No exception is thrown but when debugging it seems that the function bound to the event listener not being executed when the event is simulated.</p>

<p>You can clone the it here:
<a href=""https://github.com/itsh01/react-dragdrop/tree/testing-simutale-events"" rel=""nofollow"">https://github.com/itsh01/react-dragdrop/tree/testing-simutale-events</a></p>

<p>Thank you very much in advance.</p>

<p>Here is my test:</p>

<pre><code>beforeEach(function () {

    var CompDrag = React.createClass({
        mixins: [DragDropMixin],
        dragDrop: function dragDrop() {
            return {
                draggable: true,
                dropType: 'test',
                dataTransfer: {
                    test: true
                }
            };
        },
        render: function render() {
            return React.createElement('div', {});
        }
    });

    var CompDrop = React.createClass({
        mixins: [DragDropMixin],
        dragDrop: function dragDrop() {
            var self = this;
            return {
                droppable: true,
                acceptableTypes: ['test'],
                drop: function (data) {
                    self.setState(data);
                }
            };
        },
        render: function render() {
            return React.createElement('div', {});
        }
    });

    elementDrag = React.createElement(CompDrag, {});
    elementDrop = React.createElement(CompDrop, {});

});

...

it('should attach drop functionality when configured', function () {
    var renderedDrag = TestUtils.renderIntoDocument(elementDrag);
    var renderedDrop = TestUtils.renderIntoDocument(elementDrop);
    var nodeDrag = renderedDrag.getDOMNode();
    var nodeDrop = renderedDrop.getDOMNode();
    var mockEvent = {
        preventDefault: function () {},
        dataTransfer: {
            types: [""objtopass""],
            setData: function () {},
            getData: function () {
                return JSON.parse({
                    dropType: 'test',
                    data: {
                        test: true
                    }
                });
            }
        }
    };

    TestUtils.SimulateNative.dragStart(nodeDrag, mockEvent);
    TestUtils.Simulate.dragOver(nodeDrop, mockEvent);
    TestUtils.Simulate.drop(nodeDrop, mockEvent);

    expect(renderedDrop.state).not.toBeNull();
});
</code></pre>

<p>Here is the mixin:</p>

<pre><code>'use strict';

var _ = lodash;

var DragDropMixin = {
    /*
     *  usage:
     *
     *  mixins: [DragDropMixin],
     *  dragDrop: function () {
     *
     *     return {
     *
     *         // when dragging an item
     *         draggable: true,
     *         dropType: 'myItem',
     *         dataTransfer: { myItemData: property }
     *
     *         // when dropping an item:
     *         droppable: true,
     *         acceptableDrops: ['myItem'],
     *         drop: function (myItem) {},
     *     };
     *  }
     *
     */
    isAttrEnabled: function (attr) {
        return this.dragDropData &amp;&amp; this.dragDropData[attr];
    },
    isDroppable: function () {
        return this.isAttrEnabled('droppable');
    },
    isDraggable: function () {
        return this.isAttrEnabled('draggable');
    },
    componentDidMount: function () {
        var node = this.getDOMNode();

        this.dragDropData = this.dragDrop();

        if (this.isDroppable()) {
            node.addEventListener('dragover', this.handleDragOver, this);
            node.addEventListener('drop', this.handleDrop, this);
        }

        if (this.isDraggable()) {
            node.draggable = true;
            node.addEventListener('dragstart', this.handleDragStart, this);
        }
    },
    componentWillUnmount: function () {
        var node = this.getDOMNode();

        if (this.isDroppable()) {
            node.removeEventListener('dragover', this.handleDragOver);
            node.removeEventListener('drop', this.handleDrop);
        }

        if (this.isDraggable()) {
            node.removeEventListener('dragstart', this.handleDragStart);
        }
    },
    handleDragOver: function (e) {
        e.preventDefault();
    },
    handleDrop: function (e) {
        var jsonData = e.dataTransfer.getData('objToPass'),
            passedObj = JSON.parse(jsonData),
            acceptableDrops = this.dragDropData.acceptableDrops;

        e.preventDefault();

        if (!this.dragDropData.drop) {
            throw new Error('Must define drop function when using droppable');
        }

        if (_.includes(acceptableDrops, passedObj.dropType)) {
            this.dragDropData.drop(passedObj.data);
        }

    },
    handleDragStart: function (e) {
        var objToPass = {
            data: this.dragDropData.dataTransfer,
            dropType: this.dragDropData.dropType
        };

        e.dataTransfer.setData('objToPass', JSON.stringify(objToPass));
    }
};
</code></pre>

<p>Thanks again.</p>
","5232011","","","","","2015-08-17 09:13:22","Simulating drag drop with react testutils not working","<javascript><drag-and-drop><reactjs><karma-jasmine><reactjs-testutils>","1","0","1","",""
"32098837","1","","","2015-08-19 14:49:27","","0","134","<p>Im changing the style of a component root div by browser resize. This triggers every single child to render also. Im in process of doing a complex map with many child components including tables and fb fixed table component. </p>

<p>The component has basicly 3 child tables one of them also gets the new width/height from the main component. All are in there own divs.</p>

<p>I just started with react a few days ago, hope someone can give me tips.
Please let me know if something is unclear.</p>

<p>Resizing:</p>

<pre><code>getInitialState: function() {
    return {
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight
    };
},

handleResize: function(e) {
    this.setState({
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight
    });
},

componentDidMount: function() {
    window.addEventListener('resize', this.handleResize);
},

componentWillUnmount: function() {
    window.removeEventListener('resize', this.handleResize);
},
</code></pre>

<p>style object</p>

<pre><code>    var style = {
        width: this.state.windowWidth,
        height: this.state.windowHeight,
        position: ""absolute""
    };  
</code></pre>

<p>render()</p>

<pre><code>    return (
        &lt;div className=""map_quadrant"" ref=""map_quadrant"" style={style}&gt;

...

                &lt;div className=""column""&gt;
                    &lt;div className=""ui top attached segment""&gt;
                        &lt;div className=""ui top attached label""&gt;Current Selection Summary for {this.props.model._name}&lt;/div&gt;
                        &lt;SummaryTable model_name={this.props.model._name} model={this.props.model} keys={this.props.model.simpleSchema()._schemaKeys} /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    &lt;MasterTable width={this.state.windowWidth} height={this.state.windowHeight/2} model_name={this.props.model._name} data={this.state.model_data} keys={this.props.model.simpleSchema()._schemaKeys} /&gt;
                &lt;/div&gt;
</code></pre>

<p>(its experimental code, so definitely not optimal)</p>
","2984112","","","","","2015-08-19 14:49:27","reactjs (+meteor) on browser resize change style but not rerender complete childs tree","<javascript><meteor><reactjs><fixed-data-table>","0","3","","",""
"32121231","1","34200536","","2015-08-20 14:39:49","","7","3472","<p>I am coding a simple app on reactjs-flux and everything works fine except I am receiving a warning from reactjs telling me that I am calling setState on unmounted components.</p>

<p>I have figured out this is because changelisteners to which components are hooked are not being removed from the store on <code>componentWillUnmount</code>. I know it because when I print the list of listeners from <code>Eventemitter</code> I see the listener which was supposed to be destroyed still there, and the list grows larger as I mount/unmount the same component several times. </p>

<p>I paste code from my BaseStore:</p>

<pre class=""lang-js prettyprint-override""><code>import Constants from '../core/Constants';
import {EventEmitter} from 'events';

class BaseStore extends EventEmitter {
  // Allow Controller-View to register itself with store
  addChangeListener(callback) {
    this.on(Constants.CHANGE_EVENT, callback);
  }

  removeChangeListener(callback) {
    this.removeListener(Constants.CHANGE_EVENT, callback);
  }

  // triggers change listener above, firing controller-view callback
  emitChange() {
    this.emit(Constants.CHANGE_EVENT);
  }
}

export default BaseStore;
</code></pre>

<p>I paste the relevant code from a component experiencing this bug  (it happens with all components, though):</p>

<pre class=""lang-js prettyprint-override""><code>@AuthenticatedComponent
class ProductsPage extends React.Component {
  static propTypes = {
    accessToken: PropTypes.string
  };

  constructor() {
    super();
    this._productBatch;
    this._productBatchesNum;
    this._activeProductBatch;
    this._productBlacklist;
    this._searchById;
    this._searchingById;
    this.state = this._getStateFromStore();
  }

  componentDidMount() {
    ProductsStore.addChangeListener(this._onChange.bind(this));
  }

  componentWillUnmount() {
    ProductsStore.removeChangeListener(this._onChange.bind(this));
  }

  _onChange() {
    this.setState(this._getStateFromStore());
  }
}
</code></pre>

<p>This is driving me pretty nuts at this point. Any ideas?</p>

<p>Thank you!</p>
","1177084","","990356","","2016-11-17 03:23:15","2016-11-17 03:23:15","Stores' change listeners not getting removed on componentWillUnmount?","<reactjs><reactjs-flux><flux>","7","2","6","",""
"32247605","1","","","2015-08-27 11:00:39","","4","539","<p>I am trying to understand how componentWillUnmount works in reactjs. Does it get called automatically or do we need to manually call unmountComponentAtNode to make it work? </p>

<p>I am using reactjs with angular and rendering the parent component inside the directive. Now, what I want is that when I change the route, I want my parent component's componentWillUnmount to run and do the necessary cleanup before ng-view is replaced with another directive containing another parent component.</p>
","4623273","","2209007","","2015-08-27 12:08:32","2015-08-27 12:08:32","How to make componentWillUnmount work?","<angularjs><reactjs>","1","0","","",""
"48851613","1","","","2018-02-18 12:22:44","","0","49","<p>I have a simple react application. I want to call a component on a click event. Now what happens is when I click that function, it gets called but that component doesn't change. I tried the checking the path and all everything seems fine as when I put the same component in render it gets executed. Here's my code:</p>

<p>Please let me know what am I doing wrong.</p>

<p>Please ignore some of the wrong if else condition, I have put them trying to bug to no avail.</p>

<p>header.jsx</p>

<pre><code>   class Head extends React.Component {
  handleClick = (e) =&gt; {
    console.log(e.key);
    &lt;Cont key1 = e.key /&gt;
  }


  render(){
      return( 
      &lt;Header&gt;
        &lt;div className=""logo"" /&gt;
        &lt;Menu
        onClick={ this.handleClick }&gt;
        &lt;Menu.Item key=""1""&gt;Hungry Rides&lt;/Menu.Item&gt;
        &lt;Menu.Item key=""2""&gt;Hiker's Diary&lt;/Menu.Item&gt;
        &lt;Menu.Item key=""3""&gt;Hiking @ Hometown &lt;/Menu.Item&gt;
      &lt;/Menu&gt;
    &lt;/Header&gt;
    )
  }
}
</code></pre>

<p>content.jsx</p>

<pre><code>    class Cont extends React.Component {

  constructor(props) {
    super(props);
    thisDefault = this.props.key1
    console.log('inside constructor')
    // alert(this.props.key1)
    if ( thisDefault != 100){
        alert('miracle')
    thisDefault = 1
  }


componentWillMount() {
    console.log('component mounted')
}

componentWillUnmount() {
    console.log('unmounted')
}

componentWillReceiveProps() {
    console.log('ghfdshg')
}



  render(){
    console.log('called from key')
    let data = null
     if(thisDefault == null) {
     data = (
      &lt;div id = ""journal"" style={{ background: '#fff', padding: 24 , textAlign : 'center'}}&gt;
       &lt;Intro /&gt;
      &lt;/div&gt;
      )
  }
  else{
  data = (  &lt;div id = ""journal"" style={{ background: '#fff', padding: 24 , textAlign : 'center'}}&gt;
       &lt;h1&gt; Hello &lt;/h1&gt;
      &lt;/div&gt;
      )
  }
    return( 
        &lt;Content style={{ padding: '0 50px' }}&gt;
        &lt;Bread /&gt;
        &lt;Slider /&gt;
    {data}
    &lt;/Content&gt;

    )}}

    export default Cont
</code></pre>
","3949511","","","","","2018-02-18 13:08:30","How to call a component on a click event in react?","<javascript><reactjs>","1","2","","",""
"48217565","1","","","2018-01-11 23:46:47","","1","153","<p>After making a stand alone three js app I wanted to make this three js app a component in my React application.</p>

<p>I needed multiple scenes overlayed so I made a threeApp function that instantiates a scene, camera, renderer and adds it to the DOM. So I tried to make a lot of stuff reusable. </p>

<p>After following <a href=""https://stackoverflow.com/questions/41248287/how-to-connect-threejs-to-react"">this answer</a> I managed to get some a three js scene with a spinning cube in my react app. Success! Since I already made a functioning OOP (?) implementation without react so I dove right in. </p>

<p>Right now I have a rendered canvas in my app but the objects in it are not getting rendered. However I can see the scene in three js inspector extension. If I console log at the animate/update functions they all fire.</p>

<p>This is the react component copied from this <a href=""https://stackoverflow.com/questions/41248287/how-to-connect-threejs-to-react"">SO answer</a> which originally worked.</p>

<pre><code>import React, { Component } from 'react'
import * as THREE from 'three'

import testCube from ""./viz/testCube""
import VizHandler from './VizHandler'


class Visualizer extends Component {
  constructor(props) {
    super(props)

    this.start = this.start.bind(this)
    this.stop = this.stop.bind(this)
    this.animate = this.animate.bind(this)
  }

  componentDidMount() {
    const vizHandler = this.vizHandler = new VizHandler();
    vizHandler.init(this.mount);
    this.start()
  }

  componentWillUnmount() {
    this.stop()
    // this.mount.removeChild(threeApps['vizholder'].getRenderer().domElement)
    // vizHandler.unmount(this.mount);
  }

  start() {
    if (!this.frameId) {
      this.frameId = requestAnimationFrame(this.animate)
    }
  }

  stop() {
    cancelAnimationFrame(this.frameId)
  }

  animate() {
    this.vizHandler.update(); // update / animate stuff in here

    this.vizHandler.render()
    this.frameId = window.requestAnimationFrame(this.animate)
  }

  render() {
    return (
      &lt;div
        // style={{ width: '400px', height: '400px' }}
        ref={(mount) =&gt; { this.mount = mount }}
      /&gt;
    )
  }
}

export default Visualizer
</code></pre>

<p>I handle multiple threejs scenes/canvases here in the VizHandler function/class</p>

<pre><code>import * as THREE from ""three"";
import threeApp from ""./threeApp"";
import WhiteRing from ""./viz/WhiteRing"";
import testCube from ""./viz/testCube"";
import Bars from ""./viz/Bars"";


const VizHandler = function () {

  var threeApps = [];
  var rings = new WhiteRing();
  var bars = new Bars();
  var cube = new testCube();

  function init(mount) {


      threeApps['vizholder'] = new threeApp();
      // threeApps['overlay'] = new threeApp();
      threeApps['vizholder'].init(mount, 'VizHolder') ;
      // threeApps['overlay'].init(mount, 'Overlay');

      window.scene = threeApps['vizholder'].getScene();
      window.THREE = THREE;

      const vizHolder = threeApps['vizholder'].getVizHolder();
      rings.init( vizHolder );
      bars.init( vizHolder );
      cube.init( vizHolder );

  }

  function update() {
    rings.update();
    bars.update();
    cube.update();
  }

  function render() {
    threeApps[""vizholder""].render();
  }


  return {
      init: init,
      update: update,
      render: render,
      getVizHolder: function( name ) {
          if ( name ) return threeApps[name].getVizHolder();
          else return threeApps['vizholder'].getVizHolder();
      },
      getRenderer: function( name ) {
          if ( name ) return threeApps[name].getRenderer();
          else return threeApps['vizholder'].getRenderer();
      },
      getThreeApps: function() {
          return threeApps
      },
  };

};
</code></pre>

<p>And this is the most basic cube to that I'm trying to render.</p>

<pre><code>import * as THREE from 'three';

const testCube = function () {

  let cube;

  function init (vizHolder) {

      const groupHolder = new THREE.Object3D();
      groupHolder.name = ""TemplateViz"";
      vizHolder.add(groupHolder);

      const geometry = new THREE.BoxGeometry(1, 1, 1)
      const material = new THREE.MeshBasicMaterial({ color: '#ffffff' })
      cube = new THREE.Mesh(geometry, material)
      cube.name = ""TESTCUBE"";
      groupHolder.add(cube);
      vizHolder.add(groupHolder);

  }

  function update() {
    cube.rotation.x += 0.01
    cube.rotation.y += 0.01
  }

  return {
    init: init,
    update: update,
  }

};

export default testCube;
</code></pre>

<p>And the result of all this is a renderer element in the dom that does not render my elements to the scene. I can change the renderer color and update the objects in the scene but I cannot make them appear.</p>

<p>EDIT: After solving the problem in my more simplified answer <a href=""https://stackoverflow.com/questions/48241380/react-three-js-scene-wont-render-until-manipulated-in-chrome-inspector-extension"">here</a>, I forgot to post 1 important file where the error eventually occurred. The threeApp class where I make scenes, renderers and camera's. The code below was the non working code.</p>

<pre><code>import * as THREE from ""three"";

function threeApp() {

  let camera, scene, renderer;
  let groundLight, skyLight, hemiLight;
  let vizHolder;
  let objName;
  let renderColor = '#909009';

  function init(mount, name) {

      objName = name;
      this.holderName = name;

      renderer = new THREE.WebGLRenderer({
          // antialias: true,
          // alpha: true
      });
      renderer.setSize(800, 600);

      renderer.domElement.className = ""renderer"";
      mount.appendChild(renderer.domElement);

      //3D SCENE
      camera = new THREE.PerspectiveCamera(70, 800 / 600, 1, 3000);
      camera.position.z = 1000;
      camera.name = ""camera"";


      scene = new THREE.Scene();
      // window.THREE = THREE;
      scene.name = name + "" scene"";
      console.log( 'name', name );
      if ( name == ""VizHolder"") {
          window.scene = scene;
      }
      camera.lookAt(scene);
      scene.fog = new THREE.Fog(0xffd8e5, 1000, 3000);
      scene.add(camera);

      //INIT VIZ
      vizHolder = new THREE.Object3D();
      vizHolder.name = name;

      scene.add(vizHolder);
  }


  function update () {
        render();
  }

  function render() {
    renderer.render(scene, camera);
  }

  function onResize () {

      var renderW = window.innerWidth;
      var renderH = window.innerHeight;
      camera.aspect = renderW / renderH;
      camera.updateProjectionMatrix();
      renderer.setSize(renderW, renderH);
  }

  return {
    init: init,
    render: render,
    onResize: onResize,
    getVizHolder: function() {
        return vizHolder;
    },
    getCamera: function() {
        return camera;
    },
    getScene: function() {
        return scene;
    },
    getRenderer: function() {
        return renderer;
    },
    setRenderColor: setRenderColor
}

};

export default threeApp
</code></pre>
","4358005","","4358005","","2018-01-20 00:10:06","2018-01-20 00:10:06","Three js not rendering objects in scene after OOP implementation in react","<javascript><reactjs><three.js>","0","1","1","",""
"48753480","1","","","2018-02-12 18:51:18","","0","46","<p>So i am new to learning Reactjs. While learning l had a old code which is written in reactjs version 0.13. And i want to add a <a href=""https://www.npmjs.com/package/react-portal-tooltip/%22Tooltip%22"" rel=""nofollow noreferrer"">ToolTip</a> on that button. I am not able to add because i know only new version code and how to add. So please suggest me what to do my container code is below</p>

<pre><code>define(['react'], function(React, ) {
     var D = React.DOM;
     return React.createClass({
         displayName: 'BetButton',
         propTypes: {
             engine: React.PropTypes.object.isRequired,
             placeBet: React.PropTypes.func.isRequired,
             cancelBet: React.PropTypes.func.isRequired,
             cashOut: React.PropTypes.func.isRequired,
             isMobileOrSmall: React.PropTypes.bool.isRequired,
             betSize: React.PropTypes.string.isRequired,
             betInvalid: React.PropTypes.any.isRequired,
             cashOutInvalid: React.PropTypes.any.isRequired,
             controlsSize: React.PropTypes.string.isRequired
         },
         getInitialState: function() {},
         style: function() {
             if (this.state.hovered) {
                 return {
                     backgroundColor: ""red""
                 }
             } else {
                 return {
                     backgroundColor: ""grey""
                 }
             }
         },
         onMouseOver: function() {
             this.setState({
                 hovered: true
             });
         },
         onMouseOut: function() {
             this.setState({
                 hovered: false
             });
         },
         componentDidMount: function() {},
         componentWillUnmount: function() {},
         render: function() {
             return D.div({
                 className: 'bet-button-container',
                 onClick: onClickFun,
                 onMouseDown: onMouseDownFun,
                 onMouseUp: onMouseUpFun,
                 onMouseOver: onMouseOverFun,
                 onMouseOver: this.onMouseOver,
                 onMouseOut: this.onMouseOut,
                 style: this.style()
             }, btnContent);
         }
     });
 });
</code></pre>

<p>Now my task is that to add a tooltip on mouseOver in that code. I am trying to change some css properties. I have no idea how to do that in old version code but i had dine in new reactjs app same stuff. Thanks for your time.</p>
","7943901","","9095070","","2018-02-12 20:24:00","2018-02-12 20:24:00","Add tooltip on a button in reactjs old version(0.13)","<javascript><css><node.js><reactjs>","0","0","","",""
"41030724","1","41030894","","2016-12-08 02:22:16","","0","47","<p>I quite new to react. What is <code>ref={node =&gt; (this.root = node)}</code> for in: </p>

<pre><code>import React from 'react';
import Navigation from './Navigation';
import Link from '../Link';
import s from './Header.css';

class Header extends React.Component {

  componentDidMount() {
    window.componentHandler.upgradeElement(this.root);
  }

  componentWillUnmount() {
    window.componentHandler.downgradeElements(this.root);
  }

  render() {
    return (
      &lt;header className={`mdl-layout__header ${s.header}`} ref={node =&gt; (this.root = node)}&gt;
        &lt;div className={`mdl-layout__header-row ${s.row}`}&gt;
          &lt;Link className={`mdl-layout-title ${s.title}`} to=""/""&gt;
            Igene Logo Here
          &lt;/Link&gt;
          &lt;div className=""mdl-layout-spacer""&gt;&lt;/div&gt;
          &lt;Navigation /&gt;
        &lt;/div&gt;
      &lt;/header&gt;
    );
  }

}

export default Header;
</code></pre>

<p><em>( from <a href=""https://github.com/kriasoft/react-static-boilerplate/blob/master/components/Layout/Header.js"" rel=""nofollow noreferrer"">react-static-boilerplate (RSB)</a> )</em></p>

<p>and it's relationship to mount and unmounting?</p>

<p>I get the concept of ref based on reading <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">this</a>, but still find it quite hard to understand when it is used in RSB. Can someone enlighten me how it works and also it's relationship to the <code>componentDidMount()</code> and <code>componentWillMount()</code></p>
","7215872","","7215872","","2016-12-08 03:31:40","2016-12-08 03:31:40","How react-static-boilerplate make use of react's ref for mounting and umounting?","<reactjs>","1","0","","",""
"48755214","1","48776058","","2018-02-12 20:43:13","","0","42","<p>I'm building a ReactJS SPA with Preact for learning purposes. Every once in a while, a component from a library I use (<a href=""https://github.com/ryanseddon/react-frame-component"" rel=""nofollow noreferrer""><code>react-frame-component</code></a>) will throw an exception when being unmounted, which breaks other parts of the application. This is a fairly sporadic error, and as such I've not been able to create a test-case that reproduces it.</p>

<p>I do know about <a href=""https://reactjs.org/docs/error-boundaries.html"" rel=""nofollow noreferrer"">error boundaries</a>, and did try wrapping the problematic <code>&lt;Frame&gt;</code> component in one, but it hasn't made a difference. Specifically, the error message I get is</p>

<pre><code>Uncaught (in promise) TypeError: Cannot read property 'body' of null
    at Frame.getMountTarget (Frame.js:112)
    at Frame.componentWillUnmount (Frame.js:95)
    at unmountComponent (preact.js:355)
    at unmountComponent (preact.js:358)
    at recollectNodeTree (preact.js:198)
    at removeChildren (preact.js:208)
    at recollectNodeTree (preact.js:201)
    at removeChildren (preact.js:208)
    at recollectNodeTree (preact.js:201)
    at removeChildren (preact.js:208)
</code></pre>

<p>I'm unsure how to go about capturing this error myself, or even just debugging it correctly. Any help would be appreciated. </p>
","7876637","","","","","2018-02-13 21:37:40","How to handle sporadic component unmount error with ReactJS/Preact?","<reactjs><preact>","1","1","","",""
"48317962","1","","","2018-01-18 09:35:32","","1","239","<p>I'm trying to understand how the device OS treats my react-native app when left in the background for a longer time, I'm guessing a whole lot of smart battery-conserving-logic of the OS comes into play. </p>

<p>In my main index.js I'm just doing this:</p>

<pre><code>import { AppRegistry } from 'react-native';
import App from './app/App';
AppRegistry.registerComponent('CopilotApp', () =&gt; App);
</code></pre>

<p>..so App.js contains my main component of the entire app, which then has a StackNavigator and a bunch of stuff.</p>

<p>My question is - how does the lifecycle work for this main App-component? When will <em>componentWillUnmount</em> get called / will it ever?</p>

<p>I'm trying to keep things clean by removing event listeners and so on in there, but haven't really figured out when / if that will happen.</p>
","5375556","","","","","2018-03-14 13:20:14","When does the main componentWillUnmount get called for a react-native app","<react-native><react-native-android><react-native-ios>","1","0","","",""
"48477051","1","","","2018-01-27 15:00:53","","1","31","<p>I have a small question about how to properly handle mutations in Apollo for React. </p>

<p><strong>Situation</strong></p>

<p>I want to set a state of the component after a successful mutation — but before setting the state I want to perform other mutation (using <code>@client</code>). Mutations return promises so my first attempt was to <strong>chain promises</strong>, but then I realize that the remote mutation could take a long time and a user could go to another page and when the promise resolves my component will be <strong>unmounted</strong> already.</p>

<p>At the moment I consider 2 approaches to solve the issue:</p>

<ol>
<li><p>To use <strong>EventEmitter</strong> and emit an event on mutation finish. Subscribe at <code>componentDidMount</code> and unsubscribe on <code>componentWillUnmount</code>.</p></li>
<li><p>To use <strong>cancelable promises</strong> - this recommended ( <a href=""https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html"" rel=""nofollow noreferrer"">https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html</a> ) in React docs, but it is not a standard and looks a bit ""hackish"", especially on promise chains.</p></li>
</ol>

<p>But I feel that there should be a <strong>better way</strong>, thanks in advance and have a nice day.</p>
","967355","","","","","2018-01-27 15:00:53","How to handle serial mutations with react apollo","<javascript><reactjs><apollo><react-apollo>","0","2","","",""
"47660481","1","47661012","","2017-12-05 18:35:35","","2","72","<p>My component <code>this.props.save();</code> when <code>componentWillUnmount</code>? however if i leave the page to an external link in a different tab it does not trigger <code>componentWillUnmount</code></p>

<p>my component </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export default class AutoSave extends React.Component {

  constructor(props) {
    super(props);
    this.setIntervalId = null;
  }

  componentDidMount() {
    if (!window.onbeforeunload) {
      window.onbeforeunload = () =&gt; {
        this.props.save();
      };
    }

    this.setIntervalId = setInterval(() =&gt; this.props.save(), this.props.intervalInMs);
  }

  componentWillUnmount() {
    this.props.save();
    clearInterval(this.setIntervalId);
  }

  render() {

    return &lt;span className=""saving""&gt;Last saved at {now()}&lt;/span&gt;;
  }
}</code></pre>
</div>
</div>
</p>

<p>My link looks like this </p>

<pre><code>&lt;Link href=""http://www.google.com""  target=""_blank""&gt;
      Google Link
    &lt;/Link&gt; 
</code></pre>

<p>How can I make component save when user clicks link? It's a react/redux app.</p>
","8033705","","","","","2017-12-05 19:19:17","How do i make my reusable react component saves when the user clicks button?","<javascript><reactjs><ecmascript-6><redux><state>","2","2","","",""
"39325581","1","","","2016-09-05 07:20:51","","13","15682","<p>I'm trying to add an <code>onScroll</code> event on a table. This is what I've tried:</p>

<pre><code>componentDidMount() {
    ReactDOM.findDOMNode(this.refs.table).addEventListener('scroll', this.listenScrollEvent);
}

componentWillUnmount() {
    ReactDOM.findDOMNode(this.refs.table).removeEventListener('scroll', this.listenScrollEvent);
}

listenScrollEvent() {
    console.log('Scroll event detected!');
}

render() {
    return (
        &lt;table ref=""table""&gt;
           [...]
        &lt;/table&gt;
    )
}
</code></pre>

<p>I tried <code>console.log(ReactDOM.findDOMNode(this.refs.table))</code> and I'm getting the correct result but scroll event is never fired at all. I looked in <a href=""https://stackoverflow.com/questions/36180414/reactjs-add-custom-event-listener-to-component"">here</a> but still failed. Any help would be so much appreciated.</p>
","6032709","","-1","","2017-05-23 11:47:01","2017-10-30 19:13:23","How to add scroll event in react component","<javascript><reactjs><ecmascript-6>","3","4","2","",""
"39322801","1","","","2016-09-05 01:10:52","","0","1853","<p>""objects are not valid as a react child (found: object with keys {date, events}). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons. Check the render method of View.""</p>

<p>So I have kind of a cascade of method calls. I'm retrieving dates with events inside of those. It feels like I'm doing this correctly, but am getting the above error. I've tried setting createFragment on places, but still getting the error. Here's the code:</p>

<pre><code>  import React, { Component } from 'react';
  import {
    AppRegistry,
    Text,
    View,
    ScrollView,
    RefreshControl,
    StyleSheet,
    Dimensions,
    TextInput,
    Linking,
    TouchableNativeFeedback
   } from 'react-native';

  var _ = require('lodash');
  var {width, height} = Dimensions.get('window');
  var renderif = require('render-if');
  var createFragment = require('react-addons-create-fragment');

  var IMAGES_PER_ROW = 1

  class FunInATL extends Component {
    constructor(props) {
      super(props);
      this.state = {
        currentScreenWidth: width,
        currentScreenHeight: height,
        dates: [],
        boxIndex: 0,
        showBox: false,
        refreshing: false
      };
    }

        handleRotation(event) {
          if (!this.state) {
            return;
          }

          var layout = event.nativeEvent.layout
          this.state({currentScreenWidth: layout.width, currentScreenHeight: layout.height })
        }

        calculatedSize() {
          var size = this.state.currentScreenWidth / IMAGES_PER_ROW
          return {width: size}
        }

        renderRow(events) {
          return events.map((events, i) =&gt; {
            return (
              &lt;Image key={i} style={[this.getImageStyles(), styles.image, this.calculatedSize() ]} source={{uri: event.image}} /&gt;
            )
          })
        }

        openUrl(url) {
          Linking.canOpenURL(url).then(supported =&gt; {
              if (supported) {
                Linking.openURL(url);
              } else {
                console.log('nope :: ' + url);
              }
          }).catch(err =&gt; console.error('An error occurred', err));
        }

        getImageStyles(featured, category) {
            let options = {
              borderColor: 'gold',
              borderWidth: featured ? 1 : 0
            }

            if (!category) {
                options.height = featured ? 250 : 125
            }

            return options;
        }

        _clickImage(event, index) {
          if (event.title) {
            let new_val = !this.state.showBox
            this.setState({
                dates: this.state.dates,
                showBox: new_val,
                boxIndex: new_val ? index : 0
            });
          }

        }

        componentDidMount() {
          this.state = {
              dates: [],
              boxIndex: 0,
              showBox: false,
              refreshing: false
          };
          this.getApiData();

          Linking.addEventListener('url', this.handleUrl);
        }

        componentWillUnmount() {
            Linking.removeEventListener('url', this.handleUrl);
        }

        getApiData() {
          var _this = this;
          return fetch('https://www.funinatl.com/mobile2.php?v1')
            .then(function(response) {
              return response.json()
            })
            .then((responseJson) =&gt; {
              var dates = createFragment(responseJson.events)
              return;

              let _this = this;

              date.events.map((event, i) =&gt; (
                date.events[i] = event
              ))

              var datesData = [];
              dates.map((date, i) =&gt; (
                datesData.push({
                  date: i,
                  events: createFragment(date.events)
                })
              ))

              _this.setState({
                dates: createFragment(datesData),
                boxIndex: 0,
                showBox: false
              })

              console.error(this.state);
            })
            .catch((error) =&gt; {
              console.error(error);
            })
            .done();
        }

        renderDates() {
          return this.state.dates.map((date) =&gt;
                (
                  &lt;View&gt;
                    &lt;Text style={styles.dateHeader}&gt;{ date.date }&lt;/Text&gt;

                    &lt;View&gt;
                    {this.renderEvents(date.events)}
                    &lt;/View&gt;
                  &lt;/View&gt;

            ))
        }

        renderImage(event, index) {
            if (this.state.showBox &amp;&amp; this.state.boxIndex == index) {
              return (
                &lt;View&gt;
                  &lt;TouchableNativeFeedback onPress={()=&gt;this._clickImage(event, index)}&gt;
                      &lt;Image source={{ uri: event.image }} style={[styles.image, this.calculatedSize(), this.getImageStyles(event.featured), { height: 100 }]} /&gt;
                  &lt;/TouchableNativeFeedback&gt;
                  &lt;View style={{ flexDirection:'row', padding: 15 }}&gt;
                      &lt;Text style={styles.price}&gt;{event.price}&lt;/Text&gt;
                      &lt;Text style={styles.time}&gt;{event.time}&lt;/Text&gt;
                      &lt;TouchableNativeFeedback onPress={()=&gt;this.openUrl(event.website)}&gt;
                          &lt;Text style={styles.btn}&gt;Website&lt;/Text&gt;
                      &lt;/TouchableNativeFeedback&gt;
                  &lt;/View&gt;

                      {renderif(event.venue)(
                          &lt;TouchableNativeFeedback onPress={()=&gt;this.openUrl(event.venue)}&gt;
                              &lt;Text style={styles.btn}&gt;Venue&lt;/Text&gt;
                          &lt;/TouchableNativeFeedback&gt;
                      )}

                &lt;/View&gt;
              )
            } else {
              return (
                &lt;View&gt;
                    &lt;TouchableNativeFeedback onPress={()=&gt;this._clickImage(event, index)}&gt;
                        &lt;Image source={{ uri: event.image }} style={[styles.image, this.calculatedSize(), this.getImageStyles(event.featured)]} /&gt;
                    &lt;/TouchableNativeFeedback&gt;
                &lt;/View&gt;
              )
            }
        }

        renderEvents(events) {
          return events.map((event, i) =&gt;
            (
              &lt;View&gt;
                &lt;Text style={[styles.eventCategory, this.getImageStyles(event.featured, true)]}&gt;{event.category}&lt;/Text&gt;
                &lt;View&gt;
                  {this.renderImage(event, i)}
                &lt;/View&gt;
                &lt;Text style={[styles.eventTitle, this.getImageStyles(event.featured, true)]}&gt;{event.title}&lt;/Text&gt;
              &lt;/View&gt;
          ));
        }

        _onRefresh() {
          this.setState({refreshing: true});
          fetchData().then(() =&gt; {
            this.setState({refreshing: false});
          });
        }

        render() {
          return (
            &lt;ScrollView onLayout={this.handleRotation} contentContainerStyle={styles.scrollView} refreshControl={
                &lt;RefreshControl
                  refreshing={this.state.refreshing}
                  onRefresh={this._onRefresh.bind(this)}
                  tintColor=""#ff0000""
                  title=""Loading...""
                  titleColor=""#00ff00""
                  colors={['#ff0000', '#00ff00', '#0000ff']}
                  progressBackgroundColor=""#ffff00""
                /&gt;
              }&gt;
              &lt;Text style={styles.header}&gt;FunInATL&lt;/Text&gt;
                  {this.renderDates()}
            &lt;/ScrollView&gt;
          )
        }
      }

  var styles = StyleSheet.create({

    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      textAlign: 'center',
      padding: 10
    },

    header: {
      fontSize: 30,
      fontWeight: 'bold',
      padding: 20,
      textAlign: 'center',
      backgroundColor: '#000',
      color: '#fff'
    },

    dateHeader: {
      fontSize: 20,
      fontWeight: 'bold',
      padding: 20,
      textAlign: 'left',
      color: '#fff',
      backgroundColor: '#283593'
    },

    eventCategory: {
        backgroundColor: '#03a9f4',
        textAlign: 'center',
        color: '#ffffff',
        padding: 3
    },

    eventTitle: {
        borderTopWidth: 0,
        textAlign: 'center',
        fontWeight: 'bold',
        padding: 3,
        fontSize: 18,
    },

    image: {
    },

    btn: {
        backgroundColor: 'green',
        padding: 10,
        color: '#fff',
        textAlign: 'center',
        flex: 1
    },

    price: {
        marginLeft: 10,
        fontSize: 16,
        flex: 1
    },

    time: {
      marginRight: 10,
      fontSize: 16,
      flex: 1,
      width: 35
    }

  });

  AppRegistry.registerComponent('FunInATL', () =&gt; FunInATL);
</code></pre>

<p>Thanks!</p>

<p><strong>EDIT</strong>: Updated code per the map suggestion, still not working. complaining about {events} only now.</p>

<p><strong>EDIT 2</strong>: Updated with FULL code.</p>
","1370090","","1370090","","2016-09-07 22:43:01","2016-09-08 09:43:58","error ""objects are not valid as a react child"" in react native","<react-native>","1","0","","",""
"49404934","1","","","2018-03-21 11:18:44","","1","70","<p>i am using react-native-fcm to receive the push notification.it is properly working  when app notification screen is in foreground state only(not working on other screens).But i want  receive a notification when app is killed or in the background or i am on any other screen of my project.Here is my code:</p>

<pre><code>import React, { Component } from 'react';
import {
  Platform,
  StyleSheet,
  Text,
  View
} from 'react-native';
import FCM,{FCMEvent,RemoteNotificationResult,WillPresentNotificationResult,NotificationType} from ""react-native-fcm"";

let data=[];
FCM.on(FCMEvent.Notification, async(notify)=&gt;{
  if(notify.local_notification){
    //this is a local notification
    console.log('===data  =====on=='+JSON.stringify(notify))
  }
  if(notify.opened_from_tray){
    console.log(""====tray======="")
  }
  if(Platform.OS==='android'){
    switch(notify.NotificationType){
      case NotificationType.Remote:
      notify.finish(
        RemoteNotificationResult.NewData  
      )                   
      break;
      case NotificationType.NotificationResponse:
      notify.finish();
      break;
      case NotificationType.WillPresent:
      notify.finish(WillPresentNotificationResult.All)
      break;
    }           
  }
});
FCM.on(FCMEvent.RefreshToken,(token)=&gt;{
  console.log(token);
})

export default class HomePage extends Component {

  constructor(props){
    super(props);
    this.state={
      totalTarget: null,
      targetAchieved:null,
      message:null,
      notificationsType:null,
      extraMessage:null,
    }
  }

  componentDidMount () {
    const { navigate } = this.props.navigation;
    FCM.requestPermissions().then(()=&gt;console.log('granted')).catch(()=&gt;console.log('notification permission'))

    FCM.getFCMToken().then(token=&gt;{
      console.log(token)
    });

    this.notificationListener = FCM.on(FCMEvent.Notification, async(notify)=&gt;{
      console.log(""===notification---listener====""+JSON.stringify(notify));
      this.setState({
        totalTarget:notify.totalTarget,
        targetAchieved:notify.targetAchieved,
        message:notify.message,
        notificationsType:notify.notificationsType,
        extraMessage:notify.extraMessage
      })
      navigate(""TargetScreenPage"",{message:this.state.message,extraMessage:this.state.extraMessage})
    })

    FCM.getInitialNotification().then(notify=&gt;{
      console.log(""notification-----""+ JSON.stringify(notify))

    })
  }

  componentWillUnmount(){
    this.notificationListener.remove();           
  }

  render() {
    return (
      &lt;View style={styles.container}&gt;
         &lt;Text style={styles.instructions}&gt;
          {this.state.totalTarget}
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          {this.state.targetAchieved}
        &lt;/Text&gt;

         &lt;Text style={styles.instructions}&gt;
          {this.state.message}
        &lt;/Text&gt;
        &lt;Text style={styles.instructions}&gt;
          {this.state.notificationsType}
        &lt;/Text&gt;
     &lt;Text style={styles.instructions}&gt;
          {this.state.extraMessage}
        &lt;/Text&gt;

      &lt;/View&gt;
    );
  }
}
</code></pre>
","8282271","","","","","2018-03-21 11:18:44","react-native push notification is not working in background","<react-native><push-notification><react-native-fcm>","0","0","","",""
"48820908","1","","","2018-02-16 05:58:31","","0","132","<p><br>
have you done any live tracking demo like Uber in react native?<br><br>
i made one. it's working fine in emulator &amp; simulator with custom location but couldn't get proper location in real device using navigator.geolocation.<br><br></p>

<pre><code>watchID = null;

componentDidMount(){


    navigator.geolocation.getCurrentPosition((position) =&gt; {
        let lat = parseFloat(position.coords.latitude);
        let long = parseFloat(position.coords.longitude);

        let initialRegion = {
            latitude : lat,
            longitude : long,
            latitudeDelta : LATITUDE_DELTA,
            longitudeDelta : LONGITUDE_DELTA
        }

        this.setState({ initialPosition : initialRegion });
        this.setState({ markerPostition : initialRegion });
    }, (error) =&gt; { 
        alert(JSON.stringify(error)) 
    });


    this.watchID = navigator.geolocation.watchPosition((position) =&gt; {

         let lat = parseFloat(position.coords.latitude);
         let long = parseFloat(position.coords.longitude);

        let lastRegion = {
            latitude : lat,
            longitude : long,
            latitudeDelta : LATITUDE_DELTA,
            longitudeDelta : LONGITUDE_DELTA
        }

        this.setState({ initialPosition : lastRegion });
        this.setState({ markerPostition : lastRegion });    
    });


}

componentWillUnmount(){
    navigator.geolocation.clearWatch(this.watchID);
}
</code></pre>

<p>i had set enableHighAccuracy to true but it was throwing error, so, i just removed it. now i'm not getting proper (exact) location of device.<br><br>
please suggest me Geolocation setup with watchPosition what's worked better for you in case of you made any related project(s).<br><br>
if you have your code in git repo then i will be thankful of your.
forgive me if i did any grammatical mistakes.</p>
","8923201","","","","","2018-02-16 08:09:30","react native geolocation not providing exact location in real device","<reactjs><react-native><geolocation><tracking>","1","0","","",""
"49446896","1","","","2018-03-23 09:57:51","","0","186","<p>I am using react-native-FCM and trying to show notifications from the rest client, its working fine when the app is in the foreground and trigger the screen where I want to show the notifications data but when the app is in the background or killed it does not trigger the notifications screen. So, I am wondering how to trigger app notifications screen when the app is killed or in the background.Thanks in advance.Any help would be appreciated.Here is my code:</p>

<p>homepage.js</p>

<pre><code>    import React, { Component } from 'react';
    import {
      Platform,
      StyleSheet,
      Text,
      View
    } from 'react-native';

    import FCM,{FCMEvent,RemoteNotificationResult,WillPresentNotificationResult,NotificationType,NotificationActionType,NotificationActionOption,NotificationCategoryOption} from ""react-native-fcm"";

    let data=[];
    FCM.on(FCMEvent.Notification, async(notify)=&gt;{
      if(notify.local_notification){
        //this is a local notification
      }
      if(notify.opened_from_tray){

            navigation.navigate('TargetScreenPage')


      }
      if(Platform.OS==='android'){
        switch(notify.NotificationType){
          case NotificationType.Remote:
          notify.finish(
            RemoteNotificationResult.NewData  
          )                   
          break;
          case NotificationType.NotificationResponse:
          notify.finish();
          break;
          case NotificationType.WillPresent:
          notify.finish(WillPresentNotificationResult.All)
          break;
        }           
      }
    });
    FCM.on(FCMEvent.RefreshToken,(token)=&gt;{
      console.log(token);
    })



    export default class HomePage extends Component {


      constructor(props){
        super(props);
        this.state={
          totalTarget: null,
          targetAchieved:null,
          message:null,
          notificationsType:null,
          extraMessage:null,
          token:null
        }
      }

      componentDidMount () {
         const { navigate } = this.props.navigation;
        FCM.requestPermissions().then(()=&gt;console.log('granted')).catch(()=&gt;console.log('notification permission'))

        FCM.getFCMToken().then(token=&gt;{
          console.log(token)
          this.setState({token:token})
        });

        this.notificationListener = FCM.on(FCMEvent.Notification, async(notify)=&gt;{
          this.setState({
            totalTarget:notify.totalTarget,
            targetAchieved:notify.targetAchieved,
            message:notify.message,
            notificationsType:notify.notificationsType,
            extraMessage:notify.extraMessage
          })
      navigate(""TargetScreenPage"",{message:this.state.message,extraMessage:this.state.extraMessage})
        })

        FCM.getInitialNotification().then(notify=&gt;{
          console.log(""notification-----""+ JSON.stringify(notify))

        })
      }

      componentWillUnmount(){
        this.notificationListener.remove();           
      }

      render() {
        return (
          &lt;View style={styles.container}&gt;
           {/* &lt;Text style={styles.instructions}&gt;
              {this.state.token}
            &lt;/Text&gt; */}
             &lt;Text style={styles.instructions}&gt;
              {this.state.totalTarget}
            &lt;/Text&gt;
            &lt;Text style={styles.instructions}&gt;
              {this.state.targetAchieved}
            &lt;/Text&gt;

             &lt;Text style={styles.instructions}&gt;
              {this.state.message}
            &lt;/Text&gt;
            &lt;Text style={styles.instructions}&gt;
              {this.state.notificationsType}
            &lt;/Text&gt;
         &lt;Text style={styles.instructions}&gt;
              {this.state.extraMessage}
            &lt;/Text&gt;

          &lt;/View&gt;                                                       
        );
      }
    }
    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#F5FCFF',
      },
      welcome: {
        fontSize: 40,
        textAlign: 'center',
        margin: 10,
      },
      instructions: {
        fontSize:40,
        textAlign: 'center',
        color: '#333333',
        marginBottom: 5,
        flexDirection:'row'
      },              
    });
</code></pre>

<p>and TargetScreen.js</p>

<pre><code>import React, { Component } from 'react';
import {ImageBackground,
  Platform,StyleSheet,BackHandler,Image,TouchableOpacity,Text,StatusBar,View} from 'react-native';
import { Header,Right} from 'native-base';

const instructions = Platform.select({
  ios: 'Press Cmd+R to reload,\n' +
    'Cmd+D or shake for dev menu',
  android: 'Double tap R on your keyboard to reload,\n' +
    'Shake or press menu button for dev menu',
});

export default class TargetScreen extends Component {

    handleCrossButtonClick() {
        this.props.navigation.goBack(null);
        return true;
    }                      

  render() {
    const { params } = this.props.navigation.state;
    return (
    &lt;View style={{flex:1,backgroundColor: '#fff'}}&gt;
    &lt;StatusBar hidden = {true} /&gt;
    &lt;Header style={{ backgroundColor: ""#fff"" ,justifyContent:'center',alignItems:'center'}}&gt;
        &lt;Image style={{height:45,width:90,resizeMode: ""stretch"",marginLeft:95}} source={require('./images/salesLineLogo.jpg')} /&gt;
        &lt;Right&gt;      
        &lt;TouchableOpacity onPress={()=&gt;this.handleCrossButtonClick()}&gt;
        &lt;Image style={{height:25,width:25,resizeMode: ""stretch""}} source={require('./images/cross.png')}/&gt;      
        &lt;/TouchableOpacity&gt;&lt;/Right&gt;               
     &lt;/Header&gt;        
     &lt;View style={{flex:0.5,justifyContent:'center',alignItems: 'center'}}&gt;
    &lt;ImageBackground source={require('./images/up-arrow.png')} style={{ resizeMode: ""stretch"",height: 95, width: 95,justifyContent:'center',alignItems:'center' }} &gt;
    &lt;Text style={{fontSize:20}}&gt;8&lt;/Text&gt;&lt;/ImageBackground&gt;
    &lt;Text style={{fontSize:20,marginTop:25}}&gt;{params.message}&lt;/Text&gt;
    &lt;/View&gt;
    &lt;View style={{flex:0.5,justifyContent:'center',alignItems:'center'}}&gt;
    &lt;ImageBackground source={require('./images/up-arrow.png')} style={{ resizeMode: ""stretch"",height: 95, width: 95,justifyContent:'center',alignItems:'center'}} &gt;
    &lt;Text style={{fontSize:20}}&gt;8&lt;/Text&gt;&lt;/ImageBackground&gt; 
    &lt;Text style={{fontSize:20,marginTop:25}}&gt;{params.extraMessage}&lt;/Text&gt;
    &lt;/View&gt;&lt;/View&gt;               
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  instructions: {
    textAlign: 'center',
    color: '#333333',
    marginBottom: 5,
  },
});
</code></pre>
","8282271","","8282271","","2018-03-23 10:33:08","2018-03-23 10:33:08","How to show FCM push notifications when app is killed or in background react native?","<android><ios><react-native><react-native-fcm><react-native-push-notification>","0","2","1","",""
"49469961","1","","","2018-03-24 21:06:29","","0","109","<p>I was reading the top answer to this question.</p>

<p><a href=""https://stackoverflow.com/questions/41248287/how-to-connect-threejs-to-react"">How to connect Threejs to React?</a></p>

<p>Someone provided this great example of using threejs in react: </p>

<pre><code>import React, { Component } from 'react'
import * as THREE from 'three'

class Scene extends Component {
constructor(props) {
super(props)

this.start = this.start.bind(this)
this.stop = this.stop.bind(this)
this.animate = this.animate.bind(this)
}

componentDidMount() {
const width = this.mount.clientWidth
const height = this.mount.clientHeight

const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(
  75,
  width / height,
  0.1,
  1000
)
const renderer = new THREE.WebGLRenderer({ antialias: true })
const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: '#433F81' })
const cube = new THREE.Mesh(geometry, material)

camera.position.z = 4
scene.add(cube)
renderer.setClearColor('#000000')
renderer.setSize(width, height)

this.scene = scene
this.camera = camera
this.renderer = renderer
this.material = material
this.cube = cube

this.mount.appendChild(this.renderer.domElement)
this.start()
}

componentWillUnmount() {
this.stop()
this.mount.removeChild(this.renderer.domElement)
}

start() {
if (!this.frameId) {
  this.frameId = requestAnimationFrame(this.animate)
}
}

stop() {
  cancelAnimationFrame(this.frameId)
}

animate() {
this.cube.rotation.x += 0.01
this.cube.rotation.y += 0.01

this.renderScene()
this.frameId = window.requestAnimationFrame(this.animate)
}

renderScene() {
  this.renderer.render(this.scene, this.camera)
}

render() {
return (
  &lt;div
    style={{ width: '400px', height: '400px' }}
    ref={(mount) =&gt; { this.mount = mount }}
  /&gt;
)
}
}

export default Scene
</code></pre>

<p>I do not understand <code>this.mount</code> . What is <code>this.mount</code>? It seems to be used to access client width and client height. And what is the ref callback function <code>ref={(mount) =&gt; { this.mount = mount }}</code> doing?</p>

<p>I did some research and found that ref callbacks are called after the component mounts, they can be used for passing state from parents to children, but they should only be used when necessary. I got all that from the docs.</p>

<p>I plan on modifying this script for my own purpose so understanding <code>this.mount</code> and the ref callback would be really helpful. TIA</p>
","8896573","","","","","2018-03-24 21:18:37","Ref callbacks & this.mount - reactJS","<reactjs><three.js>","2","0","1","",""
"40867943","1","","","2016-11-29 14:09:09","","1","66","<p>I have a React/Flux web app and want to follow the architecture best practices:</p>

<p><a href=""https://i.stack.imgur.com/DrNGd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DrNGd.png"" alt=""enter image description here""></a></p>

<p>I will focus on one view for my question, the component used to insert/update an entity (a User in occurrence).</p>

<p>Everything is working with this code, but the core of my question is about the <code>onUserDetailChanged</code> function in my <code>AdminUserDetail</code> component, which I find too contrived and confusing.</p>

<h2>Core of my question</h2>

<p>I would like to refactor this code found in my component:</p>

<pre><code>// ALL OF THIS IS UGLY
onUserDetailChanged: function() {
    var data = AdminUserDetailStore.getData();
    GuiHelper.blockGuiLoading(false);

    // Check first if there is a feedback message
    if (typeof data.FeedbackMessage !== 'undefined') {
        if (data.FeedbackMessage === ActionConstants.ERROR) {
            // Unexpected error
            GuiHelper.unexpectedError();
        }
        else if (data.FeedbackMessage === ActionConstants.SUCCESS) {
            // User saved successfully
            GuiHelper.infoDialog(BootstrapDialog.TYPE_SUCCESS, LanguageLoader.langDict.msgUserSaved);
        }
    }
    // If there is no feedback message, check for errors
    else {
        if (data.Errors !== null &amp;&amp; data.Errors.length &gt; 0) {
            // Errors
            GuiHelper.infoDialog(BootstrapDialog.TYPE_DANGER, GuiHelper.renderErrors(data.Errors));
        }
        else {
            // No errors, data changed (either from initial load or from user input)
            this.setState({ entity: data.Data });

            // Load the user permissions if required
            // (CAN I PLACE THIS CODE ELSEWHERE THAN IN THIS FUNCTION?)
            var userPermissions = AdminUserDetailPermissionsStore.getData().Data;
            if (this.state.entity.Id !== 0 &amp;&amp; typeof userPermissions === 'undefined') {
                this.loadUserPermissions(data.Data.Username);
            }
        }
    }
},
</code></pre>

<p>What I don't like about this architecture is that all the api calls (<code>getUserDetail(userId)</code>, <code>getUserDetailPermissions(username)</code>, <code>postUserDetail(requestData)</code>) end up calling this function and I find it confusing how to notify the user about the result of the API call. Also, this function is even called on every data change caused by user input so I find  things are all mixed up.</p>

<p>The possible outcomes all supported by this contrived code:</p>

<ul>
<li><code>getUserDetail(userId)</code> can end in <code>SUCCESS</code> with data or <code>ERROR</code> when an unexpected error arises (e.g. the api server is not responding)</li>
<li><code>getUserDetailPermissions(username)</code> can end in <code>SUCCESS</code> with data or <code>ERROR</code> when an unexpected error arises (e.g. the api server is not responding)</li>
<li><code>postUserDetail(requestData)</code> is a bit more complex since there are server validations on the data posted. It can end in <code>SUCCESS</code> or <code>ERROR</code> as the other calls, but it can also return a list of validation errors which must be displayed to the user.</li>
</ul>

<p>Could I, for example, use different <code>onChange</code> functions to distinguish from each API call type and from a change in data caused by user input?</p>

<p><strong>WebApiClient.js</strong></p>

<pre><code>import request from 'superagent';
var Promise = require('es6-promise').Promise;

module.exports = {
    get: function (url) {
        return new Promise(function (resolve, reject) {
            request
                .get(url)
                .end(function (err, res) {
                    if (err !== null) {
                        reject();
                    }
                    else {
                        if (res.status === 404) {
                            reject();
                        }
                        else {
                            resolve(JSON.parse(res.text));
                        }
                    }
                });
        });
    },

    post: function (url, data) {
        return new Promise(function (resolve, reject) {
            request
                .post(url)
                .send(data)
                .end(function (err, res) {
                    if (err !== null) {
                        reject();
                    }
                    else {
                        if (res.status === 404) {
                            reject();
                        }
                        else {
                            resolve(JSON.parse(res.text));
                        }
                    }
                });
        });
    }
}
</code></pre>

<p><strong>ActionsCreator.js</strong></p>

<pre><code>var Dispatcher = require('./Dispatcher');
var ActionConstants = require('./ActionConstants');
var Promise = require('es6-promise').Promise;
var Api = require('../Util/WebApiClient');

var ActionCreator = {
    apiServer: 'http://localhost:55010/api',

    getUserDetail: function (userId) {
        Api.get(this.apiServer + '/v1/User/' + userId)
            .then(function (responseData) { Dispatcher.handleAction({ actionType: ActionConstants.GET_USER, data: responseData }); })
            .catch(function () { Dispatcher.handleAction({ actionType: ActionConstants.ERROR }); });
    },

    getUserDetailPermissions: function (username) {
        Api.get(this.apiServer + '/v1/Permission/ForUser?username=' + username)
            .then(function (responseData) { Dispatcher.handleAction({ actionType: ActionConstants.GET_USERPERMISSIONS, data: responseData }); })
            .catch(function () { Dispatcher.handleAction({ actionType: ActionConstants.ERROR }); });
    },

    postUserDetail: function (requestData) {
        Api.post(this.apiServer + '/v1/User/', requestData)
            .then(function (responseData) { Dispatcher.handleAction({ actionType: ActionConstants.POST_USER, data: responseData }); })
            .catch(function () { Dispatcher.handleAction({ actionType: ActionConstants.ERROR }); });
    }
};

module.exports = ActionCreator;
</code></pre>

<p><strong>ActionConstants.js</strong></p>

<pre><code>module.exports = {
  GET_USER: 'GET_USER',
  GET_USERPERMISSIONS: 'GET_USERPERMISSIONS',
  POST_USER: 'POST_USER',

  ERROR: 'ERROR',
  SUCCESS: 'SUCCESS'
};
</code></pre>

<p><strong>Dispatcher.js</strong></p>

<pre><code>var Dispatcher = require('flux').Dispatcher;

// Create dispatcher instance
var Dispatcher = new Dispatcher();

// Convenience method to handle dispatch requests
Dispatcher.handleAction = function(action) {
    this.dispatch({
        source: 'VIEW_ACTION',
        action: action
    });
}

module.exports = Dispatcher;
</code></pre>

<p><strong>AdminUserDetailStore.js</strong></p>

<pre><code>var Dispatcher = require('../Core/Dispatcher');
var ActionConstants = require('../Core/ActionConstants');
var EventEmitter = require('events').EventEmitter;
var assign = require('object-assign');

var CHANGE_EVENT = 'change';

var AdminUserDetailStore = assign({}, EventEmitter.prototype, {
    data: {},

    // Called after the initial GET to load the initial User entity
    // or from user input
    setData: function(data, doEmitChange) {
        this.data = data;

        if (typeof doEmitChange !== 'undefined' &amp;&amp; doEmitChange) {
            this.emitChange();
        }
    },

    // Called from a POST when trying to save the User entity
    // or when getting an unexpected error (e.g. api server unavailable)
    setFeedbackMessage: function(data, message) {
        if (typeof message !== 'undefined')
            this.data.FeedbackMessage = message;
        else {
            if (data.Errors.length &gt; 0)
                this.data.Errors = data.Errors;
            else
                this.data.FeedbackMessage = ActionConstants.SUCCESS;
        }
    },

    emitChange: function () {
        this.emit(CHANGE_EVENT);
    },

    addChangeListener: function (callback) {
        this.on(CHANGE_EVENT, callback);
    },

    removeChangeListener: function (callback) {
        this.removeListener(CHANGE_EVENT, callback);
    },

    getData: function () {
        return this.data;
    }
});

Dispatcher.register(function(payload) {
    var action = payload.action;

    switch(action.actionType) {
        case ActionConstants.ERROR:
            // Force a feedback message
            AdminUserDetailStore.setFeedbackMessage(null, ActionConstants.ERROR);
            break;
        case ActionConstants.GET_USER:
            AdminUserDetailStore.setData(action.data);
            break;
        case ActionConstants.POST_USER:
            // Check for errors wthin the data object and set a SUCCESS feedback message if none are found
            AdminUserDetailStore.setFeedbackMessage(action.data);
            break;
        default:
            return true;
    }

    AdminUserDetailStore.emitChange();
    return true;
});

module.exports = AdminUserDetailStore;
</code></pre>

<p><strong>AdminUserDetail.js</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import ActionCreator from '../../Core/ActionCreator';
import ActionConstants from '../../Core/ActionConstants';

import AdminUserDetailStore  from '../../Stores/AdminUserDetailStore';
import AdminUserDetailPermissionsStore  from '../../Stores/AdminUserDetailPermissionsStore';

import LanguageLoader from '../../Util/LanguageLoader';
import GuiHelper from '../../Util/GuiHelper';
import BootstrapDialog from 'bootstrap-dialog';

import blockUI from '../../../Content/js/jquery.blockUI.js';

import {AgGridReact} from 'ag-grid-react';
import BoolCellEditor from '../AgGrid/BoolCellEditor';

$ = window.$ = window.jQuery = require('jquery');

var AdminUserDetail = React.createClass({
    getInitialState: function () {
        return {
            entity: {
                Id: 0,
                Username: '',
                Email: ''
            },

            userPermissions: null,
            userPermissionsColumns: [
                { headerName: LanguageLoader.langDict.lblRole, field: 'role' },
                { headerName: LanguageLoader.langDict.lblPermission, field: 'permission' },
                { headerName: LanguageLoader.langDict.lblDescription, field: 'description', width:600 }
            ],

            gridOptions: {
                context: this,
                singleClickEdit: true,
                enableColResize: true,
                onGridReady: function(event) {
                    //event.api.autoSizeColumns();
                },
            },
        };
    },

    getDefaultProps: function () {
        return { };
    },

    componentWillMount: function () {
        AdminUserDetailStore.addChangeListener(this.onUserDetailChanged);
        AdminUserDetailPermissionsStore.addChangeListener(this.onUserDetailPermissionsChanged);
    },

    componentWillUnmount: function () {
        AdminUserDetailStore.removeChangeListener(this.onUserDetailChanged);
        AdminUserDetailPermissionsStore.removeChangeListener(this.onUserDetailPermissionsChanged);
    },

    // ALL OF THIS IS UGLY
    onUserDetailChanged: function() {
        var data = AdminUserDetailStore.getData();
        GuiHelper.blockGuiLoading(false);

        // Check first if there is a feedback message
        if (typeof data.FeedbackMessage !== 'undefined') {
            if (data.FeedbackMessage === ActionConstants.ERROR) {
                // Unexpected error
                GuiHelper.unexpectedError();
            }
            else if (data.FeedbackMessage === ActionConstants.SUCCESS) {
                // User saved successfully
                GuiHelper.infoDialog(BootstrapDialog.TYPE_SUCCESS, LanguageLoader.langDict.msgUserSaved);
            }
        }
        // If there is no feedback message, check for errors
        else {
            if (data.Errors !== null &amp;&amp; data.Errors.length &gt; 0) {
                // Errors
                GuiHelper.infoDialog(BootstrapDialog.TYPE_DANGER, GuiHelper.renderErrors(data.Errors));
            }
            else {
                // No errors, data changed (either from initial load or from user input)
                this.setState({ entity: data.Data });

                // Load the user permissions if required
                // (CAN I PLACE THIS CODE ELSEWHERE THAN IN THIS FUNCTION?)
                var userPermissions = AdminUserDetailPermissionsStore.getData().Data;
                if (this.state.entity.Id !== 0 &amp;&amp; typeof userPermissions === 'undefined') {
                    this.loadUserPermissions(data.Data.Username);
                }
            }
        }
    },

    onUserDetailPermissionsChanged: function() {
        var data = AdminUserDetailPermissionsStore.getData();
        GuiHelper.blockGuiLoading(false);

        if (typeof data.FeedbackMessage !== 'undefined' &amp;&amp; data.FeedbackMessage === ActionConstants.ERROR) {
            GuiHelper.unexpectedError();
        }
        else {
            var userPermissions = data.Data.map(function(i, idx) {
                return { role: i.Key, permission: i.Value, description: LanguageLoader.langDict['P_' + i.Value] };
            });
            this.setState({ userPermissions: userPermissions });
        }
    },

    componentDidMount: function () {
        // Initialize/clear the stores
        AdminUserDetailStore.setData({});
        AdminUserDetailPermissionsStore.setData({});

        if (this.props.id !== null) {
            GuiHelper.blockGuiLoading(true);
            ActionCreator.getUserDetail(this.props.id);
        }
    },

    loadUserPermissions :function(username) {
        GuiHelper.blockGuiLoading(true);
        ActionCreator.getUserDetailPermissions(username);
    },

    saveUser: function () {
        GuiHelper.blockGuiLoading(true);
        ActionCreator.postUserDetail(this.state.entity);
    },

    onUsernameChanged: function(e) {
        var entity = this.state.entity;
        entity.Username = e.target.value;
        AdminUserDetailStore.setData({ Errors: null, Data: entity }, true);
    },

    onEmailChanged: function(e) {
        var entity = this.state.entity;
        entity.Email = e.target.value;
        AdminUserDetailStore.setData({ Errors: null, Data: entity }, true);
    },

    render: function () {
        return (
            &lt;div&gt;
                &lt;h1&gt;{LanguageLoader.langDict.lblUserDetail}&lt;/h1&gt;

                &lt;form&gt;
                    &lt;div className=""row""&gt;
                        &lt;div className=""col-lg-3 col-md-4 col-sm-6 col-xs-9 col-centered""&gt;
                            &lt;div className=""form-group""&gt;
                                &lt;label htmlFor=""userUsername""&gt;{LanguageLoader.langDict.lblUsername}&lt;/label&gt;
                                &lt;input type=""text"" className=""form-control"" id=""userUsername"" value={this.state.entity.Username} placeholder={LanguageLoader.langDict.lblUsername} onChange={this.onUsernameChanged} /&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div className=""row""&gt;
                        &lt;div className=""col-lg-3 col-md-4 col-sm-6 col-xs-9 col-centered""&gt;
                            &lt;div className=""form-group""&gt;
                                &lt;label htmlFor=""userEmail""&gt;{LanguageLoader.langDict.lblEmailAddress}&lt;/label&gt;
                                &lt;input type=""text"" className=""form-control"" id=""userEmail"" value={this.state.entity.Email} placeholder={LanguageLoader.langDict.lblEmail} onChange={this.onEmailChanged} /&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/form&gt;

                &lt;div className={this.state.userPermissions === null ? 'hidden' : ''}&gt;
                    &lt;div className=""row""&gt;
                        &lt;div className=""col-lg-3 col-md-4 col-sm-6 col-xs-9 col-centered""&gt;
                            &lt;div className=""form-group""&gt;
                                &lt;label&gt;{LanguageLoader.langDict.lblPermissionsFromRole}&lt;/label&gt;
                                &lt;div style={{height: 400}} className=""ag-fresh""&gt;
                                    &lt;AgGridReact gridOptions={this.state.gridOptions} columnDefs={this.state.userPermissionsColumns} rowData={this.state.userPermissions} /&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

            &lt;/div&gt;
        );
    }
});

module.exports = AdminUserDetail;
</code></pre>

<p>Finally, from the server-side, an api call always return an object with 2 properties:</p>

<pre><code>public dynamic Data { get; set; }
public ICollection&lt;string&gt; Errors { get; set; }
</code></pre>
","215553","","215553","","2016-11-29 17:36:19","2016-11-29 17:36:19","What is the recommended approach to have less contrived code in the function of my component that reacts on data changed from the store?","<javascript><reactjs><flux><reactjs-flux>","0","5","","",""
"48676965","1","","","2018-02-08 03:16:07","","0","201","<p>I tried 'react-native-sensor-manager' and 'react-native-shake-event' and gyroscope in Expo. but i failed again and again. I don't know why. here is my code.</p>

<pre><code>import React from 'react';
import {
  Gyroscope,
} from 'expo';
import {
  StyleSheet,
  Text,
  TouchableOpacity,
  View
} from 'react-native';

export default class GyroscopeSensor extends React.Component {
  state = {
    gyroscopeData: {},
  }

  componentDidMount() {
    this._toggle();
  }

  componentWillUnmount() {
    this._unsubscribe();
  }

  _toggle = () =&gt; {
    if (this._subscription) {
      this._unsubscribe();
    } else {
      this._subscribe();
    }
  }

  _slow = () =&gt; {
    Gyroscope.setUpdateInterval(1000);
  }

  _fast = () =&gt; {
    Gyroscope.setUpdateInterval(16);
  }

  _subscribe = () =&gt; {
    this._subscription = Gyroscope.addListener((result) =&gt; {
      this.setState({gyroscopeData: result});
    });
  }

  _unsubscribe = () =&gt; {
    this._subscription &amp;&amp; this._subscription.remove();
    this._subscription = null;
  }

  render() {
    let { x, y, z } = this.state.gyroscopeData;

    return (
      &lt;View &gt;
        &lt;Text&gt;Gyroscope:&lt;/Text&gt;
        &lt;Text&gt;x: {round(x)} y: {round(y)} z: {round(z)}&lt;/Text&gt;

        &lt;View &gt;
          &lt;TouchableOpacity onPress={this._toggle} style={styles.button}&gt;
            &lt;Text&gt;Toggle&lt;/Text&gt;
          &lt;/TouchableOpacity&gt;
          &lt;TouchableOpacity onPress={this._slow} style={[styles.button, styles.middleButton]}&gt;
            &lt;Text&gt;Slow&lt;/Text&gt;
          &lt;/TouchableOpacity&gt;
          &lt;TouchableOpacity onPress={this._fast} &gt;
            &lt;Text&gt;Fast&lt;/Text&gt;
          &lt;/TouchableOpacity&gt;
        &lt;/View&gt;
      &lt;/View&gt;
    );
  }
}

function round(n) {
  if (!n) {
    return 0;
  }

  return Math.floor(n * 100) / 100;
}
</code></pre>

<p>View is rendered successfully but Gyroscope motion function is not working. how can i use Gyroscope in react-native??</p>

<p>Somebody help me..............................................</p>
","7765168","","","","","2018-02-08 03:19:23","How can i use gyroscope in react-native?","<react-native><expo>","1","0","","",""
"38511700","1","","","2016-07-21 18:23:25","","0","865","<p>I have this issue. I went through other post as well but couldnt help me.
I have herewith attached my code. 
My problem is when I try to navigate in SearchLead.js , this gives me the same error  undefined is not an object (evaluating 'this.props.navigator.push') .
Appreciate the help.</p>

<p>index.ios.js </p>

<pre><code>'use strict';
import React, { Component } from 'react';
import {
 AppRegistry,
 StyleSheet,
 Text,
 TextInput,
 TouchableHighlight,
 View,
 AsyncStorage,
 AlertIOS,
 Navigator
}from 'react-native';
var Login = require('./Login');
var AfterLoginView = require('./AfterLoginView');
var Searchlead = require('./Searchlead');
var RenderDetails = require('./RenderDetails');
class EHNYApp extends Component {
componentWillUnmount() {
Actions.currentRouter = null
}
renderScene(route,navigator){
if(route.name == 'login'){
return &lt;Login navigator = {navigator} /&gt;
}
if(route.name == 'afterlogin'){
return &lt;AfterLoginView navigator = {navigator} /&gt;
}
if(route.name == 'search'){
return &lt;Searchlead navigator = {navigator} /&gt;
}
if(route.name == 'renderdetails'){
return &lt;RenderDetails navigator = {navigator} /&gt;
}
}
render() {
return (
    &lt;Navigator
          initialRoute = {{ name: 'login' }}
          renderScene = {this.renderScene.bind(this)}
      /&gt;
 );
}
}
AppRegistry.registerComponent('EHNYApp', () =&gt; EHNYApp);
</code></pre>

<p>Login.js </p>

<pre><code>    'use strict';
    import React, { Component } from 'react';
    import {
    AppRegistry,
            StyleSheet,
            Text,
            TextInput,
            TouchableHighlight,
            View,
            AsyncStorage,
            AlertIOS,
            NavigatorIOS,
            Image,
            ActivityIndicatorIOS

            } from 'react-native';
    var AfterLoginView = require('./AfterLoginView');
    var STORAGE_KEY = 'id_token';
    class Login extends Component{
    constructor(props){
    super(props)
            this.state = {
            username : '',
                    password : '',
                    errorMesage  : '',
                    isLoading : false,
            }
    }
     submitForm(event){
                 this.setState({ isLoading: true });
                   this.swipeToAfterLoginView('afterlogin');
    }
     swipeToAfterLoginView(routeName){
            this.props.navigator.push({
            name : routeName,
          });
    }
    render() {
    var spinner = this.state.isLoading ? ( &lt;ActivityIndicatorIOS hidden = 'true' size = 'large'/&gt; ) :
            &lt;View/&gt;
            return (
                    &lt;View style = {styles.container}&gt;
                    &lt;View style = {styles.logo}&gt;
                    &lt;Image style = {styles.logoImage}
            source = {require('./logo.png')}
            resizeMode = 'contain'
                    /&gt;
                    &lt;/View&gt;
            {spinner}
            &lt;View style = {styles.containerFirst}&gt;
                    &lt;Text style = {styles.errorMesage}&gt; { this.state.errorMesage } &lt;/Text&gt;

                    &lt;TextInput style = {styles.textInput}
            placeholder = 'Email'
                    placeholderTextColor = 'white'
                    autofocus = {true}
            autoCapitalize = 'none'
                    onChange = {this.usernameInput.bind(this)}          /&gt;                        &lt;/View&gt;
                    &lt;View style = {styles.containerSecond}&gt;
                    &lt;TextInput ref = 'password' placeholderTextColor = 'white'
                    value = { this.state.password}
            onChangeText = {password =&gt; this.setState({password})}
            onSubmitEditing = {this._submitForm}
            style = {styles.textInput}
            placeholder = 'Password'
                    autoCapitalize = 'none'
                    password = {true}
            /&gt;
                    &lt;/View&gt;
                    &lt;TouchableHighlight
                    style = {styles.button}   onPress = {this.submitForm.bind(this)}&gt;
                    &lt;Text style = {styles.buttonText}&gt; LOGIN &lt;/Text&gt;
                    &lt;/TouchableHighlight&gt;

                    &lt;Text style = {styles.forgotPassword}&gt; Forgot Password ? &lt;/Text&gt;

                    &lt;/View&gt;
                    );
    }

    }
    module.exports = Login;
</code></pre>

<p>AfterLoginView.js </p>

<pre><code>    'use strict';
    import React, { Component } from 'react';
    import {
    AppRegistry,
            StyleSheet,
            Text,
            TextInput,
            TouchableHighlight,
            View,
            AsyncStorage,
            AlertIOS,
            Navigator,
            TabBarIOS,
            ActivityIndicatorIOS
            } from 'react-native';
    var Dashboard = require('./Dashboard');
    var Other = require('./Other');
    var Searchlead = require('./Searchlead');
    class AfterLoginView extends Component{
    constructor(props) {
    super(props);
            this.state = {
            selectedTab:'searchlead',
                    isLoading : false,
            };
    }
    render(){
    var spinner = this.state.isLoading ?
            ( &lt;ActivityIndicatorIOS
                    hidden = 'true'
                    size = 'large'/&gt; ) :
            ( &lt;View/&gt; );
            return (
                    &lt;TabBarIOS selectedTab = {this.state.selectedTab}&gt;
                    &lt;TabBarIOS.Item
                    selected = {this.state.selectedTab === 'searchlead'}
            title = 'SearchLead'
                    systemIcon = 'search'
                    onPress = { () =&gt; {
                    this.setState({
                    selectedTab : 'searchlead'
                    })
                    }} &gt;
                    &lt;Searchlead/&gt;
                    &lt;/TabBarIOS.Item&gt;
                    &lt;TabBarIOS.Item
                    selected = {this.state.selectedTab === 'dashboard'}
            //systemIcon=""featured""
            title = 'Dashboard'
                    onPress = {() =&gt; {
                    this.setState({
                    selectedTab :'dashboard'
                    });
                    }}&gt;
                    &lt;Dashboard/ &gt;
                    &lt;/TabBarIOS.Item&gt;
                    &lt;TabBarIOS.Item
                    selected = {this.state.selectedTab === 'other'}
            title = 'Other'
                    onPress = {() =&gt; {
                    this.setState({
                    selectedTab : 'other'
                    });
                    }} &gt;
                    &lt;Other/&gt;
                    &lt;/TabBarIOS.Item&gt;
                    &lt;/TabBarIOS&gt;    
                    );
    }
    async submitForm(event){

    var demoToken = await AsyncStorage.getItem('id_token');
            console.log(demoToken);
            // this.login();
    }


    };
    module.exports = AfterLoginView;`
</code></pre>

<p>SearchLead.js</p>

<pre><code>    'use strict';
    import React, { Component } from 'react';
    import {
    AppRegistry,
            StyleSheet,
            Text,
            TextInput,
            ListView,
            View,
            TouchableHighlight,
            Navigator
            } from 'react-native';
    var RenderDetails = require('./RenderDetails');
    var Login = require('./Login');
    var ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2});
    class Searchlead extends Component {
    constructor(props) {
    super(props);
            this.state = {
            searchedAdresses: []
            };
    };
            componentWillMount = function(){
            this._pressData = {};
            }
    _pressData = function (){
    console.log(""yes"");
    }
    searchedAdresses = (searchedText) =&gt; {
    if (searchedText === '') {
    return [];
    }
    var url = 'https://maps.googleapis.com/maps/api/place/autocomplete/json?input=' + searchedText + '&amp;types=geocode&amp;key=apikeuys-s&amp;sensor=true';
            var i = 0;
            var addressData = new Array();
            fetch(url, { method:""GET""})
            .then((response) = &gt; response.json())
            .then((responseData) = &gt; {
            for (i = 0; i &lt; responseData.predictions.length; i++){
            addressData[i] = {description : responseData.predictions[i].description, place_id :  responseData.predictions[i].place_id };
            }
            this.setState({searchedAdresses: addressData});
            })
            .done();
    };
            renderAdress = (rowData, sectionID, rowID) =&gt; {

    return (
            &lt;TouchableHighlight  onPress = { this._onPressAddressList.bind(this)} underlayColor = 'white'&gt;
            &lt;Text style = { styles.listTextInput }&gt; {rowData.description} &lt;/Text&gt;

            &lt;/TouchableHighlight&gt;
            );
    };
            _onPressAddressList = () =&gt; {
    this.props.navigator.push({
    name:'renderdetails'

});
    }
    _renderSeperator(sectionID: number, rowID: number, adjacentRowHighlighted: bool) {
    return (
            &lt;View key = {`${sectionID} - ${rowID}`} style = {{ height: adjacentRowHighlighted ? 4 : 1, backgroundColor: adjacentRowHighlighted ? '#3B5998' : '#CCCCCC', }}
    /&gt; 
            );
    }
    render() {
    return (
            &lt;View style = {styles.container}&gt;
            &lt;View style = {styles.imageContainer}&gt; &lt;/View&gt;
            &lt;View style = {styles.textContainer}&gt;
            &lt;TextInput
            style = {styles.textinput}
    onChangeText = {this.searchedAdresses}
    placeholder = ""Type your adress here""/&gt;
            &lt;/View&gt;
            &lt;View &gt;
            &lt;ListView
            dataSource = {ds.cloneWithRows(this.state.searchedAdresses)}
    renderRow = {this.renderAdress}
    renderSeparator = {this._renderSeperator}
    enableEmptySections = {true}
    /&gt;
            &lt;/View&gt;
            &lt;/View&gt;
            );
    };
            }
    module.exports = Searchlead;`
</code></pre>

<p>note:disregard my stylesheet!!
I went through following post but didnt help me.</p>

<p><a href=""https://github.com/facebook/react-native/issues/416"" rel=""nofollow noreferrer"">https://github.com/facebook/react-native/issues/416</a></p>

<p><a href=""https://stackoverflow.com/questions/30079640/undefined-is-not-an-object-evaluating-this-props-navigator-push"">undefined is not an object (evaluating &#39;this.props.navigator.push&#39;)</a></p>
","5428972","","-1","","2017-05-23 11:52:52","2016-07-21 20:01:07","undefined is not an object (evaluating 'this.props.navigator.push') react native","<javascript><ios><react-native>","0","2","","",""
"33115258","1","","","2015-10-14 01:40:27","","0","305","<p>I am learn reactjs flux pattern from the link below</p>

<p><a href=""https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture"" rel=""nofollow"">https://scotch.io/tutorials/getting-to-know-flux-the-react-js-architecture</a></p>

<p>I get completely confused and lost with this following bit, when will the following code ever been trigger or used? i do not see any where in the app where the this._onChange will be trigger... please help and explain any suggestion is appreciated as i  am start to learn.</p>

<pre><code>// Listen for changes
  componentDidMount: function() {
    ShoeStore.addChangeListener(this._onChange);
  },

  // Unbind change listener
  componentWillUnmount: function() {
    ShoesStore.removeChangeListener(this._onChange);
  },
</code></pre>

<p>in the store, does it means in order to trigger the update need to run <strong>ShoesStore.emitChange()</strong>?</p>

<pre><code>// Emit Change event
  emitChange: function() {
    this.emit('change');
  },

  // Add change listener
  addChangeListener: function(callback) {
    this.on('change', callback);
  },

  // Remove change listener
  removeChangeListener: function(callback) {
    this.removeListener('change', callback);
  }
</code></pre>
","409275","","409275","","2015-10-14 01:47:56","2015-10-14 23:01:30","Learning reactJs Flux and encounter the addEventListener confusion","<reactjs><flux>","2","5","","",""
"49493163","1","","","2018-03-26 13:51:57","","0","38","<p>I am implementing a project where the data going to be shared in different components. so i decided to use redux-react for state management. I used redux react async api call to get data from api. However I got undefined when the component mount for first time and return actual data. However, when i tried to implement some function on returned data, i got cannot read property of undefined. I can see the state in redux developer tools and it has data and the logs function display action correctly. I can't understand why i am getting undefined. Here is my codes </p>

<pre><code>const initialState = {  
    candidate: {},
    companies: [], 
    offers: [], 
    moreStatehere:...
  }
</code></pre>

<p><strong>Reducer for the candidate</strong></p>

<pre><code>export default function profileReducer(state = initialState, action) {  
    switch(action.type) {

      case FETCH_POSTS_FAILURE:
      return Object.assign({}, state, {
        didInvalidate: true
      })

      case REQUEST_PROFILE:
      return Object.assign({}, state, {
        isFetching: true,
        didInvalidate: false
      })

      case RECEIVE_PROFILE:
      return {
        ...state, 
        candidate: action.data
      }

      default: 
        return state;
    }
  }
</code></pre>

<p><strong>root reducer</strong> </p>

<pre><code>const rootReducer =  combineReducers({
  profiles: profileReducer
})

export default rootReducer; 
</code></pre>

<p><strong>create store</strong></p>

<pre><code>const composeEnhanser = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__||compose;
const loggerMiddleware = createLogger()


export default function configureStore() {  
  return createStore(
    rootReducer,
    composeEnhanser(applyMiddleware(thunkMiddleware,
      loggerMiddleware))
  );
}
</code></pre>

<p><strong>index.js</strong></p>

<pre><code>const store = configureStore(); 

const app = (
  &lt;Provider store= {store}&gt;
    &lt;BrowserRouter&gt;
     &lt;App/&gt;
    &lt;/BrowserRouter&gt;
    &lt;/Provider&gt;
)


ReactDOM.render(app, document.getElementById('root'));
registerServiceWorker();
</code></pre>

<p><strong>action creator/api call</strong> </p>

<pre><code>export function feachProfiles() {
  return function (dispatch) {
    dispatch(requestProfile)
    return fetch(API_URL)
      .then(
        response =&gt; response.json(),
        error =&gt; console.log('An error occurred.', error)
      )
      .then(json =&gt;
        dispatch(receiveProfile(json))
      )
  }
}
</code></pre>

<p>componentuse</p>

<pre><code>class CandidatesList extends Component {

    constructor (props){
        super (props)
      }

    componentWillMount() {
            this.props.feachProfiles(); 

        }

    handleClick() {
      }

      componentWillUnmount() {
      }  

    render() {     
   const candidate = this.props.profiles.map(profile=&gt;(
       &lt;div&gt; &lt;/div&gt;
   )); 

        return (
            &lt;div&gt;
                 &lt;ViewCandidate
                 /&gt;
            &lt;/div&gt;
        );
    }
}


const mapStateToProps = state =&gt; {
    return {
      profiles: state.profiles.candidate || []
      }
    }
const mapDispatchToProps = (dispatch) =&gt; {
        return {
            feachProfiles: bindActionCreators(feachProfiles, dispatch)
        }
    }

  export default connect(mapStateToProps, mapDispatchToProps)(CandidatesList);  

action RECEIVE_PROFILE @ 
redux-logger.js:1  prev state {profiles: {…}}
redux-logger.js:1  action     {type: ""RECEIVE_PROFILE"", data: {…}}
redux-logger.js:1  next state {profiles: {…}}
</code></pre>
","3262564","","","","","2018-03-26 14:00:34","Undefined redux-react state in componet","<javascript><reactjs><redux>","1","1","","",""
"48491175","1","48491251","","2018-01-28 20:52:40","","0","23","<p>I've been following a react tutorial by Wes Bos and I can't seem to get some of the state to persist using the firebase database. My 'order' state seems to persist, but the 'fishes' state in my inventory doesn't.</p>

<p>Specifically, I can see the changes made to 'fishes' once I change them in the react app, but if I exit the store and come back in, the order persists but the 'fishes' do not. </p>

<p>base.js</p>

<pre><code>import Rebase from 're-base';
import * as firebase from 'firebase';

const app = firebase.initializeApp({
  apiKey: ""XXXXXXXXX"",
  authDomain: ""XXXXXXXX"",
  databaseURL: ""XXXXXXXXXXXXXXXXX"",
  projectId: ""XXXXXXXXXXXX"",
  storageBucket: ""XXXXXXXXXXXXXXXXX"",
});

const base = Rebase.createClass(app.database());

export default base;
</code></pre>

<p>app.js</p>

<pre><code>import React from 'react';
import Header from './Header';
import Order from './Order';
import Inventory from './Inventory';
import Fish from './Fish';
import sampleFishes from '../sample-fishes';
import base from '../base';
import PropTypes from 'prop-types';
import * as firebase from 'firebase';

export default class App extends React.Component {
  constructor() {
    super();

    this.addFish = this.addFish.bind(this);
    this.loadSamples = this.loadSamples.bind(this);
    this.addToOrder = this.addToOrder.bind(this);
    this.updateFish = this.updateFish.bind(this);
    this.removeFish = this.removeFish.bind(this);
    this.removeFromOrder = this.removeFromOrder.bind(this);

    this.state = {
      fishes: {},
      order: {},
    };

  }

componentDidMount() {
    this.FishRef = base.syncState(`${this.props.match.params.storeId}/fishes`,
    {
      context: this,
      state: 'fishes' 
    });
  }

  componentDidMount() {
    this.OrderRef = base.syncState(`${this.props.match.params.storeId}/order`,
    {
      context: this,
      state: 'order' 
    });
  }

  componentWillUnmount() {
    base.removeBinding(this.FishRef);
    base.removeBinding(this.OrderRef);
  }

  addFish(fish) {
    const fishes = {...this.state.fishes};
    const timestamp = Date.now();
    fishes[`fish-${timestamp}`] = fish;
    this.setState({ fishes });
  }

  removeFish(key) {
    const fishes = {...this.state.fishes};
    fishes[key] = null;
    this.setState({ fishes });
  }

  updateFish(key, updatedFish) {
    const fishes = {...this.state.fishes};
    fishes[key] = updatedFish;
    this.setState({ fishes });
  }

  loadSamples() {
    this.setState({
      fishes: sampleFishes
    });
  }

  addToOrder(key) {
    const order = {...this.state.order};
    order[key] = order[key] + 1 || 1;
    this.setState({ order });
  }

  removeFromOrder(key){
    const order = {...this.state.order};
    delete order[key];
    this.setState({ order });
  }

  render() {
    return(
      &lt;div className=""catch-of-the-day""&gt;
        &lt;div className=""menu""&gt;
          &lt;Header tagline=""Fresh seafood market""/&gt;
          &lt;ul className=""list-of-fishes""&gt;
            {Object
              .keys(this.state.fishes)
              .map(key =&gt; &lt;Fish key={key}
                details={this.state.fishes[key]}
                addToOrder={this.addToOrder}
                index={key}
                /&gt;)
            }
          &lt;/ul&gt;
        &lt;/div&gt;
        &lt;Order fishes={this.state.fishes}
          order={this.state.order}
          removeFromOrder={this.removeFromOrder}/&gt;
        &lt;Inventory addFish={this.addFish}
          loadSamples={this.loadSamples}
          fishes = {this.state.fishes}
          updateFish = {this.updateFish}
          removeFish = {this.removeFish}/&gt;
      &lt;/div&gt;
    );
  }
}

App.propTypes = {
  match: PropTypes.object.isRequired
}
</code></pre>
","3532271","","6143482","","2018-01-30 06:28:37","2018-01-30 06:28:37","Not all state attributes populating from firebase databse in react app","<reactjs><firebase><firebase-database>","1","0","","",""
"31990294","1","","","2015-08-13 13:57:35","","2","682","<p>I'm using CKEditor with my project and im trying to prefill the textarea with data im getting from the server, that way it is easier for a user to edit. I do so in this component:</p>

<pre><code>import React from 'react';
import {Link,State, Route} from 'react-router';
import Router from 'react-router';
import ReportsActions from 'actions/ReportsActions';
import ReportsStore from 'stores/ReportsStore';
import $ from 'jquery';

export default class EditReport extends React.Component {
constructor(props) {
  super(props);
  this.state = ReportsStore.getState();
  this.state.singleReport = [];
  this.state.editReport = [];
  this.state.link = window.location.href;
    }

componentDidMount() {
  let state = this.state.link;
  state = state.split('/');
  state = state[state.length-2];
  ReportsActions.getSoloReport(state);
  ReportsStore.listen(this._onChanges);
 CKEDITOR.replace( 'ckedit', {
  allowedContent : true,      
  pasteFromWordRemoveFontStyles : false,
  pasteFromWordRemoveStyles : false
  });
  console.log(this.state.editReport);
 }
componentWillUnmount() {
  ReportsStore.unlisten(this._onChanges);
    }

_onChanges = () =&gt; {
  this.setState({
      singleReport: ReportsStore.getState().singleReport,
      duplicate: ReportsStore.getState().singleReport,
      editReport: ReportsStore.getState().editReport
    });
}

_onCreateReport = () =&gt; {
  for ( var instance in CKEDITOR.instances )
        CKEDITOR.instances[instance].updateElement();

  let state = this.state.link;
  state = state.split('/');
  state = state[state.length-2];
  const title = React.findDOMNode(this.refs.title).value;
  const date = React.findDOMNode(this.refs.date).value;
  const body = React.findDOMNode(this.refs.body).value;
  const id = state;
  ReportsActions.editReport({
        title: title,
        date: date,
        body: body,
        id: id
    });
}

render() {
  let singleReport = this.state.singleReport;
  let editReport = this.state.editReport;
  let ckbody = ""fetching data.."";
  if(ckbody == undefined) {
     ckbody = ""Fetching data.."";
  }
  else {
    ckbody = editReport.body;
   }

 let state = this.state.link;
 if(CKEDITOR.instances['ckedit'] == undefined) {
    console.log('not defined');
 }
  else {
    console.log(CKEDITOR.instances['ckedit'].getData());
    CKEDITOR.instances['ckedit'].setData(ckbody);
  }
  state = state.split('/');
  state = state[state.length-2];
  return(
    &lt;div&gt;
    &lt;main&gt;
    &lt;h1&gt;Hello im trying to edit&lt;/h1&gt;
    &lt;fieldset className = ""fieldSet2""&gt;
          &lt;input type = ""text"" placeholder = {editReport.title} ref = ""title""/&gt;
          &lt;input type = ""text"" placeholder = {editReport.date} ref = ""date""/&gt;
          &lt;textarea className = ""ckeditor"" id = ""ckedit"" ref = ""body"" name = ""ckedit"" defaultValue = {editReport.body}&gt;{editReport.body}&lt;/textarea&gt;
          &lt;Link to= ""singlereports"" params ={{id: state}}&gt;&lt;button type=""submit"" rows = ""5"" cols = ""5"" className =""superButton"" onClick={this._onCreateReport}&gt;Edit Report&lt;/button&gt;&lt;/Link&gt;
          &lt;/fieldset&gt;
          &lt;div className =""toMyEmployees2""&gt;
        &lt;div className=""containers1""&gt;
  &lt;div className=""spacer""&gt;
   &lt;Link to=""AllEmployees""&gt;
    &lt;a className=""wide blue""&gt;
    &lt;i className=""fa fa-users""&gt;&lt;/i&gt;
      &lt;h2&gt;View All Employees&lt;/h2&gt;
    &lt;/a&gt;
    &lt;/Link&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;div className =""toMyEmployees3""&gt;
        &lt;div className=""containers1""&gt;
  &lt;div className=""spacer""&gt;
   &lt;Link to=""dashboard""&gt;
    &lt;a className=""wide redgay""&gt;
    &lt;i className=""fa fa-tachometer""&gt;&lt;/i&gt;
      &lt;h2&gt;Dashboard&lt;/h2&gt;
    &lt;/a&gt;
    &lt;/Link&gt;
    &lt;/div&gt;
    &lt;/div&gt;
        &lt;/div&gt;
        &lt;/div&gt;
    &lt;/main&gt;
    &lt;/div&gt;
    );

}
}
</code></pre>

<p>I've set CKEditor and initialized it in ComponentDidMount, then in render I try to setHTML to one of my states. When I first visit the component the editor displays the data inside it that I wan't to edit, however if I hit the back button or any other link/route and return to the editor, it spits out 'cannot read property of getSelection of undefined', tracing it, it belongs to this.document.getWindow. This is a single page app as well. I don't know why it's doing this, but maybe I have to remove the instance as well? </p>
","3357318","","","","","2015-08-13 13:57:35","Ckeditor and reactjs, this.getselection is null","<javascript><ckeditor><reactjs><react-router>","0","0","","",""
"49450876","1","","","2018-03-23 13:34:21","","0","72","<p>[1]How to make a stopwatch app like this <a href=""https://www.online-stopwatch.com/countdown/"" rel=""nofollow noreferrer"">https://www.online-stopwatch.com/countdown/</a> in reactjs...?</p>

<pre><code>import React,{Component} from 'react';

export default class StopWatch extends Component{
  constructor(props){
    super(props);
    this.state={
      time2: ''
    }
  }
  timeCount(){
    this.time= setInterval(() =&gt; {
      this.setState({ time2:this.state.time2 - 1});
    },1000);
  }
  stopTimer() {
    clearInterval(this.time);
  }
  componentDidUpdate(){
    console.log(this.state.time2);
    if(this.state.count===0){
      clearInterval(this.time);
    }
  }
  componentWillUnmount(){
    clearInterval(this.time);
  }

  toggle(key){
    if(this.state.time2.length &lt; 6) {
      this.setState({ time2: `${this.state.time2}` + `${key}` });
    }
  }
</code></pre>

<p>[2]:Value of timer is not changing after trigger buttons.Provide me the 
     best method to achieve this.</p>

<p>Reference Link: <a href=""https://www.online-stopwatch.com/countdown/"" rel=""nofollow noreferrer"">https://www.online-stopwatch.com/countdown/</a></p>
","9540479","","","","","2018-03-23 13:34:21","How to make a Stopwatch app in reactjs?","<stopwatch>","0","0","","",""
"49509685","1","","","2018-03-27 09:51:12","","1","122","<p>My code for setting up a Fade transition is the simplest :</p>

<pre><code>import React from 'react';
import { Transition } from 'react-transition-group';
import PropTypes from 'prop-types';

const duration = 250;

const defaultStyle = {
  transition: `opacity ${duration}ms ease-in-out, color ${duration}ms ease-in-out`,
  opacity: 0,
}


const transitionStyles = {
  entering: { opacity: 0 },
  entered: { opacity: 1 },
  exiting: { opacity: 1 },
  exited: { opacity: 0 },
};


export default class Fade extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      in: false,
    };
  }

  componentDidMount() {
    this.setState({ in: true });
  }
  componentWillUnmount() {
    this.setState({ in: false });
  }

  render() {

    return(
      &lt;Transition in={!!this.state.in} timeout={{ enter: 250, exit: 250, }} unmountOnExit={this.props.unmountOnExit || false} &gt;
        {(state) =&gt; {
          return (
            &lt;div 
              className={this.props.classes ? this.props.classes : ''} 
              style={{  ...defaultStyle, ...transitionStyles[state],}}&gt;
              {this.props.children}
            &lt;/div&gt;
          )
        }}
      &lt;/Transition&gt;
    )
  }
}

Fade.propTypes = {
  classes: PropTypes.string,
};
</code></pre>

<p>Wrap any of your component within to try it out. I tried to build a snippet with it but I didn't succeed to build one with React, sorry about that.</p>

<p>My question : thanks to <code>componentDidMount</code> I can toggle the state of my component and make the fade in work perfectly. However, I struggle putting in place the fade out : using <code>componentWillUnmount</code> doesn't make it work.</p>

<p>What is the solution to my problem ? How should I delay the unmounting of the component in order to have the transition going on ?</p>
","5225096","","","","","2018-03-27 09:51:12","Basic transition when component unmount with react-transition-group v2 (march 2018)","<reactjs><transition><react-transition-group>","0","0","","",""
"31813512","1","31816415","","2015-08-04 15:36:41","","8","6008","<p>I am using react-router in my application and I am looking for a way to stop the remount of components that are already in the DOM. For example, if I am at the URL <code>dashboard</code>, then I will have an associated <code>DashboardComponent</code> mounted. When I transition to <code>dashboard/settings</code> then my <code>DashboardComponent</code> as well as <code>SettingsComponent</code> get remounted into the DOM. I would like to find a clean way to mount only the children of the current URL. Is this posible?</p>

<p>Router:</p>

<pre><code>import { Component, createFactory, PropTypes } from 'react'
import { Route, RouteHandler, DefaultRoute, NotFoundRoute } from 'react-router'

import Home from '../components/Home'
import Dashboard from '../components/Dashboard'
import ViewPlayers from '../components/clubs/ViewPlayers'

let route = createFactory(Route),
    handler = createFactory(RouteHandler),
    root = createFactory(DefaultRoute),
    pageNotFound = createFactory(NotFoundRoute),
    Transitions = createFactory(require('react/lib/ReactCSSTransitionGroup'));

class App extends Component {

    constructor() {

        super();
    }

    render() {

        return (
            Transitions({transitionName: 'fade'},
                handler({key: this.context.router.getCurrentPath()})
            )
        )
    }
}
App.contextTypes = {
    router: PropTypes.func
};

let Router = (
    route({path: '/', name: 'home', handler: App},
        root({handler: Home}),
        route({path: 'dashboard', name: 'dashboard', handler: Dashboard},
            route({path: 'players', name: 'players', handler: ViewPlayers}),
        )
    )
);
export { Router };
</code></pre>

<p>Dashboard (Parent component):</p>

<pre><code>import React from 'react'
import { RouteHandler, Link } from 'react-router'
import { _, div } from './Html'

export default
class Dashboard extends React.Component {

    constructor() {

        super();

        this.state = {}
    }

    componentWillMount() {

        console.log('mounted')
    }

    componentWillUnmount() {

    }

    render() {

        return (
            div({},
                _(Link)({to: 'players'}),
                _(RouteHandler)({})
            )
        )
    }
}
</code></pre>

<p><strong>Note:</strong> <code>_</code> is just a wrapper for React.createFactory()</p>
","3078552","","3078552","","2015-08-04 18:11:47","2015-08-04 18:16:29","Is it possible to only remount only the new child components on react-router transition","<reactjs><react-router>","1","4","3","",""
"49457341","1","","","2018-03-23 19:47:43","","0","134","<p>I'm learning how to test my components using Jest, but I'm having trouble testing my Login screen. The component is connected to Redux and is part of a navigator. I'm mocking my redux store, but I get the following error when running my tests:</p>

<pre><code> FAIL  __tests__/screens/Login.test.js
 Test suite failed to run

TypeError: Cannot read property 'getStateForAction' of undefined

&gt; 1 | import { NavigationActions } from ""react-navigation"";
  2 | import AppNavigator from ""../navigators/AppNavigator"";
  3 |
  4 | const NavigationInitialState = AppNavigator.router.getStateForAction({

  at Object.&lt;anonymous&gt; (src/redux/reduxHelpers.js:1:1287)
  at Object.&lt;anonymous&gt; (src/redux/reducers/index.js:1:5765)
  at Object.&lt;anonymous&gt; (src/redux/store.js:1:2177)
</code></pre>

<p>The same error happens when trying to test my reducer. It's worth noticing that I'm using react navigation integrated with redux.</p>

<p>Here is the code of my tests for the Login screen:</p>

<pre><code>import React from ""react"";
import { shallow } from ""enzyme"";

import Login from ""../../src/screens/Login"";
import mockStore from ""../../__mocks__/redux-mock-store"";
import { eventInitialState } from ""../../src/redux/reducers"";

jest.mock(""../../src/navigators/AppNavigator"", () =&gt; ({
  AppNavigator: {
    router: {
      getStateForAction: jest.fn(),
      getActionForPathAndParams: jest.fn()
    }
  }
}));

describe(""Testing login screen"", () =&gt; {
  it(""renders as expected"", () =&gt; {
    const wrapper = shallow(&lt;Login /&gt;, {
      context: { store: mockStore(eventInitialState) }
    });
    expect(wrapper.dive()).toMatchSnapshot();
  });
});
</code></pre>

<p>Here is my login screen (big):</p>

<pre><code>import React, { Component } from ""react"";
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  Alert,
  Linking,
  ImageBackground,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Keyboard,
  Image
} from ""react-native"";
import { connect } from ""react-redux"";
import PropTypes from ""prop-types"";

import { login } from ""../redux/actions"";

import Button from ""../components/Button"";
import CustomCheckBox from ""../components/CustomCheckBox"";
import ErrorBox from ""../components/ErrorBox"";
import { VersaoAmbiente } from ""../utils/helpers"";

const recuperarSenhaUrl = ""my-url"";
const backgroundImage = require(""../../assets/images/splash.png"");
const logoImage = require(""../../assets/images/logo-white-v.png"");

const styles = StyleSheet.create({...});

class Login extends Component {
  constructor(props) {
    super(props);

    this.fazerLogin = this.fazerLogin.bind(this);
    this.switch = this.switch.bind(this);
    this.keyboardDidShow = this.keyboardDidShow.bind(this);
    this.keyboardDidHide = this.keyboardDidHide.bind(this);
    this.state = {
      email: """",
      senha: """",
      continuarConectado: true,
      tecladoVisivel: false
    };
  }

  componentWillMount() {
    if (Platform.OS !== ""ios"") {
      this.keyboardDidShowListener = Keyboard.addListener(
        ""keyboardDidShow"",
        this.keyboardDidShow
      );
      this.keyboardDidHideListener = Keyboard.addListener(
        ""keyboardDidHide"",
        this.keyboardDidHide
      );
    }
  }

  componentWillUnmount() {
    if (Platform.OS !== ""ios"") {
      this.keyboardDidShowListener.remove();
      this.keyboardDidHideListener.remove();
    }
  }

  keyboardDidShow() {
    this.setState({
      tecladoVisivel: true
    });
  }

  keyboardDidHide() {
    this.setState({
      tecladoVisivel: false
    });
  }

  esqueciMinhaSenha = () =&gt; {
    Linking.openURL(recuperarSenhaUrl).catch(err =&gt; {
      Alert.alert(""Ops, um erro ocorreu"", err, [{ text: ""OK"" }], {
        cancelable: false
      });
    });
  };

  fazerLogin() {
    const { email, senha, continuarConectado } = this.state;
    this.props.login(email.trim(), senha.trim(), continuarConectado);
  }

  switch(value) {
    this.setState({ continuarConectado: value });
  }

  mensagemErro() {
    const { erroLogin, erroNegocio } = this.props;
    return erroLogin &amp;&amp; erroLogin.response &amp;&amp; erroLogin.response.status === 401
      ? ""Email ou senha incorretos""
      : erroNegocio &amp;&amp; erroNegocio.mensagem
        ? erroNegocio.mensagem
        : ""Ops, houve um erro. Tente novamente"";
  }

  render() {
    const { erroLogin, logando } = this.props;

    return (
      &lt;ImageBackground style={styles.container} source={backgroundImage}&gt;
        &lt;KeyboardAvoidingView
          style={styles.keyboardViewContainer}
          behavior={Platform.OS === ""ios"" ? ""padding"" : null}
        &gt;
          &lt;ScrollView
            style={styles.scrollView}
            contentContainerStyle={styles.contentScrollView}
            scrollEnabled={false}
          &gt;
            &lt;Image
              source={logoImage}
              style={{
                marginBottom: 20.7 * 3,
                width: 155,
                height: 125
              }}
            /&gt;

            &lt;TextInput
              value={this.state.email}
              placeholder=""Usuário""
              style={[styles.input, { marginBottom: 4 * 3 }]}
              placeholderTextColor=""#828282""
              maxLength={255}
              autoCorrect={false}
              keyboardType=""email-address""
              autoCapitalize=""none""
              returnKeyType=""done""
              underlineColorAndroid=""transparent""
              onChangeText={text =&gt; this.setState({ email: text })}
            /&gt;

            &lt;TextInput
              value={this.state.senha}
              placeholder=""Senha""
              style={styles.input}
              placeholderTextColor=""#828282""
              maxLength={255}
              autoCorrect={false}
              autoCapitalize=""none""
              returnKeyType=""done""
              secureTextEntry
              underlineColorAndroid=""transparent""
              onChangeText={text =&gt; this.setState({ senha: text })}
            /&gt;

            &lt;View style={styles.esqueceuView}&gt;
              &lt;TouchableOpacity onPress={this.esqueciMinhaSenha}&gt;
                &lt;Text style={styles.esqueceuSenha}&gt;Esqueceu a senha?&lt;/Text&gt;
              &lt;/TouchableOpacity&gt;
            &lt;/View&gt;

            &lt;CustomCheckBox
              style={styles.continuarConectadoView}
              onValueChange={this.switch}
              value={this.state.continuarConectado}
            &gt;
              &lt;Text style={styles.continuarConectadoText}&gt;
                Manter conectado
              &lt;/Text&gt;
            &lt;/CustomCheckBox&gt;

            &lt;View style={styles.viewButton}&gt;
              &lt;Button
                title=""ACESSAR SISTEMA""
                onPress={() =&gt; this.fazerLogin()}
                titleStyle={styles.buttonText}
                buttonStyle={styles.button}
                loading={logando}
              /&gt;
            &lt;/View&gt;
            {erroLogin &amp;&amp; (
              &lt;View style={styles.erroBox}&gt;
                &lt;ErrorBox defaultMessage={this.mensagemErro()} /&gt;
              &lt;/View&gt;
            )}
          &lt;/ScrollView&gt;
        &lt;/KeyboardAvoidingView&gt;
        {!this.state.tecladoVisivel &amp;&amp; (
          &lt;Text style={styles.versao}&gt;{VersaoAmbiente}&lt;/Text&gt;
        )}
      &lt;/ImageBackground&gt;
    );
  }
}

function mapDispatchToProps(dispatch) {
  return {
    login: (email, senha, continuarConectado) =&gt;
      dispatch(login(email, senha, continuarConectado))
  };
}

function mapStateToProps(state) {
  return {
    erroLogin: state.config.erroLogin,
    erroNegocio: state.config.erroNegocio,
    logando: state.config.logando
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(Login);

/* eslint-disable */
Login.propTypes = {
  erroLogin: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),
  erroNegocio: PropTypes.object,
  logando: PropTypes.bool.isRequired,
  login: PropTypes.func.isRequired
};
</code></pre>

<p>And, finally, my reducer:</p>

<pre><code>import { NavigationActions } from ""react-navigation"";
import AppNavigator from ""../navigators/AppNavigator"";

const NavigationInitialState = AppNavigator.router.getStateForAction({
  type: NavigationActions.Init
});

const LoggedInInitialState = AppNavigator.router.getStateForAction(
  NavigationActions.reset({
    index: 1,
    actions: [
      NavigationActions.navigate({ routeName: ""Splash"" }),
      NavigationActions.navigate({ routeName: ""Drawer"" })
    ]
  }),
  NavigationInitialState
);
const navReducer = (state = NavigationInitialState, action) =&gt; {
      let newState;
      let logoutSuccessAction;
      switch (action.type) {
        case LOAD_STATE:
          return LoggedInInitialState;
        case LOGIN:
          return LoggedInInitialState;
        case LOGOUT:
          logoutSuccessAction = NavigationActions.reset({
            index: 0,
            actions: [NavigationActions.navigate({ routeName: ""Login"" })]
          });
          return AppNavigator.router.getStateForAction(logoutSuccessAction, state);
        default:
          newState = AppNavigator.router.getStateForAction(action, state);
          break;
      }
      return newState || state;
    };
</code></pre>

<p><strong>Any ideas?</strong></p>
","2175458","","","","","2018-03-23 19:47:43","Testing screen connected to redux in a react native app that uses react navigation - JEST","<react-native><redux><jestjs><react-navigation>","0","0","","",""
"33129192","1","33129829","","2015-10-14 15:14:37","","3","886","<p>I'm creating my first application with React and have encountered an issue that I'm sure is easy to solve but I can't figure out how. I can't get the user to see a new ""success"" page after they signup. 
I think the redirect should be in the state but I can't seem to find the right calls to make. This is what I have so far:</p>

<h2>SignUpForm.js</h2>

<pre><code>import React from 'react';
import {Link} from 'react-router';
import SignUpFormStore from '../stores/SignUpFormStore';
import SignUpFormActions from '../actions/SignUpFormActions';

class SignUpForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = SignUpFormStore.getState();
    this.onChange = this.onChange.bind(this);
  }

  componentDidMount() {
    SignUpFormStore.listen(this.onChange);
  }

  componentWillUnmount() {
    SignUpFormStore.unlisten(this.onChange);
  }

  onChange(state) {
    this.setState(state);
  }

  handleSubmit(e){
    e.preventDefault();
    var first_name = this.state.first_name;
    var last_name = this.state.last_name;
    var email = this.state.email;
    var phone = this.state.phone;
    var password = this.state.password;
    var passwordConfirmation = this.state.passwordConfirmation;
    var tos = this.state.tos;

    if (!first_name) {
      SignUpFormActions.invalidFirstName();
    };

    SignUpFormActions.addUser(
      first_name,
      last_name,
      email,
      phone,
      password,
      passwordConfirmation,
      tos
    );
   }
  render() {
    return (
      &lt;div&gt;

         &lt;form className=""SignUpForm col-md-4"" onSubmit={this.handleSubmit.bind(this)}&gt;
          &lt;span className='help-block'&gt;{this.state.helpBlock}&lt;/span&gt;
          &lt;div className={'form-group ' + this.state.firstNameValidationState}&gt;
            &lt;input type=""text"" placeholder=""First Name"" ref=""first_name"" className=""form-control"" value={this.state.first_name}  onChange={SignUpFormActions.updateFirstName} required/&gt;
          &lt;/div&gt;
          ...
          &lt;input type=""submit"" value=""Sign Up"" className=""btn btn-primary""/&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }
}

export default SignUpForm;
</code></pre>

<h2>SignUpFormActions.js</h2>

<pre><code>import alt from '../alt';
import {assign} from 'underscore';

class SignUpFormActions {
  constructor() {
    this.generateActions(
        'addUserSuccess',
        'addUserFail',
        ...
    );
  }

  addUser(first_name, last_name, email, phone, password, passwordConfirmation, tos){
    var data = { 
        first_name: first_name,
        last_name: last_name,
        email: email,
        phone_number: phone,
        password: password,
        password_confirmation: passwordConfirmation,
        tos: tos
      };

    $.ajax({
      type: 'POST',
      url: 'https://app.herokuapp.com/users',
      crossDomain: true,
      dataType: 'json',
      data: data
    })
      .done((data) =&gt; {
        this.actions.addUserSuccess(data.message);
      })
      .fail((jqXhr) =&gt; {
        this.actions.addUserFail(jqXhr.responseJSON.error.message);
  });
 }
</code></pre>

<h2>SignUpFormStore.js</h2>

<pre><code>import alt from '../alt';
import SignUpFormActions from '../actions/SignUpFormActions';

class SignUpFormStore {
  constructor() {
    this.bindActions(SignUpFormActions);
    this.first_name= """";
    ...
  }

  onAddUserSuccess(successMessage) {
    console.log('add user success!');
    //I think the user should be re-directed here
    //I have tried these two options but they don't work
    //Route.get().transitionTo('/success');
    //transition.redirect('success');
  }
  onAddUserFail(errorMessage){
    console.log('add user error! ' + errorMessage);
    this.helpBlock = errorMessage;
  }
  ...
}

export default alt.createStore(SignUpFormStore);  
</code></pre>

<h2>Routes.js</h2>

<pre><code>import React from 'react';
import {Route} from 'react-router';
import App from './components/App';
import Home from './components/Home';
import LoginForm from './components/LoginForm';
import SignUpForm from './components/SignUpForm';
import Success from './components/Success';

export default (
  &lt;Route handler={App}&gt;
    &lt;Route path='/' handler={Home} /&gt;
    &lt;Route path='/login' handler={LoginForm} /&gt;
    &lt;Route path='/signup' handler={SignUpForm} /&gt;
    &lt;Route path='/success' handler={Success} /&gt;
  &lt;/Route&gt;
);
</code></pre>
","4178090","","218196","","2015-10-14 20:50:55","2015-10-15 14:39:57","Redirect after signup [react, react-router, alt]","<javascript><reactjs><react-router>","1","1","1","",""
"49515009","1","","","2018-03-27 14:02:27","","0","37","<p>I want to use jQuery and <a href=""https://harvesthq.github.io/chosen/"" rel=""nofollow noreferrer"">chosen</a> library  to make dynamic select box.
This is chosen component:</p>

<pre><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import $ from 'jquery'
import ""chosen-js/chosen.css"";
import ""chosen-js/chosen.jquery.js"";

export default class Chosen extends Component {
  componentDidMount() {
    this.$el = $(this.el)
    this.$el.chosen({ rtl: true })

    this.handleChange = this.handleChange.bind(this)
    this.$el.on('change', this.handleChange)
  }

  componentWillUnmount() {
    this.$el.chosen('destroy');
  }

  handleChange(e) {
    this.props.onChange(e.target.value)
  }

  render() {
    return (
      &lt;div&gt;
        &lt;select className=""Chosen-select"" style={{ width: ""100%"" }} ref={el =&gt; this.el = el}&gt;
          {this.props.children}
        &lt;/select&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>When import chosen component in and i want to fetch data from api, Select box that created will be empty. but real select box that hidden by chosen have option.
This my code for import data from api:</p>

<pre><code>componentDidMount() {
 fetch('/api/getcarname')
  .then(response =&gt; {
    return response.json();
  })
  .then(response =&gt; {
    this.setState({
     carName: response
    })
  })
}
render() {
 return (
  &lt;Chosen className=""chosen-container chosen-container-single"" onChange={value =&gt; console.log(value)}&gt;
    {this.state.carName.map((object, i) =&gt;
    &lt;option key={i}&gt;
    {object.name}
     &lt;/option&gt;
    )}
 &lt;/Chosen&gt;
)}
</code></pre>

<p>How Can i fetch data to html then run chosen component to attach option in fake select box?</p>
","4026146","","5159261","","2018-03-27 14:14:46","2018-03-27 14:14:46","render chosen library option from api JSON react","<javascript><jquery><reactjs><jquery-chosen>","0","0","","",""
"39814995","1","39815100","","2016-10-02 07:56:12","","1","582","<p>I have just started with learning reactjs and trying to retrieve data through an ajax call. The component looks like this:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import $ from 'jquery';

class App extends React.Component {
   // myTitle='';

    constructor() {
        super();
        this.state = {val: 0};
        this.update = this.update.bind(this);
    }

    update() {
        var root = 'http://jsonplaceholder.typicode.com';
        $.ajax({
            url: root + '/posts/1',
            method: 'GET'
        }).then(function (data) {
            this.state.val = data.title;
        });

        console.log(this.state);
    }

    componentWillMount() {
        console.log('mounting')
    }

    render() {
        console.log('rendering!')
        return &lt;button onClick={this.update}&gt;{this.state.val}&lt;/button&gt;
    }

    componentDidMount() {
        console.log('mounted')
    }

    componentWillUnmount() {
        console.log('bye!')
    }
}
</code></pre>

<p>When the ajaxcall comes back it returns an error where the state.val statement is:</p>

<pre><code>jQuery.Deferred exception: Cannot set property 'val' of undefined TypeError: Cannot set property 'val' of undefined
    at Object.&lt;anonymous&gt; (http://localhost:3000/08-lifecycle-mounting/index.js:28958:33)
    at mightThrow (http://localhost:3000/08-lifecycle-mounting/index.js:32563:30)
    at process (http://localhost:3000/08-lifecycle-mounting/index.js:32631:13) 
</code></pre>

<p>How can I update the state and use the returning data from the ajax call?</p>
","5390873","","","","","2016-10-02 09:27:26","How to use response data from ajax call in react?","<jquery><ajax><reactjs>","1","0","1","",""
"48535492","1","48537622","","2018-01-31 06:04:27","","0","532","<p>I am doing this simple steps but unmount was not calling I don't know why. Please I need a solution for this I need unmount to be get called while navigating to another screen...</p>

<pre><code>class Homemain extends Component {
    constructor(props) {
        super(props);
    }

    componentWillMount(){
        alert('willMount')
    }
    componentDidMount(){
        alert('didMount')
    }
    componentWillUnmount(){
        alert('unMount')
    }
    Details = () =&gt; {
        this.props.navigation.navigate('routedetailsheader')
    }

    render() {
        return(
            &lt;View style={styles.container}&gt;
                &lt;TouchableOpacity onPress={() =&gt; this.Details()} style={{ flex: .45, justifyContent: 'center', alignItems: 'center', marginTop: '10%', marginRight: '10%' }}&gt;
                    &lt;Image
                        source={require('./../Asset/Images/child-notification.png')}
                        style={{ flex: 1, height: height / 100 * 20, width: width / 100 * 20, resizeMode: 'contain' }} /&gt;
                    &lt;Text
                        style={{ flex: 0.5, justifyContent: 'center', fontSize: width / 100 * 4, fontStyle: 'italic', fontWeight: '400', color: '#000', paddingTop: 10 }}&gt;Details&lt;/Text&gt;
                &lt;/TouchableOpacity&gt;
            &lt;/View&gt;
        );
    }
}
export default (Homemain);
</code></pre>

<p>This is my RouteConfiguration in this way I am navigating to the next screen. Can someone please help me for this error  so that i can proceed to the next steps</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { addNavigationHelpers, NavigationActions } from 'react-navigation';
import { connect } from 'react-redux';
import { BackHandler } from 'react-native';
import { Stack } from './navigationConfiguration';

const getCurrentScreen = (navigationState) =&gt; {
  if (!navigationState) {
    return null
  }
  const route = navigationState.routes[navigationState.index]
  if (route.routes) {
    return getCurrentScreen(route)
  }
  return route.routeName
}
class StackNavigation extends Component {
  static propTypes = {
    dispatch: PropTypes.func.isRequired,
    navigation: PropTypes.shape().isRequired,
  };

  constructor(props) {
    super(props);
    BackHandler.addEventListener('hardwareBackPress', this.backAction);
  }

  //backAction = () =&gt; this.navigator.props.navigation.goBack();

  backAction = () =&gt; {
    const { dispatch, navigation } = this.props;
    const currentScreen = getCurrentScreen(navigation)

    if (currentScreen === 'Homemain') {
      return false
    }
    else
      if (currentScreen === 'Login') {
        return false
      }

    dispatch(NavigationActions.back());
    return true;
  };

  render() {
    const { dispatch, navigation } = this.props;

    return (
      &lt;Stack
        ref={(ref) =&gt; { this.navigator = ref; }}
        navigation={
          addNavigationHelpers({
            dispatch,
            state: navigation,
          })
        }
      /&gt;
    );
  }
}

export default connect(state =&gt; ({ navigation: state.stack }))(StackNavigation);
</code></pre>
","6689575","","6689575","","2018-01-31 09:27:08","2018-01-31 12:37:52","react-native componentWillUnmount not working while navigating","<react-native>","3","4","","",""
"49187991","1","","","2018-03-09 06:42:51","","2","151","<p>I am developing sample application in react-native. i am creating Netinfo file after i am calling like component another screen.</p>

<p>Where should i place this component to get it into all screens?</p>

<p>Main problem is status not always changing when networking changes.</p>

<p>if i select offline showing red textview, and then i am choose online showing green Textview. Again if i change  tooffline it's not updated.</p>

<p>Here this is my sample code:</p>

<pre><code>import React, { PureComponent } from 'react';
import { View, Text, NetInfo, Dimensions, StyleSheet } from 'react-native';

const { width } = Dimensions.get('window');

function MiniOfflineSign() {
  return (
    &lt;View style={styles.offlineContainer}&gt;
      &lt;Text style={styles.offlineText}&gt;No Internet Connection&lt;/Text&gt;
    &lt;/View&gt;
  );
}

class OfflineNotice extends PureComponent {
  state = {
    isConnected: true
  };

  componentDidMount() {
    NetInfo.isConnected.addEventListener('connectionChange', this.handleConnectivityChange);
  }

  componentWillUnmount() {
    NetInfo.isConnected.removeEventListener('connectionChange', this.handleConnectivityChange);
  }

  handleConnectivityChange = isConnected =&gt; {
    if (isConnected) {
      this.setState({ isConnected });
    } else {
      this.setState({ isConnected });
    }
  };

  render() {
    if (!this.state.isConnected) {
      return (
         &lt;View style={styles.offlineContainer}&gt;
          &lt;Text style={styles.offlineText}&gt;No Internet Connection&lt;/Text&gt;
         &lt;/View&gt;
         );
    }else{
       return (
         &lt;View style={[styles.offlineContainer, {backgroundColor:'green'}]}&gt;
          &lt;Text style={styles.offlineText}&gt;Internet Connection Is Availiable&lt;/Text&gt;
         &lt;/View&gt;
         );

    }
  }
}

const styles = StyleSheet.create({
  offlineContainer: {
    backgroundColor: '#b52424',
    height: 30,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
    width,
    position: 'absolute',
    top: 30
  },
  offlineText: { color: '#fff' }
});

export default OfflineNotice; 
</code></pre>
","6642958","","4420967","","2018-03-09 07:52:35","2018-03-09 07:52:35","NetInfo not working perfectly in react-native (often not updatings)","<react-native><react-native-android><react-native-ios>","0","2","","",""
"49285513","1","","","2018-03-14 18:43:42","","2","79","<p>I am trying to read the networkstatechange in react-native ios code as : </p>

<pre><code>componentDidMound(){
NetInfo.isConnected.addEventListener('connectionChange',this._handleNetworkStateChange);
}

componentWillUnmount(){
NetInfo.isConnected.removeEventListener('connectionChange',this._handleNetworkStateChange);
}

_handleNetworkStateChange = (isConnected) =&gt; {
this.setState({
netStatus : isConnected
})
}
</code></pre>

<p>1)When nework is Active :
while network state is changing from online to offline. App(ios) is directely crashing instead of reading state. </p>

<p>2)when network is inActive/offline initially :
while changing network state from offline to online, it works properly. shows and loads the view perfectly.</p>

<p>any help would be appreciated as i have gone through many tutorials but not getting the solution.Thanks in advance.</p>
","8432870","","","","","2018-03-14 18:43:42","getting crash while using NetInfo.isConnected in ios react native","<react-native-ios><network-state>","0","0","","",""
"49300675","1","","","2018-03-15 13:26:24","","0","43","<p>i am doing async loading with react router,all is working fine but when i send some id in route,then it gives me error,</p>

<p>When i go to invite-members/10,then it gives me error,please help me what to do?</p>

<p>using react-router-dom - ^4.2.2.</p>

<p>But when i remove async component it works well that parameter route</p>

<p><a href=""https://i.stack.imgur.com/l7pbM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/l7pbM.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>Route.js</p>
</blockquote>

<pre><code>&lt;Switch&gt;
 &lt;Route path={`${match.url}your-performance`} exact component={asyncComponent(() =&gt; import('../containers/charts/yourPerformance/index'))}
        /&gt;
        &lt;Route
            path={`${match.url}invite-members/:groupID`}
            exact
            component={asyncComponent(() =&gt; import('../containers/inviteMembers/index'))}
        /&gt;
        &lt;Route
            path={`${match.url}team-and-players`}
            exact
            component={asyncComponent(() =&gt; import('../containers/teams&amp;players/index'))}
        /&gt;

        &lt;Route component={asyncComponent(() =&gt; import('../app/routes/extraPages/routes/404'))} /&gt;
&lt;/Switch&gt;
</code></pre>

<blockquote>
  <p>Async.js</p>
</blockquote>

<pre><code>import React, {Component} from 'react';
 import Nprogress from 'nprogress';
 import ReactPlaceholder from 'react-placeholder';
 import 'nprogress/nprogress.css';
 import 'react-placeholder/lib/reactPlaceholder.css';

export default function asyncComponent(importComponent) {
 class AsyncFunc extends Component {
    constructor(props) {
        super(props);
        this.state = {
            component: null
        };
    }

    componentWillMount() {
        Nprogress.start();
    }

    componentWillUnmount() {
        this.mounted = false;
    }

    async componentDidMount() {
        this.mounted = true;
        const {default: Component} = await importComponent();
        Nprogress.done();
        if (this.mounted) {
            this.setState({
                component: &lt;Component {...this.props} /&gt;
            });
        }
    }

    render() {
        const Component = this.state.component || &lt;div/&gt;;
        return (
            &lt;ReactPlaceholder type=""text"" rows={7} ready={Component !== null}&gt;
                {Component}
            &lt;/ReactPlaceholder&gt;
        );
    }
}

return AsyncFunc;
}
</code></pre>
","8759508","","","","","2018-03-15 13:26:24","issue in async loading in react router","<javascript><reactjs><react-router><react-redux><react-router-v4>","0","0","","",""
"49742348","1","49742423","","2018-04-09 22:02:00","","0","31","<p>I am building an app using create-react-native-app and Expo and I would like to call a search function when the on-screen keyboard closes.</p>

<pre><code>class SearchPage extends Component {
  state = {
    modalVisible: false
  };
  componentDidMount() {
    this.keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      this._keyboardDidHide
    );
  }

  componentWillUnmount() {
    this.keyboardDidHideListener.remove();
  }

  _keyboardDidHide() {
    this.onSearchButtonPress();
  }
  onSearchButtonPress() {
    this.props.searchCatalog(
      this.props.search,
      this.props.begins,
      this.props.makes
    );
  }
...
}
</code></pre>

<p>I have tried calling <code>this.props.searchCatalog(...)</code> directly inside of <code>_keyboardDidHide()</code> but every time I get the same sort of error:</p>

<p>""this.onSearchButtonPress is not a function. (In `this.onSearchButtonPress()', 'this.onSearchButtonPress' is undefined)</p>

<p>Ultimately, all I want to do is call <code>this.props.searchCatalog(...)</code> when the on-screen keyboard closes.</p>
","9053902","","","","","2018-04-09 22:09:34","Calling a function inside react-native keyboardDidHide","<javascript><reactjs><react-native>","1","0","","",""
"49120598","1","","","2018-03-05 22:32:33","","0","24","<p>I have found this piece of code for a component that displays dots on loading.</p>

<pre><code>class LoadingDots extends React.Component {
    constructor(props, context) {
        super(props, context);

        this.state = {frame: 1};
    }

    componentDidMount() {
        this.interval = setInterval(() =&gt; {
            this.setState({ // eslint-disable-line react/no-did-mount-set-state
                frame: this.state.frame + 1
            });
        }, this.props.interval);
    }

    componentWillUnmount() {
       clearInterval(this.interval);
    }

    render() {
        let dots = this.state.frame % (this.props.dots + 1);
        let text = '';
        while (dots &gt; 0) {
            text += '.';
            dots--;
        }
        return &lt;span {...this.props}&gt;{text}&amp;nbsp;&lt;/span&gt;;
    }
}

LoadingDots.defaultProps = {
    interval: 300, dots: 3
};

LoadingDots.propTypes = {
    interval: PropTypes.number,
    dots: PropTypes.number
}
</code></pre>

<p>What I wonder is how is this being calculated so that it gives the result on the console like this one, when we pass the value of 20 for the dots property and 100 for the interval property?</p>

<pre><code>let dots = this.state.frame % (this.props.dots + 1);
console.log(dots) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
</code></pre>

<p>What confuses me, is this part, since from what I thought if we pass <code>20</code>, and we have set the state to <code>frame: 1</code> then we would set the dots variable to <code>1</code>, since <code>1 % 21</code> is <code>1</code>, the first time on render function, and then in the while loop would just decrease it to <code>0</code> and it would stop there. So, I assume that react rerenders the template on each state change, so the frame increases on each interval, but how we go then from <code>0</code> to <code>20</code>, if the first time the frame is set to <code>1</code>, and then we decrease the <code>dots</code> in the <code>while</code> loop. Not sure about what is the point of decreasing the <code>dots</code> either in the <code>while</code> loop if we are already changing the variable on each interval?</p>
","7071069","","","","","2018-03-05 22:32:33","Javascript/react loading function explanation","<javascript><reactjs>","0","2","","",""
"49776175","1","49785000","","2018-04-11 13:17:07","","1","376","<p>version:
<code>
""dependencies"": {
""prop-types"": ""^15.6.1"",
""react"": ""16.3.1"",
""react-native"": ""0.55.2"",
""react-native-elements"": ""^0.19.1"",
""react-navigation"": ""^1.5.11"",
""react-navigation-redux-helpers"": ""^1.0.5"",
""react-redux"": ""^5.0.7"",
""redux"": ""^3.7.2"",
""redux-thunk"": ""^2.2.0""
},
</code></p>

<p>After using the latest version of <code>react-navigation</code> with <code>redux</code>, i get the message:</p>

<blockquote>
  <p><strong>'Warning: isMounted(...) is deprecated in plain JavaScript React classes. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.'</strong>
  I didn't use <em>isMounted</em> in my code.</p>
</blockquote>

<p>I don't know why this happen. 
I haven't get this message before.</p>

<p>Need some help, please.</p>

<pre><code>import React from 'react';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import PropTypes from 'prop-types';
import {View, Text, Button} from 'react-native';
import {handleNav} from '../../actions/navAction';
import styles from '../styles/styles';
const Login = ({handleNav}) =&gt; (
&lt;View style={styles.container}&gt;
&lt;Text&gt;Login Page&lt;/Text&gt;
&lt;Text&gt;Login Page&lt;/Text&gt;
&lt;Text&gt;Login Page&lt;/Text&gt;
&lt;Text&gt;Login Page&lt;/Text&gt;
&lt;Text&gt;Login Page&lt;/Text&gt;
&lt;Text&gt;Login Page&lt;/Text&gt;
&lt;Button
title = {'Login Button'}
onPress = {handleNav.bind(null, 'MAIN')}
/&gt;
&lt;Button
title={'go to register page'}
onPress={handleNav.bind(null, 'REGISTER')}
/&gt;
&lt;/View&gt;
);
Login.propTypes = {
handleNav:PropTypes.func,
};
const mapDispatchToProps = dispatch =&gt; bindActionCreators({handleNav},dispatch);
export default connect(null, mapDispatchToProps)(Login);
</code></pre>
","9147556","","6606831","","2018-04-11 13:30:13","2018-04-11 21:56:00","after using react-navigation-redux, get the warning","<react-native><react-navigation>","1","1","","",""
"48533555","1","","","2018-01-31 02:30:20","","0","36","<p>I have an image slider that is built using react that works in all browsers except Safari. The preview and next buttons(image-slider__button-next and image-slider__button-previous) do not show up The slider is not giving any errors at all. I can not figure out why it would not work in Safari, but works in all other browsers. I've never had a browser conflict with js unless I was testing in a really old browser. Any help on this would be greatly appreciated. My code is below:</p>

<pre><code>/* globals document */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Image from '../Common/Image';

import './ImageSlider.css';

const defaultProps = {
  data: [],
};

const propTypes = {
  data: PropTypes.arrayOf(PropTypes.shape({
    LogoColor: PropTypes.shape({
      Src: PropTypes.string,
      Alt: PropTypes.string,
    }),
    Url: PropTypes.string,
  })).isRequired,
};

class ImageSlider extends Component {
  state = {
    isSlider: false,
  }

  componentDidMount() {
    document.addEventListener('resize', this.handleResize());
    this.attachInterval();
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  setSlidesOrder = (nextRefIndex) =&gt; {
    let currentOrder = 1;
    let counter = nextRefIndex;
    for (let i = 0; i &lt; this.props.data.length; i += 1) {
      if (counter === this.props.data.length) {
        counter = 0;
      }
      this.slider.querySelector(`#image-slider__slider-item-${counter}`).style.order = currentOrder;
      currentOrder += 1;
      counter += 1;
    }
  };

  attachInterval = () =&gt; {
    if (this.props.data &amp;&amp; this.props.data.length &gt; 0) {
      this.interval = setInterval(() =&gt; {
        this.handleNext();
      }, 4000);
    }
  }

  handleResize = () =&gt; {
    this.setState({
      isSlider: document.body.clientWidth / 180 &gt; this.props.data.length,
    });
  }

  handleNext = () =&gt; {
    const currentRef = this.slider.querySelector('.image-slider__slider-item.is-ref');
    if (!currentRef) return;

    const currentRefIndex = Number(currentRef.id.substring(currentRef.id.lastIndexOf('-') + 1));
    const nextRefIndex =
      currentRefIndex === (this.props.data.length - 1)
        ? 0
        : currentRefIndex + 1;

    this.slider.querySelector('.image-slider__slider').classList.remove('is-reversing');

    // reset order
    currentRef.classList.remove('is-ref');
    this.slider.querySelector(`#image-slider__slider-item-${nextRefIndex}`).classList.add('is-ref');
    this.slider.querySelector(`#image-slider__slider-item-${nextRefIndex}`).style.order = 1;

    this.setSlidesOrder(nextRefIndex);

    this.slider.querySelector('.image-slider__slider').classList.remove('is-set');
    setTimeout(() =&gt; {
      this.slider.querySelector('.image-slider__slider').classList.add('is-set');
    }, 50);
  };

  handlePrevious = () =&gt; {
    const currentRef = this.slider.querySelector('.image-slider__slider-item.is-ref');
    if (!currentRef) return;

    const currentRefIndex = Number(currentRef.id.substring(currentRef.id.lastIndexOf('-') + 1));
    const nextRefIndex =
      currentRefIndex === 0
        ? this.props.data.length - 1
        : currentRefIndex - 1;

    this.slider.querySelector('.image-slider__slider').classList.add('is-reversing');
    // reset order
    currentRef.classList.remove('is-ref');
    this.slider.querySelector(`#image-slider__slider-item-${nextRefIndex}`).classList.add('is-ref');
    this.slider.querySelector(`#image-slider__slider-item-${nextRefIndex}`).style.order = 1;

    this.setSlidesOrder(nextRefIndex);

    this.slider.querySelector('.image-slider__slider').classList.remove('is-set');
    setTimeout(() =&gt; {
      this.slider.querySelector('.image-slider__slider').classList.add('is-set');
    }, 50);
  };

  render() {
    if (!this.props.data || this.props.data.length === 0) return null;

    const items = this.props.data.map((item, index) =&gt; {
      if (!item.LogoColor.Src) return null;

      return (
        &lt;li
          className={`image-slider__slider-item ${index === this.props.data.length - 1 &amp;&amp; this.state.isSlider ? 'is-ref' : ''}`}
          id={`image-slider__slider-item-${index}`}
          key={item.LogoColor.Src}
        &gt;
          &lt;a href={item.Url}&gt;
            &lt;Image src={item.LogoColor.Src} /&gt;
          &lt;/a&gt;
        &lt;/li&gt;
      );
    });
    return (
      &lt;div ref={(ref) =&gt; { this.slider = ref; }} className=""image-slider p-tb-30""&gt;
        &lt;div className=""slider-container""&gt;
          &lt;div className=""row""&gt;
            &lt;div className=""col-xs-12""&gt;
              &lt;div className=""image-slider__container""&gt;
                {
                  this.state.isSlider ?
                    (&lt;button className=""image-slider__button-previous"" onClick={this.handlePrevious}&gt;
                      &lt;i className=""fa fa-chevron-left"" /&gt;
                    &lt;/button&gt;) : ''
                }
                &lt;div className=""image-slider__slider-container""&gt;
                  &lt;ul className={`image-slider__slider list--nostyle ${this.state.isSlider ? 'is-set' : ''}`}&gt;
                    {items}
                  &lt;/ul&gt;
                &lt;/div&gt;
                {
                  this.state.isSlider ?
                    (&lt;button className=""image-slider__button-next"" onClick={this.handleNext}&gt;
                      &lt;i className=""fa fa-chevron-right"" /&gt;
                    &lt;/button&gt;) : ''
                }
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

ImageSlider.defaultProps = defaultProps;
ImageSlider.propTypes = propTypes;

export default ImageSlider;
</code></pre>
","6051253","","","","","2018-01-31 02:30:20","My react js image slider is working perfectly in all browsers except Safari","<javascript><reactjs><slider><jsx>","0","0","","",""
"49316914","1","49317830","","2018-03-16 09:14:12","","5","869","<p>I am creating a dashboard app that fetches data from an endpoint and uses the setState method to assign variables from the JSON returned by the endpoint to state variables. When I make a change to state, some components like 'react-svg-gauge' will update but 'react-chartjs-2' does not update.</p>

<p>The below code is an example of how my state changes in my actual app. This example will display the correct value of the state variables in the chrome developer console but does not update the DOM accordingly.</p>

<pre><code>import React, { Component } from 'react';
import {Doughnut} from 'react-chartjs-2';

class DoughnutExample extends Component {
  state = {
    data: {
        labels: [
            'Red',
            'Green',
            'Yellow'
        ],
        datasets: [{
            data: [300, 50, 100],
            backgroundColor: [
            '#FF6384',
            '#36A2EB',
            '#FFCE56'
            ],
            hoverBackgroundColor: [
            '#FF6384',
            '#36A2EB',
            '#FFCE56'
            ]
        }]
    }
  }

  componentDidMount() {
    this.timer = setInterval(
      () =&gt; this.increment(),
      1000
    )
  }

  componentWillUnmount() {
    clearInterval(this.timer)
  }

  increment() {
    let datacopy = Object.assign({}, this.state.data)
    datacopy.datasets[0].data[0] = datacopy.datasets[0].data[0] + 10
    console.log(datacopy.datasets[0].data[0])
    this.setState({data: datacopy})
  }

  render(){
    return(
      &lt;div&gt;
      &lt;Doughnut data = {this.state.data}/&gt;
      &lt;/div&gt;
    )
  }
}

export default DoughnutExample;
</code></pre>

<p>Am I using the lifecycle methods correctly? This code will update the value of the pie chart, the state variable but will not correctly render the DOM.</p>
","7600930","","","","","2018-03-16 09:59:14","react-chartjs-2 not updating graph when state updates","<javascript><reactjs><react-chartjs>","2","1","","",""
"49796304","1","","","2018-04-12 12:16:23","","0","15","<p>i am trying to get the current location of a user but everytime i run my emulator it is showing me the location of googleplex 
<a href=""https://i.stack.imgur.com/au6Yp.png"" rel=""nofollow noreferrer"">this is the output iam getting
</a>
.My guess is that its the default location somehow. I added ""ACCESS_FINE_LOCATION"" in my manifest.xml and here is my source code .
.
.
.
.
.
.</p>

<pre><code>import React, { Component } from 'react';
import {
    StyleSheet,
    Text,
    View,
    Dimensions
} from 'react-native';

// import { Actions } from 'react-native-router-flux';
import MapView from 'react-native-maps'

const { width, height } = Dimensions.get('window')
const SCREEN_HEIGHT = height
const SCREEN_WIDTH = width
const ASPECT_RATIO = width / height
const LATITUDE_DELTA = 0.0922;
const LONGITUDE_DELTA = LATITUDE_DELTA * ASPECT_RATIO;

export default class Location extends Component {
    constructor(props){
        super(props);
        this.state = {
            initialPosition: {
              latitude: 0,
              longitude: 0,
              latitudeDelta: 0,
              longitudeDelta: 0
            },
            markerPosition: {
              latitude: 0,
              longitude: 0,

            }
        }
    }
    watchID: ?number = null
    componentDidMount(){
        navigator.geolocation.getCurrentPosition((position) =&gt; {
            //let lat = parseFloat(position.coords.latitude);
            //let long = parseFloat(position.coords.longitude);
            var lat = parseFloat(position.coords.latitude);
            var long = parseFloat(position.coords.longitude);

            //this.setState({initialRegion : {
              var initialRegion = {
                latitude : lat,
                longitude : long,
                latitudeDelta : LATITUDE_DELTA,
                longitudeDelta: LONGITUDE_DELTA
            }
              this.setState({initialPosition: initialRegion})
              this.setState({markerPosition: initialRegion})


        },
            (error)=&gt; alert(JSON.stringify(error)),
            {enableHighAccuracy : true , timeout: 20000, maximumAge:1000})

            this.watchID= navigator.geolocation.watchPosition((position)=&gt;{
              var lat = parseFloat(position.coords.latitude)
              var long = parseFloat(position.coords.longitude)

              var lastRegion ={
                latitude: lat,
                longitude: long,
                latitudeDelta: LATITUDE_DELTA,
                longitudeDelta: LONGITUDE_DELTA
              }
              this.setState({initialPosition: lastRegion})
              this.setState({markerPosition: lastRegion})
            })
    }
    componentWillUnmount(){
      navigator.geolocation.clearWatch(this.watchID)
    }

    render(){
        return(
            &lt;View style={styles.container}&gt;
              &lt;MapView style={styles.map}
              region ={this.state.initialPosition}&gt;

              &lt;MapView.Marker
              coordinate={this.state.markerPosition}
              &gt;
              &lt;View style={styles.radius}&gt;
              &lt;View style={styles.marker}&gt;
              &lt;/View&gt;
              &lt;/View&gt;
              &lt;/MapView.Marker&gt;
              &lt;/MapView&gt;

            &lt;/View&gt;
        );
    }}


    const styles = StyleSheet.create({
      container: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        justifyContent: 'flex-end',
        alignItems: 'center',
      },
      map: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
      },
    });
</code></pre>

<p>Also if someone could help me, add the current location button it would be very helpful.</p>
","9077505","","","","","2018-04-12 12:16:23","react-native-maps get current location using geolocation","<android><react-native><geolocation><react-native-maps>","0","2","1","2018-04-12 14:55:21",""
"48506835","1","","","2018-01-29 17:29:59","","0","83","<p>I have a react component (it is a react-native projects). in the componentDidMount I make ajax calls to get some data and then I update the flux store that feeds the props of this component. however, everytime the flux store state is updated the component is unmounted and re-mounted again, so this causes it to get into an infinite loop. This does not seem like the expected behaviour of a react component. enter code here. this is my component:</p>

<pre><code>    export default class InitializeView extends React.Component {

    constructor(props) {
        super(props);
        this._loadWorkList = this._loadWorkList.bind(this);
        this.state = {
            loadingWorkForms: true,
            loadingPointForms: true,
            loadingWorks: true,
            loadingPoints: true,
            loadingIcons: true,
            loadingPointFiles: true,
        }
    }

    _loadWorkList() {
         AsyncStorage.getItem('apiKey').then((apiKey) =&gt; {
             Reactotron.log(apiKey);

            if(this.props.works.length === 0  ) {
                Api.getWorks(apiKey).then(works =&gt; {
                    this.props.onLoadWorks(JSON.parse(works));
                    this.setState({
                        loadingWorks: false,
                    })
                });
            }
            Api.getPointForms(apiKey).then(pointForms =&gt; {
                this.props.onLoadPointFormSchemes(JSON.parse(pointForms));
                this.setState({
                    loadingPointForms: false,

                })
            });
            Api.getWorkForms(apiKey).then(workForms =&gt; {
                this.props.onLoadWorkFormSchemes(JSON.parse(workForms));
                this.setState({
                    loadingWorkForms: false,
                })
            });
            Api.getPointForms(apiKey).then(forms =&gt; {
                Api.getIcons(apiKey).then(icons =&gt; {
                     Api.getWorkPoints(apiKey, this.props.app.activeWork).then((points) =&gt; {
                       this.props.onLoadWorkPoints(JSON.parse(points), JSON.parse(icons), JSON.parse(forms));
                         this.setState({
                             loadingPoints: false,
                             loadingIcons: false,
                             loadingPointFiles: false
                         })
                     })
                })
            })
         }).done();
    }


    componentDidMount() {

        Reactotron.log('initialize View is mounted!');
        this._loadWorkList();
    }

    componentWillUnmount(){
        Reactotron.log('initializeView is Unmounting');
    }

    render() {
        return (&lt;View style={{marginTop: 50,}} key=""render_only_once"" id=""whatTheFuck""&gt;
            &lt;View key={1} style={styles.row}&gt;
                {this.state.loadingWorkForms ? &lt;ActivityIndicator animating={true} size='small' /&gt; : &lt;MaterialCommunityIcons name='check' size={25} style={styles.icon}/&gt;}
                &lt;Text style={styles.text}&gt;{this.state.loadingWorkForms ? 'Downloading Work Forms...' : `Downloaded ${this.props.workFormSchemes.lenght} work forms`}&lt;/Text&gt;
            &lt;/View&gt;
            &lt;View key={2} style={styles.row}&gt;{ this.state.loadingPointForms ? &lt;Text style={styles.text}&gt;{'Downloading Point Forms...'}&lt;/Text&gt; : &lt;Text style={styles.text}&gt;{`Downloaded ${this.props.workFormSchemes.lenght} work forms`}&lt;/Text&gt; }&lt;/View&gt;
            &lt;View key={3} style={styles.row}&gt;{ this.state.loadingWorks ? &lt;Text style={styles.text}&gt;{'Downloading Work Forms...'}&lt;/Text&gt; : &lt;Text style={styles.text}&gt;{`Downloaded ${this.props.workFormSchemes.lenght} work forms`}&lt;/Text&gt; }&lt;/View&gt;
            &lt;View key={4} style={styles.row}&gt;{ this.state.loadingPoints ? &lt;Text style={styles.text}&gt;{'Downloading Point Forms...'}&lt;/Text&gt; : &lt;Text style={styles.text}&gt;{`Downloaded ${this.props.workFormSchemes.lenght} work forms`}&lt;/Text&gt; }&lt;/View&gt;
            &lt;View key={5} style={styles.row}&gt;{ this.state.loadingIcons ? &lt;Text style={styles.text}&gt;{'Downloading Icons...'}&lt;/Text&gt; : &lt;Text style={styles.text}&gt;{`Downloaded ${this.props.workFormSchemes.lenght} work forms`}&lt;/Text&gt; }&lt;/View&gt;
            &lt;View key={6} style={styles.row}&gt;{ this.state.loadingPointFiles ? &lt;Text style={styles.text}&gt;{'Downloading Points Files...'}&lt;/Text&gt; : &lt;Text style={styles.text}&gt;{`Downloaded ${this.props.workFormSchemes.lenght} work forms`}&lt;/Text&gt; }&lt;/View&gt;
        &lt;/View&gt;)

    }
}

//flux container component
export default class AppContainer extends React.Component {
    static getStores() {
      return [
        LoginStore,
        WorkFormSchemeStore,
        PointFormSchemeStore,
        WorkStore,
        AppStore,
      ];
    }

    static getState() {
      return {

            loginState: LoginStore.getState(),
            onLoggedIn: LoginActions.loggedIn,
            onLoginFailed: LoginActions.loginFailed,
            onLoggedOut: LoginActions.loggedOut,
            workFormSchemes: WorkFormSchemeStore.getState(),
            pointFormSchemes: PointFormSchemeStore.getState(),
            onLoadWorkFormSchemes: WorkFormSchemeActions.loadWorkFormSchemes,
            onLoadPointFormSchemes: PointFormSchemeActions.loadPointFormSchemes,
            works: WorkStore.getState(),
            onLoadWorks: WorkActions.loadWorks,
            points: WorkPointsStore.getState(),
            onLoadWorkPoints: WorkPointsActions.loadWorkPoints,
            app: AppStore.getState(),
            onSetActiveWork: AppActions.setActiveWork,
            onSetActivePoint: AppActions.setActivePoint,
            onSetActiveFile: AppActions.setActiveFile,

      };
    }

    static calculateState(prevState) {
        Reactotron.log('app state changed');
        return{
            loginState: LoginStore.getState(),
            onLoggedIn: LoginActions.loggedIn,
            onLoginFailed: LoginActions.loginFailed,
            onLoggedOut: LoginActions.loggedOut,
            workFormSchemes: WorkFormSchemeStore.getState(),
            pointFormSchemes: PointFormSchemeStore.getState(),
            onLoadWorkFormSchemes: WorkFormSchemeActions.loadWorkFormSchemes,
            onLoadPointFormSchemes: PointFormSchemeActions.loadPointFormSchemes,
            works: WorkStore.getState(),
            onLoadWorks: WorkActions.loadWorks,
            points: WorkPointsStore.getState(),
            onLoadWorkPoints: WorkPointsActions.loadWorkPoints,
            app: AppStore.getState(),
            onSetActiveWork: AppActions.setActiveWork,
            onSetActivePoint: AppActions.setActivePoint,
            onSetActiveFile: AppActions.setActiveFile,
        };

    }

    componentDidMount() {
        //Reactotron.log(a)
    }

    render() {
        return (!this.state.loginState.loggedIn ? &lt;LoginView  {...this.state} {...this.props}/&gt; :  &lt;DataCollectionStack key=""appstack"" {...this.state} {...this.props}/&gt;)
    }
}

//parent of the component (stack navigator)

export default class DataCollectionStack extends React.Component {

    constructor (props) {
        super (props);

    }

    render() {

        Reactotron.log(this.props);

        const DrawerNavigationComponent = ({navigation}) =&gt; (
            &lt;DrawerNavigation key=""drawerNavigationComponent"" stackNavigation={navigation} {...this.props}/&gt;
        );

        const ErrorScreen = ({navigation}) =&gt; (
            &lt;ErrorView key=""errorScreen"" navigation={navigation} /&gt;
        );
        const CreatePointScreen = ({navigation}) =&gt; (
            &lt;CreatePoint key=""createPointScreen"" navigation={navigation} {...this.props}/&gt;
        );

        const InitialScreen = ({navigation}) =&gt; (
            &lt;InitializeView key=""initialScreen"" navigation={navigation} {...this.props}/&gt;
        )

        const AppStack = StackNavigator({
                 Initial: {
                     screen: InitialScreen,
                     path:'/',
                     navigationOptions: ({navigation}) =&gt; ({
                         header: null,
                     })
                 },
                 Drawer: {
                     screen: DrawerNavigationComponent,
                     path:'/main',
                     navigationOptions: ({navigation}) =&gt; ({
                         header: null,
                     })
                 },
                 PointView: {
                     screen: PointFormContainer,
                     path:'/point',
                     navigationOptions: ({navigation}) =&gt; ({
                         title: 'Point',
                         headerStyle: styles.stackHeader,
                         headerRight: &lt;TouchableOpacity style={styles.doneButton} onPress={() =&gt; {navigation.goBack()}}&gt;&lt;MaterialIcons name='done' size={40} color={'#419388'}/&gt;&lt;/TouchableOpacity&gt;
                     })
                 },
                 CreatePoint: {
                     screen: CreatePointScreen,
                     path:'/create',
                     navigationOptions: ({navigation}) =&gt; ({
                         title: 'New Point',
                         headerStyle: styles.stackHeader,
                         headerRight: &lt;TouchableOpacity style={styles.doneButton} onPress={() =&gt; {navigation.goBack()}}&gt;&lt;MaterialIcons name='done' size={40} color={'#419388'}/&gt;&lt;/TouchableOpacity&gt;
                     })
                 },
                 Error: {
                     screen: ErrorScreen,
                     path:'/error',
                     navigationOptions: ({navigation}) =&gt; ({
                         title: `Point ID: ${navigation.state.params.point.id}`,
                         headerStyle: styles.stackHeader,
                     })
                 },
             },
             {
                headerMode : 'screen'
             },
             {
                initialRouteName: 'Drawer',
             }
         );

        return &lt;AppStack/&gt;

    }

} 
</code></pre>
","4526373","","","","","2018-04-16 01:11:24","why is my react-native component unmounted every time its props are updated through flux store?","<reactjs><react-native><react-redux><flux><react-lifecycle>","0","0","","",""
"31331636","1","","","2015-07-10 02:44:58","","0","4389","<p>I have a component that I am trying to pass data to from a previous component when it is clicked. I have tried setState to change the state but nothing is working. How do I pass the data? The data is living in this.listing</p>

<p>Here is the first component:</p>

<pre><code>const JobOffer = React.createClass({
  mixins: [Navigation],

  getInitialState: function() {
    console.log(this.props.data);
    return {
        listing: this.props.data
    };
  },

  componentDidMount: function() {
    AppStore.addChangeListener(this._onChange);
  },

  componentWillUnmount: function() {
    AppStore.removeChangeListener(this._onChange);
  },

    _onChange : function(){

    },


  handleClick: function () {

    this.transitionTo('/listing/' + this.state.listing.id );

  },


  render: function () {
      var data = this.state.listing;
      var employmentType;
      switch(data.employment_type) {
        case 'F':
            employmentType = 'Full Time';
            break;
        case 'P':
            employmentType = 'Part Time';
            break;
        case 'H':
            employmentType = 'Hourly';
            break;
        default:
            employmentType = 'Unknown';
      }
      return (
        &lt;div&gt;
          &lt;a onClick={this.handleClick.bind(this)}&gt;
              &lt;img style={{width: 50+'px', height: 50+'px'}} src=""/images/job1.jpg"" alt="""" className=""img-circle"" /&gt;
              &lt;div className=""title""&gt;
                  &lt;h5&gt;{data.job_title}&lt;/h5&gt;
                  &lt;p&gt;{data.Business.business_name}&lt;/p&gt;
              &lt;/div&gt;
              &lt;div className=""data""&gt;
                  &lt;div &gt;&lt;i&gt;Posted 1 Day Ago&lt;/i&gt;&lt;/div&gt;
                  &lt;div className=""city""&gt;&lt;i className=""fa fa-map-marker""&gt;&lt;/i&gt;{data.Business.business_city}&lt;/div&gt;
                  &lt;div className=""type full-time""&gt;&lt;i className=""fa fa-clock-o""&gt;&lt;/i&gt;{employmentType}&lt;/div&gt;
                  &lt;div className=""sallary""&gt;&lt;i className=""fa fa-dollar""&gt;&lt;/i&gt;{data.job_compensation}&lt;/div&gt;
              &lt;/div&gt;
          &lt;/a&gt;
        &lt;/div&gt;
      );
    },

});


module.exports = JobOffer;
</code></pre>

<p>As you can see the component above transitionTo the route I want but how do I pass the this.listings data when handleClick is invoked?</p>

<p>Here is the component I am trying to pass it to:</p>

<pre><code>var React = require('react');
var ReactBootstrap = require('react-bootstrap');
var Button = ReactBootstrap.Button;
var Modal = ReactBootstrap.Modal;
var AppActions = require('../actions/app-actions');
var AppStore = require('../stores/app-store');
var Navigation = require('react-router').Navigation;
var _ = require('lodash');


// Our custom component is managing whether the Modal is visible
const ListingDetail = React.createClass({
  mixins: [Navigation],

  getInitialState: function() {
    console.log(this.props.data);
    return {
        listing: this.props.data
    };
  },

  componentDidMount: function() {
    AppStore.addChangeListener(this._onChange.bind(this));
  },


  _onChange : function(){

  },


  handleClick: function () {
    this.transitionTo('/listing/apply/' + this.state.listing.id );
  },


  render: function () {
        var data = this.state.listing;
        var employmentType = 'test';
        return (
                &lt;div&gt;
                    &lt;img style={{width: 200+'px', height: 200+'px'}} src=""/images/job1.jpg"" alt="""" className=""img-circle"" /&gt;
                    &lt;div className=""title""&gt;
                        &lt;h5&gt;{data.job_title}&lt;/h5&gt;
                        &lt;p&gt;{data.Business.business_name}&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
         );
      },

});


module.exports = ListingDetail;
</code></pre>
","3643019","","","","","2015-12-29 18:01:03","Passing data from one component to another in react","<javascript><reactjs><reactjs-flux><react-router>","2","3","","",""
"49234519","1","","","2018-03-12 11:48:35","","1","756","<p>I am user react navigation in react native application. After login I navigate to Home screen from where I want to sign out I should be navigate to previous screen(say Login). But inside navigation props I am unable to find any way to Login screen back without use of goBack function. <strong>My navigation is little messy please see my navigation  carefuly.</strong></p>

<p>This is my Navigators</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import{ View, Text } from 'react-native';

// Navigators
import { DrawerNavigator, StackNavigator, TabNavigator } from 'react-navigation'

// Drawer Screens
import Welcome from '../../screens/Welcome';
import Profile from '../../screens/Profile';

// Tab Screens
import Home from '../../screens/Home';
import Message from '../../screens/Message';

//TabNav
const routeConfigs = {
    Home: {
        screen: Home,
        navigationOptions: {
          title: 'Home'
        }
    },
    Message: {
        screen: Message,
    },
}

const tabNavigatorConfig = {
    // tabBarComponent: tabBarComponent,
    tabBarPosition: 'top',
    lazy: true,
    tabBarOptions: {
        activeTintColor: 'yellow',
        inactiveTintColor: 'gray',
        style: {
            backgroundColor: '#8e24aa',
          },
        activeBackgroundColor: 'green',
    },
    header: 'screen'
}

export const TabNav = TabNavigator(routeConfigs, tabNavigatorConfig);

//Used Stack to get Header above TabBar
export const StackNav = StackNavigator({TabNav: { screen: TabNav }});

//DrawerNav 
export const DrawerNav = DrawerNavigator (
    {
        Welcome: { screen: Welcome},
        Profile: { screen: Profile },
        StackNav: { screen: StackNav}, // Stack Navigator to get Header on each Tabs
    },
    {
        initialRouteName: 'Welcome',
        drawerBackgroundColor: '#98eef3',
    }
);</code></pre>
</div>
</div>
</p>

<p>This is Welcome or say Login Screen</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { View, Text, StyleSheet, Button, TouchableOpacity, Modal, BackHandler, Alert, Image } from 'react-native';
import { connect } from 'react-redux';
import firebase from 'firebase';
import {
    loginUser
} from '../actions';
import Input from '../components/Input';
import Spinner from '../components/Spinner';

class Welcome extends Component {
    constructor(props){
        super(props);
        this.state = {
            modalVisible: false,
            email: '',
            password: '',
        }
        this.renderHome = this.renderHome.bind(this);
    }

    componentDidMount() {
        BackHandler.addEventListener('hardwareBackPress', this.handleBackButton);
    }

    componentWillUnmount() {
        BackHandler.removeEventListener('hardwareBackPress', this.handleBackButton);
      }

    handleBackButton = () =&gt; {
        Alert.alert(
            'Exit App',
            'Exiting the application?', 
            [
                {text: 'Cancel', onPress: () =&gt; console.log('Cancel Pressed'), style: 'cancel'}, 
                {text: 'OK', onPress: () =&gt; BackHandler.exitApp()}
            ], 
            { cancelable: false }
        )
        return true;
    } 

    static navigationOptions = () =&gt; ({
        drawerLockMode: 'locked-closed'
    })

    loginButtonPress() {
        this.props.loginUser(this.state.email, this.state.password);
    }

    renderHome(){
        this.props.navigation.navigate('StackNav');
    }

    renderLoginButton(loading){
        if(loading){
            return &lt;Spinner /&gt;;
        }else{
            return (
                &lt;View style={{alignItems: 'center'}}&gt;
                    &lt;TouchableOpacity style={styles.button} onPress={this.loginButtonPress.bind(this)} &gt;
                        &lt;Text style={styles.buttonText}&gt;Login&lt;/Text&gt;
                    &lt;/TouchableOpacity&gt;
                &lt;/View&gt;
            );
        }
    }

    render() {
        return (
            &lt;View style={styles.container}&gt;
                {(this.props.user)?this.renderHome():null}
                &lt;View style={{flex: 3, justifyContent: 'center'}}&gt;
                    &lt;Input
                        placeholder=""Email""
                        keyboardType=""email-address""
                        value={this.state.email}
                        onChangeText={(email) =&gt; this.setState({email})}
                    /&gt;
                    &lt;Input
                        placeholder=""Password""
                        value={this.state.password}
                        onChangeText={(password) =&gt; this.setState({password})}
                        secureTextEntry
                    /&gt;
                    {this.renderLoginButton(this.props.loading)}
        );
    }
}

mapStateToProp = ({auth}) =&gt; {
    return {
        user: auth.user,
        error: auth.error,
        loading: auth.loading,
    }
}

export default connect(mapStateToProp, { loginUser })(Welcome);</code></pre>
</div>
</div>
</p>

<p>This is Home screen</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { View, Text, Button, Alert, Animated, BackHandler } from 'react-native';
import { connect } from 'react-redux';
import Header from '../components/Header';
import Ionicons from 'react-native-vector-icons/Ionicons';
export class Home extends Component {

    constructor(props){
        super(props);
    }

    componentDidMount() {
        BackHandler.addEventListener('hardwareBackPress', this.handleBackButton);
    }

    componentWillUnmount() {
        BackHandler.removeEventListener('hardwareBackPress', this.handleBackButton);
      }

    handleBackButton = () =&gt; {
        Alert.alert(
            'Exit App',
            'Exiting the application?', 
            [
                {text: 'Cancel', onPress: () =&gt; console.log('Cancel Pressed'), style: 'cancel'}, 
                {text: 'OK', onPress: () =&gt; BackHandler.exitApp()}
            ], 
            { cancelable: false }
        )
        return true;
    }
    
    static navigationOptions = ({navigation}) =&gt;( {
        title: 'Home',
        header: &lt;Header headerTitle={navigation.state.routeName}/&gt;,
        headerTintColor: '#fff',
      });

    render(){
        console.log(this.props.user) // after signout getting undefined
        return (
            &lt;View 
                style={{height: 1000}}
            &gt;

                &lt;View style={{height: 1000}}&gt;
                  &lt;Text&gt;Home&lt;/Text&gt;
                &lt;/View&gt;
            &lt;/View&gt;
        );
    }
}

mapStateToProp = ({auth}) =&gt; {
    return {
        user: auth.user,
    }
}

export default connect(mapStateToProp, null)(Home);</code></pre>
</div>
</div>
</p>

<p>Signout is correctly working  but need to navigate back to welcome/login screen.</p>
","4931545","","","","","2018-03-12 13:24:40","How to get previous route in react navigation?","<react-native><react-navigation>","1","0","","",""
"41603606","1","41603861","","2017-01-12 01:20:36","","1","929","<p>I'm learning react, and have an application that used to work with static data stored in a javascript object. I am now loading that data via ajax using <a href=""https://github.com/mzabriskie/axios"" rel=""nofollow noreferrer"">axios</a>.</p>

<p>This works, and I am currently storing that data in the app's state, then passing it down to the components once the data is loaded, but the way I'm passing the data as a prop to each component doesn't feel right. </p>

<p>How can each component access the parent app's data without passing it as a prop to each component?</p>

<p>Here's my code</p>

<pre><code>    class App extends Component {

  constructor(props) {
    super(props);
    this.state = {appData: {}};
  }

  componentDidMount() {
    axios.get('/data/appData.json')
    .then((result)=&gt; {
      const thisData = result.data;
      this.setState({
        appData: result.data
      });
    })
  }

  componentWillUnmount() {
    this.serverRequest.abort();
  }

  render() {

    const theData = this.state.appData;
    if (Object.keys(theData).length &gt; 0 &amp;&amp; theData.constructor === Object){ //if the object is not empty
      return (
        &lt;div className=""App""&gt;
          &lt;AppHeader appData={theData} /&gt;
          &lt;AppMenu appData={theData} /&gt;
          &lt;MainCarousel appData={theData} /&gt;
          &lt;HomeDetails appData={theData} /&gt;
          &lt;Model3D appData={theData} /&gt;
          &lt;AppMaps appData={theData} /&gt;
          &lt;AppContact appData={theData} /&gt;
        &lt;/div&gt;
      );
    } else {
      return (
        &lt;div className=""App""&gt;&lt;/div&gt;
      )
    }

  }
}
</code></pre>

<p>And a component that would use the data looks like:</p>

<pre><code>function AppHeader(props) {
  return (
    &lt;div className=""App-header""&gt;
      &lt;h2 className=""App-title""&gt;{props.appData.copy.title}&lt;/h2&gt;
      &lt;h4 className=""App-subtitle""&gt;{props.appData.copy.subtitle}&lt;/h4&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<p>for a function, or </p>

<pre><code>class MainCarousel extends Component {
  mixins: [Carousel.ControllerMixin];

  constructor(props) {
    super(props);
  }

  render() {
    const carouselItems = this.props.appData.carouselItems.map((carouselItem) =&gt;
      &lt;AppCarouselItem key={carouselItem.name.toLowerCase()} name={carouselItem.name} image={carouselItem.image} /&gt;
    );
    return (
      &lt;div className=""App-carousel""&gt;
        &lt;Carousel autoplay={true} wrapAround={true}&gt;
          {carouselItems}
        &lt;/Carousel&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>for a class.</p>
","287436","","","","","2017-01-12 01:51:59","how to pass ajax data down to components in react","<javascript><ajax><reactjs><components><axios>","1","2","","",""
"49818980","1","","","2018-04-13 14:10:17","","1","15","<p>The primary problem is that doing a <code>history.push()</code> as part of a dispatch is not allowed because you can't do a dispatch within a dispatch. As an alternative to actually doing the redirect in the action function itself I'm currently passing callback functions to action methods to do calls to history methods. I don't think this is a good way to do things and I'm looking for a better way to do it. I'm doing this is in quite a few places including in the case of getting 401 errors - I clear session info and go to the login page. Here is how my code looks.</p>

<p>client.js</p>

<pre><code>import React from ""react"";
import ReactDOM from ""react-dom"";
import { Router, Route, IndexRoute, hashHistory } from ""react-router"";

import CreateEntity from ""./pages/CreateEntity"";
import Dashboard from ""./pages/Dashboard"";
import Entity from ""./pages/Entity"";


const app = document.getElementById('app');


ReactDOM.render(
  &lt;Router history={hashHistory}&gt;
    &lt;Route path=""/"" component={Layout}&gt;
      &lt;Route path=""dashboard"" component={Dashboard}&gt;&lt;/Route&gt;
      &lt;Route path=""createEntity"" component={CreateEntity}&gt;&lt;/Route&gt;
      &lt;Route path=""entity/:name"" component={Entity}&gt;&lt;/Route&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;,
app);
</code></pre>

<p>pages/Entity.js</p>

<pre><code>import React from ""react"";
import * as EntityActions from ""../actions/EntityActions"";
import EntityStore from ""../stores/EntityStore"";


export default class Entity extends React.Component {

  constructor() {
    super();
    this.finishDelete = this.finishDelete.bind(this);
    this.state = {
      description: undefined,
      name: undefined,
      id: undefined,
    };
  }

  delete() {
    EntityActions.deleteProject('mbrady', this.state.id, this.finishDelete)
  }

  finishDelete() {
    this.props.history.push(""dashboard"")
  }

  componentWillMount() {
    EntityStore.on(""change"", this.getProject);
    this.refresh()
  }

  componentWillUnmount() {
    EntityStore.removeListener(""change"", this.getProject);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button class=""btn btn-default"" onClick={this.delete.bind(this)}&gt;
          &lt;span class=""glyphicon glyphicon-trash""&gt;&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>actions/EntityActions.js</p>

<pre><code>import dispatcher from ""../dispatcher"";
import axios from ""axios"";
import * as config from '../AppConfig'

export function deleteEntity(user, id, delete_callback) {
  dispatcher.dispatch({type: ""DELETE_ENTITY""});
  const url = ""http://localhost:""+port+""/""+config.appName+""/some_url"";
  axios.delete(url)
    .then((response) =&gt; {
      dispatcher.dispatch({type:""DELETE_ENTITY_FULFILLED"", payload: response.data});
      console.log(delete_callback)
      delete_callback(response.data);
    })
    .catch((err) =&gt; {
      dispatcher.dispatch({type:""DELETE_ENTITY_FAILED"", payload: err})
    })
}
</code></pre>

<p>stores/EntityStore.js</p>

<pre><code>import { EventEmitter } from ""events"";

import dispatcher from ""../dispatcher"";


class CurrentProjectStore extends EventEmitter {

  constructor() {
    super()
    this.project = undefined;
  }

  handleActions(action) {
    switch(action.type) {
      case ""DELETE_PROJECT"": {
        break;
      }
      case ""DELETE_PROJECT_FAILED"": {
        break;
      }
      case ""DELETE_PROJECT_FULFILLED"": {
        this.project = undefined
        break;
      }
    }
  }

}

const projectStore = new CurrentProjectStore;
dispatcher.register(projectStore.handleActions.bind(projectStore));

export default projectStore;
</code></pre>
","1753106","","","","","2018-04-13 14:10:17","How should you do page redirects on action completion in flux based react using react-router and hashHistory","<reactjs><reactjs-flux>","0","0","","",""
"39998143","1","39998946","","2016-10-12 12:03:20","","2","299","<p>I am trying to make a react component library so I can use them through out my entire application. I have the first part of the library being a table and this is still in the testing stages but I cannot figure out how to call the component and create it on the page its called. Currently this is how its working. I also just starting programming in React yesterday.</p>

<p>HTML</p>

<pre><code>&lt;script type=""text/babel"" src=""/js/reactcomponents/table.js""&gt;&lt;/script&gt;
&lt;div id=""loadboardContainer""&gt;
  &lt;div class=""table-desc""&gt;Future Loads&lt;/div&gt;
  &lt;div id=""futureLoadsContainer""&gt;&lt;/div&gt;

  &lt;div class=""table-desc""&gt;Todays Loads&lt;/div&gt;
  &lt;div id =""todaysLoadsContainer""&gt;&lt;/div&gt;

  &lt;div class=""table-desc""&gt;Active Loads&lt;/div&gt;
  &lt;div id =""activeLoadsContainer""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Then I have my react component.</p>

<pre><code>var Table = React.createClass({
  getInitialState: function() {
    return {
      results: [],
      columns: []
    }
  },
  componentDidMount: function() {
    this.serverRequest = $.get(this.props.source, function(result) {
      result = JSON.parse(result);

      if(result['resultRows'] == undefined){
        result['resultRows'] = [];
      }

      this.setState({
        results: result['resultRows'],
        columns: $.makeArray(result['resultCols'])
      });
    }.bind(this));
  },
  componentWillUnmount: function(){
    this.serverRequest.abort();
  },
  render: function() {
    // Set array for rows.
    var rows = [];
    var header = [];

    this.state.columns.map(function(cols) {
      header.push(&lt;TableColumns data={cols.cols} key={cols.id} /&gt;);
    });

    this.state.results.map(function(result) {
      rows.push(&lt;TableRow data={result.rows} key={result.id} /&gt;);
    });

    // Return the table.
    return (
      &lt;table className=""table table-condensed table-bordered no-bottom-margin""&gt;
        &lt;thead&gt;
          {header}
        &lt;/thead&gt;
        &lt;tbody&gt;
          {rows}
        &lt;/tbody&gt;
      &lt;/table&gt;
    );
  }
});

// Set up columns
var TableColumns = React.createClass({
  render: function() {
    var colNodes = this.props.data.map(function(col, i){
      return (
        &lt;th key={i}&gt;{col}&lt;/th&gt;
      );
    });
    return (
      &lt;tr&gt;
        {colNodes}
      &lt;/tr&gt;
    );
  }
});

// Set up row
var TableRow = React.createClass({
  render: function() {
    var rowNodes = this.props.data.map(function(row, i){
      return (
        &lt;td key={i}&gt;{row}&lt;/td&gt;
      );
    });
    return (
      &lt;tr&gt;
        {rowNodes}
      &lt;/tr&gt;
    );
  }
});

var futureContainer = document.getElementById('futureLoadsContainer');
var todaysContainer = document.getElementById('todaysLoadsContainer');
var activeContainer = document.getElementById('activeLoadsContainer');

ReactDOM.render(&lt;Table source=""/reactloadboard/react/getFutureTableValues.php"" /&gt;, futureContainer);
ReactDOM.render(&lt;Table source=""/reactloadboard/react/getTodaysTableValues.php"" /&gt;, todaysContainer);
ReactDOM.render(&lt;Table source=""/reactloadboard/react/getActiveTableValues.php"" /&gt;, activeContainer);
</code></pre>

<p>And this works when I import the table.js file to the html but I would like it to be more universal in the component usage and remove the</p>

<pre><code>var futureContainer = document.getElementById('futureLoadsContainer');
var todaysContainer = document.getElementById('todaysLoadsContainer');
var activeContainer = document.getElementById('activeLoadsContainer');

ReactDOM.render(&lt;Table source=""/reactloadboard/react/getFutureTableValues.php"" /&gt;, futureContainer);
ReactDOM.render(&lt;Table source=""/reactloadboard/react/getTodaysTableValues.php"" /&gt;, todaysContainer);
ReactDOM.render(&lt;Table source=""/reactloadboard/react/getActiveTableValues.php"" /&gt;, activeContainer);
</code></pre>

<p>to be called in the html/php page like the following.</p>

<pre><code>&lt;script type=""text/babel"" src=""/js/reactcomponents/table.js""&gt;&lt;/script&gt;
    &lt;div id=""loadboardContainer""&gt;
          &lt;div class=""table-desc""&gt;Future Loads&lt;/div&gt;
          &lt;div id=""futureLoadsContainer""&gt;&lt;/div&gt;

          &lt;div class=""table-desc""&gt;Todays Loads&lt;/div&gt;
          &lt;div id =""todaysLoadsContainer""&gt;&lt;/div&gt;

          &lt;div class=""table-desc""&gt;Active Loads&lt;/div&gt;
          &lt;div id =""activeLoadsContainer""&gt;&lt;/div&gt;
        &lt;/div&gt;

var futureContainer = document.getElementById('futureLoadsContainer');
    var todaysContainer = document.getElementById('todaysLoadsContainer');
    var activeContainer = document.getElementById('activeLoadsContainer');

    ReactDOM.render(&lt;Table source=""/reactloadboard/react/getFutureTableValues.php"" /&gt;, futureContainer);
    ReactDOM.render(&lt;Table source=""/reactloadboard/react/getTodaysTableValues.php"" /&gt;, todaysContainer);
    ReactDOM.render(&lt;Table source=""/reactloadboard/react/getActiveTableValues.php"" /&gt;, activeContainer);
</code></pre>

<p>The first way that is working works fine, but if I remove the ReactDom.renders to the html page I am actually putting the component on it says that Component Table doesn't exist. Is there anyway to do this so later on in the application when I have a table all I have to do is import the table.js react component and connect the source and its there? I have looked at other answers on here but they seem to mainly deal with the data for usability.</p>
","7007592","","7007592","","2016-10-12 12:26:59","2017-09-24 16:21:47","How to reuse react table","<javascript><php><jquery><reactjs>","3","0","","",""
"48337984","1","","","2018-01-19 09:35:42","","0","661","<p>Probably this seams like a stupid question.</p>

<p>I'm trying to do a react native demo app for Android with Firebase notification using <a href=""https://github.com/evollu/react-native-fcm"" rel=""nofollow noreferrer"">react-native-fcm</a>.</p>

<p>After all set, and the Firebase registring that there is a app conected, I try a push notification test and the app do 2 things:</p>

<ol>
<li>It does not register the notification event</li>
<li>It shuts down 10-20s after firebase sends the notification. (probably this is some error in my app that I will check latter.)</li>
</ol>

<p>This is my app Notification listener:</p>

<p><strong>Listeners.js</strong>
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {
  Platform,
  AsyncStorage
} from 'react-native';

import FCM, {
  FCMEvent,
  RemoteNotificationResult,
  WillPresentNotificationResult,
  NotificationType
} from ""react-native-fcm"";

AsyncStorage.getItem('lastNotification').then(data =&gt; {
  if (data) {
    // if notification arrives when app is killed, it should still be logged here
    console.log('last notification', JSON.parse(data));
    AsyncStorage.removeItem('lastNotification');
  }
})

export function registerKilledListener() {
  // these callback will be triggered even when app is killed
  FCM.on(FCMEvent.Notification, notif =&gt; {
    AsyncStorage.setItem('lastNotification', JSON.stringify(notif));
  });
}

// these callback will be triggered only when app is foreground or background
export function registerAppListener() {
  FCM.on(FCMEvent.Notification, notif =&gt; {
    console.log(""Notification"", notif);
    if (notif.local_notification) {
      return;
    }
    if (notif.opened_from_tray) {
      return;
    }

    if (Platform.OS === 'ios') {
      //optional
      //iOS requires developers to call completionHandler to end notification process. If you do not call it your background remote notifications could be throttled, to read more about it see the above documentation link.
      //This library handles it for you automatically with default behavior (for remote notification, finish with NoData; for WillPresent, finish depend on ""show_in_foreground""). However if you want to return different result, follow the following code to override
      //notif._notificationType is available for iOS platfrom
      switch (notif._notificationType) {
        case NotificationType.Remote:
          notif.finish(RemoteNotificationResult.NewData) //other types available: RemoteNotificationResult.NewData, RemoteNotificationResult.ResultFailed
          break;
        case NotificationType.NotificationResponse:
          notif.finish();
          break;
        case NotificationType.WillPresent:
          notif.finish(WillPresentNotificationResult.All) //other types available: WillPresentNotificationResult.None
          break;
      }
    }
  });

  FCM.on(FCMEvent.RefreshToken, token =&gt; {
    console.log(""TOKEN (refreshUnsubscribe)"", token);
    this.props.onChangeToken(token);
  });

  FCM.enableDirectChannel();
  FCM.on(FCMEvent.DirectChannelConnectionChanged, (data) =&gt; {
    console.log('direct channel connected' + data);
  });
  setTimeout(function() {
    FCM.isDirectChannelEstablished().then(d =&gt; console.log(d));
  }, 1000);
}</code></pre>
</div>
</div>
</p>

<p>An here is where the notification is managed:</p>

<p><strong>Notifications.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {
  Component
} from 'react'
import {
  Platform,
  View,
  TouchableOpacity,
  Text
} from 'react-native';
import FCM, {
  FCMEvent,
  RemoteNotificationResult,
  WillPresentNotificationResult,
  NotificationType
} from 'react-native-fcm';
import {
  registerKilledListener,
  registerAppListener
} from ""./Listeners"";

registerKilledListener();

export default class Notifications extends Component {

  constructor(props) {
    super(props);

    this.state = {
      token: """",
      tokenCopyFeedback: """"
    }
  }

  async componentDidMount() {
    registerAppListener();
    FCM.getInitialNotification().then(notif =&gt; {
      console.log(notif)
      this.setState({
        initNotif: notif
      })
    });

    try {
      let result = await FCM.requestPermissions({
        badge: false,
        sound: true,
        alert: true
      });
    } catch (e) {
      console.error(e);
    }

    FCM.getFCMToken().then(token =&gt; {
      console.log(""TOKEN (getFCMToken)"", token);
      this.setState({
        token: token || """"
      })
    });

    if (Platform.OS === 'ios') {
      FCM.getAPNSToken().then(token =&gt; {
        console.log(""APNS TOKEN (getFCMToken)"", token);
      });
    }
  }

  componentWillUnmount() {

  }

  render() {
    return null
  }
}</code></pre>
</div>
</div>
</p>

<p>I'm completely lost and any help would be appriciated. Thank you very much and sorry for my spelling mistakes. </p>
","4117369","","5246885","","2018-01-19 10:28:21","2018-01-19 10:28:21","[react-native][android]App not receiving notifications","<firebase><react-native><firebase-cloud-messaging><react-native-fcm>","0","1","","",""
"48554178","1","","","2018-02-01 01:53:11","","0","631","<p>Essentially I get the demo to work save for the actual scanning. i.e. camera is on etc. Not sure what I am missing...</p>

<p>Here is my code. </p>

<p>App.js file:</p>

<pre><code>import React, { Component } from 'react';
import Scanner from './Scanner';
import Result from './Result';

export default class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      scanning: false,
      results: [],
    };
    this._scan = this._scan.bind(this);
    this._onDetected = this._onDetected.bind(this);
  }

  _scan() {
    this.setState({ scanning: !this.state.scanning });
  }

  _onDetected(result) {
    this.setState({ results: this.state.results.concat([result]) });
  }
  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this._scan}&gt;{this.state.scanning ? 'Stop' : 'Start'}&lt;/button&gt;
        &lt;ul className=""results""&gt;
          {this.state.results.map(result =&gt; {
            &lt;Result key={result.codeResult.code} result={result} /&gt;;
          })}
        &lt;/ul&gt;
        {this.state.scanning ? &lt;Scanner onDetected={this.state._onDetected} /&gt; : null}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>Scanner.js file:</p>

<pre><code>import React, { Component } from 'react';
import Quagga from 'quagga';

export default class Scanner extends Component {
    constructor(props) {
        super(props);
        this._onDetected = this._onDetected.bind(this);
    }

    componentDidMount() {
        Quagga.init(
            {
                inputStream: {
                    type: 'LiveStream',
                    constraints: {
                        width: 640,
                        height: 480,
                        facingMode: 'environment', // or user
                    },
                },
                locator: {
                    patchSize: 'medium',
                    halfSample: true,
                },
                numOfWorkers: 2,
                decoder: {
                    readers: ['upc_reader'],
                },
                locate: true,
            },
            function(err) {
                if (err) {
                    return console.log(err);
                }
                Quagga.start();
            }
        );
        Quagga.onDetected(this._onDetected);
    }

    componentWillUnmount() {
        Quagga.offDetected(this._onDetected);
    }

    _onDetected(result) {
        this.props.onDetected(result);
    }

    render() {
        return &lt;div id=""interactive"" className=""viewport"" /&gt;;
    }
}
</code></pre>

<p>Result.js file:</p>

<pre><code>import React, { Component } from 'react';

export default class Result extends Component {
    render() {
        const result = this.props.result;

        if (!result) {
            return null;
        }
        return (
            &lt;li&gt;
                {result.codeResult.code} [{result.codeResult.format}]
            &lt;/li&gt;
        );
    }
}
</code></pre>

<p>Thanks my friends!</p>
","1315857","","","","","2018-04-25 12:15:52","quagga-react barcode scanner","<reactjs><quaggajs>","1","0","","",""
"33510553","1","33510703","","2015-11-03 22:47:54","","1","170","<p>I'm getting this error trying to create my fluxible component with an es6 class declaration:</p>

<pre><code>Warning: getInitialState was defined on SearchResults,
a plain JavaScript class. This is only supported for 
classes created using React.createClass. Did you mean 
to define a state property instead?
</code></pre>

<p>I'm going off of this example on the fluxible docs:</p>

<p><a href=""http://fluxible.io/api/components.html"" rel=""nofollow"">http://fluxible.io/api/components.html</a></p>

<p>Am I declaring my fluxible component correctly?  It errors with no initial state so it looks like it's not being called.</p>

<pre><code>import React from 'react';
import SearchStore from '../stores/SearchStore';
import Product from './Product';

    class SearchResults extends React.Component {

        static contextTypes = {
            executeAction: React.PropTypes.func.isRequired,
            getStore: React.PropTypes.func.isRequired
        };

        static propTypes = {
            results: React.PropTypes.array
        };

        static defaultProps = {
            results:[]
        };
        getInitialState () {
            return this.getStoreState();
        }
        getStoreState () {
            return {
                results: this.context.getStore(SearchStore).getResults()
            }
        }
        componentDidMount () {
            this.context.getStore(SearchStore).addChangeListener(this._onStoreChange);
        }
        componentWillUnmount () {
            this.context.getStore(SearchStore).removeChangeListener(this._onStoreChange);
        }
        _onStoreChange () {
            this.setState(this.getStoreState());
        }


        render() {

            var main;

            if (this.state &amp;&amp; this.state.results &amp;&amp; this.state.results.length) {
                let products = this.state.results.map(function (product) {
                    return (
                        &lt;Product
                            key={product.id}
                            imageUrl={product.image_url_large}
                            description={product.description}
                            name={product.name}
                            maxPrice={product.price_max}
                            minPrice={product.price_min}
                        /&gt;
                    );
                }, this);

                main = (
                    &lt;section id=""results""&gt;
                        &lt;ul id=""todo-list""&gt;
                            {products}
                        &lt;/ul&gt;
                    &lt;/section&gt;
                );
            }

            return (
                &lt;div&gt;
                    &lt;header id=""header""&gt;
                        &lt;h1&gt;Search Results&lt;/h1&gt;
                    &lt;/header&gt;
                    {main}
                &lt;/div&gt;
            );
        }

    }


    export default SearchResults;
</code></pre>
","611750","","","","","2015-12-01 11:59:35","Error trying to declare my fluxible react.js component in an es6 class","<reactjs><fluxible>","2","0","","",""
"41509898","1","41509965","","2017-01-06 16:27:01","","2","1380","<p>I have a form setup with redux-form and basically want to create a scenario where if there's content filled in any of the form's inputs and you try to navigate away from the page you get a prompt. </p>

<p>The intent is to cancel the page unmount or page nav if they click <em>Cancel</em>. I tried creating a conditional, that if fulfilled would just <code>return</code> but it still navigates away from the current page. </p>

<p>This is probably natural and that I'm not privy to the react/react-router workflow just yet but for the time being would anyone be able to explain the best approach for this? Is there something in general that would allow me to stop an unmount if something is unmet?</p>

<pre><code>import { reduxForm } from 'redux-form';

class Form extends Component {
  componentWillUnmount() {
    if (!this.props.pristine &amp;&amp; !confirm('Are you sure you want to navigate away from this page?')) {
      return;
    }
  }

  render() {
    const { handleSubmit } = this.props;

    return (
      &lt;form onSubmit={ handleSubmit(this.props.onSubmit) }&gt;
        ...
      &lt;/form&gt;
    );
  }
}

...

export default connect(mapStateToProps, null)(reduxForm({
  form: 'Form',
  enableReinitialize: true,
  validate
})(Form));
</code></pre>
","3046413","","3046413","","2017-01-12 18:58:34","2017-01-12 18:58:34","Cancel componentWillUnmount if a form is incomplete","<javascript><reactjs><redux><redux-form>","1","0","3","",""
"50752927","1","","","2018-06-08 03:28:05","","0","66","<p>I want to use the connect method from react-redux to pass the props into react hoc high order function.</p>

<p>The wrapper function:</p>

<pre><code>export const withInfiniteScroll = (Component) =&gt;
  class WithInfiniteScroll extends React.Component {
    componentDidMount() {
      window.addEventListener('scroll', this.onScroll, false)
    }
    componentWillUnmount() {
      this.props.initPage()
      window.removeEventListener('scroll', this.onScroll, false)
    }
    onScroll = () =&gt; {
      (
        (window.innerHeight + window.scrollY) &gt;= (document.body.offsetHeight - 500)
          &amp;&amp; this.props.stocks.length
      )
        &amp;&amp; this.props.onPaginatedSearch()
    }
    render() {
      return &lt;Component {...this.props}/&gt;
    }
  }
</code></pre>

<p>And the component is wrapped:</p>

<pre><code>const StockCard = ({ stocks }) =&gt;
  stocks.errmsg === 'ok' ?
    stocks.data.map (
      (stock, i) =&gt;
        &lt;CardContainer key={i}&gt;
          &lt;p&gt;{stock.cinvcode}&lt;/p&gt;
          &lt;p&gt;{stock.cinvname}&lt;/p&gt;
        &lt;/CardContainer&gt;
      ) : ''
</code></pre>

<p>Get the hoc function:</p>

<pre><code>const StockCardWithInfiniteScroll = withInfiniteScroll(StockCard)
</code></pre>

<p>The reducer:</p>

<pre><code>const initState = {
  ...
  stocks: {
    errcode: '',
    errmsg: '',
    data: []
  }
}

export const PAGE_INIT = 'PAGE_INIT'
export const initPage = () =&gt; ({type: PAGE_INIT, payload: 0})

export const STOCK_FETCH = 'STOCK_FETCH'
export const updateStock = (res) =&gt; ({type: STOCK_FETCH, payload: res})
export const onPaginated = (searchStock) =&gt; {
  return(dispatch) =&gt; {
    const searchStockNextPage = {
      ...searchStock,
      pageindex: searchStock.pageindex + 1
    }
    // console.log(searchStockNextPage)
    getStock(searchStockNextPage)
      .then(res =&gt; dispatch(updateStock(res)))
      .then(res =&gt; console.log(res))
  }
}

const stockReducer = (state = initState, action) =&gt; {
  switch (action.type) {
    ...
    case PAGE_INIT:
      return {
        ...state,
        searchStock: {...state.searchStock, page: 0}
      }
    case STOCK_FETCH:
      return {
        ...state,
        stocks: state.stocks.data.concat(action.payload.data)
      }
    default:
      return state
  }
}
</code></pre>

<p>Last use the connect method to pass the props from redux:</p>

<pre><code>export default connect(
  (state) =&gt; ({
    stocks: state.stock.stocks
  }),
  {onPaginated, initPage}
)(StockCardWithInfiniteScroll)
</code></pre>

<p>I can see the feedback stocks props in browser console, but the StockCard can not get it.</p>
","9768260","","9768260","","2018-06-08 06:23:28","2018-06-08 06:23:28","Hoc's function can not get the react-redux connect props","<reactjs><redux><react-redux>","0","2","","",""
"50666075","1","","","2018-06-03 11:51:34","","0","47","<p>I'm trying to develop unit test for my react component with jest and enzyme. So basically my component have resize listener, when resize occured my component will update component state. But i just couldn't get the clientWidth for my react component. Below is some code of my component.</p>

<pre><code>import React, { Component } from ""react"";
import moment from ""moment"";
// import PropTypes from ""prop-types"";

import Table from ""./Table"";
import Grid from ""./Grid"";
import ActionBlock from ""../ActionBlock"";
import ConfirmDialog from './ConfirmDialog';
import ReactTooltip from 'react-tooltip'
import { debounce } from '../../utils';
import styles from './styles.scss';

export default class Pagination extends Component {

  constructor(props) {
    super(props);
    this.state = {
      index: props.index,
      type: props.type,
      config: props.config,
      data: props.data,
      currentPage: 1,
      dataPerPage: 20,
      enableActionBlock: props.enableActionBlock,
      confirmDialogIndex: null,
      confirmDialogActionName: null,
      confirmDialogData: null,
      width: 0
    };

    this.handleWindowResize = debounce(this.handleWindowResize.bind(this), 100); //delay trigger resize event
  }

  componentDidMount() {
    this.setState({ width: this.refs.pagination_wrapper.clientWidth })
    window.addEventListener('resize', this.handleWindowResize)
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleWindowResize);
  }

  handleWindowResize = () =&gt; {
    this.setState({ width: this.refs.pagination_wrapper.clientWidth })
  }

  render() {
    return (
      &lt;div ref=""pagination_wrapper"" className={styles.pagination_wrapper}&gt;
        &lt;ReactTooltip /&gt;
        {this.renderViewType()}
        {this.renderConfirmDialog()}
      &lt;/div&gt;
    )
  }
}

Pagination.defaultProps = {
  enableActionBlock: true,
  dataPerPage: 20
};
</code></pre>

<p>And below is my test code.</p>

<pre><code>import React from 'react'
import { shallow, mount, render } from 'enzyme';
import Pagination from '../index';
let img = 'https://www.jqueryscript.net/images/Simplest-Responsive-jQuery-Image-Lightbox-Plugin-simple-lightbox.jpg';
let imageStream = 'http://192.168.100.125:8080/';
let imgQuoteError = `http://192.168.100.71/target-data/fr/target-person-images/1111112222233333@Rizkifika-Asanuli'nam/qTD8vYa.jpeg`;

describe('Testing Pagination', () =&gt; {

  let action = (actionName, indexData) =&gt; {
    console.log('action APP', actionName, indexData);
  }

  let dataListProps = {
    index: 'id',
    type: 'grid',
    config: [
      { text: 'Image', type: 'image', textPath: 'image', textColor: 'red', valuePath: 'image' },
      { text: 'Fullname', type: 'string', textPath: 'fullname', valuePath: 'fullname' },
      { text: 'Role', type: 'string', textPath: 'role', valuePath: 'role' },
      { text: 'Datetime', type: 'date', textPath: 'datetime', valuePath: 'datetime' },
      { text: 'Json', type: 'json', textPath: 'json', valuePath: 'json' },
    ],
    data: [
      { id: 305, created_at: '2018-02-23T09:43:08.928Z', rule_detail: { id: 1 }, cam_detail: { id: 2, name: 'kamera huawei' }, vas_detail: { id: 3, name: 'VAS 3' }, image: img },
      { id: 306, created_at: '2018-02-23T09:43:08.928Z', rule_detail: { id: 2, name: '' }, cam_detail: { id: 3, name: 'kamera avigilon' }, vas_detail: { id: 4, name: 'VAS 4' }, image: imageStream },
      { id: 306, created_at: '2018-02-23T09:43:08.928Z', rule_detail: { id: 2, name: null }, cam_detail: { id: 3, name: 'kamera avigilon' }, vas_detail: { id: 4, name: 'VAS 4' }, image: imgQuoteError },
      { id: 306, created_at: '2018-02-23T09:43:08.928Z', rule_detail: { id: 2, name: 'Crowd Behaviour' }, cam_detail: { id: 3, name: 'kamera avigilon' }, vas_detail: { id: 4, name: 'VAS 4' }, image: imageStream },
    ],
    onAction: action,
    enableActionBlock: false
  }

  it('snapshot', () =&gt; {
    const wrapper = shallow(&lt;Pagination {...dataListProps}/&gt;)
    expect(wrapper).toMatchSnapshot();
  })
})
</code></pre>

<p>I need help for solving this</p>
","3026781","","1727948","","2018-06-04 04:20:43","2018-06-04 07:50:31","Test react component can't get clientWidth","<javascript><reactjs><jestjs><enzyme>","2","3","","",""
"50727041","1","50735857","","2018-06-06 18:16:51","","0","94","<p>I've been trying to implement the react-image-gallery v0.8.7 (0.8.8 has a <a href=""https://github.com/xiaolin/react-image-gallery/issues/288"" rel=""nofollow noreferrer"">bug</a>) from this npm package: <a href=""http://I&#39;ve%20been%20trying%20to%20implement%20the%20react-image-gallery%20from%20this%20npm%20package:%20https://github.com/xiaolin/react-image-gallery"" rel=""nofollow noreferrer"">https://github.com/xiaolin/react-image-gallery</a> and integrated following the <a href=""https://github.com/xiaolin/react-image-gallery#example"" rel=""nofollow noreferrer"">example</a> as follows (I am developing a Meteor web app):</p>

<pre><code>class MyGallery extends Component {
    constructor(props) {
    super(props);
    this.state = {
      mediaSrc: [],
      isFullScreen: false
    };
  }

  componentWillMount() {
    const mediaSrc = this.props.myObject.pictures.map((picture) =&gt; {
      return { original: picture, thumbnail: picture };
    });
    this.setState({ mediaSrc });
  }

  _onImageClick(event) {
    if (this.state.isFullScreen) {
      this._imageGallery.exitFullScreen();
      this.setState({ isFullScreen: false });
    } else {
      this._imageGallery.fullScreen();
      this.setState({ isFullScreen: true });
    }
  }

  render() {
    return (
      &lt;div className=""dish row""&gt;
        &lt;figure className=""center col-12"" &gt;
          &lt;div className=""dish__preview_container""&gt;
            &lt;ImageGallery
              ref={i =&gt; this._imageGallery = i}
              items={this.state.mediaSrc}
              onClick={this._onImageClick.bind(this)}
              showFullscreenButton={false}
              showIndex
              showPlayButton={false}
              showThumbnails={false}
            /&gt;
         &lt;/div&gt;
      );
  }
}

MyGallery.propTypes = {
  myObject: PropTypes.object.isRequired,
}

}
</code></pre>

<p>The object <code>myObject</code> contains the following value in the pictures array:</p>

<pre><code>[ 'https://media-cdn.tripadvisor.com/media/photo-s/05/6c/2b/9b/america-s-taco-shop.jpg',
  'https://www.cocinavital.mx/wp-content/uploads/2017/09/tostadas-de-tinga-de-pechuga-de-pollo-con-chipotle-video.jpg'
]
</code></pre>

<p>When rendering the ImageGallery is shown as expected, however when clicking on either the button aria-label=""Previous Slide"" or aria-label=""Next Slide"", doesn't show the respective image and throws the following exception on the developer tools console:</p>

<pre><code>Warning: Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
    in ImageGallery (created by MyGallery)
    in div (created by MyGallery)
</code></pre>

<p>Any suggestions for a solution, please?</p>

<p>Update: Had a reset of component state variables on the componenteWillUmnount method. Removed it, also tried with <a href=""https://atmospherejs.com/meteor/reactive-dict"" rel=""nofollow noreferrer"">Meteor Reactive Dic</a>t instead of component state variables. The exception remains, though.</p>
","1084126","","1084126","","2018-06-07 20:16:09","2018-06-07 20:16:09","Can't call setState (or forceUpdate) on an unmounted component. Memory leak on react-image-gallery","<javascript><reactjs><ecmascript-6>","1","1","","",""
"50898357","1","50900008","","2018-06-17 16:11:18","","0","96","<p>I have the following code that is not letting me set the state ever after getting mounted.</p>

<p>Here is the code</p>

<pre><code>    import React, { Component } from 'react';
import Messages from '../locale/en/Messages';
import '../styles/base.css';

class AlertService extends Component {
    state = {
        message: '',
        classType: 'alert-info',
        isMessageSet: false
    }

    Messages = new Messages();

    componentDidMount = () =&gt; {
        console.log('This has mounted'); // This is working
    }
    componentWillUnmount = () =&gt; {
        console.log('Is this getting unounted ?'); // This is working, the component is not getting unmounted
    }
    setAlert = (key, type, isMessage, readMore) =&gt; {
        let message = isMessage ? key : this.Messages[key];
        let classType = 'alert-info';
        if (type === 0) {
            classType = 'alert-danger';
        } else if (type === 1) {
            classType = 'alert-success';
        }
        this.openMessage(message,classType);


    }
    openMessage = (message,classType) =&gt;{
        this.setState({
            message: message,
            classType: classType,
            isMessageSet: true
        });
    }
    closeMessage = () =&gt; {
        this.setState({
            message: '',
            classType: 'info',
            isMessageSet: false
        });
    }
    render() {
        let classes = this.state.classType + ' ' + 'alertBox';
        return (this.state.isMessageSet ? 

                                        &lt;div className={classes}&gt;
                                           &lt;div className=""col-md-11""&gt; {this.state.message} &lt;/div&gt;
                                           &lt;div className=""col-md-1 closeAlert"" onClick={this.closeMessage}&gt; x &lt;/div&gt;


                                        &lt;/div&gt;

                                : null
        )
    }
}
export default AlertService;
</code></pre>

<p>I am geting the following error when trying to call the function setAlert from outside this component.
However if I set the <code>isMessageSet</code> property to <code>true</code> then on clicking the X and calling the closeAlert method, it works fine.</p>

<p>componentDidMount indicates that the component is getting mounted and componentWillUnmount is never getting executed , I am not sure what is wrong here </p>

<p>Error Message
 Can't call setState on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to <code>this.state</code> directly or define a <code>state = {};</code> class property with the desired state in the AlertService component.</p>
","2121671","","2121671","","2018-06-17 16:21:57","2018-06-17 19:58:35","Unable to use setState in react component","<javascript><reactjs><react-native><components><setstate>","3","4","1","",""
"50799812","1","","","2018-06-11 14:13:17","","0","143","<p>I am getting this warning:   </p>

<blockquote>
  <p><code>Warning: isMounted(...) is deprecated in plain JavaScript React classes. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.</code></p>
</blockquote>

<p><strong>How do I fix the warning? I don't want to hide it like this:</strong></p>

<pre><code>import { YellowBox } from 'react-native';
YellowBox.ignoreWarnings(['Warning: isMounted(...) is deprecated', 'Module 
RCTImageLoader']);
</code></pre>
","6569224","","6569224","","2018-06-12 06:48:13","2018-06-12 06:48:13","How to perfect fix isMounted(...) warnings in react-native not to silence this warning","<react-native><warnings>","0","3","","",""
"51029535","1","51029820","","2018-06-25 18:09:36","","1","38","<p>I need to add or remove class on element if page is scrolled in react I wrote such a code to track page scroll:</p>

<pre><code>export default class TestComponenet extends React.Component {
  constructor(props) {
    super(props);
    autoBind(this);
    this.state = {
      scrolled: false
    }
  }

  componentDidMount() {
    window.addEventListener('scroll', this.handleScroll);
  };

  componentWillUnmount() {
    window.removeEventListener('scroll', this.handleScroll);
  };

  handleScroll(event) {
    this.setState({srolled: true});
  };

  render() {
    return (
      &lt;div className ={scrolled ? 'scrolling' : ''}&gt;&lt;/div&gt;
    );
  }
}
</code></pre>

<p>but I can only track scroll but I cannot toggle class dynamically.</p>
","6641245","","3617886","","2018-06-25 18:52:17","2018-07-05 18:05:02","how to toggle class on scroll event in react?","<javascript><reactjs>","1","3","","",""
"49866427","1","49870513","","2018-04-16 21:21:18","","1","85","<p>I build react native app and I'm trying to make event when user close the app, so it update in firebase the status to 'offline'.
what I do is</p>

<pre><code>    import React, { Component } from 'react'
import Router from './src/Router'
import firebase from 'react-native-firebase';

export default class App extends Component {
    constructor(props){
        super(props)
        this.state = {
            uid: '',
            userStatusDatabaseRef :'',
            userStatusFirestoreRef: ''
        }
    }
    componentWillMount() {
        firebase.auth().signInAnonymouslyAndRetrieveData().then((user) =&gt; {

            var uid = firebase.auth().currentUser.uid;
            console.log('uid', uid)
            var userStatusDatabaseRef = firebase.database().ref('status/' + uid);

            var isOfflineForDatabase = {
                state: 'offline',
                last_changed: firebase.database.ServerValue.TIMESTAMP,
            };

            var isOnlineForDatabase = {
                state: 'online',
                last_changed: firebase.database.ServerValue.TIMESTAMP,
            };

            var userStatusDatabaseRef = firebase.database().ref('status/' + uid);

            var userStatusFirestoreRef = firebase.firestore().doc('status/' + uid);


            var isOfflineForFirestore = {
                state: 'offline',
                last_changed: firebase.firestore.FieldValue.serverTimestamp(),
            };

            var isOnlineForFirestore = {
                state: 'online',
                last_changed: firebase.firestore.FieldValue.serverTimestamp(),
            };

            const connectedRef = firebase.database().ref("".info/connected"");
            connectedRef.on(""value"", function (snap) {
                // validate if connection is established
                if (snap.val() === true) {
                    // remove the user's record on the disconnect
                    userStatusDatabaseRef.onDisconnect().set(isOfflineForDatabase).then(()=&gt;{
                        userStatusFirestoreRef.set(isOnlineForFirestore);

                    })
                    // then request user to enter their name
                } else {
                    userStatusFirestoreRef.set(isOfflineForFirestore);

                }
            });
            this.setState({userStatusDatabaseRef,userStatusFirestoreRef,uid})
        })

    }
    render() {
        return &lt;Router /&gt;
    }
    componentWillUnmount(){
        var isOfflineForFirestore = {
            state: 'offline',
            last_changed: firebase.firestore.FieldValue.serverTimestamp(),
        };

        this.state.userStatusFirestoreRef.set(isOfflineForFirestore);

    }
}
</code></pre>

<p>first, I would like to understand when onDisconnect fire and what is do. second, when i navigate to other screen, it fire me and that's not what I'm looking for, only when user close app from each screen. I don't want to duplicate the code and write in each component because it's not right coding. what I'm looking for event from each screen/component that user that can update in firebase offline or online</p>

<p>I changed my code and it update only in firebase and not the firestore</p>

<pre><code> const connectedRef = firebase.database().ref("".info/connected"");

            // validate if connection is established
            if (snap.val() === true) {
                userStatusFirestoreRef.set(isOnlineForDatabase);
                userStatusDatabaseRef.set(isOnlineForDatabase)

                // remove the user's record on the disconnect
                userStatusDatabaseRef.onDisconnect().remove((error)=&gt;{
                    userStatusDatabaseRef.set(isOfflineForFirestore);
                    userStatusFirestoreRef.set(isOfflineForFirestore);

                })
                // then request user to enter their name
            } else {

                userStatusFirestoreRef.set(isOfflineForFirestore);

            }
        });
</code></pre>

<p>why it's not set the value also in firestore to 'offline' </p>

<pre><code> userStatusDatabaseRef.onDisconnect().remove((error)=&gt;{
                    userStatusDatabaseRef.set(isOfflineForFirestore); // it update only in firebase
                    userStatusFirestoreRef.set(isOfflineForFirestore);

                })
</code></pre>
","6455516","","6455516","","2018-04-17 06:59:38","2018-04-17 06:59:38","react native with firebase onDisconnect","<javascript><reactjs><firebase><react-native><google-cloud-firestore>","1","0","","",""
"50902612","1","50902718","","2018-06-18 04:16:58","","0","37","<p>While exploring through react documentation(<a href=""https://reactjs.org/docs/integrating-with-other-libraries.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/integrating-with-other-libraries.html</a>), I found this code snippet:</p>

<pre><code>class Chosen extends React.Component {

   componentDidMount() {
      this.$el = $(this.el);
      this.$el.chosen();
    }

    componentWillUnmount() {
      this.$el.chosen('destroy');
    }

  render() {
    return (
      &lt;div&gt;
        &lt;select className=""Chosen-select"" ref={el =&gt; this.el = el}&gt;
          {this.props.children}
        &lt;/select&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>the syntax I don't undertand is below:</p>

<pre><code>ref = {el =&gt; this.el = el} 
</code></pre>

<p>what does the statement refer to ? I get it is identical to :</p>

<pre><code>ref = { el =&gt; {
            return this.el = el
            }
       }
</code></pre>

<p>but what does it mean ? what is the flow in this code ? </p>
","9032824","","","","","2018-06-18 04:35:59","Curiosity on react(?) or javascript syntax","<javascript><jquery><reactjs><syntax><jquery-chosen>","1","2","","",""
"50914528","1","","","2018-06-18 17:16:23","","0","73","<p>I'm getting a new project going. I am using create-react-app with redux and thunk. The api server is a separate project, and uses node/express and mongo/mongoose for the database. I am trying to redirect to an item list view after either a create or delete item action. If the redirect is in the component itself, the redirect happens before the action is completed, and the refetch of the list happens before the create or delete happens. Therefore I am trying to use thunk to dispatch a redirect action in the .then() part of the action. The redirect successfully changes the url in the browser, but no re-render is triggered. How can I get the redirect to from either the create action or delete action to trigger a re-render of the stockitems list component?</p>

<p>full code is at: <a href=""https://github.com/jhlindell/BarCode-app/tree/stockitem"" rel=""nofollow noreferrer"">https://github.com/jhlindell/BarCode-app/tree/stockitem</a>
server is at: <a href=""https://github.com/jhlindell/BarCode-server/tree/jon"" rel=""nofollow noreferrer"">https://github.com/jhlindell/BarCode-server/tree/jon</a></p>

<p>My index.js:</p>

<pre><code>import 'bootstrap/dist/css/bootstrap.css';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import React from 'react';
import ReactDOM from 'react-dom';
import registerServiceWorker from './registerServiceWorker';
import { ConnectedRouter } from 'connected-react-router'

import { createStore, applyMiddleware, compose } from 'redux';
import { composeWithDevTools } from 'redux-devtools-extension';
import { createBrowserHistory } from 'history';
// import { browserHistory } from 'react-router'
import reducers from './reducers';
import thunk from 'redux-thunk';
import { connectRouter, routerMiddleware } from 'connected-react-router'
import { logger } from 'redux-logger';

const history = createBrowserHistory();
const reactRouterMiddleware = routerMiddleware(history); 

const middleWares = [
  thunk,
  logger,
  reactRouterMiddleware
]

const store = createStore(
  connectRouter(history)(reducers), 
  composeWithDevTools(applyMiddleware(...middleWares)));

ReactDOM.render(
  &lt;Provider store = {store}&gt;
    &lt;ConnectedRouter history={history}&gt;
      &lt;App history={history}/&gt;
    &lt;/ConnectedRouter&gt;
  &lt;/Provider&gt;
, document.getElementById('root'));
registerServiceWorker();
</code></pre>

<p>My app.js file:</p>

<pre><code>import './App.css';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Footer from './components/Nav/Footer';
import NavBar from './components/Nav/NavBar';
import React, { Component } from 'react';
import StockItemCreate from './components/StockItems/StockItemCreate';
import StockItemDetail from './components/StockItems/StockItemDetail';
import StockItemList from './components/StockItems/StockItemList';
import HomePage from './components/HomePage';


class App extends Component {
  com

  render() {
    const flexCol = {
      display: 'flex',
      flexDirection: 'column',
    };

    const flex0 = {
      flex: 0
    };

    const flex1 = {
      display: 'flex',
      flex: '1 1 100%',
    };
    return (
      &lt;Router&gt;
        &lt;div className=""App"" style={flexCol}&gt;
          &lt;div style={flex0}&gt;
            &lt;NavBar /&gt;
          &lt;/div&gt;
          &lt;div style={flex1} id=""mainBlock""&gt;
            &lt;Switch&gt;
              &lt;Route exact path='/' component={HomePage} /&gt;
              &lt;Route exact path='/stockitems/create' component={StockItemCreate} /&gt;
              &lt;Route exact path='/stockitems' component={StockItemList} /&gt;
              &lt;Route path='/stockitems/:id' component={StockItemDetail} /&gt;
            &lt;/Switch&gt;
          &lt;/div&gt;
          &lt;div style={flex0}&gt;
            &lt;Footer /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Router&gt;
    );
  }
}

export default App;
</code></pre>

<p>the list component:</p>

<pre><code>import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import React, {Component} from 'react';
import { getStockItemList, clearStockItemList } from '../../actions';

const listStyle = {
    display: 'flex',
    margin: 'auto'
}

class StockItemList extends Component {
  componentDidMount(){
    this.props.getStockItemList();
  }

  componentWillUnmount(){
    this.props.clearStockItemList();
  }

  render(){
    return (
      &lt;div style={listStyle}&gt;
        {this.props.stockItemList ? &lt;ul className=""list-group""&gt;
          {this.props.stockItemList.map((item) =&gt; {
            return &lt;li 
            className=""list-group-item"" 
            key={item.name}
            onClick={()=&gt; this.props.history.push(`/stockitems/${item._id}`)}
            &gt;{item.name}&lt;/li&gt;
          })}
        &lt;/ul&gt; : &lt;span&gt;loading...&lt;/span&gt;}
      &lt;/div&gt;
    );
  }
}

function mapStateToProps(state){
  return { stockItemList: state.stockItemList }
}

function mapDispatchToProps(dispatch){
  return bindActionCreators({ getStockItemList, clearStockItemList }, dispatch)
}

export default connect(mapStateToProps, mapDispatchToProps)(StockItemList);
</code></pre>

<p>the create component:</p>

<pre><code>import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import React, {Component} from 'react';
import { createStockItem } from '../../actions'

const cardStyle = {
  display: 'flex',
  margin: 'auto',
};

const formStyle = {
  display: 'flex',
  flexDirection: 'column',
  width: '80%',
  margin: 'auto'
};

class StockItemCreate extends Component{
  constructor(props){
    super(props);
    this.state = {
      name: '',
      description: ''
    }
  }
  handleFormSubmit = (event) =&gt; {
    event.preventDefault();
    this.props.createStockItem(this.state);
    this.clearForm();
    //this.props.history.push('/stockitems');
  }

  handleInputChange = (event) =&gt; {
    const target = event.target;
    const value = target.value;
    const name = target.name;
    this.setState({[name]: value});
  }

  clearForm = () =&gt; {
    this.setState({ name: '', description: ''});
  }

  render(){
    return(

        &lt;form className=""card"" onSubmit={this.handleFormSubmit} style={cardStyle}&gt;
            &lt;div className=""card-header""&gt;
              &lt;h3&gt;Add new ingredient&lt;/h3&gt;
            &lt;/div&gt;
            &lt;div className=""card-block mt-2""&gt;
              &lt;div style={formStyle}&gt; 
                &lt;label&gt;Name&lt;/label&gt;
                &lt;input name=""name"" type=""text""
                  onChange={(e) =&gt; {this.handleInputChange(e)}}
                  placeholder=""Name""
                  value={this.state.name}/&gt;             
              &lt;/div&gt;
              &lt;div className=""mt-2"" style={formStyle}&gt; 
                &lt;label&gt;Description&lt;/label&gt;
                &lt;input name=""description"" type=""text""
                  onChange={(e) =&gt; {this.handleInputChange(e)}}
                  placeholder=""Description""
                  value={this.state.description}/&gt;             
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div className=""btn-group mb-2 mt-2"" style={{padding: '0', margin: 'auto'}}&gt;
              &lt;button className=""btn btn-primary"" type=""submit""&gt;
                Submit
              &lt;/button&gt;
              &lt;button className=""btn btn-secondary"" type=""button"" onClick={()=&gt;this.clearForm()}&gt;
                Cancel
              &lt;/button&gt;
            &lt;/div&gt;
        &lt;/form&gt;

    )
  }
}

function mapDispatchToProps(dispatch){
  return bindActionCreators({ createStockItem }, dispatch);
}

export default connect(null, mapDispatchToProps)(StockItemCreate);
</code></pre>

<p>and finally, the action file where the redirect is called:</p>

<pre><code>import axios from 'axios';
import { push, replace } from 'connected-react-router'


const URL = 'http://localhost:8000';

export function getStockItemList(){
  return function(dispatch){
    axios.get(`${URL}/api/stock_items/`)
      .then((response) =&gt; {
        dispatch({ type: 'STOCK_ITEM_LIST', payload: response.data });
      })
      .catch((error) =&gt; {
        console.log('error getting stock items');
      });
  }
}

export function clearStockItemList(){
  return { type: 'CLEAR_STOCK_ITEM_LIST' };
}

export function getStockItemById(id){
  return function(dispatch){
    axios.get(`${URL}/api/stock_items/${id}`)
      .then((response) =&gt; {
        dispatch({ type: 'SINGLE_STOCK_ITEM', payload: response.data });
      })
      .catch((error) =&gt; {
        console.log('error getting stock item by id');
        dispatch(push('/stockitems'));
      });
  }
}

export function clearSingleStockItem(){
  return { type: 'CLEAR_SINGLE_STOCK_ITEM' };
}

export function createStockItem(item){
  return function(dispatch){
    axios.post(`${URL}/api/stock_items/`, item)
      .then((response)=&gt; {
        console.log(""response"", response);
        dispatch(push('/stockitems'));
      })
      .catch((error) =&gt; {
        //create error container to post error to
        console.log('error creating stock item', error);
      });
  }
}

export function deleteStockItem(id){
  return function(dispatch){
    axios.delete(`${URL}/api/stock_items/${id}`)
      .then((response)=&gt; {
        console.log(""delete response: "", response);
        dispatch(push('/stockitems'));
      })
      .catch((error) =&gt; {
        //create error container to post error to
        console.log('error deleting stock item', error);
      });
  }
}
</code></pre>
","9957873","","","","","2018-06-18 17:16:23","How do I get connected-react-router to redirect using a redux-thunk dispatch action?","<reactjs><redux><react-router><thunk>","0","0","","",""
"51163468","1","","","2018-07-03 22:18:59","","1","29","<p>I am using Socket.io Callbacks with react. However, sometimes I get this warning</p>

<blockquote>
  <p>Warning: Can't call setState (or forceUpdate) on an unmounted
  component. This is a no-op, but it indicates a memory leak in your
  application. To fix, cancel all subscriptions and asynchronous tasks
  in the componentWillUnmount method.</p>
</blockquote>

<p>Fundamentally, I understand that the callback can be holding references to local data and preventing that data from being cleared until the callback is cleared.</p>

<p>Unfortunately Socket.io does not work with promises but with direct callbacks. What this means is that I may get a callback AFTER the component has unmounted since these callbacks cannot be ""cancelled""</p>

<p>I make sure that the server responds to all callbacks to make sure they get satisfied and therefore do not leak memory</p>

<p>I attempted to ""silence"" this warning by calling <code>this.setState({mounted:true});</code> in <code>componentDidMount</code> and    <code>this.setState({mounted:false});</code> in <code>componentWillUnmount</code></p>

<p>And then within my update simply checking <code>if(this.state.mounted)</code> before calling <code>this.setState()</code> within the socket.io callback.</p>

<p>This works for most cases. However it seems that in this case. The parent component causes this component </p>

<ul>
<li>componentDidMount

<ul>
<li>update state to mounted:true</li>
<li>send request to socket.io
-componentWillUnmount</li>
<li>update state to mounted:false</li>
</ul></li>
<li>componentDidMount

<ul>
<li>update state to mounted:true</li>
<li>send additional request to socket.io</li>
</ul></li>
<li>Callback response from socket.io

<ul>
<li>warning printed</li>
</ul></li>
</ul>

<p>How do I prevent this? Is there a better design pattern for sock.io</p>
","1481240","","1481240","","2018-07-04 11:31:59","2018-07-04 11:31:59","Socket.io Callbacks with react","<reactjs><socket.io>","2","2","","",""
"50644161","1","","","2018-06-01 13:07:54","","0","23","<p>I am trying to implement button group in reactjs es6. now i have taken this example <a href=""https://react-bootstrap.github.io/components/button-group/"" rel=""nofollow noreferrer"">https://react-bootstrap.github.io/components/button-group/</a> with the checkbox and I am trying to implement but it does not seem to trigger the onchange event.</p>

<pre><code>    class ToggleButtonGroupControlled extends React.Component {
          constructor(props, context) {
            super(props, context);

            //this.handleChange = this.handleChange.bind(this);

            this.state = {
              value: 1
            };
          }

          handleChange(e) {
              console.log(e);
            this.setState({ value: e });
          }

          render() {
            return (
              &lt;ToggleButtonGroup
                type=""radio""
                    name=""exemption_status_button""
                value={this.state.value}
                onChange={this.handleChange.bind(this)}
              defaultChecked={this.state.value}
              &gt;
                &lt;ToggleButton onChange={this.handleChange}value={1} className=""badge2"" data-count={this.props.statusButton.requested}&gt;Requested&lt;/ToggleButton&gt;
                &lt;ToggleButton onChange={this.handleChange}value={3} className=""badge2"" data-count={this.props.statusButton.accepted}&gt;Accepted&lt;/ToggleButton&gt;
                &lt;ToggleButton onChange={this.handleChange}value={6} className=""badge2"" data-count={this.props.statusButton.implemented}&gt;Implemented&lt;/ToggleButton&gt;
                &lt;T

oggleButton onChange={this.handleChange}value={5} className=""badge2"" data-count={this.props.statusButton.cancelled}&gt;Cancelled&lt;/ToggleButton&gt;
            &lt;ToggleButton onChange={this.handleChange}value={4} className=""badge2"" data-count={this.props.statusButton.rejected}&gt;Rejected&lt;/ToggleButton&gt;
          &lt;/ToggleButtonGroup&gt;
        );
      }
    }
</code></pre>

<p>i got it working the following way. I had to use jquery to extract the value and use passback functions .</p>

<pre><code>import _ from 'lodash';
import axios from 'axios';
import React, { Component } from 'react';
import { Checkbox } from 'react-bootstrap';
import { connect } from 'react-redux';
import {
    fetchSecurityExemptions,
    fetchSecurityExemptionsCount,
    fetchMarkets,
    fetchServiceDomains,
    fetchServicesList,
    fetchSecurityEngineerList,
    fetchBusinessPriorityList,
    updateSecurityExemption
} from '../../actions/security';
import { bindActionCreators } from 'redux';
import { Button, ButtonToolbar, Modal, Tooltip, OverlayTrigger, ToggleButton, ToggleButtonGroup } from 'react-bootstrap';
import FontAwesome from 'react-fontawesome';
import { BootstrapTable, TableHeaderColumn, InsertModalHeader, InsertModalFooter, SearchField } from 'react-bootstrap-table';
import 'react-bootstrap-table/dist/react-bootstrap-table-all.min.css';
import $ from 'jquery';
import ModalError from '../modalerror';
import ModalConfirm from '../modalconfirm';
import { Link } from 'react-router-dom';
import { isGenericName } from '../../scripts/validation';

class ToggleButtonGroupControlled extends Component {
      constructor(props, context) {
        super(props, context);

        this.handleChange = this.handleChange.bind(this);

        this.value = 1

      }

      handleChange(e) {
        this.value = $(e.target).children('input').val();
        this.passStatusButtonBack();
      }

      passStatusButtonBack(){
          this.props.passStatusButtonBack(this.value);
      }

      render() {
        return (
        &lt;ButtonToolbar&gt;
          &lt;ToggleButtonGroup
            type=""radio""
            name=""exemption_status_button""
            value={this.value}
            onChange={this.handleChange}
            defaultChecked={this.value}
          &gt;
            &lt;ToggleButton onClick={this.handleChange}value={1} className=""badge2"" data-count={this.props.statusButton.requested}&gt;Requested&lt;/ToggleButton&gt;
            &lt;ToggleButton onClick={this.handleChange}value={3} className=""badge2"" data-count={this.props.statusButton.accepted}&gt;Accepted&lt;/ToggleButton&gt;
            &lt;ToggleButton onClick={this.handleChange}value={6} className=""badge2"" data-count={this.props.statusButton.implemented}&gt;Implemented&lt;/ToggleButton&gt;
            &lt;ToggleButton onClick={this.handleChange}value={5} className=""badge2"" data-count={this.props.statusButton.cancelled}&gt;Cancelled&lt;/ToggleButton&gt;
            &lt;ToggleButton onClick={this.handleChange}value={4} className=""badge2"" data-count={this.props.statusButton.rejected}&gt;Rejected&lt;/ToggleButton&gt;
          &lt;/ToggleButtonGroup&gt;
        &lt;/ButtonToolbar&gt;
        );
      }
    }


class SecurityExemptions extends Component {
    constructor(props) {
        super(props);
        this.securityExemptions = [];
        this.state = {
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            },
            data: [],
            show: false,
            showError: false,
            errorMsg: '',
            errorTitle: '',
            confirm: {
                body: '',
                show: false,
                id: '',
                next: null
            },
            totalDataSize: 0,
            currentPage: 1,
            statusButton: {value: 1, requested: 0, accepted: 0, implemented: 0, cancelled:0, rejected: 0}
        };
        this.where = [];
        this.sort = 'id desc';
        this.meta = { title: '', description: 'Lists and manages security exemptions' };
        this.options = {
            noDataText: 'Loading...',
            defaultSortName: 'id',
            defaultSortOrder: 'desc',
            page: 1,
            paginationShowsTotal: true,
            sizePerPage: 50,
            sizePerPageList: [10, 25, 50, 100, 250],
            onPageChange: this.onPageChange.bind(this),
            onSizePerPageList: this.onSizePerPageList.bind(this),
            onFilterChange: this.onFilterChange.bind(this),
            onSortChange: this.onSortChange.bind(this),
            selectRowProp: {
                mode: 'checkbox',
                clickToSelect: true,
                onSelect: this.handleRowSelect,
                customComponent: this.customMultiSelect.bind(this)
            },
            cellEditProp: {
                mode: 'click',
                blurToSave: true,           
                afterDeleteRow: this.onAfterDeleteRow.bind(this),
                afterSaveCell: this.onAfterSaveCell.bind(this),
                nonEditableRows: function() {
                    return this.state.data.filter(row =&gt; row.exemption_status_id != 1 ).map(row =&gt; row.id);
                  }.bind(this)
            },
            handleConfirmDeleteRow: this.customConfirm.bind(this),
            btnGroup: this.createCustomButtonGroup.bind(this),
            deleteBtn: this.createCustomDeleteButton.bind(this),
            onSearchChange: this.onSearchChange.bind(this),
            searchField: this.createCustomSearchField            
        };

        this.updateWindowDimensions = this.updateWindowDimensions.bind(this);
        this.handleShowError = this.handleShowError.bind(this);
        this.fetchSecurityExemptions = this.fetchSecurityExemptions.bind(this);
        this.handlestatusButtonChange = this.handlestatusButtonChange.bind(this);
        this.runOnce = false;
        this.passStatusButtonBack = this.passStatusButtonBack.bind(this)

        this.markets = [];
        this.serviceDomain = [];
        this.servicesList = [];
        this.servicesListDisplay = [];
        this.securityEngineerList = [];
        this.businessPriority = []        
    }

    passStatusButtonBack(status){
        let statusButton = this.state.statusButton;
        statusButton.value = status;
        this.setState({ statusButton });
        this.where.exemption_status_id = status;
        this.fetchSecurityExemptions(this.options.page, this.options.sizePerPage, this.where, this.sort);
    }    


    passMetaBack = () =&gt; {
        this.props.passMetaBack(this.meta);
    };



    createCustomButtonGroup = props =&gt; {    
            return (
                &lt;ButtonGroup className=""my-custom-class"" sizeClass=""btn-group-md""&gt;
                    {props.insertBtn}
                    {props.deleteBtn}
                    &lt;ExemptionStatusButtons self={this} /&gt;
                    &lt;ToggleButtonGroupControlled statusButton={this.state.statusButton} passStatusButtonBack={this.passStatusButtonBack}/&gt;
                &lt;/ButtonGroup&gt;
            );

    };



    componentDidMount() {
        this.passMetaBack();
        this.updateWindowDimensions();
        window.addEventListener('resize', this.updateWindowDimensions);
    }

    componentWillUnmount() {
        window.removeEventListener('resize', this.updateWindowDimensions);
    }

    renderTable(tableData) {
        let insertRow = false;
        let deleteRow = false;

        return (
            &lt;div className=""container-fluid""&gt;
                &lt;div className=""row-fluid""&gt;
                    &lt;BootstrapTable 
                        data={tableData} 
                        remote 
                        search 
                        fetchInfo={{ dataTotalSize: this.state.totalDataSize }} 
                        options={this.options} 
                        pagination 
                        striped 
                        hover 
                        tableHeaderClass=""table-vf thead"" 
                        tableContainerClass=""securityExemptions"" 
                        insertRow={insertRow} 
                        cellEdit={this.options.cellEditProp} 
                        deleteRow={deleteRow} 
                        selectRow={this.options.selectRowProp} 
                        maxHeight={this.state.viewport.height * 0.66} 
                        ref=""table""
                    &gt;
                        &lt;TableHeaderColumn dataField=""id"" isKey={true} editable={false} hiddenOnInsert width={`60px`} dataFormat={this.exemptionsLink}&gt;
                            ID
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""hits"" editable={false} hiddenOnInsert width={`50px`}&gt;
                            Hits
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""market"" width={`150px`} formatExtraData={this.markets} editable={{ type: 'select', options: { values: this.markets } }}&gt;
                            Market
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""service_domain"" width={`150px`} formatExtraData={this.serviceDomain} editable={{ type: 'select', options: { values: this.serviceDomain } }}&gt;
                            Service Domain
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""service_id"" width={`200px`}  editable={false} dataFormat={this.serviceFormatter}&gt;
                            Service / Project / Programme
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""demand_ref""  width={`70px`} editable={{ type: 'text', validator: this.isGenericName }}&gt;
                            Demand ID
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""summary""  width={`200px`} editable={false}&gt;
                            Summary
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""filename"" width={`200px`} dataFormat={this.commsMatrixLink} editable={false}&gt;
                            Commsmatrix
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""business_priority"" width={`100px`} formatExtraData={this.businessPriority} editable={{ type: 'select', options: { values: this.businessPriority } }}&gt;
                            Priority
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""expiry_date"" width={`150px`} editable={true}&gt;
                            Expiry
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""security_engineer"" width={`200px`} dataFormat={this.htmlFormatter} formatExtraData={this.securityEngineerList} editable={{ type: 'select', options: { values: this.securityEngineerList } }}&gt;
                            Security Engineer
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""ts_created"" width={`130px`} editable={false} hiddenOnInsert&gt;
                            Requested
                        &lt;/TableHeaderColumn&gt;
                        &lt;TableHeaderColumn dataField=""created_by"" width={`110px`} editable={false} hiddenOnInsert&gt;
                            Requested By
                        &lt;/TableHeaderColumn&gt;
                    &lt;/BootstrapTable&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }

    render() {
        const { securityExemptions } = this.props;

        if (!this.runOnce &amp;&amp; this.props.isReady &amp;&amp; this.securityExemptions.length == 0) {
            this.runOnce = true;

            this.where = {exemption_status_id : this.state.statusButton.value};
            this.initData();
        }

        let table = (
            &lt;div&gt;
                Loading...&lt;i className=""fa fa-spinner fa-spin"" /&gt;
            &lt;/div&gt;
        );

        if (this.state.show) {
            table = this.renderTable(this.state.data);
            this.moveElement();
        }

        return (
            &lt;div className=""container-fluid""&gt;
                &lt;div className=""row-fluid top-buffer""&gt;{table}&lt;/div&gt;
                &lt;ModalConfirm body={this.state.confirm.body} show={this.state.confirm.show} id={this.state.confirm.id} handleConfirmYes={this.handleConfirmYes} handleConfirmNo={this.handleConfirmNo} /&gt;
                &lt;ModalError title={this.state.errorTitle} body={this.state.errorMsg} show={this.state.showError} handleCloseError={this.handleCloseError} /&gt;
            &lt;/div&gt;
        );
    }
}

function mapStateToProps(state) {
    return {
        securityExemptions: state.securityExemptions,
        listsReducer: state.listsReducer
    };
}

function mapDispatchToProps(dispatch) {
    return bindActionCreators(
        {
            fetchSecurityExemptions,
            fetchSecurityExemptionsCount,
            fetchMarkets,
            fetchServiceDomains,
            fetchServicesList,
            fetchSecurityEngineerList,
            fetchBusinessPriorityList,
            updateSecurityExemption
        },
    dispatch
);
</code></pre>

<p>}</p>

<p>export default connect(mapStateToProps, mapDispatchToProps)(SecurityExemptions);</p>

<p>}</p>
","1164789","","1164789","","2018-06-01 13:57:10","2018-06-04 12:08:32","reactjs ToggleButtonGroup with type radio is not working","<twitter-bootstrap><reactjs>","1","0","","",""
"50996256","1","","","2018-06-22 22:22:50","","0","24","<p>I'm trying to put React, Mapbox and d3 together. React for DOM manipulation, Mapbox for map rendering and d3 for drawing on the map. While I have gotten to the stage where I am able to draw a line on the map, I wanted to redraw the line when the user decides to zoom or move in the map. I am quite stuck, as I don't know exactly how to implement this event listener. Here is my code so far:</p>

<pre><code>import React, { Component } from 'react';
import MapboxGl from 'mapbox-gl/dist/mapbox-gl.js';
import MapPoints from './MapPoints.jsx';
import { geoMercator, geoPath, geoTransform, geoProjection } from 'd3-geo';
import './App.css';
import 'mapbox-gl/dist/mapbox-gl.css';

export default class Map extends Component {
    constructor(props) {
        super(props);
        this.d3Draw = [];
        this.box_measures = {
            bottom: 244,
            height: 220,
            left: 0,
            right: 1321,
            top: 24,
            width: 1321,
            x: 0,
            y: 24
        };
    }
    componentDidMount() {
        MapboxGl.accessToken =
            'pk.eyJ1Ijoiam9zZWNvdG8iLCJhIjoiY2l2OGZxZWNuMDAxODJ6cGdhcGFuN2IyaCJ9.7szLs0lc_2EjX6g21HI_Kg';

        this.map = new MapboxGl.Map({
            container: this.mapContainer,
            style: 'mapbox://styles/mapbox/streets-v9'
        });

        this.map.jumpTo({ center: [13.29, 52.51], zoom: 10 });
        this.map.addControl(new MapboxGl.NavigationControl());
        this.box_measures = document.getElementsByClassName('mapboxgl-canvas')[0].getBoundingClientRect();
    }

    componentWillUnmount() {
        this.map.remove();
    }

    componentDidUpdate() {
        this.d3Draw = this.props.dataPoints.map(x =&gt;
            this.map.project(new MapboxGl.LngLat(x.geometry.coordinates[0], x.geometry.coordinates[1]))
        );
    }

    render() {
        const style = {
            position: 'absolute',
            top: 100,
            bottom: 0,
            width: '80%'
        };

        return (
            &lt;div&gt;
                &lt;div className=""map"" style={style} ref={el =&gt; (this.mapContainer = el)} /&gt;
                &lt;MapPoints drawPoints={this.d3Draw} measures={this.box_measures} /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>Your help will be greatly appreciated!</p>
","6463630","","","","","2018-06-22 22:22:50","Re rendering points when resizing map (mapbox + react + d3)","<javascript><reactjs><d3.js><mapbox-gl-js>","0","1","","",""
"50911974","1","","","2018-06-18 14:39:47","","1","33","<p>I have read through many posts/information about Z index and still have not been able to figure this out, I have a website with the navbar position fixed so it stays on the top of the page on scroll, when I get down below my header (component where the navbar is placed), all the elements appear ABOVE the navbar when scrolled over (which is obviously not desired), I am able to put a zIndex of -1 on those elements to fix this, however currently I have a form, and making its zIndex -1 makes all the form inputs and submit button disabled or unclickable (guessing it puts the form below another div/element), so I'm pretty stuck and appreciate any advice .. :) </p>

<p>Navbar.js</p>

<pre><code>import React, { Component } from ""react"";
import Radium from ""radium"";
class NavBar extends Component {
  state = {
    topOfPage: true,
    headerSection: true
  };
  componentDidMount() {
    window.addEventListener(""scroll"", this.navBarState);
  }

  componentWillUnmount() {
    window.removeEventListener(""scroll"", this.navBarState);
  }

  navBarState = () =&gt; {
    if (window.scrollY &lt; 58) {
      this.setState({
        topOfPage: true
      });
    }
    if (window.scrollY &gt; 58 &amp;&amp; window.scrollY &lt; 740) {
      this.setState({
        topOfPage: false,
        headerSection: true
      });
    }
    if (window.scrollY &gt; 740) {
      this.setState({
        headerSection: false
      });
    }
  };

  render() {
    const { topOfPage, headerSection } = this.state;
    let navStyle;
    let linkStyle;
    if (topOfPage &amp;&amp; headerSection) {
      navStyle = {
        base: {
          background: ""transparent"",
          transition: ""background-color 0.7s ease""
        }
      };
      linkStyle = {
        base: {
          transition: ""font-size 0.8s"",
          "":hover"": {
            color: ""black"",
            fontSize: ""25px"",
            fontWeight: ""bold"",
            background: ""white"",
            textTransform: ""uppercase"",
            paddingTop: ""10px"",
            borderRadius: ""50px""
          }
        }
      };
    } else if (!topOfPage &amp;&amp; headerSection) {
      navStyle = {
        base: {
          background: ""rgba(20, 20, 20, 0.87)"",
          boxShadow: ""0 8px 6px -6px"",
          transition: ""background-color 0.7s ease""
        }
      };
      linkStyle = {
        base: {
          transition: ""font-size 0.5s"",
          "":hover"": {
            color: ""white"",
            fontSize: ""25px"",
            fontWeight: ""bold""
          }
        }
      };
    } else {
      navStyle = {
        base: {
          background: ""rgba(20, 20, 20, 0.99)"",
          boxShadow: ""0 8px 6px -6px""
        }
      };
      linkStyle = {
        base: {
          transition: ""font-size 0.5s"",
          "":hover"": {
            color: ""white"",
            fontSize: ""25px"",
            fontWeight: ""bold""
          }
        }
      };
    }
    return (
      &lt;nav style={[navStyle.base]}&gt;
        &lt;ul className=""navbarWrapper""&gt;
          &lt;li&gt;
            &lt;a href=""#!"" style={[linkStyle.base]} key=""1""&gt;
              Home
            &lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=""#!"" style={[linkStyle.base]} key=""2""&gt;
              Beat Store
            &lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=""#!"" style={[linkStyle.base]} key=""3""&gt;
              Licensing
            &lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=""#!"" style={[linkStyle.base]} key=""4""&gt;
              Drum Kits
            &lt;/a&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;a href=""#!"" style={[linkStyle.base]} key=""5""&gt;
              Contact Us
            &lt;/a&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/nav&gt;
    );
  }
}

export default Radium(NavBar);
</code></pre>

<p>Form.js </p>

<pre><code>import React from ""react"";
import { Form, Button, Grid, Segment, Input } from ""semantic-ui-react"";

const FreeBeatForm = () =&gt; {
  return (
    &lt;Grid
      container
      style={{
        marginTop: ""50px"",
        display: ""flex"",
        justifyContent: ""center"",

      }}
    &gt;
      &lt;Grid.Column width={5} style={{zIndex: '-1'}}&gt;
        &lt;Segment&gt;
          &lt;h1&gt;Subscribe&lt;/h1&gt;
          &lt;Form&gt;
            &lt;Form.Field&gt;
              &lt;label&gt;Name&lt;/label&gt;
              &lt;Input placeholder=""Name"" /&gt;
            &lt;/Form.Field&gt;
            &lt;Form.Field&gt;
              &lt;label&gt;Email&lt;/label&gt;
              &lt;Input placeholder=""Email"" /&gt;
            &lt;/Form.Field&gt;
            &lt;Button type=""submit""&gt;Submit&lt;/Button&gt;
          &lt;/Form&gt;
        &lt;/Segment&gt;
      &lt;/Grid.Column&gt;
    &lt;/Grid&gt;
  );
};

export default FreeBeatForm;
</code></pre>
","9613899","","","","","2018-06-19 02:17:06","Issues With ZIndex using reactjs and a fixed navbar","<css><reactjs>","2","0","","",""
"50489452","1","50495014","","2018-05-23 13:16:18","","0","46","<p>I'm trying to make a simple authentication system in my Single Page Application.
I want to disable all routes execpt <code>/login</code> for guest.
The way to know if the user is authenticated or a guest it's to know if there are an <code>access_token</code> in the <code>localStorage</code>.</p>

<p>When I'm starting the app the <code>Main</code> component is started. The component define the routes and know if the user is authenticated by check the <code>localStorage</code>.</p>

<p>The default route (<code>/</code>) is for render the <code>Home</code> component but, like this <a href=""https://reacttraining.com/react-router/web/example/auth-workflow"" rel=""nofollow noreferrer"" title=""example"">example</a> of <strong>react router</strong> the <code>Home</code> component is protected by a <code>PrivateRoute</code> object.</p>

<p>The <code>PrivateRoute</code> object check if the user is authenticated. If yes, <code>Home</code> component is rendered, else the user is redirected to the <code>login</code>component at <code>/login</code>.</p>

<p>The <code>Login</code> component redirect the user to <code>/</code> in case of success and execute a callback to give the <code>access_token</code>.</p>

<p>The <code>Main</code> component define the callback, It's about to save the <code>access_token</code> in the <code>localStorage</code> and change the <code>state</code> for declare the user as authenticated. And now, the user can access the <code>Home</code> component.</p>

<p>My problem is, the <code>PrivateRoute</code> system always the check the user as a guest so it's always a redirection to <code>/login</code>. But when the are an <code>access_token</code> in <code>localStorage</code> the <code>Login</code> component redirect to the <code>Home</code> protected by the <code>PrivateRoute</code> and this is an infite loop despite the <code>handleLogin</code> callback.</p>

<p>Can you find a solution ?</p>

<hr>

<p><strong>Main.jsx</strong></p>

<pre class=""lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';
import {BrowserRouter, Link, Redirect, Route} from ""react-router-dom"";
import {Login} from ""./Login""
import {Home} from ""./Home"";


class Main extends Component {
    constructor(props) {
        super(props);

        this.handleLogout = this.handleLogout.bind(this);
        this.handleLogin = this.handleLogin.bind(this);
        this.state = {authed: localStorage.getItem('access_token') !== null};
    }

    componentDidCatch(error, info) {
    }

    handleLogout(event) {
        event.preventDefault();
        localStorage.removeItem('access_token');
        this.setState({authed: false});
    }

    handleLogin(token) {
        localStorage.setItem('access_token', token);
        this.setState({authed: token !== null});
    }

    render() {
        const PrivateRoute = ({component: Component, ...rest}) =&gt; (
            &lt;Route {...rest} render={props =&gt;
                this.state.authed()
                    ? (&lt;Component {...props} /&gt;)
                    : (&lt;Redirect to=""/login""/&gt;)
            }
            /&gt;
        );

        const LoginLogout = () =&gt; {
            return this.state.authed
                ? (&lt;button onClick={this.handleLogout}&gt;Logout&lt;/button&gt;)
                : (&lt;Link to=""/login""&gt;Login&lt;/Link&gt;);
        };

        return (
            &lt;BrowserRouter&gt;
                &lt;div&gt;
                    &lt;ul&gt;
                        &lt;li&gt;
                            &lt;Link to=""/""&gt;Home&lt;/Link&gt;
                        &lt;/li&gt;
                        &lt;li&gt;
                            &lt;LoginLogout/&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;

                    &lt;Route path=""/login"" component={() =&gt; &lt;Login handleLogin={this.handleLogin}/&gt;}/&gt;
                    &lt;PrivateRoute exact path=""/"" component={Home}/&gt;

                &lt;/div&gt;
            &lt;/BrowserRouter&gt;
        );
    }
}

if (document.getElementById('main')) {
    ReactDOM.render(&lt;Main/&gt;, document.getElementById('main'));
}
</code></pre>

<p><strong>Login.jsx</strong></p>

<pre class=""lang-js prettyprint-override""><code>import React, {Component} from 'react';
import {Redirect} from ""react-router-dom"";

export class Login extends Component {

    constructor(props) {
        super(props);

        this.state = {
            email: '',
            password: '',
            redirect: localStorage.getItem('access_token') !== null,
            token: null,
            loading: false,
            error: null
        };
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
    }

    componentWillUnmount() {
        this.props.handleLogin(this.state.token);
    }

    handleInputChange(event) {
        const target = event.target;
        const value = target.type === 'checkbox' ? target.checked : target.value;
        const name = target.name;

        this.setState({
            [name]: value
        });
    }

    handleSubmit(event) {
        event.preventDefault();
        this.setState({
            error: null,
            loading: true
        });
        axios.post('/api/login', {
            'client_id': '3',
            'email': this.state.email,
            'password': this.state.password,
            'confirm_password': this.state.password
        }).then((response) =&gt; {
            let token = response.data.access_token;
            this.setState({
                redirect: true,
                token: token,
                loading: false
            });
        }, (error) =&gt; {
            console.error('error', error.response.data);
            this.setState({
                error: error.response.data,
                loading: false
            });
        });
    }

    render() {

        if (this.state.redirect)
            return (&lt;Redirect to={""/""}/&gt;);

        return (
            &lt;form onSubmit={this.handleSubmit}&gt;
                &lt;label htmlFor=""email""&gt;Email :&lt;/label&gt;
                &lt;input type=""text"" name=""email"" id=""email"" value={this.state.email} onChange={this.handleInputChange}
                       disabled={this.state.loading}/&gt;
                &lt;label htmlFor=""password""&gt;Password :&lt;/label&gt;
                &lt;input type=""password"" name=""password"" id=""password"" value={this.state.password}
                       onChange={this.handleInputChange} disabled={this.state.loading}/&gt;
                &lt;button type=""submit""
                        disabled={this.state.loading}&gt;{this.state.loading ? ""..."" : ""Se connecter""}&lt;/button&gt;
                {this.state.error &amp;&amp; (
                    &lt;div&gt;
                        &lt;p&gt;Erreur : {JSON.stringify(this.state.error)}&lt;/p&gt;
                    &lt;/div&gt;
                )}
            &lt;/form&gt;
        );
    }
}
</code></pre>
","3203320","","","","","2018-05-23 18:20:50","react - react router - privateRoute - infinite loop","<javascript><reactjs><react-router><infinite-loop>","1","4","","",""
"50578100","1","","","2018-05-29 06:55:56","","0","106","<p>I am trying to do a little example from material-kit, in own project, but I Can not make it work. The problem that I Have is in the render when I did </p>

<blockquote>
  <p>const { classes, ...rest } = this.props;</p>
</blockquote>

<p>Never works causes classes are undefined. Debugging I find that I haven't got my Object Header, then the function __objectWithStyles, never works because in this.props are not be the object Header.</p>

<p>Can someone help me? </p>

<p>My LoginPage.jsx</p>

<pre><code> import React from ""react"";
// material-ui components
import withStyles from ""@material-ui/core/styles"";
// core components
import Header from ""components/Header/Header.jsx"";
import HeaderLinks from ""components/Header/HeaderLinks.jsx"";    
import loginPageStyle from ""assets/jss/material-kit-react/views/loginPage.jsx"";

 class LoginPage extends React.Component {


 constructor(props) {
    super(props);
    // we use this to make the card to appear after the page has been rendered
    this.state = {
      cardAnimaton: ""cardHidden""
    };
  }
  componentDidMount() {
    // we add a hidden class to the card and after 700 ms we delete it and the transition appears
    setTimeout(
      function() {
        this.setState({ cardAnimaton: """" });
      }.bind(this),
      700
    );
  }
  render() {
    const { classes, ...rest } = this.props;
    return (
      &lt;div&gt;
        &lt;Header
          absolute
          color=""transparent""
          brand=""Material Kit React""
          rightLinks={&lt;HeaderLinks /&gt;}
          {...rest}
        /&gt;
        &lt;div
          className={classes.pageHeader}
          style={{
            backgroundImage: ""url("" + image + "")"",
            backgroundSize: ""cover"",
            backgroundPosition: ""top center""
          }}
        &gt;
    );
    }
</code></pre>

<p>export withStyles(loginPageStyle)(LoginPage);
        }</p>

<p>The HeaderPage.jsx</p>

<pre><code>import React from ""react"";
// nodejs library that concatenates classes
import classNames from ""classnames"";
// nodejs library to set properties for components
import PropTypes from ""prop-types"";
// material-ui components
import withStyles from ""material-ui/styles/withStyles"";
import AppBar from ""material-ui/AppBar"";
import Toolbar from ""material-ui/Toolbar"";
import IconButton from ""material-ui/IconButton"";
import Button from ""material-ui/Button"";
import Hidden from ""material-ui/Hidden"";
import Drawer from ""material-ui/Drawer"";
// @material-ui/icons
import Menu from ""@material-ui/icons/Menu"";
// core components
import headerStyle from ""assets/jss/material-kit-react/components/headerStyle.jsx"";

class Header extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      mobileOpen: false
    };
    this.handleDrawerToggle = this.handleDrawerToggle.bind(this);
    this.headerColorChange = this.headerColorChange.bind(this);
  }
  handleDrawerToggle() {
    this.setState({ mobileOpen: !this.state.mobileOpen });
  }
  componentDidMount() {
    if (this.props.changeColorOnScroll) {
      window.addEventListener(""scroll"", this.headerColorChange);
    }
  }
  headerColorChange() {
    const { classes, color, changeColorOnScroll } = this.props;
    const windowsScrollTop = window.pageYOffset;
    if (windowsScrollTop &gt; changeColorOnScroll.height) {
      document.body
        .getElementsByTagName(""header"")[0]
        .classList.remove(classes[color]);
      document.body
        .getElementsByTagName(""header"")[0]
        .classList.add(classes[changeColorOnScroll.color]);
    } else {
      document.body
        .getElementsByTagName(""header"")[0]
        .classList.add(classes[color]);
      document.body
        .getElementsByTagName(""header"")[0]
        .classList.remove(classes[changeColorOnScroll.color]);
    }
  }
  componentWillUnmount() {
    if (this.props.changeColorOnScroll) {
      window.removeEventListener(""scroll"", this.headerColorChange);
    }
  }
  render() {
    const {
      classes,
      color,
      rightLinks,
      leftLinks,
      brand,
      fixed,
      absolute
    } = this.props;
    const appBarClasses = classNames({
      [classes.appBar]: true,
      [classes[color]]: color,
      [classes.absolute]: absolute,
      [classes.fixed]: fixed
    });
    const brandComponent = (
      &lt;Button href=""#"" className={classes.title}&gt;
        {brand}
      &lt;/Button&gt;
    );
    return (
      &lt;AppBar className={appBarClasses}&gt;
        &lt;Toolbar className={classes.container}&gt;
          {leftLinks !== undefined ? brandComponent : null}
          &lt;div className={classes.flex}&gt;
            {leftLinks !== undefined ? (
              &lt;Hidden smDown implementation=""css""&gt;
                {leftLinks}
              &lt;/Hidden&gt;
            ) : (
              brandComponent
            )}
          &lt;/div&gt;
          &lt;Hidden smDown implementation=""css""&gt;
            {rightLinks}
          &lt;/Hidden&gt;
          &lt;Hidden mdUp&gt;
            &lt;IconButton
              color=""inherit""
              aria-label=""open drawer""
              onClick={this.handleDrawerToggle}
            &gt;
              &lt;Menu /&gt;
            &lt;/IconButton&gt;
          &lt;/Hidden&gt;
        &lt;/Toolbar&gt;
        &lt;Hidden mdUp implementation=""css""&gt;
          &lt;Drawer
            variant=""temporary""
            anchor={""right""}
            open={this.state.mobileOpen}
            classes={{
              paper: classes.drawerPaper
            }}
            onClose={this.handleDrawerToggle}
          &gt;
            &lt;div className={classes.appResponsive}&gt;
              {leftLinks}
              {rightLinks}
            &lt;/div&gt;
          &lt;/Drawer&gt;
        &lt;/Hidden&gt;
      &lt;/AppBar&gt;
    );
  }
}

Header.defaultProp = {
  color: ""white""
};

Header.propTypes = {
  classes: PropTypes.object.isRequired,
  color: PropTypes.oneOf([
    ""primary"",
    ""info"",
    ""success"",
    ""warning"",
    ""danger"",
    ""transparent"",
    ""white"",
    ""rose"",
    ""dark""
  ]),
  rightLinks: PropTypes.node,
  leftLinks: PropTypes.node,
  brand: PropTypes.string,
  fixed: PropTypes.bool,
  absolute: PropTypes.bool,
  // this will cause the sidebar to change the color from
  // this.props.color (see above) to changeColorOnScroll.color
  // when the window.pageYOffset is heigher or equal to
  // changeColorOnScroll.height and then when it is smaller than
  // changeColorOnScroll.height change it back to
  // this.props.color (see above)
  changeColorOnScroll: PropTypes.shape({
    height: PropTypes.number.isRequired,
    color: PropTypes.oneOf([
      ""primary"",
      ""info"",
      ""success"",
      ""warning"",
      ""danger"",
      ""transparent"",
      ""white"",
      ""rose"",
      ""dark""
    ]).isRequired
  })
};

export default withStyles(headerStyle)(Header);
</code></pre>

<p>There a link from the src repository: <a href=""https://github.com/creativetimofficial/material-kit-react/"" rel=""nofollow noreferrer"">https://github.com/creativetimofficial/material-kit-react/</a></p>

<p><strong>Updated</strong></p>

<p>It seems that my class LoginPagte can not find the components that I import. For example.</p>

<blockquote>
  <p>import Header from ""components/Header/Header.jsx"";</p>
</blockquote>

<p>My class can not find <strong>Header object</strong></p>
","4718057","","4718057","","2018-05-30 07:22:46","2018-05-30 07:22:46","TypeError: classes are undefined ReactComponent. Material-kit-react","<reactjs><react-redux><material-ui>","2","0","","",""
"50760870","1","","","2018-06-08 12:40:10","","0","30","<p>I have a major performance issue with rendering markers based on active filters on the map.</p>

<p>I have a data structure, which is something like</p>

<pre><code>const businesses = [
  {
    ...location,
    businessType: 'Market'
  },
  ...etc
]
</code></pre>

<p>There's 150 items in that dataset right now. All of the markers are rendered by default. Currently I'm generating the data for markers randomly.</p>

<p>Now, I as well have categories which can be toggled, if category is toggled => render that business type.</p>

<p>Now, whenever I toggle categories my JS thread jumps to 0 fps and the UI thread get's blocked.</p>

<p>Here's my current code:</p>

<pre><code>import React, { PureComponent } from 'react';
import { InteractionManager } from 'react-native';
import generateRandomMapData from 'utils/generateRandomMapData';
import CustomMarker from './CustomMarker';

const CENTER_OF_BERLIN = {
  latitude: 52.5200,
  longitude: 13.4050,
};

const RADIUS = 5000;
const AMOUNT_OF_MARKERS = 150;

class Markers extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      markers: null
    }
  }
  componentDidMount() {
    this.interactionHandle = InteractionManager.runAfterInteractions(() =&gt; {
      this.setState({ markers: generateRandomMapData(CENTER_OF_BERLIN, RADIUS, AMOUNT_OF_MARKERS) }, () =&gt; {
        this.interactionHandle = null;
      })
    })
  }
  componentWillUnmount() {
    if (this.interactionHandle) this.interactionHandle.cancel();
  }
  renderMarkers() {
    const { markers } = this.state;

    if (markers &amp;&amp; markers.length) {
      return markers.map((b, i) =&gt; &lt;CustomMarker location={b.location} key={i} businessType={b.businessType} /&gt;)
    }

    return null;
  }
  render() {
    return this.renderMarkers()
  }
}

export default Markers;
</code></pre>

<p>And the file for individual Markers</p>

<pre><code>import React, { PureComponent } from 'react';
import { View, InteractionManager } from 'react-native'
import { Marker } from 'react-native-maps';
import { connect } from 'react-redux';
import SVG from 'components/svg/SVG'

const BUSINESS_COLORS = {
  market: '#EC6D52',
  farm: '#763DAB',
  restaurant: '#C45D72',
  UrbanFarm: '#4B85DD',
  store: '#65A077',
}

class CustomMarker extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      shouldRender: false
    }
  }
  componentWillMount() {
    const { businessType, categories } = this.props;

    this.interactionHandle = InteractionManager.runAfterInteractions(() =&gt; {
      if (this._getActiveCategories(categories).includes(businessType) !== this.state.shouldRender) {
        this.setState({ shouldRender: this._getActiveCategories(categories).includes(businessType) }, () =&gt; {
          this.interactionHandle = null;
        });
      }
    });
  }
  componentDidUpdate() {
    if (this.interactionHandle) this.interactionHandle.cancel();

    const { businessType, categories } = this.props;
    const { shouldRender } = this.state;

    this.interactionHandle = InteractionManager.runAfterInteractions(() =&gt; {
      if (this._getActiveCategories(categories).includes(businessType) !== shouldRender) {
        this.setState({ shouldRender: this._getActiveCategories(categories).includes(businessType) }, () =&gt; {
          this.interactionHandle = null;
        })
      }
    });
  }
  componentWillUnmount() {
    if (this.interactionHandle) this.interactionHandle.cancel();
  }
  _getActiveCategories(categories) {
    const active = [];

    for (let category of categories) {
      if (category.active) {
        active.push(category.icon)
      }
    }

    return active;
  }
  render() {
    const { businessType, location } = this.props;
    const { shouldRender } = this.state;
    const iconColor = BUSINESS_COLORS[businessType.toLowerCase()];

    const opacity = shouldRender ? 1.0 : 0.0;

    return (
      &lt;Marker coordinate={{ ...location }} opacity={opacity}&gt;
        &lt;View style={{ width: 29, height: 36 }}&gt;
          &lt;SVG icon=""Marker"" width=""29"" height=""36"" fill={iconColor} /&gt;
        &lt;/View&gt;
      &lt;/Marker&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  categories: state.categories
});

export default connect(mapStateToProps, {
})(CustomMarker);
</code></pre>

<p>The categories themselves live in Redux and the Markers are mapped based on that.</p>

<p>It seems that calling <code>setState</code> on like 25 affected markers at the same time is incredibly heavy, even if used <code>InteractionManager</code>.</p>

<p>Any ideas how to optimize this performance?</p>
","3840147","","","","","2018-06-08 12:40:10","Dynamic render of multiple custom markers with react-native-maps","<javascript><reactjs><react-native><react-native-maps>","0","2","","",""
"50823363","1","50823479","","2018-06-12 18:14:10","","0","44","<p>i am building a ui for tracking a driver, i update the track as well as direction...
And for the custom marker, I have used transform and the rotation of the driver's heading value, the marker animates very nicely with respective to the heading, but the problem comes when i rotate the map, after rotating the map the marker doesn't rotate along the map,
Is there any possible way i could rotate the map and maintain the rotation of the marker?</p>

<pre><code>import React from 'react';
import { View, StyleSheet, Platform, Image } from 'react-native';
import MapView, { AnimatedRegion } from 'react-native-maps';
import { connect } from 'react-redux';
import { Card, Heading, Text, Button } from '@shoutem/ui';
import { Icon } from 'react-native-elements';
import { DARK } from '../../config';
import * as actions from '../../actions';
import { Loading } from '../../components/common';

const DEFAULT_PADDING = { top: 40, right: 40, bottom: 40, left: 40 };
const IUST = {
    latitude: 33.9260206, longitude: 75.0173499
};
let IntervalFlag = 0;
//Because without this componentWillUpdate will call setInterval as many times componentUpdates

class TrackDriver extends React.Component {
  state = {
    loading: true,
    error: false,
    coordinate: new AnimatedRegion({
      latitude: IUST.latitude,
      longitude: IUST.longitude,
    }),
  }
  onDone = (loadingFlag, error) =&gt; {
    this.setState({ loading: loadingFlag });
    this.setState({ error });
  }
  onLayout = () =&gt; {
    const { origin, des } = this.props.liveLocation;
    console.log(origin);
    console.log(des);
    setTimeout(
        () =&gt; {
            try {
                this.map.fitToCoordinates([{ latitude: Number(origin.lat), longitude: Number(origin.lng) }, { latitude: Number(des.lat), longitude: Number(des.lng) }], {
                    edgePadding: DEFAULT_PADDING,
                    animated: true,
                });
            } catch (e) {
                console.error(e);
            } 
        }, 1000
    );   
}
  componentWillUnmount() {
    clearInterval(this.interval);
  }
  componentDidMount() {
    IntervalFlag = 0;
    this.setState({ loading: true });
    const { navigation } = this.props;
    const pool = navigation.getParam('pool');
    this.props.getJourneyState(pool, this.onDone);
  }  
  componentWillReceiveProps(nextProps) {
    const duration = 1000;

    if (this.props.liveLocation.origin !== nextProps.liveLocation.origin) {
      const newCoordinate = {
        latitude: Number(nextProps.liveLocation.origin.lat),
        longitude: Number(nextProps.liveLocation.origin.lng)
      };


      if (Platform.OS === 'android') {
        if (this.marker) {
          this.marker._component.animateMarkerToCoordinate(
            newCoordinate,
            duration
          );
        }
      } else if (this.props.liveLocation.origin != null) {
        const oldCoordinate = {
          latitude: Number(this.props.liveLocation.origin.lat),
          longitude: Number(this.props.liveLocation.origin.lng)
        };
        oldCoordinate.timing(newCoordinate).start();
        }
    }
  }
  componentWillUpdate() {
    const { navigation, liveLocation } = this.props;
    const pool = navigation.getParam('pool');
    if (this.state.loading === false &amp;&amp; IntervalFlag === 0) {
      IntervalFlag = 1;
      this.interval = setInterval(() =&gt; this.props.trackDirections(pool, liveLocation.des), 3000);
     }
  }

  renderContent() {
    if (this.state.loading) {
      return (
        &lt;Loading /&gt;
      );
    } else if (this.state.error) {
      return (
        &lt;Card&gt;
            &lt;Heading&gt; No directions available &lt;/Heading&gt;
            &lt;Button&gt; 
              &lt;Text&gt; Retry &lt;/Text&gt;
              &lt;Icon name='refresh' /&gt;
            &lt;/Button&gt;
        &lt;/Card&gt;
      );
    } 
    if (this.props.liveLocation.origin !== null) {
      const { origin, des, coords } = this.props.liveLocation;
      return (
        &lt;MapView
              provider='google'
              style={{ height: '100%', width: '100%' }}
              ref={ref =&gt; { this.map = ref; }}
              initialRegion={{
                latitude: Number(origin.lat),
                longitude: Number(origin.lng),
                longitudeDelta: 0.2,
                latitudeDelta: 0.2
              }}
              onLayout={this.onLayout}
        &gt;
          {origin != null &amp;&amp; &lt;MapView.Marker.Animated 
            coordinate={{ latitude: Number(origin.lat), longitude: Number(origin.lng) }}
            ref={marker =&gt; { this.marker = marker }}
            style={{ transform: [{
              rotate: origin.heading === undefined ? '0deg' : `${origin.heading}deg`
            }]
          }}
            &gt;
            &lt;Image
              style={{ 
                height: 50,
                width: 50,
                transform: [{
                rotate: '270deg'
                }]
              }}
              source={require('../../assets/car.png')}
            /&gt;
          &lt;/MapView.Marker.Animated&gt;}

           {des != null &amp;&amp; &lt;MapView.Marker 
            coordinate={{ latitude: Number(des.lat), longitude: Number(des.lng) }}
           &gt;
             &lt;Icon name='place' /&gt;
             &lt;/MapView.Marker&gt;}

          {coords.length &gt; 1 &amp;&amp; 
                &lt;MapView.Polyline
                            coordinates={coords}
                            strokeWidth={2}
                            strokeColor=""black""
                /&gt;
                }
        &lt;/MapView&gt;
      );
    }  
  }
  render() {
    return (
      &lt;View style={{ flex: 1 }}&gt;
      {this.renderContent()}
      &lt;/View&gt;
    );
  }
}

const mapStateToProps = state =&gt; {
  return {
    liveLocation: state.activepool.liveLocation
  };
};
export default connect(mapStateToProps, actions)(TrackDriver);
</code></pre>
","6943916","","","","","2018-06-12 18:21:20","React-Native: Get rotation angle of react-native-maps","<javascript><react-native><react-native-maps>","1","0","","",""
"49821608","1","","","2018-04-13 16:37:37","","0","58","<p>I am trying to make an API request (GET) then the received data should be appended on the graph as a statistatics , this is my code when i run it i got nothing on the graph .
I am trying to make an API request (GET) then the received data should be appended on the graph as a statistatics , this is my code when i run it i got nothing on the graph.
I am trying to make an API request (GET) then the received data should be appended on the graph as a statistatics , this is my code when i run it i got nothing on the graph.
I am trying to make an API request (GET) then the received data should be appended on the graph as a statistatics , this is my code when i run it i got nothing on the graph</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import React, {Component} from 'react';
import AmCharts from ""@amcharts/amcharts3-react"";
import {Bar, Doughnut, Line, Pie, Polar, Radar} from 'react-chartjs-2';
import {CardColumns, Card, CardHeader, CardBody,Row, Col, Button, Modal, ModalHeader, ModalBody, ModalFooter} from 'reactstrap';
import axios from 'axios';
import Modals from '../Notifications/Modals/Modals.js';
import RangedDatePicker from '../DatePicker/RangedDatePicker.js';
import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';
import ButtonDropdowns from '../Buttons/ButtonDropdowns/ButtonDropdowns.js';



let loginPath = 'http://127.0.0.1:8000/api/reactions/daily';

let config = { 
  headers: {   
    'Access-Control-Allow-Origin': '*',
    'Authorization': 'Bearer '+localStorage.getItem('token') 
  },
  mode: 'no-cors'
};



function generateData() {
   var successDataCount=[];
    axios.get('http://127.0.0.1:8000/api/reactions/daily?from=2017-01-01 &amp;to=2018-06-04 ', config)
        .then((response )=&gt; {
             
              for(let i=0 ; i&lt;response.data[0].reactions.length;i++)
              { 
                var year =response.data[0].reactions[i].year;
                var month =response.data[0].reactions[i].month;
                var day =response.data[0].reactions[i].day;
                var dateOfReaction = new Date(year,month,day);
                var count = response.data[0].reactions[i].count;

                successDataCount.push({date:dateOfReaction ,count:count });
              }
              

               
                var firstDate = new Date();

                var dataProvider = [];

                for (var i = 0; i &lt; 100; ++i) {
                  var date = new Date(firstDate.getTime());

                  date.setDate(i);

                  dataProvider.push({
                    date: date,
                    value: Math.floor(Math.random() * 100)
                  });
                }
                console.log(dataProvider)

                return dataProvider;
             
  })

  .catch((error) =&gt; console.log(error))

  


  
}




class Charts extends Component {

 constructor(props) {

    super(props);

    const minDate = new Date();
    const maxDate = new Date();
    minDate.setFullYear(minDate.getFullYear() - 1);
    minDate.setHours(0, 0, 0, 0);
    maxDate.setFullYear(maxDate.getFullYear() + 1);
    maxDate.setHours(0, 0, 0, 0);

    this.state = {
    dataProvider: [],
    timer: null,
    minDate: minDate,
    maxDate: maxDate,
    autoOk: false,
  };



    this.handleChangeMinDate = this.handleChangeMinDate.bind(this);
    this.handleChangeMaxDate= this.handleChangeMaxDate.bind(this)
    this.getTimeRangeFromCalendar = this.getTimeRangeFromCalendar.bind(this);
}


componentDidMount() {


 
      // Update the chart dataProvider every 3 seconds
     
        this.setState({
          dataProvider: generateData()
        });
  



}

componentWillUnmount() {
  clearInterval(this.state.timer);
}

//Getting StartDate and EndDate from calendar to update charts
getTimeRangeFromCalendar(range){

  let from = JSON.stringify(range.startDate._d);
  let to = JSON.stringify(range.endDate._d);

  
  console.log('*************************CHOISEN STATISTICS*************************')
  let config = { 
    headers: {   
      'Access-Control-Allow-Origin': '*',
      'Authorization': 'Bearer '+localStorage.getItem('token') 
    },
    mode: 'no-cors',
    params :{
      from: from,
      to: to
    }

  };

  console.log(config.params)  
  console.log(config.params.to) 
  
  axios.get('http://127.0.0.1:8000/api/reactions/daily', { 
    headers: {   
      'Access-Control-Allow-Origin': '*',
      'Authorization': 'Bearer '+localStorage.getItem('token') 
    },
    mode: 'no-cors',
    params :{
      from: from,
      to: to
    }

  } )
  .then((response )=&gt; console.log(response.data))
  .catch((error) =&gt; console.log(error))


}



  handleChangeMinDate(event, date) {
    this.setState({
      minDate: date,
    } , function(){console.log(this.state.minDate)});
  };

  handleChangeMaxDate(event, date) {
    this.setState({
      maxDate: date,
    });
  };

render() {
 const config = {
  ""type"": ""serial"",
  ""theme"": ""light"",
  ""marginRight"": 40,
  ""marginLeft"": 40,
  ""autoMarginOffset"": 20,
  ""mouseWheelZoomEnabled"": true,
  ""valueAxes"": [{
    ""id"": ""v1"",
    ""axisAlpha"": 0,
    ""position"": ""left"",
    ""ignoreAxisWidth"": true
  }],
  ""balloon"": {
    ""borderThickness"": 1,
    ""shadowAlpha"": 0
  },
  ""graphs"": [{
    ""id"": ""g1"",
    ""balloon"":{
      ""drop"": true,
      ""adjustBorderColor"": false,
      ""color"":""#ffffff""
    },
    ""bullet"": ""round"",
    ""bulletBorderAlpha"": 1,
    ""bulletColor"": ""#FFFFFF"",
    ""bulletSize"": 5,
    ""hideBulletsCount"": 50,
    ""lineThickness"": 2,
    ""title"": ""red line"",
    ""useLineColorForBulletBorder"": true,
    ""valueField"": ""value"",
    ""balloonText"": ""&lt;span style='font-size:18px;'&gt;[[value]]&lt;/span&gt;""
  }],
  ""chartScrollbar"": {
    ""graph"": ""g1"",
    ""oppositeAxis"": false,
    ""offset"":30,
    ""scrollbarHeight"": 80,
    ""backgroundAlpha"": 0,
    ""selectedBackgroundAlpha"": 0.1,
    ""selectedBackgroundColor"": ""#888888"",
    ""graphFillAlpha"": 0,
    ""graphLineAlpha"": 0.5,
    ""selectedGraphFillAlpha"": 0,
    ""selectedGraphLineAlpha"": 1,
    ""autoGridCount"": true,
    ""color"":""#AAAAAA""
  },
  ""chartCursor"": {
    ""pan"": true,
    ""valueLineEnabled"": true,
    ""valueLineBalloonEnabled"": true,
    ""cursorAlpha"":1,
    ""cursorColor"":""#258cbb"",
    ""limitToGraph"":""g1"",
    ""valueLineAlpha"":0.2,
    ""valueZoomable"": true
  },
  ""valueScrollbar"":{
    ""oppositeAxis"": false,
    ""offset"":50,
    ""scrollbarHeight"":10
  },
  ""categoryField"": ""date"",
  ""categoryAxis"": {
    ""parseDates"": true,
    ""dashLength"": 1,
    ""minorGridEnabled"": true
  },
  ""dataProvider"": this.state.dataProvider
};
return (

  &lt;div className=""animated fadeIn""&gt;
  &lt;CardColumns className=""cols-2 column-count-1""&gt;
  &lt;Row&gt;
  &lt;Col&gt;
  &lt;Card&gt;
  &lt;CardHeader&gt;
  &lt;i className=""fa fa-align-justify""&gt;&lt;/i&gt; Choosing parameters
  &lt;/CardHeader&gt;
  &lt;CardBody&gt;


  &lt;MuiThemeProvider&gt;
  &lt;RangedDatePicker  sendMinDate={this.handleChangeMinDate} sendMaxDate= {this.handleChangeMaxDate}/&gt;
  &lt;/MuiThemeProvider&gt;
  &lt;ButtonDropdowns/&gt;



  &lt;/CardBody&gt;
  &lt;/Card&gt;
  &lt;/Col&gt;
  &lt;/Row&gt;



  &lt;Card&gt;
  &lt;CardHeader&gt;
  Statistics
  &lt;div className=""card-actions""&gt;
  &lt;a href=""http://www.chartjs.org""&gt;
  &lt;small className=""text-muted""&gt;docs&lt;/small&gt;
  &lt;/a&gt;
  &lt;/div&gt;
  &lt;/CardHeader&gt;
  &lt;CardBody&gt;

  &lt;div className=""App""&gt;

  &lt;AmCharts.React style={{ width: ""100%"", height: ""500px"" }} options={config} /&gt;
  &lt;/div&gt;
  &lt;/CardBody&gt;
  &lt;/Card&gt;


  &lt;/CardColumns&gt;
  &lt;/div&gt;

  )
}
}

export default Charts;</code></pre>
</div>
</div>
</p>

<p>and this is the error when i clicked on the graph ........................</p>

<p><a href=""https://i.stack.imgur.com/vDCEa.png"" rel=""nofollow noreferrer"">enter image description here</a></p>
","6155430","","6155430","","2018-04-13 16:58:46","2018-04-13 17:28:36","Using amcharts3 with reactjs cannot display graph","<reactjs><amcharts>","0","3","","",""
"50901587","1","","","2018-06-18 00:57:52","","0","15","<p>I am trying to use chosen.js in my react application.
However, although I have read the documentation about refs and stuffs here( <a href=""https://reactjs.org/docs/integrating-with-other-libraries.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/integrating-with-other-libraries.html</a> ), I don't really get anything it's saying. What is ref and what does it do exactly? I have my react code and it does not work. Please if anyone could explain what this ref and this.$el do in react, I'd appreciate it.   </p>

<pre><code>import React, { Component } from 'react';
import $ from 'jquery';
import { findDOMNode } from 'react-dom';

class Chosen extends Component {

    componentDidMount(){
        this.el = $(this.el);
        this.$el.chosen();
    }

    componentWillUnmount(){
        this.$el.chosen('destroy');
    }
    render() {
        return (
            &lt;div&gt;
                &lt;select className=""Chosen-select"" ref={ el =&gt; this.el = el }&gt;
                    { this.props.children }
                &lt;/select&gt;
            &lt;/div&gt;
        )
    }
}

export default Chosen;
</code></pre>

<p>and also, </p>

<pre><code>import React from 'react';
import Chosen from './Chosen';

function Restaurants(props) {

    return (
        &lt;Chosen className=""Chosen-select"" onChange={ value =&gt; console.log(value) }&gt;
            {   
                [{name: 'h'}, {name: 'j'}, {name: 'k'}].forEach( r =&gt; {
                    &lt;option&gt;{ r.name }&lt;/option&gt;
                })
            }
        &lt;/Chosen&gt;
    );
}

export default Restaurants;
</code></pre>
","9032824","","","","","2018-06-18 00:57:52","using chosen.js on my react application","<javascript><jquery><node.js><reactjs><jquery-chosen>","0","0","","",""
"50979916","1","","","2018-06-22 02:40:24","","0","51","<p>I am using react navigation and redux together.</p>

<p>The problem is, after building the android version, I press the back button of the android actual device (Samsung Galaxy 8, etc ..) and the app will exit without going backward.</p>

<p>However, in the android emulator, when I click the back button, it grabs the event and works backwards.</p>

<p>this is my index.js code</p>

<pre><code>import React, { Component } from ""react"";
import {
    BackHandler,
    AsyncStorage,
} from ""react-native"";
import { bindActionCreators } from 'redux';
import { connect } from ""react-redux"";
import {
    addNavigationHelpers,
    NavigationActions,
} from ""react-navigation"";

import NavigationStack from ""./navigationStack"";
import { login } from '../actions/actionCreator';
import * as settings from '../config/settings';


class AppNavigation extends Component {

    componentDidMount = async () =&gt; {
        // 안드로이드 백 버튼 인식
        BackHandler.addEventListener(""hardwareBackPress"", this.onBackPress);

        // 로컬스토리지 유저정보 유효성을 체크합니다.
        let user_info = await AsyncStorage.getItem('user_info');

        if (user_info) {
            user_info = JSON.parse(user_info);

            let api_uri = settings.base_uri + ""member/profile/""
            let request = {
                method: 'GET',
                headers: {
                    'Authorization': 'Token ' + user_info.key
                }
            }
            console.log('index is mounted');

            fetch(api_uri, request)
                .then((response) =&gt; {
                    return response.json()
                })
                .then((responseData) =&gt; {

                    if (responseData.email) {
                        console.log('pass user_info');
                        this.props.login();
                    } else {
                        console.log('remove user_info');
                        AsyncStorage.removeItem('user_info')
                    }
                    return responseData;
                })
                .catch(function (err) {
                    console.log(err);
                })
        } else {
            console.log('user is not logined');
        }
    }

    componentWillUnmount() {
        // 안드로이드 백버튼 listener 해제
        BackHandler.removeEventListener('hardwareBackPress', this.onBackPress.bind(this));
    }

    onBackPress = () =&gt; {
        const { dispatch, navigationState } = this.props;
        dispatch(NavigationActions.back());
        console.log('press android back6', navigationState.stateForLoggedIn.index)
        if (navigationState.stateForLoggedIn.index === 0) {
            return false;
        }

        return true
    };

    render() {
        const { navigationState, dispatch } = this.props;
        const state = navigationState.stateForLoggedIn
        return (
            &lt;NavigationStack navigation={addNavigationHelpers({ dispatch, state })}/&gt;
        );
    }
}

const mapStateToProps = state =&gt; {
    return {
        isLoggedIn: state.loginReducer.isLoggedIn,
        navigationState: state.navigationReducer
    };
};

function mapDispatchToProps(dispatch) {
    return Object.assign({ dispatch: dispatch }, bindActionCreators({ login: login }, dispatch ));
}

export default connect(mapStateToProps, mapDispatchToProps)(AppNavigation);
</code></pre>

<p>this is my package.json</p>

<pre><code>{
""name"": ""*****"",
""version"": ""****"",
""private"": true,
""scripts"": {
    ""start"": ""node node_modules/react-native/local-cli/cli.js start"",
    ""test"": ""jest""
},
""dependencies"": {
    ""firebase"": ""^5.0.4"",
    ""moment"": ""^2.20.1"",
    ""prop-types"": ""^15.6.0"",
    ""react"": ""^16.0.0-alpha.12"",
    ""react-addons-update"": ""^15.6.2"",
    ""react-moment"": ""^0.6.9"",
    ""react-native"": ""^0.48.4"",
    ""react-native-camera"": ""^1.1.4"",
    ""react-native-check-box"": ""^2.0.2"",
    ""react-native-communications"": ""^2.2.1"",
    ""react-native-device-info"": ""^0.13.0"",
    ""react-native-elements"": ""^0.18.5"",
    ""react-native-facebook-login"": ""^1.6.0"",
    ""react-native-fcm"": ""^10.0.3"",
    ""react-native-gifted-chat"": ""^0.4.3"",
    ""react-native-image-crop-picker"": ""^0.18.2"",
    ""react-native-image-picker"": ""^0.26.7"",
    ""react-native-image-zoom-viewer"": ""^2.0.20"",
    ""react-native-keyboard-aware-scroll-view"": ""^0.4.3"",
    ""react-native-keyboard-spacer"": ""^0.4.1"",
    ""react-native-maps"": ""^0.17.1"",
    ""react-native-modal"": ""^4.1.1"",
    ""react-native-modal-selector"": ""0.0.24"",
    ""react-native-permissions"": ""^1.0.6"",
    ""react-native-progress"": ""^3.4.0"",
    ""react-native-simple-radio-button"": ""^2.7.2"",
    ""react-native-snap-carousel"": ""^3.5.0"",
    ""react-native-splash-screen"": ""^3.0.6"",
    ""react-native-swiper"": ""^1.5.13"",
    ""react-native-vector-icons"": ""^4.5.0"",
    ""react-navigation"": ""^1.0.0-beta.27"",
    ""react-redux"": ""^5.0.6"",
    ""redux"": ""^3.7.2"",
    ""redux-persist"": ""^5.5.0"",
    ""redux-thunk"": ""^2.2.0""
},
""devDependencies"": {
    ""babel-jest"": ""21.2.0"",
    ""babel-preset-react-native"": ""4.0.0"",
    ""jest"": ""21.2.1"",
    ""react-test-renderer"": ""16.0.0""
},
""jest"": {
    ""preset"": ""react-native""
},
""build:ios"": ""react-native bundle --entry-file='index.ios.js' --bundle-output='./ios/luxlabUser/main.jsbundle' --dev=false --platform='ios' --assets-dest='./ios'""
}
</code></pre>
","7824862","","","","","2018-06-25 08:25:26","react-navigation + redux When I press Android back button. App is killed not backward action","<android><react-native><redux><react-native-android><react-navigation>","1","8","1","",""
"51113462","1","","","2018-06-30 09:06:02","","0","40","<p>I wrote a event listener for body to get the mouse position in react js</p>

<pre><code>getMousePosition = (event) =&gt; {
        if(this.props.navActiveClass === ""active-sm""){
            var mouseX = 0, mouseY = 0;
            this.setState({
                mouseX:event.pageX,
                mouseY:event.pageY,
            })
        }
    }

    componentDidMount(){
        document.body.addEventListener('mousemove', this.getMousePosition);
    }
    componentWillUnmount() {
        document.body.removeEventListener('mousemove', this.getMousePosition);
    }
</code></pre>

<p>after that whenever i move the mouse showing component is re-rendering again and again.</p>
","4650166","","4650166","","2018-06-30 09:12:29","2018-06-30 11:13:47","Components are rendering again and again after i set mouse move event listener for body in react js","<reactjs>","1","2","","",""