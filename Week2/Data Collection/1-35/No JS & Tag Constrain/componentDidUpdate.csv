Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate
"42456975","1","","","2017-02-25 13:58:58","","1","189","<p>I'm trying to make a simple chat using <code>webrtc</code> technology, <code>react.js</code> and <code>meteor.js</code>.
This is client code:</p>

<pre><code> class Rtc extends Component {
   constructor(props) {
     super(props);
   }

   componentDidUpdate(){
     let localVideo, remoteVideo, peerConnection, localStream;
     $('#start').on('click', ()=&gt;{ start(true) });
     let id = Meteor.uuid();
     localVideo = document.getElementById('localVideo');
     remoteVideo = document.getElementById('remoteVideo');

     if (!this.props.loadingRtc) {
       this.props.messagesRtc.forEach((item, i ,arr)=&gt;{
         let signal = JSON.parse(item.text);
         if(i == 0)return;
         gotMessageFromServer(signal);
       });
     }

     if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
         localStream = stream;
         localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
     } else { alert('Your browser does not support getUserMedia API'); }

     function start(isCaller) {
       peerConnection = new RTCPeerConnection( { 'iceServers': [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
       peerConnection.onicecandidate = ( e ) =&gt; {
         console.log('e.candidate', e.candidate);
         if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
         }
       };

       peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
       };
       peerConnection.addStream(localStream);
       if(isCaller) {
         peerConnection.createOffer().then(createdDescription).catch(errorHandler);
       }
     }

     function gotMessageFromServer(signal) {
       if(!peerConnection)  start(false);      
       if(signal._id == id) return;
       if(signal.sdp) {
         peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp)).then(()=&gt; {
           if(signal.sdp.type == 'offer') {
             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
           }
         }).catch(errorHandler);
       } else if(signal.ice) {
         peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
       }
     }
     function createdDescription(description) {
       peerConnection.setLocalDescription(description).then(()=&gt; {
         Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
       }).catch(errorHandler);
     }
     function errorHandler(error) { console.log(error); }
   }

   render() {
     return (
       &lt;div&gt;
         &lt;video id=""localVideo""  autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;video id=""remoteVideo"" autoPlay       style={{width:""40%""}}&gt;&lt;/video&gt;
         &lt;br/&gt;
         &lt;input type=""button"" id=""start"" value=""Start Video""/&gt;
       &lt;/div&gt;
     );
   }
 }


 export default createContainer( ()=&gt; {
   const subscriptionRtc = Meteor.subscribe('rtc');
   const loadingRtc = !subscriptionRtc.ready();
   return {
     loadingRtc:loadingRtc,
     messagesRtc: msgRtc.find().fetch(),
   };
 }, App);
</code></pre>

<p>Server code:</p>

<pre><code>export const msgRtc = new Mongo.Collection('rtc');
 let messagesRtc = [];
 let clients = [];

  Meteor.publish('rtc', function wsPub() {
    clients.push(this);
    _.each(messagesRtc, (message) =&gt; {
      this.added('rtc', message._id, message);
    });
    this.ready();
  });

 Meteor.methods({
    'addMsgRtc'(arr, id) {
      let newMessage = {_id:id, 'text':arr};
      messagesRtc.push(newMessage);
      _.each(clients, (client) =&gt; {
        client.added('rtc', id, newMessage);      
      });
    },
</code></pre>

<p>The problem is that why after the initialization of <code>getUserMedia</code> does not want to further this videos and what not so I can't understand. Because it is actually a similar code with the usual <code>websockets</code> <a href=""https://github.com/shanet/WebRTC-Example/blob/master/client/webrtc.js"" rel=""nofollow noreferrer"">like this</a> works and syncs fine.</p>

<p>UPD:<br>
When you click on the button and call the function <code>start</code>. </p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object</p>
</blockquote>

<p>If <code>websockets</code> to put in then then it turns out another error:</p>

<p>Code:</p>

<pre><code> navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
    localStream = stream;
    localVideo.src = window.URL.createObjectURL(stream);
  }).catch(errorHandler).then(()=&gt;{
    if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){
        let signal = JSON.parse(i.text);
        gotMessageFromServer(signal)
      }
    }
  }).catch(errorHandler);
</code></pre>

<p>Error:</p>

<blockquote>
  <p>DOMException [InvalidStateError: ""Cannot set remote offer or answer in
  current state have-remote-offer"" code: 11 nsresult: 0x8053000b] 
  app.js:11075:9 DOMException [InvalidStateError: ""No outstanding offer""
  code: 11 nsresult: 0x8053000b]</p>
</blockquote>
","2529221","","2529221","","2017-02-25 21:36:43","2017-02-25 21:36:43","Error simple WebRTC chat on react.js and meteor.js","<javascript><node.js><reactjs><meteor><webrtc>","0","6","","",""
"50228991","1","","","2018-05-08 08:13:43","","0","56","<p>I have a component that extends a generic component (custom react component). How do I unit-test using enzyme's mount? Here's the code:</p>

<p>Container.js</p>

<pre><code>import React from 'react';
import request from 'API/request';

export default class Container extends React.Component {
  componentDidMount() {
    this.populateData();
  }

  componentDidUpdate() {
    if (this.isDataStale()) {
      return this.populateData();
    }
  }

  populateData() {
    const url = this.getUrl();
    const params = this.getParams();

return request(this.props.dispatch, {
  url,
  params,
  method: 'GET'
})
  .then(response =&gt; {
    this.dispatchData(response.data);
  })
  .catch(error =&gt; {
    this.dispatchError(error);
  });


}
render() {
    if (this.getData() &amp;&amp; !this.isDataStale()) {
      return this.renderChildren();
    } else {
      return null;
    }
  }

  getError() {}
  getParams() {}
  isDataStale() {
    return false;
  }
}
</code></pre>

<p>Here's the functional component:</p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import { Route, withRouter } from 'react-router-dom';
import CustomPage from 'Client/customPage';
import Container from 'Client/container';
import TestPanel from 'Client/testPanel/TestPanel';
import Greeting from 'Client/greeting';
import Button from '../Button';

export class Test extends Container {
  constructor({ match }) {
    super();
    this.state = {
      match: match,
      id: match.params.id,
      location: ''
    };
  }

  isDataStale() {
    return (
      this.props.data.id !== this.props.match.params.id
    );
  }

  getData() {
    return this.props.data.values;
  }

  dispatchData(data) {
    this.props.dispatch({
      type: 'DATA_FOUND',
      data: data,
      id: this.state.id
    });
  }

  dispatchError(error) {
    this.props.dispatch({ type: 'CUSTOM_ERROR', data: error });
  }

  showDetails(url) {
    this.props.history.push(url);
  }

  renderChildren() {
    const match = this.state.match;
    const testUrl = `/test/values/${this.state.id}`;
    const verifyUrl = `${testUrl}/verify`;

    return (
      &lt;div className=""test-plan""&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;Greeting show={true} /&gt;
        )} /&gt;
        &lt;TestPanel
          data={this.props.data}
          id={this.props.match.params.id}
        /&gt;
        &lt;Route exact path={testUrl} render={() =&gt; (
          &lt;CustomPage id={this.state.id} /&gt;
        )} /&gt;
        &lt;Route path={verifyUrl} render={() =&gt; (
          &lt;div className=""next-button"" &gt;&lt;Button label = {' NEXT '} onButtonClick = { this.showDetails.bind(this, loanUrl) } /&gt; &lt;/div&gt;
        )} /&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = state =&gt; {
  return {
    data: state.data
  };
};

export default withRouter(connect(mapStateToProps)(Test));
</code></pre>

<p>How do I test this Test (functional) component using Enzyme? Am not sure how this mock works since the render method is inside the container which in turn invokes the renderChildren method in our functional component. Lot of functional components extends this container so we can't change this to composition pattern as of now.</p>

<p>Here's the test case (Not working)</p>

<pre><code>import jsdomWindow from '../../test.setup';
import React from 'react';
import {BrowserRouter} from 'react-router-dom';
import { Test } from 'Client/containers/test';
import { createStore } from 'redux';
import { Provider } from 'react-redux';
import Enzyme, {mount} from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
import sinon from 'sinon';
import * as api from 'API/request';
import { populateData, isDataStale } from '../../../../src/client/app/container';

Enzyme.configure({ adapter: new Adapter() });
const sandbox = sinon.sandbox.create();

describe('&lt;Test /&gt;',() =&gt; {
  beforeEach(function() {
    sandbox.stub(api, 'default').returns(Promise.resolve({data: { saySomething: 'Yay Tests!'}}));
  });

  afterEach(function() {
    sandbox.restore();
  });
  const match = {
    params: {
      id: 100
    }
  };
  const testState = {
    data : {
      test: {
        id:'100',
        email:'someone@something.com',
        first_name:'John',
        home_phone:'325-555-6564',
        last_name:'Doe'
      }
    }
  };
  const wrapper = mount(
    &lt;BrowserRouter&gt;
      &lt;Provider store={createStore(state =&gt; state, { data: testState.data })}&gt;
        &lt;Test data={testState.data} dispatch={ sinon.spy() }
          match={match} /&gt;
      &lt;/Provider&gt;
    &lt;/BrowserRouter&gt;
  );
  jest.mock('../../../../src/client/app/container', () =&gt; ({
    populateData: jest.fn(),
    isDataStale: jest.fn(),
    getError: jest.fn(),
    getParams: jest.fn(),

  }));

  it('should render', () =&gt; {
    console.log(wrapper.debug());
    populateData.mockReturnValueOnce({});
    isDataStale.mockReturnValueOnce(false);
    const greetingContainer = wrapper.find('.greeting-container').find('.quick-info').find('.quick-info-heading');
    expect(greetingContainer.text()).toContain('PROPER RESPONSE');
  });

  // it('should render greeting component by default', () =&gt; {
  //   expect(wrapper.find('div.greeting-container')).toBeDefined();
  //   expect(wrapper.find('div.info-container')).toBeDefined();
  //   expect(wrapper.find('div.next-button')).toBeDefined();
  // });

  // it('should not render greeting and next-button components on clicking next', () =&gt; {
  //   console.log(`Test**** ${JSON.stringify(wrapper.find('div.plan'))}`);
  // });
});
</code></pre>

<p>Could anyone help me to unit test this using mount method of enzyme. Don't want to use shallow here as i have to test nested components' properties.</p>

<p>Thank you.</p>
","4486280","","4486280","","2018-05-08 13:06:11","2018-05-08 13:06:11","How to unit test a react component that uses inheritance instead of composition using jest and enzyme?","<reactjs><unit-testing><redux><react-router><enzyme>","0","3","","",""
"36573252","1","36573540","","2016-04-12 12:26:35","","2","974","<p>This is vanila code to run list.js in the browser. And it works with no problem</p>

<pre><code>&lt;script src=""http://listjs.com/no-cdn/list.js""&gt;&lt;/script&gt;
&lt;div id=""users""&gt;
&lt;input class=""search"" placeholder=""Search"" /&gt;
&lt;ul class=""list""&gt;
    &lt;li&gt;
        &lt;h3 class=""name""&gt;Jonny Stromberg&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;h3 class=""name""&gt;Jonas Arnklint&lt;/h3&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;h3 class=""name""&gt;Martina Elm&lt;/h3&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
var options = { valueNames: [ 'name' ] };
var userList = new List('users', options);
&lt;/script&gt;
</code></pre>

<p>So I thought it will be simple to that in react, I tried this</p>

<pre><code>import React from ""react"";
import ReactDOM from ""react-dom"";

    class Home extends React.Component{
        componentDidUpdate(){
            const options = { valueNames: [ 'name' ] };
            const userList = new List('users', options);
        }
        render(){ 
            return(
                &lt;div id=""users""&gt;
                    &lt;input class=""search"" placeholder=""Search"" /&gt;
                    &lt;ul class=""list""&gt;
                        &lt;li&gt;
                            &lt;h3 class=""name""&gt;Jonny Stromberg&lt;/h3&gt;
                        &lt;/li&gt;
                        &lt;li&gt;
                            &lt;h3 class=""name""&gt;Jonas Arnklint&lt;/h3&gt;
                        &lt;/li&gt;
                        &lt;li&gt;
                            &lt;h3 class=""name""&gt;Martina Elm&lt;/h3&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
            )
        }
    }

    const app = document.getElementById('app');

    ReactDOM.render(&lt;Home /&gt;, app);
</code></pre>

<p>index.html</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;div id=""app""&gt;&lt;/div&gt;
&lt;script src=""//cdnjs.cloudflare.com/ajax/libs/list.js/1.2.0/list.min.js""&gt;&lt;/script&gt;
&lt;script src=""bundle.js""&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>But it's not working. And specially no error at all. What could be done here?</p>
","455340","","455340","","2016-04-12 19:16:13","2016-04-13 05:43:18","Make list.js and react.js work together","<javascript><reactjs><listjs>","1","0","1","",""
"42872062","1","42872472","","2017-03-18 08:17:24","","0","1753","<p>So I've been struggling to figure out the react-redux ecosystem for a while now. I'm almost there but there is still something that keep giving is me issues, and that's the componentDidUpdate method. When I dispatch an async action, the store is reducer is called correctly and the component's state does update.</p>

<p>But for some reason, the componentDidUpdate method does not fire, there is no re-render, and I cannot access the updated props. I can see it change in devtools, if I console.log(this.props.blogStore). At first it shows as an empty object but when on click it opens and shows the updated state.</p>

<p>I've tried as many life cycle methods as I can but nothing seems to work, including componentWillReceiveProps.</p>

<p>Any idea what I'm doing wrong?</p>

<p>Here is the code:</p>

<p><strong>index.js</strong></p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';

import App from './App';
import Datastore from 'Datastore';

const store = Datastore()

store.subscribe(() =&gt; console.log(""state changed"", store.getState()))

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
    document.getElementById('app')
);
</code></pre>

<p><strong>Datastore.js</strong></p>

<pre><code>import { combineReducers, createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk'

import Mainmenu from 'reducers/Mainmenu';
import Blogstore from 'reducers/Blogstore';

const reducer = combineReducers({
    Mainmenu,
    Blogstore,
})

export default function Datastore() {
    const store = createStore(
        reducer,
        applyMiddleware(thunk)
    )

    return store
}
</code></pre>

<p><strong>reducer</strong></p>

<pre><code>import Article from 'lib/Article';
import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';

const initialBlogState = {
}

const Blogstore = (state=initialBlogState, action) =&gt; {
    switch(action.type) {
        case SAVE_ARTICLE_LIST:
            state.init = true
            state.articles = action.payload
            return state
        case ARTICLE_LOAD:
            return state
        case ARTICLE_UPDATE:
            return state
    }
    return state
}

export default Blogstore;
</code></pre>

<p><strong>blog-actions.js</strong></p>

<pre><code>import { ARTICLE_LOAD, ARTICLE_UPDATE, SAVE_ARTICLE_LIST } from 'actionTypes';
import APIFetch from '../lib/Fetch';

export function getArticlePids() {
    return dispatch =&gt; {
        APIFetch().get(""/blog/list"").then(response =&gt; {
            dispatch({
                type: SAVE_ARTICLE_LIST,
                payload: response.data
            })
        })
    }
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
import * as blogActions from '../actions/blog-actions';

@connect(state =&gt; ({
    blogStore: state.Blogstore
}))
export default class Blog extends React.Component {
    constructor() {
        super()
    }

    componentDidMount() {
        this.props.dispatch(blogActions.getArticlePids())
    }

    componentDidUpdate(prevProps) {
        console.log(""update"", prevProps)
    }

    render() {
        console.log(""render"", this.props.blogStore)

        return (
            &lt;div&gt;&lt;h1&gt;Blog&lt;/h1&gt;&lt;/div&gt;
        )

    }
}
</code></pre>

<p>That is pretty much it. I won't bother pasting the App and Router that are between index.js and the component because there is nothing of interest there. Just a basic react router and components that have nothing to do with this.</p>
","5918922","","5918922","","2017-03-18 08:56:26","2017-03-18 09:12:00","componentDidUpdate does not fire","<react-redux>","1","4","","",""
"40666463","1","40709636","","2016-11-17 22:48:31","","0","362","<p>I am passing a self invoking function from <code>App</code> Component into <code>getBgColor</code> function of <code>WeatherForecast</code> Component. This grabs a value from the child component <code>WeatherForecast</code> and passes it into <code>App</code> Component to update <code>this.state.appColorClass</code>. </p>

<p>*<code>getBgColor</code> function is inside <code>componentDidUpdate()</code> which creates a loop and crashes the broweser. New to react and not sure how to solve this.</p>

<pre><code>export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = { appColorClass: 'app-bg1' };
  }

  setAppColor(colorClass) {
    alert(""set className"");
    this.setState({ appColorClass: colorClass });
  }

  render() {
    return (
    &lt;div className={""app-container "" + this.state.appColorClass}&gt;
      &lt;div className=""main-wrapper""&gt;

          &lt;WeatherForecast getBgColor={color =&gt; this.setAppColor(color)} /&gt;

      &lt;/div&gt;   
    &lt;/div&gt; 
    );
  }
}


class WeatherForecast extends Component {
  componentDidUpdate() {
    console.log('Component DID UPDATE!')
      //The function `setAppColor` from `App` component is passed into `getBgColor`
      this.props.getBgColor(this.appColor(this.props.weather));
  }

  appColor(weatherData) {
    console.log(""app color working"");

    let temp = 0;
    if ( typeof weatherData === 'undefined' || weatherData === null ) {
      console.log("" initial Color went through"");
      return 'app-bg1';
    }
    temp = Math.round(weatherData.list[0].main.temp - 273.15);
    if (temp &lt;= -30) {
        return ""app-bg1"";
    }
    if (temp &gt;= -29 &amp;&amp; temp &lt;= -21) {
        return ""app-bg2"";
    }
    if (temp &gt;= -20 &amp;&amp; temp &lt;= -11) {
        return ""app-bg3"";
    }
    if (temp &gt;= -10 &amp;&amp; temp &lt;= 4) {
        return ""app-bg4"";
    }
    if (temp &gt;= 5 &amp;&amp; temp &lt;= 15) {
        return ""app-bg5"";
    }
    if (temp &gt;= 16 &amp;&amp; temp &lt;= 24) {
        return ""app-bg6"";
    }
    if (temp &gt;= 25 &amp;&amp; temp &lt;= 32) {
        return ""app-bg7"";
    }
    if (temp &gt;= 33 &amp;&amp; temp &lt;= 38) {
        return ""app-bg8"";
    }
    if (temp &gt;= 39) {
        return ""app-bg9"";
    }
  }

  render() {

    return (
      &lt;div className=""text-center col-xs-12""&gt;
         &lt;h1 id=""temp""&gt;{this.displayTemp(this.props.weather)}&lt;sup&gt;&amp;deg;&lt;/sup&gt;&lt;/h1&gt;
         &lt;h1&gt;{this.displayCity(this.props.weather)}&lt;/h1&gt; 
      &lt;/div&gt;
    );
  }
}
</code></pre>
","2125972","","","","","2016-11-20 21:34:06","Loop with componentDidUpdate","<javascript><reactjs>","2","2","1","",""
"43726814","1","43766651","","2017-05-01 21:30:32","","3","262","<p>I'm getting a warning on the following line on my react component</p>

<pre><code>handleToggle: Function;
</code></pre>

<p>I'm using <a href=""https://github.com/yannickcr/eslint-plugin-react"" rel=""nofollow noreferrer"">eslint-plugin-react</a> and <a href=""https://flow.org/"" rel=""nofollow noreferrer"">Flow</a> and I'm getting a warning ""handleToggle should be placed after constructor"". This is related to rule react/sort-comp. I tried with the following on my .eslintrc.json</p>

<pre><code> ""react/sort-comp"": [1, {
  ""order"": [
    ""static-methods"",
    ""lifecycle"",
    ""everything-else"",
    ""render""
  ],
  ""groups"": {
    ""lifecycle"": [
      ""displayName"",
      ""propTypes"",
      ""contextTypes"",
      ""childContextTypes"",
      ""/^.*: Function$/"",
      ""mixins"",
      ""statics"",
      ""defaultProps"",
      ""state"",
      ""constructor"",
      ""getDefaultProps"",
      ""getInitialState"",
      ""getChildContext"",
      ""componentWillMount"",
      ""componentDidMount"",
      ""componentWillReceiveProps"",
      ""shouldComponentUpdate"",
      ""componentWillUpdate"",
      ""componentDidUpdate"",
      ""componentWillUnmount""
    ]
  }
}]
</code></pre>

<p>But I'm unable to fix the warning. I want the Function Types before constructor the same as the other Type Definition. How can I achieve this?</p>
","5623087","","4076315","","2017-05-03 02:09:47","2017-05-03 17:44:15","How to fix warning caused by Flow Function Types using eslint-plugin-react?","<reactjs><eslint><flowtype>","1","1","","",""
"43640765","1","","","2017-04-26 17:22:55","","1","184","<p>My React component requires an ajax call to get the data to render itself.</p>

<p>Initially, I used the approach to make an ajax call kicked off within render.  Here is my pseudo code...</p>

<pre><code>export class MyView extends React.Component&lt;any, any&gt; {

    hasAjaxData: boolean = false;

    renderAndGetData() {
        const data = {

        };

        AjaxCall(data)
            .then((results) =&gt; {
                this.hasAjaxData = true;
                // save to store here, causing a rerender
                ...
                });
            })
            .catch((err: Error) =&gt; {
                console.error(err);
            });
        return (
            &lt;SpinnerComponent /&gt;
        );
    }

    renderWithData() {
        return (
            &lt;div&gt;
                Render with data here
            &lt;/div&gt;
        );
    }

    render() {
        return this.hasAjaxData ? this.renderWithData() : this.renderAndGetData();
    }
}
</code></pre>

<p>After reading in the React documentation about the <a href=""https://facebook.github.io/react/docs/react-component.html#render"" rel=""nofollow noreferrer"">render call</a>, I was a bit concerned about changing the store in a render call, even asynchronously.</p>

<p>I came up with another approach that uses componentDidMount and componentDidUpdate.  This ended up being slightly more complicated, since when the component is initially rendered, componentDidMount and componentDidUpdate both get called.  Any subsequent updates (via the URL being changed, then rerendering via react-router) do <em>not</em> call componentDidMount, but rather only componentDidUpdate, (which also gets called during the initial mount).  To avoid any unnecessary renders, careful attention to flags is required.</p>

<p>This second approach seems more complicated and involves more function overrides...</p>

<p>So the question is: is there anything wrong with firing off an ajax request from within the render function?</p>

<p>thanks...</p>
","1431343","","","","","2017-04-26 17:25:59","Best practice for making an ajax call using React and react-router","<ajax><reactjs><react-router>","1","0","","",""
"42945897","1","","","2017-03-22 08:04:57","","0","232","<p>I am new to <code>react-router</code> and right now I have following routes in my app:</p>

<pre><code>&lt;Router history={browserHistory}&gt;
    &lt;Route path=""/"" component={MainLayout}&gt;
        &lt;Route path=""/v/:username/:reponame/:page/:perPage"" component={Results} /&gt;
    &lt;/Route&gt;
&lt;/Router&gt;
</code></pre>

<p>As you can see, there's a MainLayout component that includes an <code>&lt;input type=""text""&gt;</code> which is used to connect to Github API and retrieve list of issues for a certain repo.</p>

<p>Then the <code>Results</code> component steps in. Here's the code for it's <code>componentDidMount()</code>:</p>

<pre><code>componentDidMount() {
    const {
        username,
        reponame,
        page,
        perPage
    } = this.props.params;
    this.sendRequest(username, reponame, page, perPage);
}
</code></pre>

<p><code>sendRequests</code> essentially contains the ajax query for fetching the output data, after which it's being set into the component's state:</p>

<pre><code>    this.state = {
        data: [], // here
        lastPage: -1,
        errorMessage: ''
    }
</code></pre>

<p>Now this works pretty well till the very moment when one wants to change the value of an <code>input</code>.</p>

<p>As I see, the <code>Result</code> component doesn't unmount. Instead, it invokes <code>componentWillReceiveProps()</code> and updates the existing component. AFAIK it is safe to perform side calls in <code>componentDidUpdate()</code> so I just copied the code above from <code>componentDidMount()</code> and pasted it in there. This way, though (and it is absolutely reasonable) <code>componentDidMount()</code> is being invoked over and over again.</p>

<p>The only workaround I came up with at the moment is comparing old and new data in the <code>sendRequest()</code> itself and invoke <code>setState()</code> inside of it only if it differs via <code>deep-equal</code> package, so it looks like this:</p>

<pre><code>    if (!equal(res, this.state.data)) {
        this.setState({
          ...this.state,
          data: res,
          lastPage
        });
    }
</code></pre>

<p>Is this considered to be an ok pattern or there is a better way to solve this issue?</p>
","5659471","","","","","2017-03-22 08:27:34","Infinite componentDidUpdate() calls with react-router","<reactjs><react-router>","1","1","1","",""
"50185157","1","50185682","","2018-05-05 02:33:33","","3","149","<p>I am working with react 16.3 where <code>componentWillUpdate</code> is deprecated (strict mode). We have a react wrapper around <code>Highcharts</code> and used to update the <code>highchart</code> in <code>componentWillUpdate</code> that runs just before render. </p>

<p>But now in react 16.3 when the input <code>highchartoptions</code> prop updates, there seems to be no way to call <code>Highchart.update</code> before <code>render()</code> is called. Its suggested to use <code>componentDidUpdate</code> but its called only after <code>render()</code> and it doesn't seem to work at all.Any suggestions will help.</p>

<p>Code snippet here:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class HighchartReactWrapper extends React.Component {
  constructor(props) {
    super(props);

    // We maintain the user provided options being used by highchart as state
    // inorder to check if chart update is needed.
    this.state = { highChartOptions: this.props.options };
    this.onChartRendered = this.onChartRendered.bind(this);
  }

  componentDidMount() {
    // Create chart
    this.chart = new Highcharts.Chart(this.container, this.state.highChartOptions, this.onChartRendered);
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.options !== prevState.options) {
      return { highChartOptions: nextProps.options };
    }
  }

  componentDidUpdate() {
    this.chart.update(this.state.highChartOptions, false, true); &lt;---- Doesn't work
  }

  onChartRendered() {
    // Callbacks..
    if (this.props.onChartRenderedCallback !== undefined) {
      this.props.onChartRenderedCallback();
    }
  }

  componentWillUnmount() {
    // Destroy chart
    this.chart.destroy()
  }

  render() {
    return (
      &lt;div className=""react-highchart-wrapper""&gt;
        &lt;div id={container =&gt; this.container = container} /&gt;
      &lt;/div&gt;
    );
  }
}

HighchartReactWrapper.propTypes = {
  /**
   * Chart options to be used in Highcharts library.
   */
  options: PropTypes.object.isRequired,
  onChartRenderedCallback: PropTypes.func
};

HighchartReactWrapper.defaultProps = {
  options: undefined,
  onChartRenderedCallback: undefined
};</code></pre>
</div>
</div>
</p>
","9743947","","6622817","","2018-05-05 02:38:16","2018-05-05 04:23:13","How to update Highchart from inside react a component?","<reactjs><highcharts>","1","3","1","",""
"44107644","1","44117766","","2017-05-22 08:01:35","","1","641","<p>I have a weird situation at hand while trying to make a demo appointment system. 
I want to fetch events through Django backend rest api, which works totally fine and I could see the data coming in console as well.</p>

<p>Here is my index file (where provider is):
<a href=""https://hastebin.com/ubefumofor.js"" rel=""nofollow noreferrer"">https://hastebin.com/ubefumofor.js</a></p>

<p>My calendar rendering component:
<a href=""https://hastebin.com/oronefibap.scala"" rel=""nofollow noreferrer"">https://hastebin.com/oronefibap.scala</a></p>

<p>My Redux, its reduxsauce library I am using:
<a href=""https://hastebin.com/usetavasub.js"" rel=""nofollow noreferrer"">https://hastebin.com/usetavasub.js</a></p>

<p>My ReduxSaga file:
<a href=""https://hastebin.com/wutuvelefi.js"" rel=""nofollow noreferrer"">https://hastebin.com/wutuvelefi.js</a></p>

<p>Now, the thing is, I am struggling to do a few things after I fetch the events:</p>

<ul>
<li><p>Where to setState, as it goes in infinite look if I call it in componentWillUpdate or componentDidUpdate?</p></li>
<li><p>if I use this.props.events I get the following error which I have attached as a picture. It says <code>uncaught at fetchEventsByDoctor The sort method cannot be invoked on an Immutable data structure.</code>
<a href=""https://i.stack.imgur.com/kX3tR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX3tR.png"" alt=""enter image description here""></a></p></li>
</ul>

<p>Now I know that props cant be modified and state could be.</p>

<p>Any suggestions what could be wrong? Thanks</p>

<p><strong>Note: I am new to react and redux related technologies.</strong>
<a href=""https://i.stack.imgur.com/TgYAD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TgYAD.png"" alt=""enter image description here""></a></p>

<hr>

<h2>Solution</h2>

<hr>

<pre><code>componentDidUpdate(prevProps, prevState){

if(prevProps.events !== this.props.events) {

     let a = this.state.events.slice();
     let p = this.props.events
     for(var i = 0; i &lt; p.length; i++ ){
         a[a.length] = p[i]

     }
     this.setState({events: a})



   }
  }
</code></pre>

<p>And that should do the trick, but Nagaraj's answer below is very much a good working solution too.</p>
","262914","","262914","","2017-05-23 02:35:25","2017-05-23 02:35:25","react-big-calendar fetch events from remote url redux issue","<reactjs><redux><redux-saga><seamless-immutable><react-big-calendar>","1","7","1","",""
"42540397","1","","","2017-03-01 19:31:51","","0","269","<p>I am using react-router with a route structure like so:</p>

<pre><code>const routes = (
  &lt;Router history={browserHistory}&gt;
    &lt;Route path=""/main"" component={MainPage}&gt;&lt;/Route&gt;
    &lt;Route path=""/charts/:chartID"" component={App}&gt;&lt;/Route&gt;
  &lt;/Router&gt;
)
</code></pre>

<p>I am trying to do a call to a meteor method when a user switches away from ""/charts/:chartID"" to ""/main"". I only want the method to be called once if possible</p>

<p>In App.js, I used the life cycle methods:</p>

<pre><code>  componentDidUpdate(){
    Meteor.call('test',""update"");   
  } // prints ""update""

  componentWillUnmount(){
    Meteor.call('test',""unmount"");
  } // nothing happens when url changes
</code></pre>

<p>Main.js (server):</p>

<pre><code>Meteor.methods({
    'test'(obj){
        console.log(obj)
    }
})
</code></pre>

<p>I read from this <a href=""https://github.com/ReactTraining/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow noreferrer"">source</a> that components should unmount when the url changes in my situation, but seems like I may have missed out something. How should I be resolving this?</p>

<p>Any help is greatly appreciated!</p>
","6150999","","","","","2017-03-01 22:55:19","react-router: Calling componentWillUnmount across different non-nested routes","<javascript><reactjs><meteor><react-router>","1","0","1","",""
"43557569","1","","","2017-04-22 09:33:04","","0","165","<p>My app has a component that is updated every time the user swipe it.<br>
That component gets new props every time and it's values are updated accordingly.<br>
With the new data received, I create a facebook graph api fetch request to get the user's profile image.<br>
To make it look better, I added a default image until the fetch request finishes. I reset the image to default in <code>componentWillReceiveProps</code>.<br>
The error I get is ""Error calling function: RCTDeviceEventEmitter:emit""<br>
It only happanes when I am not remotely debugging (using the chrome debugger of react native).<Br>
This is the relevant code:</p>

<pre><code>  componentWillReceiveProps(nextProps){
    var temp;
    temp=this.state.profileInfo;
    temp.image='http://s3.amazonaws.com/cdn.roosterteeth.com/default/tb/user_profile_female.jpg';
    this.setState({
      profileInfo:temp,
    });
  },
  componentDidUpdate(prevProps, prevState){
    if(prevProps!=this.props){
      console.log(""Updated!!!"");
      var api = 'https://graph.facebook.com/' + this.props.owner_id +
                     '/picture?type=normal&amp;access_token=' + this.props.credentials.token;
      fetch(api)
            .then((response) =&gt;{
              var temp;
              temp=this.state.profileInfo;
              temp.image=response.url;
              this.setState({
                profileInfo:temp,
              });
            })
            .done();
    }
  },
  componentDidMount(){
    var api = 'https://graph.facebook.com/' + this.props.owner_id +
                   '/picture?type=normal&amp;access_token=' + this.props.credentials.token;
    fetch(api)
          .then((response) =&gt;{
            var temp;
            temp=this.state.profileInfo;
            temp.image=response.url;
            this.setState({
              profileInfo:temp,
            });
          })
          .done();
  },
</code></pre>

<p>Does anybody know how can I resolve this error? Why is it only when not debugging?</p>
","1689604","","","","","2017-04-22 09:50:05","componentDidUpdate gives RCTDeviceEventEmitter error when doing network request","<react-native>","1","0","","",""
"43541451","1","","","2017-04-21 11:21:18","","3","681","<p>I'm new to React and I feel I didn't catch the component lifecycle flow, this is the component I have:</p>

<pre><code>import React, {Component, PropTypes} from 'react';
import { connect } from 'react-redux';
import { fetchMyWishlist, fetchSpecificBook } from '../actions/index';

class Cart extends Component {

  static contextTypes = {
        router:PropTypes.object
    };

  constructor(props) {
    super(props);
    this.state = { currentCart:[], currentBook:[], wishlist:[] };

    var self = this;
    if (this.props.authenticated){
      this.props.fetchMyWishlist(this.props.signedInUserInfo._id).then(function(data){
        self.setState({ currentCart: data});
      });
    }
    else {
      this.context.router.push('/signin');
    }
  }

  componentWillMount(){}

  componentDidMount(){
    // I get undefined here
    console.log(""component has been mounted: ""+this.state.currentCart.payload);
  }

  componentDidUpdate(prevProps, prevState){
    var jsonObj = this.state.currentCart.payload;
    console.log(""test: ""+JSON.stringify(this.state.currentCart.payload));
    var self = this;
    if ((jsonObj) &amp;&amp; (jsonObj.data)){   
      return jsonObj.data.map(function(book){
          self.props.fetchSpecificBook(book.itemID);
      });
    }
  }


  render() {
    console.log(""rendering"");

    return (
      &lt;div&gt;
        &lt;div&gt;
          &lt;h3&gt;Your wishlist&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

function mapStateToProps(state){
  return {
    currentCart: state.bookReducer.currentCart,
    currentBook: state.bookReducer.currentBook,
    authenticated: state.auth.authenticated,
    signedInUserInfo:state.auth.signedInUserInfo
  };
}

export default connect(mapStateToProps, {fetchMyWishlist, fetchSpecificBook})(Cart);
</code></pre>

<p>This is what I'm doing: inside the constructor the action <code>fetchMyWishlist</code> is called and it returns an array of book ids. The reducer updates the <code>currentCart</code> state with the result of <code>fetchMyWishlist</code> action.</p>

<p>First thing I don't understand is why in componentDidMount <code>this.state.currentCart.payload</code> is undefined.
So I try to do my operations inside <code>componentDidUpdate</code> where <code>this.state.currentCart.payload</code> is defined and I can iterate through it.
Here for each book I try to retrieve additional information via <code>fetchSpecificBook</code> action.
The problem here is that I get infinite number of action calls.
What I'd like to do is to store all additional books information into an array.</p>

<p>How do I go about this? </p>
","4188968","","243392","","2017-12-05 21:31:43","2017-12-05 21:31:43","React - componentDidUpdate called infinite times","<javascript><reactjs>","3","2","1","",""
"50207151","1","","","2018-05-07 04:34:32","","0","74","<p>I wonder, what is the way to use new <code>Mutation</code> components with react lifecycle methods.</p>

<p>Say I've got a page where I use several react-apollo mutations. I want to execute another mutation when loading state changes from <code>true</code> to <code>false</code> to show a notification popup in the page corner.</p>

<p>With higher order component I would do that in <code>componentDidUpdate</code> method, but now with <code>&lt;Mutation /&gt;</code> component I can't do that. Am I missing anything?</p>
","5425414","","","","","2018-05-14 12:20:40","Using react-apollo 2.1 mutations with react lifecycle methods","<reactjs><apollo><react-apollo><apollo-client>","1","0","","",""
"43930500","1","","","2017-05-12 06:13:13","","5","870","<p>I'm working on an app with a login page and the rest of the pages of the app (should be logged in to view). I'm using  <a href=""https://github.com/react-boilerplate/react-boilerplate"" rel=""nofollow noreferrer""><code>react-boilerplate</code></a>. From this <a href=""https://github.com/react-boilerplate/react-boilerplate/issues/453#issuecomment-223279221"" rel=""nofollow noreferrer""><code>example</code></a>, I edited my <code>asyncInjectors.js</code> file to have <code>redirectToLogin</code> and <code>redirectToDashboard</code> methods:</p>

<pre><code>//asyncInjectors.js
export function redirectToLogin(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (!isAuthenticated) {
      replaceState({
        pathname: '/login',
        state: {
          nextPathname: nextState.location.pathname,
        },
      });
    }
  };
}

export function redirectToDashboard(store) {
  return (nextState, replaceState) =&gt; {
    const isAuthenticated = store.getState().get('app').get('isAuthenticated');

    if (isAuthenticated) {
      replaceState('/');
    }
  }
}
</code></pre>

<p>Then I just set the <code>redirectToLogin</code> as the <code>onEnter</code> of the pages and <code>redirectToDashboard</code> for the login page.</p>

<p>It works fine but when the page is refreshed (<strong><code>F5</code></strong>) when logged in, the login page renders briefly and then renders the actual page. The login page just dispatches an <code>authenticate</code> action in <code>componentWillMount</code> and then redirects in <code>componentDidUpdate</code>:</p>

<pre><code>//login.js
componentWillMount() {
  this.props.dispatch(authenticate());
}

componentDidUpdate(prevProps, prevState) {
  if (this.props.isAuthenticated) {
    const nextPathname = prevProps.location.state ? prevProps.location.state.nextPathname : '/';

    browserHistory.push(nextPathname);
  }
}
</code></pre>

<p>The container for the pages also has the same <code>componentWillMount</code> code. Not sure if it's because of the sagas but here's the code:</p>

<pre><code>//sagas.js
export function* login({ user, password }) {
    try {
        const token = yield call(app.authenticate, {
            strategy: 'local',
            user,
            password,
        });

        return token;
    } catch (error) {
        return onError(error);
    }
}

// For page refresh after logging in
export function* authenticate() {
    try {
        const token = yield call(app.authenticate);

        return token;
    } catch (error) {
        return onError(error);
    }
}

export function* logout() {
    try {
        const response = yield call(app.logout);

        return response;
    } catch (error) {
        return onError(error);
    }
}

export function* loginFlow() {
    while (true) {
        const request = yield take(LOGIN_REQUEST);
        const winner = yield race({
            auth: call(login, request.data),
            logout: take(LOGOUT_REQUEST),
        });

        if (winner.auth &amp;&amp; winner.auth.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export function* logoutFlow() {
    while (true) {
        yield take(LOGOUT_REQUEST);
        yield put(actions.setAuthState(false));
        yield call(logout);
        browserHistory.push('/login');
    }
}

export function* authenticateFlow() {
    while (true) {
        yield take(AUTHENTICATE);

        const response = yield call(authenticate);

        if (response &amp;&amp; response.accessToken) {
            yield put(actions.setAuthState(true));
        }
    }
}

export default [
    loginFlow,
    logoutFlow,
    authenticateFlow,
];
</code></pre>

<p>How do I get rid of the flashing login page?</p>

<p>EDIT:
When I tried <a href=""https://stackoverflow.com/a/44051537/769326"">gouroujo</a>'s answer, I couldn't logout.</p>

<pre><code>//asyncInjectors.js
import jwtDecode from 'jwt-decode';

export function redirectToLogin(store) {
    return (nextState, replaceState, callback) =&gt; {
        const token = localStorage.token;

        if (token) {
            const jwt = jwtDecode(token);

            if (jwt.exp &lt;= (new Date().getTime() / 1000)) {
                store.dispatch(actions.setAuthState(false));

                replaceState({
                    pathname: '/login',
                    state: {
                        nextPathname: nextState.location.pathname,
                    },
                });
            }
        }

        store.dispatch(actions.setAuthState(true));
        callback();
    };
}
</code></pre>

<p>When I hit refresh, the <code>login page</code> doesn't show but now I can't log out.</p>
","769326","","-1","","2017-05-23 12:18:28","2017-05-22 05:25:27","react-boilerplate authentication login page flashes on page reload","<reactjs><authentication><redux-saga><react-boilerplate>","1","4","1","",""
"43026264","1","","","2017-03-26 07:35:35","","3","183","<p>After reading about React, I decided to test some simple ideas in a sample project.But I surprised why <code>setState</code> doesn't work as expected.
<code>setState</code> doesn't change state,Even when I am using update add-on.When I change <code>setState</code> to state, it works! I have logged new state object too, and it is correct.I don't know what is wrong! I'll appreciate your help.</p>

<pre><code>import React from 'react';
import update from 'react-addons-update';
class WebFooterSubscription extends React.Component {
    //========================================================
    constructor(props) {
        super(props);
        this.state = {
            formIsValid: false,
            email: {
                value: """",
                focused: false,
                touched: false,
                isValid: false,
                error: ""Enter your email""
            },
            mobile: {
                value: """",
                focused: false,
                touched: false,
                isValid: false,
                error: ""Enter your mobile""
            }
        };
    }
    //=================================================================
    componentDidUpdate(prevProps, prevState) {}
    //========================================================
    onBlur(event) {
        if ('mobile1' === event.target.id) {
            let newState = { ...this.state,
                mobile: { ...this.state.mobile,
                    value: event.target.value,
                    focused: false,
                    touched: true
                }
            };
            console.log(""mobile blur:"", JSON.stringify(newState));
            this.setState(newState); // this seems not to work!
        }
        if ('email1' === event.target.id) {
            let newState = update(this.state, {
                email: {
                    value: {
                        $set: event.target.value
                    },
                    touched: {
                        $set: true
                    },
                    focused: {
                        $set: false
                    }
                }
            });
            console.log(""email blur:"", JSON.stringify(newState));
            this.setState(newState); // this seems not to work!
        }
        this.cmdValidate();
    }
    //========================================================
    onFocus(event) {
        console.log(""focus occured"");
        if ('mobile1' === event.target.id) {
            let newState = { ...this.state.mobile
            };
            newState.focused = true;
            newState.touched = true;
            this.setState({ ...this.state,
                mobile: newState
            });
        }
        if ('email1' === event.target.id) {
            this.setState({ ...this.state,
                email: { ...this.state.email,
                    touched: true,
                    focused: true
                }
            });
        }
    }
    //========================================================
    cmdValidate() {
        // console.log(""length "" ,this.state.mobile.value.length);
        if (this.state.mobile.value &amp;&amp; this.state.mobile.value.length === 11) {
            this.setState({ ...this.state,
                mobile: { ...this.state.mobile,
                    isValid: true,
                    error: """"
                }
            });
        } else {
            this.setState({ ...this.state,
                mobile: { ...this.state.mobile,
                    isValid: false,
                    error: ""Enter your cell phone number correctly""
                }
            });
        }
        if (this.state.email.value) {
            let isValidEmail = true;
            if (isValidEmail) {
                this.setState({ ...this.state,
                    email: { ...this.state.email,
                        isValid: isValidEmail
                    }
                });
            } else {
                this.setState({ ...this.state,
                    email: { ...this.state.email,
                        isValid: false,
                        error: ""Your email is not correct""
                    }
                });
            }
        } else {
            this.setState({ ...this.state,
                email: { ...this.state.email,
                    isValid: false,
                    error: ""Enter email""
                }
            });
        }
        if (this.state.email.isValid &amp;&amp; this.state.mobile.isValid) {
            this.setState({ ...this.state,
                formIsValid: true
            });
        } else {
            this.setState({ ...this.state,
                formIsValid: false
            });
        }
    }
    //========================================================
    onSubmitClick(event) {
        //this.setState({count : this.state.count + 1});
        event.preventDefault();
    }
    render() {
        return (&lt;form name=""subscriptionForm"" id=""subscriptionForm"" className=""form"" method=""post""&gt;
                                &lt;div className={`form-group ${this.state.email.touched &amp;&amp; !this.state.email.isValid ? ' has-danger' : ''}`}&gt;
                                    &lt;div className=""col-md-12  ""&gt;
                                        &lt;div className=""input-group"" &gt;
                                            &lt;input id=""email1"" name=""email1"" onBlur={(event)=&gt;this.onBlur(event)} onFocus={(event)=&gt;this.onFocus(event)}  className=""form-control""  placeholder=""email""  type=""text"" /&gt;
                                            &lt;div className=""input-group-addon""&gt;&lt;img src=""assets/images/icons/svg/opened-email-envelope.svg"" alt=""email"" width=""24px"" height=""24px"" /&gt;&lt;/div&gt;
                                        &lt;/div&gt;
                                        &lt;div className=""help-block"" hidden={!this.state.email.focused}&gt;
                                                 {this.state.email.touched &amp;&amp; ((this.state.email.error &amp;&amp; &lt;span&gt;{this.state.email.error}&lt;/span&gt;))}
                                        &lt;/div&gt;

                                    &lt;/div&gt;
                                &lt;/div&gt;
                                &lt;div className={`form-group ${this.state.mobile.touched &amp;&amp; !this.state.mobile.isValid ? ' has-danger' : ''}`}&gt;
                                    &lt;div className=""col-md-12  ""&gt;
                                        &lt;div className=""input-group"" &gt;
                                            &lt;input id=""mobile1"" name=""mobile1"" className=""form-control"" onBlur={(event)=&gt;this.onBlur(event)}  onFocus={(event)=&gt;this.onFocus(event)}   placeholder=""cell phone"" type=""text"" /&gt;
                                            &lt;div className=""input-group-addon""&gt;&lt;img src=""assets/images/icons/svg/talking2.svg"" alt=""cell phone"" width=""24px"" height=""24px"" /&gt;&lt;/div&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;
                                &lt;/div&gt;
                                &lt;div className=""leftButton""&gt;
                                    &lt;button type=""submit""  onClick={(event)=&gt; this.onSubmitClick(event)}  className=""btn btn-primary"" &gt;Subscribe&lt;/button&gt;
                                &lt;/div&gt;
                                    &lt;div&gt;
                                        {JSON.stringify(this.state)}disabled={!this.state.formIsValid}
                                    &lt;/div&gt;
                            &lt;/form&gt;);
    }
}
export default WebFooterSubscription;
</code></pre>
","7768683","","7750640","","2017-03-26 20:36:28","2017-03-26 20:36:28","react setState doesn't change state even when I am using react update add on","<javascript><reactjs>","2","1","","",""
"44146281","1","","","2017-05-23 22:50:49","","2","378","<p>Here's my problem:</p>

<p>I'm new at reactjs and I'm trying to make this app using SWAPI (swapi.co). For now I need to list characters and some info about them. The problem is I have this component called <code>SelectedCharacter</code> that returns some info about a character that was selected in a div.</p>

<p>The moment a character is passed through props to this component, I get a response via xmlhttp and the info is displayed. The thing is that I want to put a <code>""Loading...""</code> message while the data is fetched. This is how I was trying to figure it out:</p>

<p>I set up the <code>componentWillReceiveProps</code> function, where I test if I'll need to load stuff and the <code>componentDidUpdate</code>, where I fetch the data from this api and update the status.</p>

<p>I know, from react life cycle, that a render is called between <code>componentWillReceiveProps</code> and <code>componentDidUpdate</code>, and it indeed is.</p>

<p>I expected, then, that if I did this:</p>

<pre><code>render() {
  if (criteria) {
    return &lt;div&gt;Loading...&lt;/div&gt;
  }
}
</code></pre>

<p>The thing is: even if this criteria is true (I tested it using <code>console.log()</code>), the message doesn't show until the next re-render. Am I doing anything too wrong here? If it helps, my code is at <a href=""https://github.com/piubellofelipe/StarWars"" rel=""nofollow noreferrer"">github.com/piubellofelipe/StarWars</a>, the problem is at the selected_characters.js, in the src paste.</p>

<p>Thanks</p>
","8056204","","1633510","","2017-05-23 22:56:47","2017-05-24 04:45:03","Render after componentWillReceiveProps and before componentDidUpdate","<javascript><reactjs>","1","0","1","",""
"43888397","1","","","2017-05-10 09:22:49","","0","808","<p>I am using reactjs and react GA for google analytic integration i have the following error in the console:</p>

<pre><code>Uncaught (in promise) Error: _registerComponent(...): Target container is not a DOM element.
at invariant (bundle.js:2844)
at Object._renderNewRootComponent (bundle.js:41047)
at Object._renderSubtreeIntoContainer (bundle.js:41137)
at Object.renderSubtreeIntoContainer [as unstable_renderSubtreeIntoContainer] (bundle.js:41079)
at OverlayTrigger.renderOverlay (bundle.js:85430)
at OverlayTrigger.componentDidUpdate (bundle.js:85319)
at measureLifeCyclePerf (bundle.js:90119)
at bundle.js:90773
at CallbackQueue.notifyAll (bundle.js:39950)
at ReactReconcileTransaction.close (bundle.js:95219)
</code></pre>

<p>I am trying to resolve the issue using several resources.But i couldn't find a solution.</p>

<p><strong>Code:</strong>
Videoplayer.jsx</p>

<pre><code>    import React, {Component} from 'react';
import {Link} from 'react-router';
import videojs from 'video.js';
import {Image, Modal} from 'react-bootstrap/lib';
import 'videojs-contrib-hls';
import GA from '../GA.jsx';

const liveVideoUrl = 'http://vid-129002.hls.chinanetcenter.broadcastapp.agoraio.cn/live/';
class VideoPlayer extends Component {
    constructor(props) {
        super(props);

        this.hideModal = this.hideModal.bind(this);
        this.state = {showPopup: false};        
        this.broadcastData = this.props.broadcastData;
        this.videoUrl = this.broadcastData.recordedUrl;
        this.videoType = 'video/mp4';
        let videoStreamName = this.broadcastData.streamId;
        this.live = null;

        if (this.broadcastData.status !== 'RECORDED') {
            this.videoUrl = liveVideoUrl + videoStreamName + '/playlist.m3u8';
            this.live = (&lt;Image className=""live-logo"" src=""/images/svg/live.svg""/&gt;);
            this.videoType = 'application/x-mpegURL';
        }
    }
    componentDidMount () {
        const
            self = this,
            options = {
                autoplay: true,
                controls: true,
                preload: ""auto"",
                hls: {
                    withCredentials: true
                }
            };

        const playerTarget = 'play_video';
        this.player = videojs(this.videoNode, options);
        this.player.src({
          src: this.videoUrl,
          type: this.videoType,
        });
        this.player.on('ended', () =&gt; {
            self.setState({showPopup: true});
        });



        if (this.player.play()) {
            GA.ManualGA(playerTarget);
        }

    }

    componentWillUnmount() {
        this.player &amp;&amp; this.player.dispose();
        this.player = null;
    }

    hideModal() {
        this.setState({showPopup: false});
    }

    render() {
        let screenShotUrl = this.broadcastData.screenShotUrl;
        let downloadLinkNode = [];

        if (screenShotUrl == null) {
            screenShotUrl = '/images/default-screenshot.png'
        }

        const style = {
            ""backgroundImage"": ""url("" + screenShotUrl + "")""
        };

        if (this.showBanner) {
            if (this.isIphone) {
                downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click"" /&gt;&lt;/Link&gt;);
            } else {
                downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;&lt;/Link&gt;);
            }
        } else {
            downloadLinkNode.push(&lt;Link key=""appStore"" className=""btn btn-default btn-home-bg-one"" target=""_blank"" to={""https://itunes.apple.com/us/app/speakerswire/id100000?mt=8""}&gt;
                    &lt;Image src=""/images/appstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_ios_click""/&gt;
                &lt;/Link&gt;
            );
            downloadLinkNode.push(&lt;Link key=""playStore"" className=""btn btn-default btn-home-bg-two"" target=""_blank"" to={""https://play.google.com/store/apps/details?id=com.kryptolabs.android.speakerswire&amp;hl=en""}&gt;
                    &lt;Image src=""/images/playstore.png"" alt=""google play"" data-ga=""app_dld_aftervideo_android_click""/&gt;
                &lt;/Link&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;div className=""blur-bg"" style={style}/&gt;
                &lt;video className=""video-js vjs-sublime-skin vjs-big-play-centered"" data-setup='{ ""inactivityTimeout"": 0 }' ref={ r =&gt; { this.videoNode = r; } }/&gt;
                {this.live}
                &lt;Modal show={this.state.showPopup} dialogClassName=""app-download-play-end"" onHide={this.hideModal}&gt;
                    &lt;Modal.Header closeButton /&gt;
                    &lt;Modal.Body&gt;
                        &lt;Image src=""/images/swoo-logo-popup.svg"" className=""logo""/&gt;&lt;br/&gt;
                        &lt;Image src=""/images/svg/logo_black.svg""/&gt;
                        &lt;div className=""title""&gt;To view more broadcasts, install SWOO app&lt;/div&gt;
                        &lt;h5&gt;Get the App&lt;/h5&gt;
                        {downloadLinkNode}
                    &lt;/Modal.Body&gt;
                &lt;/Modal&gt;
            &lt;/div&gt;
        );
    }
}

export default VideoPlayer
</code></pre>

<p><strong>GA.JSX</strong></p>

<pre><code>    function GA(ReactGA) {
    const objects = ['channel_click', 'channel_home_click', 'share_btn_click', 'share_btn_click', 'terms_cond_click', 'privacy_policy_click', 'discover_btn_click', 'profile_btn_click', 'app_dld_close_btn_click', 'top_broadcaster_click', 'app_dld_andoid_btn_click', 'broadcast_live_click', 'broadcast_recorded_click',
     'app_dld_ios_btn_click', 'app_dld_ios_homebtn_click', 'app_dld_andoid_homebtn_click', 'app_dld_aftervideo_android_click', 'app_dld_aftervideo_ios_click', 'play_video', 'pause_video'];

        ReactGA.initialize('UA-96792697-3');''
        document.addEventListener('click',(e) =&gt; {
            let target = e.target.getAttribute('data-ga');
            let additional_value = e.target.getAttribute('data-value');

            if (objects.indexOf(target) &gt;= 0) {
                ReactGA.event({category:'swoo', action: target});
            }

        });

         function ManualGA(target) {
                    ReactGA.event({category:'swoo', action: target});
        }
 }

export default GA;
</code></pre>

<p><strong>Index.jsx:</strong></p>

<pre><code>import React from 'react';
import {render} from 'react-dom';
import {Router, Route, IndexRoute, browserHistory, Redirect} from 'react-router';
import {Provider} from 'react-redux';
import Layout from './components/layout/layout.jsx';
import HomePageContainer from './containers/homePageContainer.jsx';
import SearchPageContainer from './containers/searchPageContainer.jsx';
import configureStore from './store/configureStore.jsx';
import BroadcastDetailContainer from './containers/broadcastDetailContainer.jsx';
import GA from './components/GA.jsx';
//import ManualGA from './components/GA.jsx';
import ReactGA from 'react-ga';
/////////-- Static Pages --///////////
import PrivacyPolicyContainer from './containers/privacyPolicyContainer.jsx';
import PrivacyPolicyforwebContainer from './containers/privacyPolicyforwebContainer.jsx';
import TermsofServiceContainer from './containers/termsOfService.jsx';
import TermsofServiceforwebContainer from './containers/termsofServiceforwebContainer.jsx';
import NotFoundPage from './containers/notFoundPage.jsx';

require(""./stylesheets/customResponsive.css"");
require(""./stylesheets/customStyle.css"");
require(""./stylesheets/videojs.css"");

ReactGA.initialize('UA-96791297-3');
GA(ReactGA);
//ManualGA(ReactGA);


/////////-- End Static Pages --///////////

const store = configureStore();

function fireTracking() {
    ReactGA.pageview(window.location.pathname);
}

render
(
    &lt;Provider store={store}&gt;
        &lt;Router onUpdate={fireTracking} history={browserHistory}&gt;
            &lt;Route component={Layout}&gt;
                &lt;Redirect from='/' to='/home'/&gt;
                &lt;Route path=""/home"" component={HomePageContainer}/&gt;
                &lt;Route path=""/search"" component={SearchPageContainer}/&gt;
                &lt;Route path=""/broadcast/:broadcastId"" component={BroadcastDetailContainer}/&gt;
                &lt;Route path={""/privacy-policy""} component={PrivacyPolicyContainer}/&gt;
                &lt;Route path={""/privacy""} component={PrivacyPolicyforwebContainer}/&gt;
                &lt;Route path={""/terms-of-service""} component={TermsofServiceContainer}/&gt;
                &lt;Route path={""/tos""} component={TermsofServiceforwebContainer}/&gt;
                &lt;Route path=""*"" component={NotFoundPage} /&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;,
    document.getElementById('container')
);
</code></pre>

<p>In <code>videoPlayer.jsx</code> I am getting the abbove error at</p>

<pre><code>if (this.player.play()) {
  GA.ManualGA(playerTarget);
}
</code></pre>
","7184879","","5025116","","2017-07-10 01:24:04","2017-07-10 01:24:04","reactjs Target container is not a DOM element error","<reactjs>","0","3","","",""
"42287756","1","","","2017-02-17 01:22:48","","0","1896","<p>I have a component that looks like this:</p>

<pre><code>class ThingView extends Component {
    constructor(props) {
        super(props)
    }
    componentWillMount() {
        this.props.loadThingThenFrames(this.props.id)
    }
    componentDidUpdate(prevProps) {
        console.log(""did update"")
        if (prevProps.id !== this.props.id) {
            this.props.loadThingThenFrames(this.props.id)
        }
    }
    render() {
        return (
            &lt;div className=""container""&gt;
                { this.props.isRequesting ? &lt;p&gt;Loading thing...&lt;/p&gt; : null}
                &lt;h1&gt; {this.props.thing ? this.props.thing.device_id : ""Thing Not Found""} &lt;/h1&gt;
                &lt;Timeline frames={this.props.frames} /&gt;
            &lt;/div&gt;
        )
    }
}

const mapStateToProps = (state, ownProps) =&gt; ({
    thing: state.thingView.thing,
    frames: state.thingView.frames,
    id: ownProps.params.id,
    isRequesting: state.thingView.isRequesting,
    requestError: state.thingView.requestError
})

const mapDispatchToProps = (dispatch) =&gt; ({
    loadThingThenFrames: (id) =&gt; { dispatch(loadThingThenFrames(id)) }
})
</code></pre>

<p>This component is rendered when <code>things/:id</code>. According to the <a href=""https://github.com/ReactTraining/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow noreferrer"">react-router docs</a>, <code>componentDidUpdate</code> gets called when the props are changed, for example when a thing is selected from a list of things. I want to <code>loadThingThenFrames</code> when the page is refreshed, or if someone leaves <code>ThingView</code> and then comes back to <code>ThingView</code> with the same <code>thing</code>. Currently, this doesn't happen since the previous <code>props.id</code> is the same as the current <code>props.id</code> if I remove this check, then there's an infinite loop of props getting updated and <code>componentDidUpdate</code> being called.</p>
","896112","","","","","2017-02-18 08:22:48","Refreshing in react router, component lifecycle","<reactjs><redux><react-router>","1","0","1","",""
"34677234","1","","","2016-01-08 12:32:04","","4","3103","<p>i am making VideoPlayer react component with jwpalyer and i am using webpack es6 for loading module
webpack support npm module loading &amp; there is no npm for jwplayer</p>

<p>so am trying to include jwplayer.js using es6 import but it giving me error 
ReferenceError: window is not defined</p>

<p>so any one can help me to properly setup jwplayer with webpack</p>

<pre><code>  import React, { PropTypes, Component } from 'react';
  import $ from 'jquery';
  import Player from ""./lib/jwplayer/jwplayer.js"";
  import styles from './VideoPayer.css';
  import withStyles from '../../decorators/withStyles';
  import Link from '../Link';

  @withStyles(styles)
  class VideoPlayer extends Component {

    static propTypes = {
      className: PropTypes.string,
    };

    static defaultProps = {
      file: '',
      image: ''
    };

    constructor(props) {
      super(props);
      this.playerElement = document.getElementById('my-player');
    }


    componentDidMount() {
      if(this.props.file) {
        this.setupPlayer();
      }
    }

    componentDidUpdate() {
      if(this.props.file) {
        this.setupPlayer();
      }
    }

    componentWillUnmount() {
       Player().remove(this.playerElement);
    }

    setupPlayer() {
      if(Player(this.playerElement)) {
        Player(this.playerElement).remove();
      }

      Player(this.playerElement).setup({
        flashplayer: require('./lib/player/jwplayer.flash.swf'),
        file: this.props.file,
        image: this.props.image,
        width: '100%',
        height: '100%',
      });
    }

    render() {
      return (
        &lt;div&gt;
          &lt;div id=""my-player"" className=""video-player""&gt;&lt;/div&gt;
        &lt;/div&gt;
      )
    }
  }

export default VideoPlayer;
</code></pre>
","1353052","","","","","2018-06-16 06:50:41","Proper way to implement jwplayer in react component using webpack (react-starter-kit)","<reactjs><jwplayer><webpack><jwplayer6><es6-module-loader>","2","0","1","",""
"50054411","1","50055431","","2018-04-27 02:37:41","","0","776","<p>I'm confused about the new lifecycle of react 16, getDerivedStateFromProps use case. Take below code for example, getDerivedStateFromProps is not needed at all since I can achieve what I want with componentDidUpdate.</p>

<pre><code>export class ComponentName extends Component {
  //what is this for?
  static getDerivedStateFromProps(nextProps, prevState) {

    if (nextProps.filtered !== prevState.filtered &amp;&amp; nextProps.filtered === 'updated') {
      return {
        updated: true //set state updated to true, can't do anything more?
      };
    }

    return null;

  }

  componentDidUpdate(prevProps, prevState) {
    if(prevProps.filtered !== this.state.filtered &amp;&amp; this.state.filtered === 'updated'){
      console.log('do something like fetch api call, redirect, etc..')
    }
  }

  render() {
    return (
      &lt;div&gt;&lt;/div&gt;
    );
  }
}
</code></pre>
","9472172","","","","","2018-04-27 04:49:44","Why use getDerivedStateFromProps when you have componentDidUpdate?","<javascript><reactjs><ecmascript-6>","2","0","","",""
"42402234","1","","","2017-02-22 21:03:20","","0","466","<p>I want to make a simple video chat on <code>react.js</code> and <code>WebRTC</code>. But in line <code>pc.addStream(localStream)</code> error occurs:</p>

<blockquote>
  <p>TypeError: Argument 1 of RTCPeerConnection.addStream is not an object.</p>
</blockquote>

<p>And I don't understand why I can't see the log in the line:</p>

<p><code>pc.onicecandidate = (e)=&gt;{
   console.log('onicecandidate');</code></p>

<p>That is all code:    </p>

<pre><code>class App extends Component {
  constructor(props) {
    super(props);
  }
  componentDidUpdate(){
    loadScript(""https://webrtc.github.io/adapter/adapter-latest.js"");
    let localVideo, remoteVideo, peerConnection, localStream;
    $('#start').on('click', ()=&gt;{ start(true) });

    let id = uuid();
    localVideo = document.getElementById('localVideo');
    remoteVideo = document.getElementById('remoteVideo');


    if(navigator.mediaDevices.getUserMedia) {
       navigator.mediaDevices.getUserMedia( { video:true, audio:true}).then( ( stream )=&gt; {
          localStream = stream;
          localVideo.src = window.URL.createObjectURL(stream);
       }).catch(errorHandler);
   }else{ alert('Your browser does not support getUserMedia API'); }

   function start(isCaller) {
      peerConnection = new RTCPeerConnection( { 'iceServers':  [{'urls': 'stun:stun.services.mozilla.com'}, {'urls': 'stun:stun.l.google.com:19302'},]});
      peerConnection.onicecandidate = ( e ) =&gt; {
        if(e.candidate != null) {
           Meteor.call('addMsgRtc', JSON.stringify({'ice': e.candidate, '_id':id}), id);
        }
     };
      peerConnection.onaddstream = ( e )=&gt;{
         remoteVideo.src = window.URL.createObjectURL(e.stream);
      };
      peerConnection.addStream(localStream);
      if(isCaller) { 
        peerConnection.createOffer().then(
          createdDescription).catch(errorHandler);
      }
   }
   if (!this.props.loadingRtc) {
      for(let i of this.props.messagesRtc){        
        if(!peerConnection) start(false);
        let signal = JSON.parse(i.text);
        if(signal._id == id) return;
        if(signal.sdp) {
             peerConnection.setRemoteDescription(new   RTCSessionDescription(signal.sdp)).then(()=&gt; {
            if(signal.sdp.type == 'offer') {             peerConnection.createAnswer().then(createdDescription).catch(errorHandler);
            }
        }).catch(errorHandler);
      }else if(signal.ice) {
        peerConnection.addIceCandidate(new RTCIceCandidate(signal.ice)).catch(errorHandler);
      }
    }
  }


  function createdDescription(description) {
    peerConnection.setLocalDescription(description).then(()=&gt; {        
       Meteor.call('addMsgRtc', JSON.stringify({'sdp':peerConnection.localDescription, '_id':id}), id);
    }).catch(errorHandler);
  }
  function errorHandler(error) { console.log(error); }
}

  }
  render() {
    return (
        &lt;div id=""container""&gt;
          &lt;video id=""localVideo"" autoPlay muted style={{width:""40%""}}&gt;&lt;/video&gt;
          &lt;video id=""remoteVideo"" autoPlay style={{width:""40%""}}&gt;&lt;/video&gt;
          &lt;br/&gt;
        &lt;/div&gt;
    );
  }
}

export default createContainer( ()=&gt; {
  const subscriptionRtc = Meteor.subscribe('rtc');
  const loadingRtc = !subscriptionRtc.ready();
  return {
    loadingRtc:loadingRtc,
    messagesRtc: msgRtc.find().fetch(),
  };
}, App);
</code></pre>
","2529221","","2529221","","2017-02-24 12:48:49","2017-02-24 12:57:04","react.js and WebRTC RTCPeerConnection.addStream is not an object","<javascript><node.js><reactjs><meteor><webrtc>","1","0","1","",""
"42916045","1","42916252","","2017-03-20 23:50:17","","3","2359","<p>I would like to know if a React component's lifecycle method <code>componentDidUpdate</code> gets executed after all of the children's <code>render</code> methods have finished, or right after the <code>render</code> method for that component is called.</p>

<p>Since the reconciler recursively calls <code>render</code> method to update the view, I have a hunch that <code>componentDidUpdate</code> gets executed after all children of a component has been re-rendered, but there was not enough information in the <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">documentation</a>. When exactly is <code>componentDidUpdate</code> called?</p>
","3958148","","5647260","","2017-04-03 20:26:36","2017-04-03 20:26:36","Does componentDidUpdate run after all children have been updated?","<reactjs>","2","3","1","",""
"42971806","1","42971959","","2017-03-23 09:21:26","","5","2240","<p>Is componentDidUpdate suppose to fire when I change routes using react-router? I modified the example code and can't seem to get it to work.</p>

<p>I made the home component log some text but it isn't firing it seems. Any help is appreciated, thanks!</p>

<p>Code:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';
import {
    BrowserRouter as Router,
    Route,
    Link
} from 'react-router-dom'

const BasicExample = () =&gt; (
    &lt;Router&gt;
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;Link to=""/""&gt;Home&lt;/Link&gt;&lt;/li&gt;
                &lt;li&gt;&lt;Link to=""/about""&gt;About&lt;/Link&gt;&lt;/li&gt;
                &lt;li&gt;&lt;Link to=""/topics""&gt;Topics&lt;/Link&gt;&lt;/li&gt;
            &lt;/ul&gt;

            &lt;hr/&gt;

            &lt;Route exact path=""/"" component={Home}/&gt;
            &lt;Route path=""/about"" component={About}/&gt;
            &lt;Route path=""/topics"" component={Topics}/&gt;
        &lt;/div&gt;
    &lt;/Router&gt;
)

class Home extends React.Component {
    render() {
        return (&lt;div&gt;
            &lt;h2&gt;Home&lt;/h2&gt;
        &lt;/div&gt;);
    }

    componentDidUpdate() {
        console.log(""Updated!"");
    }
}


const About = () =&gt; (
    &lt;div&gt;
        &lt;h2&gt;About&lt;/h2&gt;
    &lt;/div&gt;
)

const Topics = ({ match }) =&gt; (
    &lt;div&gt;
        &lt;h2&gt;Topics&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;Link to={`${match.url}/rendering`}&gt;
                    Rendering with React
                &lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;Link to={`${match.url}/components`}&gt;
                    Components
                &lt;/Link&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;Link to={`${match.url}/props-v-state`}&gt;
                    Props v. State
                &lt;/Link&gt;
            &lt;/li&gt;
        &lt;/ul&gt;

        &lt;Route path={`${match.url}/:topicId`} component={Topic}/&gt;
        &lt;Route exact path={match.url} render={() =&gt; (
            &lt;h3&gt;Please select a topic.&lt;/h3&gt;
        )}/&gt;
    &lt;/div&gt;
)

const Topic = ({ match }) =&gt; (
    &lt;div&gt;
        &lt;h3&gt;{match.params.topicId}&lt;/h3&gt;
    &lt;/div&gt;
)

ReactDOM.render(
  &lt;BasicExample /&gt;,
  document.getElementById('root')
);
</code></pre>
","6601606","","5185595","","2018-03-30 12:56:13","2018-04-30 19:29:52","componentDidUpdate is not firing","<reactjs><react-router>","2","0","1","",""
"43845980","1","43847914","","2017-05-08 11:02:18","","1","190","<p>where to write axios post request to insert todo into database.If I write axios post request in componentDidUpdate() whenever click on checkbox for todo_completed status it will insert in database. duplicate record maintains fro true and false. i dont understand where to call post request in todoApp.jsx
Here is my Code
todoapp.jsx</p>

<pre><code>    var React = require('react');
    var TodoSearch = require('TodoSearch');
    var AddTodo = require('AddTodo');
    var TodoList = require('TodoList');
    var axios= require('axios');
    var TodoApp=React.createClass({
        getInitialState:function(){
            return{
                todo_completed:false,
                strSearchText:'',
                todos:[]

            };
        },
        componentDidMount:function(){
            var that=this;
            axios.post('/displaytodo').then(function (response){
                console.log(""display"");
                var todos=response.data;
                console.log(todos);
                that.setState({
                    todos:response.data
                });
            }).catch(function (error){
                console.log(error);
            });

        },
        componentDidUpdate:function(){
            var todo_text="""";
            var todo_completed="""";
            this.state.todos.forEach(function(todo){
                todo_text= todo.todo_text;
                todo_completed=todo.todo_completed;
            });
//insert todo in database
            axios.post('/addtodo',{
                todo_text:todo_text,
                todo_completed:todo_completed

            }).then(function (response) {

                console.log(""data"");
            }).catch(function (error) {
                console.log(error);
            });
            },
        handleAddTodo:function(todo_text){
            alert(""new todo ""+todo_text);
                    //insert query needed to add todo
             this.setState({
                todos:[
                ...this.state.todos,
                {
                    todo_text:todo_text,
                    todo_completed:false    
                }
                ]
             });
                },
        handleToggle:function(todo_id){
            var updatedTodos=this.state.todos.map((todo)=&gt;{
                if(todo.todo_id===todo_id){
                    todo.todo_completed=!todo.todo_completed;
                }
                return todo;
            });
            //update query required for completed status
            this.setState({
                todos:updatedTodos
            })
            //alert(id);
        },
        handleSearch:function(boolShowCompleted,strSearchText){
            this.setState({
                boolShowCompleted:boolShowCompleted,
                strSearchText:strSearchText.toLowerCase()

            });
        },
        render:function(){
            var urlValue = this.props.params.sessionValue;
            console.log(urlValue);
            var {todos}=this.state;
            return(
                &lt;div&gt;
                    {urlValue}
                    &lt;TodoSearch onSearch={this.handleSearch}/&gt;
                    &lt;TodoList todos={todos} onToggle={this.handleToggle}/&gt;
                    &lt;AddTodo onAddTodo={this.handleAddTodo}/&gt;
                &lt;/div&gt;
                )
        }
    });
    module.exports=TodoApp;
</code></pre>

<p><strong>AddTodo.jsx</strong></p>

<pre><code> var AddTodo = React.createClass({
             handleSubmit: function(e) {
                 e.preventDefault();
                 var strTodoText = this.refs.strTodoText.value;
                 if (strTodoText.length &gt; 0) {
                     this.refs.strTodoText.value = '';
                     this.props.onAddTodo(strTodoText);
                 } else {
                     this.refs.strTodoText.focus();
                 }
             },
             render: function() {

                     return ( &lt; div &gt;
                                 &lt; form onSubmit = { this.handleSubmit } &gt; 

                                 &lt; input type = ""text""  ref = ""strTodoText"" / &gt; 
                                 &lt; button className = ""button"" &gt; Add Todo &lt; /button&gt; 
                                 &lt;/form &gt; Add todo..... 
                              &lt; /div&gt;
                            )
             } 
 });
</code></pre>
","7951426","","5928186","","2017-05-08 12:35:08","2017-05-09 09:03:27","where to insert my todo in reactJs using axios post request?","<reactjs><axios>","1","4","","",""
"50099537","1","","","2018-04-30 11:24:05","","0","14","<p>I'm working on a camera app using react-native-camera (specifically RCTCamera, since RNCamera is missing features I need), and I'm switching between the front and back cameras.</p>

<p>I need the camera view to start at a certain zoom level, and there's no problem with that the first time the app is opened. However, when I switch from one camera type to the other, the next camera will have a zoom level of 0, even though the zoom prop is not 0.</p>

<p>Calling setZoom() as part of switching types does not work, and throws an exception about not being able to connect to the camera service. This also goes for if I try calling setZoom() in componentDidUpdate(), even though calling setZoom() when the component isn't updating or doing anything works just fine. Right now I'm getting around this by putting setZoom() on a delay, but it's not exactly ideal.</p>

<p>How can I preserve the zoom level between camera types and ensure that when the new camera renders it will have the right zoom level I want?</p>
","9172346","","","","","2018-04-30 11:24:05","Preserving zoom level between react-native-camera types","<react-native><react-native-android><react-native-camera>","0","0","","",""
"43778512","1","","","2017-05-04 09:08:12","","0","51","<p>If have a react js view with a long list of items. After rendering I want to select a certain list item via ref and scroll it into the view to make it visible to the user. At the moment I need a timeout, because that certain item has not been created in the dom on componentDidUpdate. How can I achieve the scroll into the view without a timeout?</p>

<p>React</p>

<pre><code> componentDidUpdate() {

  const that = this;

  setTimeout(function() {
    that.refs.itemSelected.scrollIntoView();
  }, 1000);

 },
</code></pre>
","2204835","","","","","2017-05-04 09:08:12","How to sroll list item into view after componentDidUpdate?","<javascript><reactjs>","0","5","1","",""
"51214269","1","","","2018-07-06 16:17:03","","0","19","<p>I am trying to view an InfoWindow everytime the maps is clicked, it will show an input field and a button to add the named location to list. For now, I am just trying to get the text out of the form, the problem that I am having is how to access the form when the button is clicked???!</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import ReactDOM from 'react-dom';
import PopUpForm from './PopUpForm';
import ReactDOMServer from 'react-dom/server'

class Map extends React.Component {
  
  state = {
      infowindow: new google.maps.InfoWindow({}),
  }

  componentDidUpdate(prevProps, prevState) {
    console.log('componentDidUpdate');
    if (prevProps.google !== this.props.google) {
      this.loadMap();
    }
  }

  componentDidMount() {
    console.log('componentDidMount');
    this.loadMap();
  }

  loadMap() {
    console.log('loadMap');
    if (this.props &amp;&amp; this.props.google) {
      // google is available
      const {google} = this.props;
      const maps = google.maps;

      const mapRef = this.refs.map;
      const node = ReactDOM.findDOMNode(mapRef);

      const {initialCenter, zoom} = this.props;
      const {lat, lng} = initialCenter;
      const center = new maps.LatLng(lat, lng);
      const mapConfig = Object.assign({}, {
        center,
        zoom
      })
      this.map = new maps.Map(node, mapConfig);

      // adding markers for corresponding saved places
      const pos = {lat: 59.329113196988345 , lng: 17.966015144369067};
      const marker = new google.maps.Marker({
        position: pos,
        map: this.map,
        title: 'first marker',
      });
      const infowindow = new google.maps.InfoWindow({
        content: `&lt;h3&gt;${marker.title}&lt;/h3&gt;`
      });
      marker.addListener('click', () =&gt; {
        infowindow.open(this.map, marker);
      });

      // pop up  infoWindoW on map
      this.map.addListener('click', (e) =&gt; {
        this.state.infowindow.close();
        const popUp = &lt;PopUpForm onSubmit={this.onSubmit}/&gt;;
        this.showPopupOnMap(e.latLng, popUp);
        google.maps.event.addListener(this.state.infowindow, 'domready', () =&gt; {
          // HOW TO ACCESS THE FORM HERE
        });
      })
      this.forceUpdate();
    }      
}

onSubmit = () =&gt; {
  e.preventDefault();
  window.alert('onSubmit form')
}

showPopupOnMap = (latLng, popUp) =&gt; {
  const contentString = ReactDOMServer.renderToString(popUp)

  const pos = { lat: latLng.lat(), lng: latLng.lng() };

  this.state.infowindow = new google.maps.InfoWindow({
    content: contentString,
    position: pos
  });
  this.state.infowindow.open(this.map)
}

renderChildren() {
  console.log('renderChildren');
  const {children} = this.props;
  if (!children) return;
  return React.Children.map(children, c =&gt; {
    return React.cloneElement(c, {
      map: this.map,
      google: this.props.google,
    });
  })
}

render() {
  console.log('render');
    const style = {
      width: '70vw',
      height: '70vh'
    }

    return (
      &lt;div  ref=""map"" style={style}&gt;
        loading map...
        {this.renderChildren()}
      &lt;/div&gt;
    )
  }
};

Map.defaultProps = {
  zoom: 11,
  initialCenter: {
    lat: 59.3293,
    lng: 18.0686
  }
}

export default Map;</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';

class PopUpForm extends React.Component {
    render() {
        return (
            &lt;div id='iwc' ref='iwc' &gt;
                &lt;b&gt;Add this location&lt;/b&gt;&lt;br /&gt;
                &lt;form ref='mapform' className='map-form' onSubmit={this.onSubmit}&gt;
                    &lt;input type='text' /&gt;
                    &lt;button id='btn'&gt;Add&lt;/button&gt;
                &lt;/form&gt;
            &lt;/div&gt;
        );
    }
}

export default PopUpForm;</code></pre>
</div>
</div>
</p>

<p>inside of this.map.addListner(this.state.infoWindow, 'domready', someFunctionToBeCalled) I do not know how to acces the form in React, I searched about it all I could found is this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>google.maps.event.addListener(info, 'domready', function() {
    document.id(""map-form"").addEvent(""submit"", function(e) {
        e.stop();
        console.log(""hi!"");
    });
});</code></pre>
</div>
</div>
</p>

<p>is this even possible? Am I missing something??</p>
","7463649","","","","","2018-07-07 07:48:19","How to access a form inside InfoWindow content in React using Google maps api and google-maps-react V2.0.2","<reactjs><google-maps><google-maps-api-3><infowindow><google-maps-react>","1","0","","",""
"48156833","1","","","2018-01-08 19:23:48","","0","63","<p>I am struggling to figure out why a change to an object located in the store handled by a redux reducer is not triggering the <code>componentDidUpdate</code> method inside of my react component.  I am using the react developer tools and can see the correct store after the state is reduced, and am also using redux logger and can see the correct after state after the reducer makes the change.  But the component still never calls the update method.</p>

<p><strong>action</strong></p>

<pre><code>export const GSAP_ANIMATION = 'GSAP_ANIMATION';
export const animateGsap = (key, next) =&gt; {
  return {
    type: GSAP_ANIMATION,
    payload: {
      key: key,
      next: next
    }
  }
}
</code></pre>

<p><strong>reducer</strong></p>

<pre><code>case GSAP_ANIMATION:
  return Object.assign({}, state, {
    ...state,
    gsap: {
      ...state.gsap,
      [payload.key]: {
        ...state.gsap[payload.key],
        next: {
          ...payload.next
        }
      }
    }
  });
</code></pre>

<p><strong>component connection</strong></p>

<pre><code>const mapStateToProps = (state, ownProps) =&gt; {
  return {
    component: state.priorities.gsap[ownProps.id]
  };
}

const mapDispatchToProps = (dispatch) =&gt; {
  return {
    addGsap: (key) =&gt; dispatch(actions.addGsap(key))
  };
}

GsapComponent = connect(mapStateToProps, mapDispatchToProps)(GsapComponent);
</code></pre>

<p>In the GsapComponent I have the <code>componentDidUpdate</code> method, but this method is never called.  However, I can see that the value of <code>this.props.component</code> should be correct when I view the component in the chrome extension.</p>

<p><strong>edit</strong></p>

<p>also doing <code>{ JSON.stringify(this.props.component) }</code> correctly shows the updated prop values.  Nothing in the react component update lifecycle is every triggered though. </p>

<p>I have also tried to use the immutibility-helper from react like so</p>

<pre><code>return update(state, {
    gsap: {
      [payload.key]: {
        $merge: { next: payload.next }
      }
    }
  });
</code></pre>

<p>but it still doesn't call the lifecycle method.</p>

<p><a href=""https://gist.github.com/kyle-mccarthy/00f29f0789d3b40f52f9ff438822e038"" rel=""nofollow noreferrer"">GsapComponent source code</a>.</p>
","1804656","","1804656","","2018-01-08 20:32:01","2018-01-08 20:32:01","Redux change to nested object not triggering componentDidUpdate in component","<reactjs><redux><react-redux>","1","7","","",""
"41333324","1","","","2016-12-26 15:37:49","","0","186","<p>I have recently implemented ReactTransitionsGroup to animate all my page transitions using react router (Velocty component is just a wrapper of ReactTransitionsGroup, so in practice is the same): </p>

<pre><code>render () {
        return (
            &lt;div className=""app-layout""&gt;
                &lt;NavBar location={this.props.location} /&gt;
                &lt;VelocityTransitionGroup enter={{ animation: 'pageTransitionIn' }} leave={{ animation: 'pageTransitionOut' }}&gt;
                    {React.cloneElement(this.props.children, {
                        key: this.props.location.pathname,
                    })}
                &lt;/VelocityTransitionGroup&gt;
                &lt;TimeOutModal /&gt;
                &lt;Notifications /&gt;
            &lt;/div&gt;
        );
    }
</code></pre>

<p>In my signup form, I have a a form component that once the signup request has successfully responded, the props will update and the component will trigger a redirect to the next signup step.</p>

<pre><code>class SignUp extends Component {

    componentDidUpdate () {
        if (this.props.signup.success) {
            hashHistory.push('/confirm-signup')
        }
    }

    render() {//....//}

}
</code></pre>

<p>The problem is, once the redirect is triggered I enter in a infinite loop, since the ReactTransitionsGroup makes the component stay for a few miliseconds, triggering the redirect again. </p>

<p>I manage to ""fix"" it, using a setTimeout on the redirect, but I don't find this solution really elegant:</p>

<pre><code>componentDidUpdate () {
        if (this.props.signup.success) {
            setTimeout(() =&gt; {
                hashHistory.push('/confirm-signup')
            }, 500)
        }
    }
</code></pre>

<p>Do you find any other solutions to this issue?</p>

<p>Thanks in advance!</p>
","3971290","","","","","2016-12-26 20:29:15","Infinite loop when triggering redirect from componentDidUpdate using ReactTransitionsGroup","<javascript><reactjs><redirect><react-router>","1","0","","",""
"49931010","1","","","2018-04-19 22:15:19","","0","49","<p>******** EDITED TO SIMPLIFY EXAMPLE AND CLARIFY REQUIREMENT AND PROBLEM **********</p>

<p>I'm stumped with this one, I hope someone can help.</p>

<p>I have a nav bar that I need to run a function on to add .active classes to li elements if they have descendants of a.active.</p>

<p>The menu system is a React component: -</p>

<pre><code>import React, {Component} from ""react"";
import { Link, NavLink } from 'react-router-dom'

import {activateMenu} from './ActivateMenu'

class SidebarMenu extends React.Component {

  componentDidMount() {
    activateMenu()
  }

  componentDidUpdate() {
    activateMenu()
  }

  render() {

    const renderNavLink = (to, text, icon, renderArrow = false) =&gt; {
      return(
        &lt;NavLink to={to}&gt;
          &lt;i className=""bullet""&gt;{icon}&lt;/i&gt;
          &lt;span&gt;{text}&lt;/span&gt;
          {renderArrow ? &lt;span className=""pull-right-container""&gt;
                &lt;i className=""angle-left""&gt;&lt;FaAngleLeft /&gt;&lt;/i&gt;
              &lt;/span&gt; : null}
        &lt;/NavLink&gt;
      )
    }

    return (
      &lt;ul className=""sidebar-menu"" data-widget=""tree""&gt;

        &lt;li className=""""&gt;
          {renderNavLink('/','Home',&lt;FaHome /&gt;)}
        &lt;/li&gt;

        &lt;li className=""treeview""&gt;
          {renderNavLink(""#"",'Users',&lt;FaGroup /&gt;, true)}
          &lt;ul className=""treeview-menu""&gt;
            &lt;li&gt;
              {renderNavLink(userSearchSlug,'Search',&lt;FaSearch /&gt;)}
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;button onClick={activateMenu}&gt;Press Me&lt;/button&gt;
      &lt;/ul&gt;
    )
  }
}

export default SidebarMenu
</code></pre>

<p>This will give me an HTML structure like this: -</p>

<pre><code>&lt;ul class=""sidebar-menu tree"" data-widget=""tree""&gt;
  &lt;li class=""treeview""&gt;
    &lt;a href=""#""&gt;
      &lt;i class=""fa fa-dashboard""&gt;&lt;/i&gt; &lt;span&gt;Links&lt;/span&gt;
      &lt;span class=""pull-right-container""&gt;
            &lt;i class=""fa fa-angle-left pull-right""&gt;&lt;/i&gt;
        &lt;/span&gt;
    &lt;/a&gt;
    &lt;ul class=""treeview-menu""&gt;
      &lt;li&gt;
        &lt;a href=""/link1""&gt;&lt;i class=""fa fa-circle-o""&gt;&lt;/i&gt; Link1&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=""/link2""&gt;&lt;i class=""fa fa-circle-o""&gt;&lt;/i&gt; Link2&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>After React has rendered the HTML, I need to trigger a click event on the the .treeview > a node if any a.active nodes are found under .treeview-menu. So: -</p>

<pre><code>&lt;li class=""treeview""&gt;
    &lt;a href=""#"" *****TRIGGER CLICK EVENT*****&gt;
        &lt;i class=""fa fa-dashboard""&gt;&lt;/i&gt; &lt;span&gt;Links&lt;/span&gt;
        &lt;span class=""pull-right-container""&gt;
            &lt;i class=""fa fa-angle-left pull-right""&gt;&lt;/i&gt;
        &lt;/span&gt;
    &lt;/a&gt;
    &lt;ul class=""treeview-menu""&gt;
        &lt;li&gt;
            &lt;a href=""/link1""&gt;&lt;i class=""fa fa-circle-o *****.ACTIVE CLASS HERE****""&gt;&lt;/i&gt; Link1&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a href=""/link2""&gt;&lt;i class=""fa fa-circle-o""&gt;&lt;/i&gt; Link2&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/li&gt;
</code></pre>

<p>activeMenu() looks like this: -</p>

<pre><code>$('ul.sidebar-menu li.treeview:not(.menu-open)').has('a.active').find('a').trigger( ""click"" );
</code></pre>

<p>This function works when called from onClick() from a button on the page but it is not working in componentDidMount() and componentDidUpdate(). The function will run (tested with console.log() but not affect the HTML as it should. However, if I run it from a Button, it works perfectly. It also works perfectly when HMR runs.</p>

<p>I've no idea why this is happening. Does anyone have any ideas?</p>
","2075602","","2075602","","2018-04-20 21:35:27","2018-04-20 21:35:27","ReactJS - valid function not working when called in componentDidMount() and componentDidUpdate()","<javascript><reactjs><adminlte>","1","0","","",""
"41162586","1","41164238","","2016-12-15 11:04:21","","2","1144","<p>I'd like to add some ""logic-component"" to the top level of my scenes.</p>

<p>i.e I got that:</p>

<pre><code>&lt;Router&gt;
    &lt;Scene key=""root"" hideNavBar={true}&gt;
        &lt;Scene key=""home"" component={HomeContainer} /&gt;
        &lt;Scene key=""search"" component={SearchContainer} /&gt;
        &lt;Scene key=""list"" component={ListContainer} /&gt;
        ...
    &lt;/Scene&gt;
&lt;/Router&gt;
</code></pre>

<p>Each container is connected to Redux, using connect()(), and each got its own reducer that only itself need.</p>

<p>i.e:</p>

<pre><code>export default connect(mapStateToProps, mapDispatchToProps)(HomeContainer)
</code></pre>

<p>So, what I'd need to do is to connect the ""root"" Scene to Redux and give it its general reducer (the one that also all the other scenes depends on).
But with that, I want to use componentDidUpdate, componentWillReceiveProps, ... to listen to, i.e Netinfo when the connection changes, to update the reducer's state.</p>

<p>I'm not sure whether it's clear or not, I hope it is. If you need more informations just ask them.</p>

<p>Thanks for the help</p>

<p><strong>Solution</strong></p>

<p>Look at atlanteh's answer, and look at the docs it says everything needed :) 
<a href=""https://github.com/aksonov/react-native-router-flux/tree/master/docs"" rel=""nofollow noreferrer"">https://github.com/aksonov/react-native-router-flux/tree/master/docs</a></p>

<p>My final solution where everything works as expected is:</p>

<pre><code>const ConnectedRouter = connect()(Router)

const scenes = Actions.create(
    &lt;Scene key=""root"" hideNavBar={true}&gt;
        &lt;Scene key=""home"" component={HomeContainer} /&gt;
    &lt;/Scene&gt;
)

class ReduxRouter extends Component {
  componentWillReceiveProps(newProps) {
      if(!newProps.isConnected) {
          // logic
      }
  }
  render() {
    return (
      &lt;ConnectedRouter scenes={scenes} {...this.props}/&gt;
    )
  }
}

const mapStateToProps = (state) =&gt; {
  return {
    // State
  }
}

const mapDispatchToProps = (dispatch) =&gt; {
  return bindActionCreators({
    // Actions
  }, dispatch);
}

export default connect(mapStateToProps, mapDispatchToProps)(ReduxRouter);
</code></pre>

<p>It's basically a mix of everything I tried before and It works great! No ""Key xxx is already defined"" or whatsoever.</p>
","5035410","","5035410","","2016-12-15 15:25:59","2016-12-15 15:25:59","Top level component root-Scene/Router react-native-router-flux","<javascript><reactjs><react-native><react-native-router-flux>","2","0","","",""
"41886929","1","41887354","","2017-01-27 04:22:31","","0","35","<p>I'm now convinced I am doing this wrong based on the fact that my app doesn't show the menu unless I open dev tools..</p>

<p>On my landing page, I have a menu bar that has the app name/logo as well as menu items and a log in button in my webapp, like this:
<a href=""https://i.stack.imgur.com/ooayP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ooayP.png"" alt=""landing page menu""></a></p>

<p>I've added that by having my <code>main.html</code> file contain:</p>

<pre><code>&lt;div id=""render-target""&gt;
    &lt;div id=""header-container""&gt;&lt;/div&gt;
    &lt;div id=""app-container""&gt;&lt;/div&gt;
    &lt;div id=""footer-container""&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>and my <code>main.jsx</code> file's <code>render()</code> function look like this:</p>

<pre><code>render(
    &lt;div className='container'&gt;
        &lt;div id=""header-container""&gt;
            &lt;MenuBar /&gt;
        &lt;/div&gt;

        &lt;div id=""app-container""&gt;
            &lt;TableSelect /&gt;
        &lt;/div&gt;

        &lt;div id=""footer-container""&gt;
        // some footer code
        &lt;/div&gt;
    &lt;/div&gt;,
    document.getElementById('render-target'));
</code></pre>

<p>Now, the user can select a ""table"" and load the data from that, which takes them to a different view.</p>

<p>So, basically from the <code>TableSelect</code> view, the user clicks a checkbox and loads a <code>TableLoad</code> view, which loads a table for display (in a super not OK way probably, since it calls <code>ReactDOM.render(&lt;TableDisplay tableId={this.props.id}/&gt;,document.getElementById('app-container'));</code>)</p>

<p>Then, in the <code>TableDisplay</code> view I have </p>

<pre><code>componentDidUpdate() {
    ReactDOM.render(&lt;MenuBar currentView=""tableDisplay"" rows={this.props.rows} cols={this.props.cols} tableId={this.props.tableId} /&gt;, document.getElementById('header-container'));
}
</code></pre>

<p>which calls the <code>MenuBar</code> view with the current data properties (or rather, replaces the DOM). What I want to see is below, including the Edit button:</p>

<p><a href=""https://i.stack.imgur.com/q181P.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/q181P.png"" alt=""new menu""></a></p>

<p>This seems to only get triggered unreliably... (though without fail if I have Chrome Dev tools open). I think it's just taking some time for the state to pass and I only show the menu <code>if (this.state.currentView !== ""loadTable"" &amp;&amp; this.props.cols !== undefined &amp;&amp; this.props.rows !== undefined)</code>. </p>

<p>I guess I know that <code>ReactDOM.render</code> is not what I want here, but I want to show the menu even if I don't have column/row data and I need to pass the column/row data once I get it. It feels like a Menu shouldn't need data information, but in order to add data to the table I have to have that data somehow. </p>

<hr>

<p>It's really clear to me that I'm doing a lot of things the non-react way. My app is currently deployed at <a href=""https://ideal-engine.herokuapp.com"" rel=""nofollow noreferrer"">ideal-engine.herokuapp.com</a> and the code is at <a href=""https://github.com/adinutzyc21/ideal-engine/tree/master/compareApp"" rel=""nofollow noreferrer"">github repo</a>, if anyone who knows React and feels altruistic enough to do a code review let me know.</p>
","1646896","","","","","2017-01-27 05:17:26","I want my menu to update based on which view I'm on React (alternative to reactdom.render)","<javascript><html><reactjs><react-dom>","1","5","","",""
"43998643","1","43998894","","2017-05-16 10:15:37","","1","292","<p>I am currently making dashboards using reactjs in which there are 4 tabs or buttons charts are creating properly but only problem is that when we click on different dashboard and it has same chart in same pannel than chart is not updating i have used both componentDidMount() and componentDidUpdate though its giving proper output but its creating an infinite loop i have also applied some conditions but its still in infinite loop Can anyone help me??</p>

<p>here is my code</p>

<pre><code>class BarChartComponent extends React.Component 
{

   constructor(props) 
   {
      super(props);

      this.state = {
         data: null
      }
   };

   componentDidMount()
    {
            var that = this;
            $.ajax({
                    method: ""GET"",
                    url: ""http://10.0.3.8:8050/querydata?query_id=""+that.props.id,
                    success: function(data) 
                    {

                        console.log(""component did mount method called"");
                        console.log(1,JSON.stringify(data));
                        var BarChartData  = [
                        {
                            key: ""totals"",
                            values: []
                        }
                        ];
                        data.forEach(function (d)
                        {
                            d.value= +d.value
                            BarChartData[0].values.push(d)
                        }) 
                        console.log(2,JSON.stringify(BarChartData))
                        that.setState({data:BarChartData});
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown)
                    { 
                        console.error(""Status: "" + textStatus);
                        console.error(""Error: "" + errorThrown); 
                    }       
                });         
    }

    componentDidUpdate(prevProps, prevState)
    {
                if(prevState.data !== this.state.data )
                {
                    var that = this;
                    $.ajax({
                        method: ""GET"",
                        url: ""http://10.0.3.8:8050/querydata?query_id=""+that.props.id,
                        success: function(data) 
                        {

                            console.log(""component did update method called"");
                            var BarChartData  = [
                            {
                                key: ""totals"",
                                values: []
                            }
                            ];
                            data.forEach(function (d)
                            {
                                d.value= +d.value
                                BarChartData[0].values.push(d)
                            }) 

                            if( prevProps.id !== that.state.id )
                            {
                                that.setState({data:BarChartData});
                                console.log(3,JSON.stringify(BarChartData))
                                console.log(4,JSON.stringify(that.state.data))
                            }                   
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown)
                        { 
                            console.error(""Status: "" + textStatus);
                            console.error(""Error: "" + errorThrown); 
                        }       
                    });         

                }
    }



    render()
    {

        if (this.state.data==null)
        {
            return (&lt;h1&gt;Loading...&lt;/h1&gt;);
        }
        return (


             &lt;NVD3Chart type=""discreteBarChart"" datum={this.state.data} x=""name"" y=""value""/&gt;

        );
    }
}

window.BarChartComponent = BarChartComponent;
</code></pre>
","4646617","","","","","2017-12-18 12:48:37","How to break infinite loop in componentDidUpdate in reactjs","<javascript><ajax><reactjs>","2","0","1","",""
"43474815","1","","","2017-04-18 14:20:42","","1","113","<p>I have a react-redux application, in which i am trying to run test cases for a react component something like below: </p>

<pre><code>class Login extends Component {

  componentWillMount() {
    this.props.checkUserAuth();
  }

  componentDidMount() {
    this.props.getEnvConfig();
  }

  componentDidUpdate() {
    if (!this.props.isAuthenticating &amp;&amp; this.props.isAuthenticated) {
      hashHistory.push('/dashboard');
  }
}

getAbc() {
  return this.props.abc;
}

anotherLogin() {
  return () =&gt; {
    const anotherURL = `${this.props.envConfig.AuthUrl}?response_type=code&amp;client_id=${this.props.envConfig.ClientId}&amp;redirect_uri=${this.props.envConfig.CallbackUri}&amp;state=8.0`;
    /* global window */
    window.location.assign(anotherURL);
  };
}

  myLogin() {
    return () =&gt; {
      const loginUrl = `${this.props.envConfig.AuthUrl}?

     scope=urlScope&amp;client_id=${this.props.envConfig.ClientId}&amp;redirect_uri
        =${this.props.envConfig.RedirectUri}&amp;response_type=token`;
     /* global window */
     window.location.assign(loginUrl);
   };
 }

 render() {
   if (this.props.isAuthenticating &amp;&amp; !this.props.isAuthenticated) {
     return (&lt;div&gt;loading&lt;/div&gt;); // needs to implement and include loading 
     component
   } else if (!this.props.isAuthenticating &amp;&amp; !this.props.isAuthenticated) {
     return (
      &lt;Grid fluid=""true""&gt;
      &lt;Row&gt;
        &lt;Col md={6} bsClass=""xyz""&gt;
          &lt;div className=""left-login-container""&gt;
            &lt;LoginLeft
              logo={logo}
              box={box}
              abc={this.abc()}
            /&gt;
          &lt;/div&gt;
        &lt;/Col&gt;
        &lt;Col md={6} bsClass=""xyz""&gt;
          &lt;div className=""right-login-container""&gt;
            &lt;LoginRight
              myLogin={this.myLogin()}
              anotherLogin={this.anotherLogin()}
            /&gt;
           &lt;/div&gt;
         &lt;/Col&gt;
       &lt;/Row&gt;
     &lt;/Grid&gt;
    );
   }
   return null;
  }
 }

  Login.defaultProps = {
    abc: '0',
    getEnvConfig: () =&gt; {},
    envConfig: {
    sfdcAuthUrl: '',
    sfdcCallbackUri: '',
    sfdcClientId: '',
  },
  isAuthenticating: true,
  isAuthenticated: false,
  checkUserAuth: () =&gt; {},
 };

 Login.propTypes = {
    abc: PropTypes.string.isRequired,
    getEnvConfig: PropTypes.func.isRequired,
    envConfig: PropTypes.shape({
       AuthUrl: PropTypes.string.isRequired,
       CallbackUri: PropTypes.string.isRequired,
       ClientId: PropTypes.string.isRequired,
    }),
    isAuthenticating: PropTypes.bool.isRequired,
    isAuthenticated: PropTypes.bool.isRequired,
    checkUserAuth: PropTypes.func.isRequired,
  };

  function mapDispatchToProps(dispatch) {
     return {
       myLogin: (data) =&gt; {
         dispatch(myLogin(data));
       },
       getEnvConfig: () =&gt; {
         dispatch(getEnvConfig());
       },
       checkUserAuth: () =&gt; {
         dispatch(getUserInfo());
       },
     };
    }

    function mapStateToProps(state, ownProps) {
        return {
          abc: state.Login.Summary.Report,
          envConfig: state.EnvConfig.envConfig,
          isAuthenticating: state.Auth.isAuthenticating,
          isAuthenticated: state.Auth.isAuthenticated,
        };
     }

    export default connect(mapStateToProps, mapDispatchToProps)(Login);
</code></pre>

<p>I am going somewhere wrong in mocking the store and creating the shallow for his login component before even writing a test case i am getting the error ""Uncaught TypeError: <strong>WEBPACK_IMPORTED_MODULE_0__compose</strong>.a.apply(...) is not a function"" Not sure abt the reason behind it. Here is the spec file content:</p>

<pre><code>import React from 'react';
import { createStore, applyMiddleware } from 'redux';
import { shallow, mount } from 'enzyme';
import configureStore from 'redux-mock-store';
import LoginReducer from '../../../reducers/rootReducers';
import thunk from 'redux-thunk'
import Login from './LoginPage';

const mockStore = configureStore([LoginReducer]);
const initialState = {
  SummaryStats: {
    Reports: '0',
  },
  isAuthenticated: false,
  isAuthenticating: true,
  userInfo: {
    firstName: 'Ruchir',
  },
  envConfig: {},
};
const store = mockStore(initialState);
const dummyData = {
  abc: '0',
  getEnvConfig: () =&gt; {},
  envConfig: {
    AuthUrl: '',
    CallbackUri: '',
    ClientId: '',
  },
};

const LoginWrapper = shallow(&lt;Login 
    store={store}
    {...dummyData}
  /&gt;);

describe('&lt;Login /&gt;', () =&gt; {    
  it('check componentDidMount method', () =&gt; {
    LoginWrapper.componentDidMount();
    expect(LoginWrapper.props().getEnvConfig).toHaveBeenCalled();
  });
});
</code></pre>
","617469","","617469","","2017-04-19 07:08:12","2017-04-19 07:08:12","While running react component test in a react-redux app, ""Uncaught TypeError: __WEBPACK_IMPORTED_MODULE_0__compose__.a.apply(...) is not a function""","<unit-testing><reactjs><web-applications><react-redux><enzyme>","0","4","","",""
"43478003","1","43478107","","2017-04-18 16:54:22","","1","20","<p>I've made a simple react app where i am generated child components via an array that is inside my state:</p>

<p>School.js:</p>

<pre><code>import React from 'react';
import Person from './Person';

export default class School extends React.Component {
  constructor() {
    super();
    this.state = {
      persons: [
        {id: 0, name: ""person0""},
        {id: 1, name: ""person1""},
        {id: 2, name: ""person2""},
        {id: 3, name: ""person3""},
        {id: 4, name: ""person4""},
        {id: 5, name: ""person5""},
        {id: 6, name: ""person6""},
        {id: 7, name: ""person7""},
        {id: 8, name: ""person8""},
        {id: 9, name: ""person9""}
      ]
    };

    this.personList = this.state.persons.map((p) =&gt;
      &lt;Person key={p.id} info={p} updateState={this.updateState.bind(this)} /&gt;
    );
  }

  updateState(){
    this.setState({
      persons: [
        {id: 0, name: ""person000000000""},
        {id: 1, name: ""person100000000""},
        {id: 2, name: ""person200000000""},
        {id: 3, name: ""person300000000""},
        {id: 4, name: ""person400000000""},
        {id: 5, name: ""person500000000""},
        {id: 6, name: ""person600000000""},
        {id: 7, name: ""person700000000""},
        {id: 8, name: ""person800000000""},
        {id: 9, name: ""person900000000""}
      ]
    });
    console.log(this.state);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;All my persons:&lt;/h1&gt;
        &lt;ul&gt;
          {this.personList}
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>Person.js:</p>

<pre><code>import React from 'react';

export default class Person extends React.Component {
    constructor(){
        super();
    }

    componentDidUpdate(){
        console.log(""updated"");
    }

    render(){
        return(
            &lt;p onClick={this.props.updateState}&gt;I'm {this.props.info.name} and my id is {this.props.info.id}&lt;/p&gt;
        );
    }
}
</code></pre>

<p>My childs are rendered, but when i update the state via onClick on one of my childs, the state is updated (you can check it when you console.log in 'updateState' method in School), but my childs are not rerendered.</p>

<p>How does this come and why? Can you create children like this (via array in state)?</p>

<p>Thanks!</p>
","4719741","","","","","2017-04-18 16:59:41","Child does not update when generated via array react","<javascript><arrays><reactjs>","1","0","","",""
"50344466","1","50344522","","2018-05-15 07:21:43","","0","43","<p>I got a problem with quill editor on react.<br/><br/>
<code>imageHandler()</code> works well.<br/>But In <code>imageHandler()</code>, It can't call others like state, props, function, etc as well.<br/>
I wanna call quillRef in <code>imageHandler()</code> that is called by module.toolbar.handlers </p>

<p>Below is my simple code. <br/></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import ReactQuill from 'react-quill'; // ES6

const formats = [
  'header', 'font', 'size',
  'bold', 'italic', 'underline', 'strike', 'blockquote',
  'list', 'bullet', 'indent',
  'link', 'image', 'video'
]

class App extends Component {
  
  constructor(props) {
    super(props)
    this.state = { text: ''}
    this.handleChange = this.handleChange.bind(this)

    this.reactQuillRef = null; // ReactQuill component
    this.quillRef = null;      // Quill instance
  }
  
  modules = {
    toolbar: {
      container:  [['bold', 'italic', 'underline', 'blockquote'],
            [{'list': 'ordered'}, {'list': 'bullet'}],
            ['image'],
      ],
      handlers: {
         'image': this.imageHandler
      }
    }
  }

  componentDidMount() {
    this.attachQuillRefs()
  }
  
  componentDidUpdate() {
    this.attachQuillRefs()
  }
  
  attachQuillRefs = () =&gt; {
    if (typeof this.reactQuillRef.getEditor !== 'function') return;
    this.quillRef = this.reactQuillRef.getEditor();
  }

  imageHandler() {
    const input = document.createElement('input');
    input.setAttribute('type', 'file');
    input.setAttribute('accept', 'image/*');
    input.click();
    
    input.onchange = () =&gt; {
    
      const file = input.files[0];
      console.log(file); // works well
      
      // problems : can't call ref, props, function... etc
      console.log(""ref : "", this.reactQuillRef, this.quillRef); // undefine
      
      // this.insertImg(); // not work (insertImg is not a function)

      console.log(this.props); // undefine
      
    };
  }

  handleChange(value) {
    this.setState({ text: value });
    this.refs.test.innerHTML = this.state.text;
  }
  
  insertImg = () =&gt; {
    console.log(""insertImg"",prototype);
    var range = this.quillRef.getSelection();
    let position = range ? range.index : 0;
    console.log(this.quillRef); // works well!!!!!!!!! why diffrent with imgHandler() 
    this.quillRef.insertEmbed(position, 'image','https://images.pexels.com/photos/47480/pexels-photo-47480.jpeg?auto=compress&amp;cs=tinysrgb&amp;h=350');
  }

  render() {
    return (
      &lt;div className=""App""&gt;
      &lt;button onClick={this.insertImg}&gt;Insert Img&lt;/button&gt;
        &lt;ReactQuill value={this.state.text}
                  onChange={this.handleChange} 
                  modules={this.modules}
                  formats={formats} 
                  ref={(el) =&gt; {this.reactQuillRef = el}}
        /&gt;

      &lt;br/&gt;&lt;br/&gt;
      &lt;div contentEditable='true' ref='test'&gt;&lt;/div&gt;
      {this.state.text}
      &lt;/div&gt;

    );
  }
}

export default App;</code></pre>
</div>
</div>
</p>

<p>I tried many ways(all failed) and this case, not work</p>

<p><code>imageHandler() {...}</code> to <code>imageHandler = () =&gt; {...}</code></p>

<p><br/><br/><br/>
And my package.json here
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>{
  ""name"": ""quill"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""dependencies"": {
    ""fine-uploader"": ""^5.16.2"",
    ""react"": ""^16.3.2"",
    ""react-dom"": ""^16.3.2"",
    ""react-quill"": ""^1.2.7"",
    ""react-scripts"": ""1.1.4""
  },
  ""scripts"": {
    ""start"": ""react-scripts start"",
    ""build"": ""react-scripts build"",
    ""test"": ""react-scripts test --env=jsdom"",
    ""eject"": ""react-scripts eject""
  }
}</code></pre>
</div>
</div>
</p>

<p>Any Idea why?
Does anyone give hands for me?
Thank you!</p>
","6724401","","6724401","","2018-05-15 09:16:36","2018-05-15 15:52:58","can't call ref(also others like state, props, function, etc) on react quill custom handler","<javascript><reactjs><quill>","1","0","","",""
"34065759","1","34227565","","2015-12-03 12:11:36","","1","3505","<p>I'm trying to use this component <a href=""https://github.com/igorprado/react-notification-system"" rel=""nofollow"">https://github.com/igorprado/react-notification-system</a> in a standard fluxible project and am looking for guidance on how to adapt the sample code into an es6 style class.</p>

<p>Here's the original sample code:</p>

<pre><code>var React = require('react');
var ReactDOM = require('react-dom');
var NotificationSystem = require('react-notification-system');

var MyComponent = React.createClass({
  _notificationSystem: null,

  _addNotification: function(event) {
    event.preventDefault();
    this._notificationSystem.addNotification({
      message: 'Notification message',
      level: 'success'
    });
  },

  componentDidMount: function() {
    this._notificationSystem = this.refs.notificationSystem;
  },

  render: function() {
    return (
      &lt;div&gt;
        &lt;button onClick={this._addNotification}&gt;Add notification&lt;/button&gt;
        &lt;NotificationSystem ref=""notificationSystem"" /&gt;
      &lt;/div&gt;
      );
  }
});

ReactDOM.render(
  React.createElement(MyComponent),
  document.getElementById('app')
);
</code></pre>

<p>And here's my attempt to add it to a fluxible application component, should I add the notificationSystem object into state?  Is using componentDidMount always reliable if I'm connecting to stores?  How should I trigger the notification from an action - should I update a notificationStore that triggers the component or act on the component directly somehow from the action itself?</p>

<pre><code>class Application extends React.Component {

    //constructor(props) {
    //    super(props);
    //    this.state = {
    //        notificationSystem: this.refs.notificationSystem
    //    };
    //}

    addNotification(event) {
        event.preventDefault();
        this.notificationSystem.addNotification({
            message: 'Notification message',
            level: 'success'
        });
    }

    render() {
        var Handler = this.props.currentRoute.get('handler');

        return (
            &lt;div&gt;
                &lt;Nav currentRoute={this.props.currentRoute} links={pages} /&gt;
                &lt;div className=""main""&gt;
                    &lt;Handler /&gt;
                &lt;/div&gt;
                &lt;NotificationSystem ref=""notificationSystem"" /&gt;
            &lt;/div&gt;
        );
    }

    componentDidMount() {
        this.state.notificationSystem = this.refs.notificationSystem;
    }

    componentDidUpdate(prevProps, prevState) {
        const newProps = this.props;
        if (newProps.pageTitle === prevProps.pageTitle) {
            return;
        }
        document.title = newProps.pageTitle;
    }
}
</code></pre>
","611750","","","","","2016-03-02 02:27:37","How to adapt the standard react-notification-system example to a fluxible project","<reactjs><reactjs-flux><fluxible>","1","0","","",""
"50060772","1","","","2018-04-27 10:47:44","","0","71","<p>I have MapContainer: </p>

<pre><code>import React, { Component } from ""react"";
import ReactDOM from ""react-dom"";
export class MapContainer extends Component {
componentDidUpdate(props) {
    this.loadMap();
}
loadMap() {
    if (this.props &amp;&amp; this.props.google) {
        const {google} = this.props;
        const maps = google.maps;
        const mapRef = this.refs.map;
        const node = ReactDOM.findDOMNode(mapRef);
        const mapConfig = Object.assign({}, {
            center: {lat: 50.4418782, lng: 30.5107196},
            zoom: 15,
        })
        this.map = new maps.Map(node, mapConfig);
            addMarker({lat: 50.4418782,lng: 30.5107196});
            function addMarker(coords) {
                const marker = new google.maps.Marker({
                    position: coords,
                    map: this.map
                });
            }
     }
 }



render() {
    const style = {
        width: '100%',
        height: '40rem',
        margin: '2rem auto'
    };

    return (
        &lt;div ref=""map"" style={style}&gt;
            loading map...
        &lt;/div&gt;
    )
  }
}

export default MapContainer;
</code></pre>

<p>When it start I have TypeError: </p>

<blockquote>
  <p>Cannot read property 'map' of undefined. <a href=""https://i.stack.imgur.com/DyQeH.png"" rel=""nofollow noreferrer"">enter image description here</a></p>
</blockquote>

<p>What's wrong?</p>
","9709906","","472495","","2018-04-27 10:56:09","2018-04-30 13:47:00","Google-maps-react doesn't work","<reactjs><google-maps-react>","1","0","0","",""
"41853164","1","41855723","","2017-01-25 13:41:41","","0","70","<p>I am new to react and redux  and I am facing a very strange issue and it is almost a week that I am trying different ways but no result. I have two component channel and its children. This is how it works: first the channel gets a list of channel from the server and then it in channel component there is a loop which send each channel to the storyboard then in storyboard I call another ajax call to get a list of stories for that specific channel. So here in storyboard as you can see I need to have my reducer separated from channel reducer since when I mix them there will be an infinite loop and browser crashes. Anyway this works on load and even when I use a button just for test and I updated channel reducer with the new channel list and it works perfectly fine, by that I mean it loads all channels and related stories with a fresh state. However when I used routing this never works as expected. For more explanation I use react-redux-router to make sure all the states are synchronized. So when I use router and and I load another page then when I get back to my channel page everything is repeated twice. so for instance if I have 2 channel with 3 stories in each, then in the result page after routing I have 4 channels with 6 stories in each channel. This means that react does not clear the states and adds everything on top of current state Here is my code:</p>

<pre><code>       import React from ""react"";
   import {connect} from ""react-redux"";
   import StoryBoard from '../story-board/StoryBoard';
   import {getChannels} from './action/ChannelAction';
   import  {updateChannels} from './action/ChannelUpdateAction';
   import  {cleanStoryBoards} from '../story-board/story-board-action/CleanStoryBoardsAction';
   class Channel extends React.Component {
   constructor(props) {
     super();

   }
   componentDidMount() {
        this.props.getChannels();

    }

    render() {
       return (
          &lt;div&gt;

            &lt;div className=""col-xs-12  col-md-8 col-lg-8 paddingStoryBoardsDownJs dummyEachChannelStoryBoard""&gt;
                &lt;div className=""row""&gt;

                    {
                        this.props.channels.channelsArr.map((item, i) =&gt; &lt;StoryBoard 
                                                                                     newsChanel={item}
                                                                                     idForDummySetUp={i + 1}
                                                                                     key={""storyBoard"" + i}
                                                                                     channelsInfo={{
                                                                                         ""channelsCount"": this.props.channels.channelsArr.length,
                                                                                         ""channelIndex"": i
                                                                                     }}&gt;&lt;/StoryBoard&gt;)
                    }
                &lt;/div&gt;
            &lt;/div&gt;


            &lt;div className=""col-xs-12  col-md-2 col-lg-2 color2""&gt;.col-sm-4&lt;/div&gt;
        &lt;/div&gt;

         );
       }
    }

     const mapStateToProps = (state) =&gt; {
      return {
        channels: state.channelReducer
      };
    };

     const mapDispatchToProps = (dispatch) =&gt; {
     return {
       getChannels: () =&gt; {
          dispatch(getChannels());

            } 
    };
   };
      export default connect(mapStateToProps, mapDispatchToProps)(Channel);
</code></pre>

<p>And also in channel action I have:</p>

<pre><code>        export function getChannels(){

            return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/jsonchannel.txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var arr=[];
                            for (var key in data.channelList) {
                                arr.push(data.channelList[key].capitalizeFirstLetter());
                            }
                            dispatch({
                                type: ""GET_CHANNEL"",
                                payload: arr

                            });
                        }.bind(this)
                    });
                };
        }
</code></pre>

<p>And in channel reducer I have:</p>

<pre><code>            const ChannelReducer = (state ={""channelsArr"":[],""channelLabelForScrolls"":[]}, action) =&gt; {
            switch (action.type) {
                case ""GET_CHANNEL"":
                    state={""channelsArr"":action.payload};
                    break;
            }
            return state;
        };
        export  default  ChannelReducer;
</code></pre>

<p>Also my storyboard is as follows:</p>

<pre><code>        import  React from ""react"";
        import {connect} from ""react-redux"";
        import  {getStoriesAction} from './story-board-action/StoryBoardAction';
        import  {HamburgerMenu} from './storyboard-classes/HamburgerMenuShouldBeRemoved';
        class StoryBoard extends React.Component {
            constructor(props) {
                super();
            }
            componentDidMount() {
                /**Loading Stories**/
                this.props.getStories(this.props.newsChanel);
            }
            render() {
                return (
                    &lt;div&gt;
                        &lt;div id={""dummyStoryBoardHeaderRowJs"" + this.props.idForDummySetUp}
                             className=""row storyBoardHeaderRowJs""&gt;
                            &lt;StoryBoardHeader idForDummySetUp={this.props.idForDummySetUp} newsChanel={this.props.newsChanel}/&gt;
                        &lt;/div&gt;
                        &lt;div className=""row"" id={""channelPositionFinder"" + this.props.newsChanel.removeAllSpaces()}&gt;
                            {
                                //this.props.stories.map((item,i)=&gt; &lt;Story key={i} position={i} story={item} &gt;&lt;/Story&gt;)
                                this.props.stories.map(function (snippet) {
                                    if ( snippet.channel.toLowerCase() === this.props.newsChanel.toLowerCase()) {
                                        return (
                                            snippet.storiesSnippet.map((item, i) =&gt; &lt;Story key={i} story={item}
                                                                                           channel={this.props.newsChanel}&gt;&lt;/Story&gt;)
                                        );

                                    }
                                }.bind(this)) //bind thid to outer loop to mae parent this valid
                            }
                        &lt;/div&gt;
                    &lt;/div&gt;
                );
            }
            componentDidUpdate() {

            }
        }
        const mapStateToProps = (state) =&gt; {
            return {
                stories: state.storyBoardReducer
            };
        };
        //which actions we wanna use in this components
        const mapDispatchToProps = (dispatch) =&gt; {
            return {
                getStories: (chanel) =&gt; {
                    dispatch(getStoriesAction(chanel));

                }

            };
        };
        export default connect(mapStateToProps, mapDispatchToProps)(StoryBoard);
</code></pre>

<p>and my story action is as follows:</p>

<pre><code>            export function getStoriesAction(channel){

                return dispatch =&gt; {
                    $.ajax({
                        url: ""http://localhost:3003/""+channel.replace(/\s+/g, '')+"".txt"",
                        dataType: 'json',
                        cache: false,
                        success: function(data) {
                            var storiesSnoppet=[];
                            for (var key in data) {
                                storiesSnoppet.push(data[key]);
                            }
                            console.log(""channel:  ""+channel  );
                            console.log(storiesSnoppet);
                            dispatch({
                                type: ""SET_STORIES"",
                                payload: {""channel"":channel,""storiesSnippet"":storiesSnoppet}

                            });
                        }.bind(this)
                    });
                };

        }
</code></pre>

<p>and finally reducer for storyboard is as follows: </p>

<pre><code>            const StoryBoardReducer = (state =[], action) =&gt; {
            switch (action.type) {
                case ""SET_STORIES"":
                    var tempStateStories = state.slice();
                    tempStateStories.push(action.payload);
                    state=tempStateStories;
                    break;
            }
            return state;
        };
        export  default  StoryBoardReducer;
</code></pre>

<p>As far as I know I took everything into account and everything works but when I use routing channels and stories inside each channel gets doubled which means that react router adds channels and stories on top of the old state rather than starting with fresh new state. For sake space I did not added the pages which rerout back to channel since it is simply a link. Can anyone help?</p>
","7272998","","7272998","","2017-01-25 13:53:38","2017-01-25 15:42:11","when I use react-redux-router and reroute to the old page the state does not get flushed and everything is added on top of the old state","<reactjs><react-router><react-redux>","1","6","","",""
"42670121","1","42671332","","2017-03-08 11:29:25","","0","1637","<p>Inside a div items are added dynamically. After the componentDidUpdate I want to scroll the content of a div, so that the last list-item gets visible.</p>

<p>css</p>

<pre><code>div { 
   height: 100px;
   overflow-y: scroll;
}
</code></pre>

<p>react js</p>

<pre><code> return(
 &lt;div&gt;
  ...
  &lt;div ref='wrap'&gt;
   &lt;ul&gt;
     &lt;li&gt;item&lt;/li&gt;
      ..
     &lt;li&gt;last item&lt;/li&gt;
   &lt;/ul&gt;
 &lt;/div&gt;
    ...
&lt;/div&gt;)
</code></pre>
","2204835","","","","","2017-03-08 14:02:58","Scroll to bottom after componentDidUpdate","<reactjs>","1","0","","",""
"34097560","1","","","2015-12-04 21:14:33","","12","11730","<p>I have a react component that is the detail view from a list.</p>

<p>I am trying to replace the image with a default image if the image does not exist and there is a 404 error.  </p>

<p>I would normally use the onerror method in the img tag but that doesn't seem to be working.</p>

<p>I am not sure how to do this with react.</p>

<p>Here is my component:</p>

<pre><code>import React from 'react';
import {Link} from 'react-router';
import ContactStore from '../stores/ContactStore'
import ContactActions from '../actions/ContactActions';

class Contact extends React.Component {
  constructor(props) {
    super(props);
    this.state = ContactStore.getState();
    this.onChange = this.onChange.bind(this); 
 }

componentDidMount() {
  ContactStore.listen(this.onChange);
  ContactActions.getContact(this.props.params.id);
}

componentWillUnmount() {
  ContactStore.unlisten(this.onChange);
}

componentDidUpdate(prevProps) {
  if (prevProps.params.id !== this.props.params.id) {
    ContactActions.getContact(this.props.params.id);
  }
}

onChange(state) {
  this.setState(state);
}

render() {
  return (
    &lt;div className='container'&gt;
      &lt;div className='list-group'&gt;
        &lt;div className='list-group-item animated fadeIn'&gt;
          &lt;h4&gt;{this.state.contact.displayname}&lt;/h4&gt;
          &lt;img src={this.state.imageUrl} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
}

export default Contact;
</code></pre>
","4017056","","1677912","","2016-03-05 18:23:33","2018-01-12 08:52:34","react.js Replace img src onerror","<javascript><reactjs><http-status-code-404>","5","1","6","",""
"50328523","1","","","2018-05-14 10:51:05","","1","56","<p>I'm trying to log out the time taken in preact to update a component and render it.</p>

<p>Here is the code :</p>

<pre><code>handleKeyPress(event) {
    renderingTime = Date.now()
    ...
}

componentDidUpdate() {
    if (renderingTime) {
        console.log('finished rendering ' + (Date.now() - renderingTime))
        this.onNextFrame(function() {
            console.log('finished rendering anim ' + (Date.now() - renderingTime))
        })
    }
}

onNextFrame(callback) {
    setTimeout(function () {
        window.requestAnimationFrame(callback)
    }, 0)
}
</code></pre>

<p>Then I get the trace from Cobalt browser (a bit like Chromium). In this trace i can see that the ""finished rendering"" log gives me the javascript execution time. The ""finished rendering anim"" log gives me the javascript execution time + the layout time. </p>

<p>Then I see on the trace that there is the rasterizer part from the media_pipeline that is still happening afterward.</p>

<p>Is there a way to get this part included in my measurement ?
I need these measurements to run automated tests and so need the result in the console logs.</p>
","8933086","","8933086","","2018-05-14 13:10:31","2018-05-14 13:10:31","Preact log performance after render","<javascript><reactjs>","1","0","","",""
"48984381","1","","","2018-02-26 08:39:26","","0","24","<p>I want to create a widget 'gallery' that allow the user to upload image or insert link Youtube. I used React for this and there is my files : </p>

<p>Select_galery :</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import reactDOM from 'react-dom';
import Select from 'react-select';

class Select_galery extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      posts:[]
    }
    this.handleChange = this.handleChange.bind(this);
    this.state.selectValue = this.props.value;
  }

  handleChange(event){
  this.setState({selectValue:event.target.value});
}

setType() {
    return this.props.type ? this.props.type : 'text';
}

  render() {
    // const selected = this.state.selectedOption;
    // const { selectedOption } = this.state;
    // const value = selectedOption &amp;&amp; selectedOption.value;
     const selected = this.state.selectValue;
     let input = null;
     let url_youtube = this.props.name+'[url]';
    if(selected != 'true' || selected == null){
      input = &lt;div&gt;&lt;label htmlFor={this.props.id}&gt;Url Video&lt;/label&gt;&lt;input id={this.props.id} type={this.setType()} name={url_youtube} defaultValue={this.props.value.url} className=""widefat""/&gt;&lt;/div&gt;;
    }else{
      input = &lt;Media /&gt;;
    }
    return (
      /* NE PAS OUBLIER LE FOR !!!! */
       &lt;label htmlFor={this.props.id}&gt;{this.props.label}
         &lt;select defaultValue={this.props.value}  id={this.props.id} className=""widefat"" name={this.props.name} onChange={this.handleChange.bind(this)}&gt;
           &lt;option value=""true""&gt;Image&lt;/option&gt;
           &lt;option value=""false""&gt;Video&lt;/option&gt;
         &lt;/select&gt;
         &lt;div&gt;{input}&lt;/div&gt;
       &lt;/label&gt;
    );
  }
}
export default Select_galery;
</code></pre>

<p>Media :</p>

<pre><code>import React from 'react';
import './media.scss';

class Media extends React.Component {
    constructor(props) {
        super(props);

        /*
         * Default state.
         * We can set the default state based on given props.
         */
        let hasMedia = false;

        if (props.value) {
            hasMedia = !!props.value.id;
        }

        this.state = {
            hasMedia: hasMedia,
            media: {
                id: props.value ? props.value.id : '',
                url: props.value ? props.value.url : '',
                name: props.value ? props.value.name : ''
            },
        };

        /*
         * Bindings.
         */
        this.addImage = this.addImage.bind(this);
        this.removeImage = this.removeImage.bind(this);
        this.select = this.select.bind(this);

        /*
         * Get a WordPress media frame.
         */
        this.wpframe = wp.media({
            // Define behaviour of the media window.
            // 'post' if related to a WordPress post.
            // 'select' if use outside WordPress post.
            frame: 'select',
            // Allow or not multiple selection.
            multiple: false,
            // The displayed title.
            title: 'Insérer Media',
            // The button behaviour
            button: {
                text: 'Insérer',
                close: true
            },
            // Type of files shown in the library.
            // 'image', 'application' (pdf, doc,...)
            /*library:{
                type: props.type ? props.type : 'image'
            }*/
        });

        // Attach an event on select. Runs when ""insert"" button is clicked.
        this.wpframe.on('select', this.select);
    }


    /**
     * Handle click on the button and open the WordPress
     * media library modal in order to fetch an image from
     * the media library. The returned ""attachment id"" value
     * is then set to the hidden input value attribute.
     *
     */
    addImage() {
        /*
         * Open the media modal.
         */
        this.wpframe.open();
    }

    /**
     * Return the selected attachment object.
     */
    select() {
        let selection = this.wpframe.state().get('selection').first(),
            type = selection.get('type'),
            id = selection.get('id'),
            thumbUrl = selection.get('icon'), // Default image url to icon.
            sizes = selection.get('sizes');

        /*
         * We receive a BackboneJs Model instance (selection).
         * Now we need to update the component in order to show the selected
         * thumbnail and populate the hidden field value with the ""id"" of the attachment.
         */
        if ('image' === type)
        {
            if (typeof sizes.thumbnail !== 'undefined') {
                thumbUrl = sizes.thumbnail.url;
            }
        }

        /*
         * We need to change the state in order
         * to force React to render the component.
         */
        this.setState({
            hasMedia: true,
            media: {
                id: id,
                url: thumbUrl,
                name: selection.get('filename')
            }
        });
    }

    /**
     * Remove the chosen image.
     * This reset the component state and force re-rendering.
     */
    removeImage() {
        this.setState({
            hasMedia: false,
            media: {
                id: '',
                url: '',
                name: ''
            }
        });
    }

    /**
     * Render a label if defined.
     *
     * @returns {*}
     */
    renderHeader() {
        if (this.props.label) {
            return (
                &lt;div className=""media-component-header""&gt;
                    &lt;h4&gt;{this.props.label}&lt;/h4&gt;
                &lt;/div&gt;
            );
        }

        return '';
    }

    /**
     * Render the media component footer.
     *
     * @returns {*}
     */
    renderFooter() {
        if (!this.props.info) {
            return '';
        }

        return (
            &lt;div className=""media-component-footer""&gt;
                &lt;p className=""description""&gt;{this.props.info}&lt;/p&gt;
            &lt;/div&gt;
        );
    }

    /**
     * Render the media component.
     * If there is a media, show the media details with a preview,
     * else only display an ""Add Image"" button.
     *
     * @returns {XML}
     */
    render() {
        if (this.state.hasMedia) {
            return (
                &lt;div ref={(domElem) =&gt; { this.domElem = domElem; }} className=""media-component""&gt;
                    {this.renderHeader()}
                    &lt;div&gt;
                        &lt;div className=""media-inner-wrapper""&gt;
                            &lt;div className=""media-preview""&gt;
                                &lt;div className=""centered""&gt;
                                    &lt;img className=""media-thumbnail"" alt=""Media Thumbnail"" src={this.state.media.url}/&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className=""media-tools""&gt;
                                &lt;div className=""media-infos""&gt;
                                    &lt;h4&gt;Nom du fichier&lt;/h4&gt;
                                    &lt;p className=""media-filename""&gt;{this.state.media.name}&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div className=""media-buttons""&gt;
                                    &lt;button type=""button""
                                            className=""button button-remove""
                                            onClick={this.removeImage}&gt;Supprimer&lt;/button&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[id]`} value={this.state.media.id}/&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[url]`} value={this.state.media.url}/&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[name]`} value={this.state.media.name}/&gt;
                    &lt;/div&gt;
                    {this.renderFooter()}
                &lt;/div&gt;
            );
        }
        return (
            &lt;div className=""media-component""&gt;
                {this.renderHeader()}
                &lt;button type=""button""
                        className=""button button-primary""
                        onClick={this.addImage}&gt;Ajouter&lt;/button&gt;
                {this.renderFooter()}
            &lt;/div&gt;
        );
    }

    /**
     * We update the DOM hidden inputs define into the parent
     * container of our media component.
     *
     * @param prevProps
     * @param prevState
     */
    componentDidUpdate(prevProps, prevState) {
        /*
         * The ""this.domElem"" property is only defined
         * when we add an image... otherwise it is null.
         *
         * We the user add/attach an image, we need to update the
         * dom hidden inputs next to our component.
         */
        if (this.domElem) {
            let parent = this.domElem.parentElement.parentElement,
                idInput = parent.querySelector('input.image-id'),
                urlInput = parent.querySelector('input.image-url'),
                nameInput = parent.querySelector('input.image-name');

            /*
             * Let's update the value attribute of each DOM hidden input.
             */
            if (idInput || urlInput || nameInput) {
                idInput.setAttribute('value', this.state.media.id);
                urlInput.setAttribute('value', this.state.media.url);
                nameInput.setAttribute('value', this.state.media.name);
            }
        }
    }
}

export default Media;
</code></pre>

<p>Add the end this will be like this : </p>

<p><a href=""https://i.stack.imgur.com/CCCse.png"" rel=""nofollow noreferrer"">Image</a>
<a href=""https://i.stack.imgur.com/5J3F8.png"" rel=""nofollow noreferrer"">Video</a></p>

<p>I'm blocked because in the database, the image's info are not save (id / name / url).</p>

<p>'{""s_gallery"":{""2"":{""lien"":"""",""0"":{""select"":""true""},""_thms_widget"":""s_gallery-2""}}}'</p>

<p>How can I solved this ? 
If you want to have more info, ask it ;)</p>

<p>Thank you ;)</p>
","8952306","","2315280","","2018-02-26 08:43:35","2018-02-26 08:43:35","gallery react in wordpress","<reactjs>","0","0","","",""
"44129789","1","","","2017-05-23 08:36:58","","0","497","<p>I'm learning redux and created a <code>Navbar</code> component that will handle user actions. It uses <code>NavLink</code> to add the 'active' class to my links so I can style the active link.  When I navigate my site however the active class doesn't move until I send an action to react (login/logout is all I""ve done so far).  If I take out the connect stuff and use the class component directly the <code>NavLinks</code> work fine.  Adding a log to <code>componentDidUpdate</code> shows that it isn't being called when connect is used.</p>

<p>Am I missing something?  I see there's <a href=""https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux"" rel=""nofollow noreferrer"">react-router-redux</a> but I'm building a site for fun to learn the whole deal and I'm just starting to get redux, I don't want to bring in the concept of middleware and I definitely don't want to use <code>combineReducers</code> since at this point it would just mean having the router property and shoving everything else under something like 'main' in the state.</p>

<p>I'm thinking of using <a href=""https://facebook.github.io/react/docs/context.html"" rel=""nofollow noreferrer"">context</a> and putting the whole redux state on it...</p>

<p><strong>update:</strong> - I added react-router-redux and I can only get it to update on a route change if I add the new 'router' to my mapped props.</p>

<p>I have a <code>NavbarC</code> component class with a render method like this:</p>

<pre><code>render() {
  let { props } = this;

  return &lt;header className=""navbar""&gt;
    &lt;nav&gt;
      &lt;h1&gt;&lt;NavLink to=""/"" exact&gt;Home&lt;/NavLink&gt;&lt;/h1&gt;
      &lt;NavLink to=""/friends""&gt;Friends&lt;/NavLink&gt;
    &lt;/nav&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div className=""center-flex-row""&gt;
      { props.busy ? &lt;section className=""nav-right""&gt;&lt;p&gt;working&lt;span className=""spacer""&gt;&lt;/span&gt;&lt;span className=""fa fa-spin fa-spinner""&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt; :
        props.user ?
          &lt;Logout onSignOutClick={props.onSignOutClick} user={props.user} /&gt; :
          &lt;Login onSignInClick={props.onSignInClick}/&gt;
      }
    &lt;/div&gt;
  &lt;/header&gt;
}
</code></pre>

<p>And I use connect():</p>

<pre><code>const mapStateToProps = (state) =&gt; {
  return { user: state.auth.user, busy: state.auth.busy
  }
}

const mapDispatchToProps = (dispatch) =&gt; {
  return {
    onSignInClick: () =&gt; {
      dispatch(userLogin());
    },
    onSignOutClick: () =&gt; {
      dispatch(userLogout());
    }
  }
}

const Logout = ({ user, onSignOutClick }) =&gt; {
  return &lt;section className=""nav-right""&gt;
    &lt;button className=""btn"" onClick={ onSignOutClick }&gt;Sign Out&lt;/button&gt;
  &lt;/section&gt;
}

const Login = ({ onSignInClick }) =&gt; {
  return &lt;section className=""nav-right""&gt;
    &lt;button className=""btn"" onClick={ onSignInClick }&gt;Sign In&lt;/button&gt;
  &lt;/section&gt;
}

export const Navbar = connect(mapStateToProps, mapDispatchToProps)(NavbarC)
</code></pre>
","369792","","369792","","2017-05-23 08:58:45","2017-05-23 23:50:59","Using connect() from react-redux makes NavLinks from react-router not work?","<react-router><react-redux>","1","2","","",""
"43435881","1","43437175","","2017-04-16 09:44:04","","9","11947","<p>I'm on a situation where I want to make some dom-node size calculations (top, bottom and size properties of the rendered DOM node)</p>

<p>What I'm doing right now, on the <code>componentDidUpdate</code> method is to call findDOMNode on this:</p>

<pre><code> componentDidUpdate() {
        var node = ReactDOM.findDOMNode(this);

        this.elementBox = node.getBoundingClientRect();
        this.elementHeight = node.clientHeight;
        // Make calculations and stuff
}
</code></pre>

<p>This is working fine, but I'm a bit worried about performance, and react best practices. Several places talks about using <code>ref</code> property instead of findDOMNode, but all of them are for child dom elements, on my case I only want the root DOM node of my component. </p>

<p>The alternative using ref may look like this:</p>

<pre><code>render(){
   return (
            &lt;section // container
                ref={(n) =&gt; this.node = n}&gt;
                 // Stuff
            &lt;/section&gt;
}
 componentDidUpdate() {

        this.elementBox = this.node.getBoundingClientRect();
        this.elementHeight = this.node.clientHeight;
        // Make calculations and stuff
}
</code></pre>

<p>To be honest, attaching a ref callback to my root dom node just to get it's reference does not feel correct to me.</p>

<p>What is considered the best practice on this case ? Which one has better performance ?</p>
","1734815","","","","","2017-04-16 12:21:18","Should I use ref or findDOMNode to get react root dom node of an element?","<javascript><reactjs><dom><react-dom>","1","0","2","",""
"42021428","1","","","2017-02-03 09:54:27","","1","232","<p>I've encountered with a problem that <code>onChange</code> event in <code>preact</code> doesn't work. In <code>react</code> everything works fine though. <code>onInput</code> doesn't work either.</p>

<p>Example of dumb code that must work (<code>preact</code> + <code>typescript</code>)</p>

<pre><code>export class Download extends React.Component&lt;DownloadProps, {}&gt; {
  constructor(props: DownloadProps) {
    super(props);
    this.state = {
      imgSrc: ''
    };
  }

  public componentDidUpdate() {
    console.log('did2')
  }
    public render() {
      console.log('render', this.state);
      return &lt;div className={s.root}&gt;
        &lt;input className='fileInput' type='file' onChange={() =&gt; { this.handleImageChange() }}  /&gt;
        &lt;div className={s.comment}&gt;Upload&lt;/div&gt;
      &lt;/div&gt;;
    }

  private handleImageChange() {
      this.setState({imgSrc: '30'})
    }
}
</code></pre>
","5906433","","5906433","","2017-02-21 15:00:59","2017-02-21 15:00:59","preact: OnChange doesn't work with input files","<javascript><reactjs><preact>","1","4","1","",""
"43583471","1","","","2017-04-24 08:43:34","","2","63","<p>I have a <code>Dashboard</code> component which has some real DOM operations (it uses some charting libraries and d3.js) in <code>componentDidUpdate()</code>.</p>

<p>These operations may cost hundreds of milliseconds in total and I just noticed that when switching pages, all the <code>componentDidUpdate</code>s are executed <strong>before</strong> the browser paints. The sequence is:</p>

<ol>
<li>Unmout current page  </li>
<li>Mount Dashboard (and its children)  </li>
<li>Dispatch Redux actions to fetch some data</li>
<li>componentDidUpdates (of Dashboard and its children)  </li>
<li>Browser paints the Dashboard (users can see the dashboard page now)</li>
</ol>

<p>I found <a href=""https://github.com/facebook/react/issues/2659"" rel=""nofollow noreferrer"">this issue</a> indicates that this is an intentional behavior. But this behavior makes my app feels laggy. Because when switching page from <code>Foo</code> to <code>Dashboard</code>, users will stuck on <code>Foo</code> and have to wait around 0.6s to see the <code>Dashboard</code> page shows.</p>

<p>My current workaround is to wrap those DOM operations with <code>setTimeout</code>:</p>

<pre><code>componentDidUpdate() {
  setTimeout(() =&gt; this.expensiveDOMOperations(), 0)
}
</code></pre>

<p>This solution works, these operations are deferred and executed after the browser paints. But there are tons of <code>setTimeout</code> that I just don't feel right.</p>

<p>So my question is, is there any better / more elegant solution for this?</p>

<p>I also have some other questions if anyone knows the answers:</p>

<ol>
<li>Does the <code>setTimeout(..., 0)</code> guarantee that the code will be executed <em>after</em> the browser paints? (In Vue.js there is a <a href=""https://vuejs.org/v2/api/#Vue-nextTick"" rel=""nofollow noreferrer""><code>nextTick()</code></a> helper to do this)</li>
<li>Will this behavior change in React Fiber?</li>
</ol>
","2739078","","2739078","","2017-04-24 10:01:45","2017-04-24 10:01:45","Defer componentDidUpdate, make it execute after browser paints","<javascript><performance><reactjs>","0","8","","",""
"44213961","1","44214719","","2017-05-27 06:58:42","","0","102","<p>I try to animate a div with reactjs using async data via redux and it's not clear to me when can I have a reference to the virtual dom on state <code>loaded</code>.</p>

<p>In my case I have a div with id <code>header</code> where I would like to push down the container when data was populated.</p>

<p>If I try in componentDidMount than I get <code>Cannot read property 'style' of undefined</code> because componentDidMount still having a reference to an on load container</p>

<pre><code>class HomePage extends React.Component {

    constructor(props) {
        super(props);

        this.state = {
            sliderLength: null
        }
    }

    componentDidMount() {
        this.props.actions.getSlides()


        if(this.header) {

            setTimeout(function() {
                this.header.style.bottom = -(this.header.clientHeight - 40) + 'px';
            }, 2000);
        }
            //header.style.bottom = -pushBottom+'px';

    }


    componentWillReceiveProps(nextProps) {
        let {loaded} = nextProps
        if(loaded === true ) {
            this.animateHeader()
        }
    }

    animateHeader() {

    }

    componentWillMount() {
        const {slides} = this.props;
        this.setState({
            sliderLength: slides.length,
            slides: slides
        });
    }


    render() {
        const {slides, post, loaded} = this.props;

        if(loaded ===true ) {

            let sliderTeaser = _.map(slides, function (slide) {
                if(slide.status === 'publish') {
                    return  &lt;Link  key={slide.id}  to={'portfolio/' + slide.slug}&gt;&lt;img key={slide.id} className=""Img__Teaser"" src={slide.featured_image_url.full} /&gt;&lt;/Link&gt;
                }
            });

            let about = _.map(post, function (data) {
                return data.content.rendered;
            })

            return (
                &lt;div className=""homePage""&gt;
                    &lt;Slider columns={1}  autoplay={true} post={post} slides={slides} /&gt;

                    &lt;div id=""header"" ref={ (header) =&gt; this.header = header}&gt;
                        &lt;div className=""title""&gt;Title&lt;/div&gt;
                        &lt;div className=""text-content""&gt;
                            &lt;div dangerouslySetInnerHTML={createMarkup(about)}/&gt;
                        &lt;/div&gt;

                        &lt;div className=""sliderTeaser""&gt;
                            {sliderTeaser}
                        &lt;/div&gt;

                        &lt;div className=""columns""&gt;
                            &lt;div className=""column""&gt;&lt;/div&gt;
                            &lt;div className=""column""&gt;&lt;/div&gt;
                            &lt;div className=""column""&gt;&lt;/div&gt;
                        &lt;/div&gt;

                    &lt;/div&gt;

                    &lt;div id=""bgHover""&gt;&lt;/div&gt;
                &lt;/div&gt;
            );
        } else {
            return &lt;div&gt;...Loading&lt;/div&gt;
        }

    }
}

function mapStateToProps(state) {
    return {
        slides: state.slides,
        post: state.post,
        loaded: state.loaded
    };
}

function mapDispatchToProps(dispatch) {
    return {
        actions: bindActionCreators(slidesActions, dispatch)
    };
}

function createMarkup(markup) {
    return {__html: markup};
}

export default connect(mapStateToProps, mapDispatchToProps)(HomePage);
</code></pre>

<p>How do I deal in this case with states?</p>

<p><strong>Between I found a solution but not sure if is the right workaround</strong></p>

<pre><code>componentDidUpdate() {
        if(this.header) {
            setTimeout(function() {
                this.header.style.bottom = -(this.header.clientHeight - 35) + 'px';
            }, 2000);
        }
    }
</code></pre>
","1831740","","1831740","","2017-05-27 10:29:38","2017-05-27 10:29:38","Trying to manipulate a div with reactjs on async data","<reactjs><react-redux><dom-manipulation><virtual-dom>","2","0","1","",""
"44214818","1","","","2017-05-27 08:47:27","","0","342","<p>I am trying to create a d3 line chart in a component method:</p>

<pre><code>import React, {Component} from ""react"";
import {observer, inject} from ""mobx-react"";

import {line, select} from ""d3""

@inject(""store"")
@observer
class PriceChart extends Component {
  constructor(props) {
    super(props)
    this.createLineChart = this.createLineChart.bind(this)
  }
  componentDidMount() {
    this.createLineChart()
  }
  componentDidUpdate() {
    this.createLineChart()
  }
  createLineChart() {

    const data = [
      {
        price: 100
      }, {
        price: 200
      }
    ]

    const node = this.node

    const priceLine = line().x((d) =&gt; 1).y((d) =&gt; d.price)

    select(node).append(priceLine(data))
  }
  render() {
    return &lt;svg ref={node =&gt; this.node = node} width={800} height={800}&gt;&lt;/svg&gt;
  }
}

export default PriceChart;
</code></pre>

<p>But I am getting the following error:</p>

<blockquote>
  <p>Failed to execute 'createElementNS' on 'Document': The qualified name
  provided ('M1,100L1,200') contains the invalid character ','..</p>
</blockquote>

<p>So where are the value M1, L1, coming from? It seems that d3 is adding values to the data that are causing it to error?  </p>
","4341439","","4341439","","2017-05-27 09:42:27","2017-09-24 02:11:11","d3 react js - Failed to execute 'createElementNS' on 'Document': The qualified name provided contains the invalid character ','","<javascript><reactjs><d3.js><ecmascript-6>","1","3","","",""
"36047675","1","36047829","","2016-03-16 21:53:16","","0","167","<p>Trying to get a react app working with <strong><a href=""http://getmdl.io/"" rel=""nofollow"">http://getmdl.io/</a></strong> just using client side code. I want a date picker and have found this <a href=""http://www.jqueryscript.net/time-clock/Pretty-Date-Time-Picker-Plugin-For-Bootstrap-Material.html"" rel=""nofollow"">http://www.jqueryscript.net/time-clock/Pretty-Date-Time-Picker-Plugin-For-Bootstrap-Material.html</a> which is rather nice. But I have a problem.  </p>

<p>How do you get a jquery event hooked up to call a function on a react class.</p>

<p>See this code below and the comment is where I want to call it. </p>

<pre><code>var DatePicker = React.createClass({
OnDateSelected: function (e) {
    this.props.onDateSelected(e.currentTarget.value);
},
render: function () {
    return (

        &lt;div className=""mdl-textfield mdl-js-textfield mdl-textfield--expandable""&gt;
            &lt;label className=""mdl-button mdl-js-button mdl-button--icon""&gt;
                &lt;i className=""material-icons""&gt;date_range&lt;/i&gt;
            &lt;/label&gt;
            &lt;div className=""mdl-textfield__expandable-holder""&gt;
                &lt;input id=""datepicker"" value={this.props.selectedDate} className=""mdl-textfield__input"" onChange={this.OnDateSelected} /&gt;
                &lt;label className=""mdl-textfield__label""&gt;Search text&lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;

    );
},
componentDidUpdate: function () {
    $(""#datepicker"").bootstrapMaterialDatePicker({ time: false, format: ""DD/MM/YYYY"" });


    $('#datepicker').bootstrapMaterialDatePicker().on('change', function (e, date) {
        // Call OnDateSelected here
    });

}});
</code></pre>
","58984","","","","","2016-03-16 22:04:18","JQuery plugin and react events and properties","<jquery><reactjs>","1","0","","",""
"45380764","1","","","2017-07-28 19:08:57","","0","261","<p>I'm trying to conditionally show or not show per say a button based on data that I receive from clicking on a point. I realized that regular jquery functions to add a class don't really work in React. So I figured I could store strings in the state like</p>

<pre><code>this.state: {
    hidden_components: {
        add_comment: ""hide""
    }
}
</code></pre>

<p>This way I can conditionally show or hide a button by </p>

<pre><code>&lt;button className={this.state.hidden_components.add_comment}&gt; Add Comment &lt;/button&gt;
</code></pre>

<p>After the render() I have more or less:</p>

<pre><code>componentDidMount() {
  this.state.g = new Dygraph
  this.state.modal = new Modal 

  this.state.modal.setContent(use some ID here to reference a div that is hidden but will show up in the modal)

  const set_hidden_container = () =&gt; {
      // I'm just going to use this = notation instead of setState()
      // this is supposed to reset the 
      this.state.hidden_components = ""hide""
      if (check_comment(this.state.points[at some index].value)) {
        this.state.hidden_components = ""show""
      }
  }

  this.state.g.updateOptions( {

    pointClickCallback: (event, p) =&gt; {
      console.log(""i clicked a point on the graph"")
      this.setState({
        currentPoint: p
      })

      set_hidden_containers()

      // force update
      this.setState({
        currentPoint: p
      })

      // I want the modal to open a div of things that only show jsx based on logic in set_hidden_container()
      this.state.modal.open()
    }
  }

componentDidUpdate() {
  // logic goes here for like event listeners and anything that queries the DOM after initialization
}
</code></pre>

<p>Then in componentDidMount() I have a function that depending on the data received from clicking on a point I do the following:
1) reset all the classes stored in the state to ""hide""
2) based on conditions set some of them to ""show""
3) concatenate all the classes stored in the state with various styling classes </p>

<p>UPDATE: 
I've long since found an easier solution to this problem, however, I'm guessing some people might have similar issues. Therefore, I'll update this question with more psuedocode and a workaround: maybe someone down the line can solve this. This component is particularly frustrating to work with because I haven't been able to make it as modular as I want because of the particular library I'm working with. There are actually about a 1000 lines in this component (I know I know not good).  </p>

<p>WORKAROUND:
For those of you who are having trouble with a component's lifecycle in dynamically setting parts of the DOM but don't want to use global variables to set classNames, jquery functions, or use react syntax to show components containing the content I recommend you do the following. </p>

<p>You can still have a set_hidden_container() set content dynamically, you just have to set things based on an id with innerHTML instead of setting a state object to be a string ""show"". The important thing is, however, that for every time you need to dynamically change content you reset these references to be empty as well as force an update. You can simply change the state of anything and then in componentDidUpdate() you can insert 1) a conditional to check if the innerHTML was actually set or not (since you're not always going to be displaying everything) and 2) within that conditional you can set whatever logic you want associated with the content showing on the page.</p>
","7363535","","7363535","","2017-07-31 07:31:28","2017-07-31 07:31:28","How to update a state object in the DOM from componentDidMount() (not componentDidUpdate())?","<javascript><reactjs><react-redux><dygraphs>","1","5","1","",""
"44309306","1","44309439","","2017-06-01 13:45:57","","2","6060","<p>I have a project using reactjs, which is transpiled by babel. I use the es2015 and react transforms in my <code>.babelrc</code>. I am currently refactoring and in my first pass I basically did <code>export class foo</code> for everything I needed. A lot of these classes should really just be functions, so I am trying to rewrite them as such, but I keep getting the same error. My main application file looks somethings like this:</p>

<pre><code>import React, { Component } from 'react';

import {Foo, Bar} from './components/ui.js';

class Application extends Component {

  constructor(props){
    super(props);
    this.state = {
      object: null
    }
  }

  componentDidMount(){
    // code
  }

  componentDidUpdate(){
    // other code
  }

  render(){
    return(
      &lt;div&gt;
        &lt;Foo /&gt;
        &lt;Bar /&gt;
      &lt;/div&gt;
    )
  }

}

module.exports = Application
</code></pre>

<p>And my import from <code>ui.js</code> is like this:</p>

<pre><code>import React, { Component } from 'react';

export class Foo extends Component {
  constructor(props){
    super(props);
  }

  render() {
    return (
      // Some JSX
    )      
  }
}


export class Bar extends Component {
  constructor(props){
    super(props);

  }

  render() {
    return (
      // Some other JSX
    )      
  }
}
</code></pre>

<p>When I try and change one of these exported classes to a function, for example:</p>

<pre><code>// Note: I have tried a variety of syntax such as function, const, etc...
export var Bar {
  render() {
    return (
      // Some other JSX
    )      
  }
}
</code></pre>

<p>I get the following error: </p>

<pre><code>SyntaxError: Unexpected token &lt;line where I declare a function&gt;
</code></pre>

<p>I am not sure what I am doing wrong, and my google searches are only coming up with answers to other problems.</p>
","2091965","","","","","2018-05-30 08:35:09","Exporting functions with reactjs and babel","<javascript><reactjs><ecmascript-6><babel>","3","0","1","",""
"45322183","1","","","2017-07-26 09:01:04","","1","421","<p>I have a component in react-native</p>

<pre><code>export default class SearchResultsScreen extends Component {
   constructor(props){
      super(props);
      this.state = {
        centres: [],
      };
  };

   componentDidMount() {
        let searchUrl =`${hostname}centres_search/`;
        let lat = this.props.origin_lat;
        let long = this.props.origin_long;
        let distance = this.props.distance;
        let url = `${searchUrl}origin_lat=${lat}&amp;origin_long=${long}&amp;distance=${distance}`
        console.log('before fetch called');
        fetch(url)
          .then((response) =&gt; response.json())
          .then((responseJson) =&gt; {
             console.log('before state updated '+responseJson[0].name);
             this.setState({
              centres: responseJson,
             });
             console.log('after fetch called '+responseJson[0].name);
          })
          .catch((error)=&gt;{
             console.log('error '+error);
             this.setState({
               centres: [],
             });
          });
   }

   static navigationOptions = {
      title: 'Centers',
      headerTitleStyle: navigationHeaderStyle
   };

   render() {
      let centresList;
      if(typeof this.state.centres == 'undefined' ||
          this.state.centres.length == 0) {
          centresList = &lt;Text&gt;No results found&lt;/Text&gt;
      } else {
         centresList = &lt;FlatList
             data={this.state.centres}
             keyExtractor={(item, index) =&gt; item._centre_id}
             renderItem={({item}) =&gt; &lt;CentreComponent Centre={item}/&gt;}
             ItemSeparatorComponent={() =&gt; &lt;ListSeperator /&gt;}
          /&gt;
      }

    return(
       &lt;View&gt;
          {centresList}
          &lt;ListSeperator /&gt;
       &lt;/View&gt;
    );
   };
}
</code></pre>

<p>So basically it loads  CentreComponent(s) based on the response from fetch (i.e the number of results it gets).</p>

<p>In my test with Jest I am trying to assert two Components of type CentreComponent exist. My test looks like this:</p>

<pre><code>jest.disableAutomock();
import 'react-native';
import React from 'react';
import {shallow, mount, render} from 'enzyme';
import SearchResultsScreen from '../../src/SearchResultsScreen/index';
import CentreComponent from 
    '../../src/SearchResultsScreen/CentreComponent';
import renderer from 'react-test-renderer';

describe('SearchResultsScreen', () =&gt; {
  test.only('renders more than one CentreComponent', () =&gt; {
    jest.useFakeTimers();
    global.fetch = jest.fn().mockImplementation(() =&gt; {
        let kc = [{
          _centre_id: 1,
          name: 'test',
          address_1: 'abc',
          address_2: 'def',
          city: 'so',
          postcode: 'tt',
        }, {
          _centre_id: 2,
          name: 'testee',
          address_1: 'abc',
          address_2: 'def',
          city: 'so',
          postcode: 'tt',
        }]
        console.log('mock fetch called');

        return new Promise((resolve, reject) =&gt; {
          process.nextTick(
            () =&gt; resolve({ok: true, json: function(){return kc}})
          );
        });
     });

     const checkbox = mount(&lt;SearchResultsScreen origin_long='5' origin_lat='2' distance='5'/&gt;);
     jest.runAllTicks();
     checkbox.update();
     expect(checkbox.find(KarCentreComponent)).toHaveLength(2);
   });
});
</code></pre>

<p>When I run the test 
      jest.js --env=jsdom </p>

<p>I see the following console.log being printed in order:</p>

<pre><code>console.log('before fetch called');
console.log('mock fetch called');
console.log('before state updated '+responseJson[0].name);

Error at line:
console.log('error '+error);
</code></pre>

<p>The error which I get is:</p>

<pre><code>  { Invariant Violation: Element type is invalid: expected a string (for 
  built-in components) or a class/function (for composite components) 
  but got: undefined. You likely forgot to export your component from 
  the file it's defined in. Check the render method of 
  `SearchResultsScreen`
</code></pre>

<p>So my suspicion is that, when componentDidUpdate is calling</p>

<pre><code>  this.setState({
          centres: responseJson,
         });
</code></pre>

<p>It is throwing an exception which is being caught by the ""catch"".</p>
","3434013","","3434013","","2017-07-26 14:38:36","2017-07-26 14:38:36","Testing a component after state has been updated in componentDidMount using enzyme jest react-native","<react-native><state><enzyme><jest>","0","1","","",""
"44674711","1","44675207","","2017-06-21 11:21:33","","0","92","<p>I am trying to show <code>message</code> <code>'hello brozz..'</code> from the reducer to a component <code>render()</code> method.<code>ComponentDidMount()</code> get the <code>this.props.message</code> as <a href=""https://i.stack.imgur.com/qpNj6.png"" rel=""nofollow noreferrer"">please see the image</a>. And my reducer is like </p>

<pre><code> export const geod = (state ={}, action) =&gt; {
      console.log('inside reducer');
        switch(action.type){


            case 'INITIAL_MESSAGE':

              return [
                        ...state, {
                          message:'hello brozz..'
                        }
                      ]
            case 'CLICK_MESSAGE':
                  return [ 
                            ...state, { 
                                            message: ''
                                      }
                          ]
            default:
                    return state;
        }

     };
</code></pre>

<p>But I can not use <code>this.props.message</code> as <code>&lt;div&gt;&lt;div&gt;{this.props.message}&lt;/div&gt;&lt;/div&gt;</code> inside the render method. I am getting the error </p>

<pre><code>Objects are not valid as a React child (found: object with keys {}). If you meant to render a collection of children, use an array instead or wrap the object using createFragment(object) from the React add-ons
</code></pre>

<p>My component is,</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
import { initialMessageAction, clickButtonAction } from './redux.js';
import { connect } from 'react-redux';
import { Message } from './messageComponent';

class App extends Component {

  componentWillMount() {
    console.log('component will mount');
    let data = this.props.initialMessageAction();
  }
  componentDidUpdate() {
    console.log('comp Did Update')
    console.log(this.props.message)
  }
  render() {

    return (
      &lt;div className=""App""&gt;
        &lt;div className=""App-header""&gt;        
        &lt;/div&gt;
        &lt;p className=""App-intro""&gt;
        react-redux-data-flow
        &lt;/p&gt; 
              &lt;div&gt;{this.props.message}&lt;/div&gt;
             &lt;div&gt;{this.props? &lt;div&gt;hi ..&lt;button onClick={ () =&gt; this.props.clickButtonAction() }&gt;hide message&lt;/button&gt;&lt;/div&gt;: ''}&lt;/div&gt;
      &lt;/div&gt;
    );
  }
}


    const mapStateToProps = (state, ownProperty) =&gt; ({ 

    message:state.geod,   


  });   

   const mapDispatchToProps =  { 

     initialMessageAction,
    clickButtonAction

  } 

  export default connect(
                             mapStateToProps,
                             mapDispatchToProps

                    )(App);
</code></pre>
","6108331","","6108331","","2017-06-21 11:49:54","2017-06-21 12:12:09","Can not show message from the reducer in react","<reactjs><react-redux>","1","3","2","",""
"50353248","1","50353907","","2018-05-15 14:49:55","","0","28","<p>I'm trying to use css transitions, but as react re-renders a component, they are getting ignored. Let's imagine the use case, in which my <code>render()</code> function outputs something like this:</p>

<pre><code>&lt;ul&gt;
  &lt;li className={this.state.path===""/menu1/"" ? ""active"" : ""inactive""}&gt;
    menu 1
  &lt;/li&gt;
  &lt;li className={this.state.path===""/menu2/"" ? ""active"" : ""inactive""}&gt;
    menu 2
  &lt;/li&gt;
  &lt;li className={this.state.path===""/menu3/"" ? ""active"" : ""inactive""}&gt;
    menu 3
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Let's imagine that:</p>

<ul>
<li>.active is putting a blue background and animating on background color</li>
<li>.inactive is putting a red background and animating on background color</li>
</ul>

<p>The app loads with /menu1 being active. Using react router I update the state and the component should update. When navigating to a new route (eg ""/menu2/"") everything works, but as a re-rendering occurs, my transition gets ignored.</p>

<p>The only solution I saw was to modify the DOM using componentDidUpdate, but I don't want react to manipulate the DOM directly, so my question is :</p>

<p>How can I animate elements properly using react together with css?</p>
","3989883","","5153468","","2018-05-15 18:05:10","2018-05-15 18:05:10","css transitions ignored because react rerenders","<reactjs><react-router>","1","1","","",""
"36672338","1","","","2016-04-17 03:25:05","","1","181","<p>So I'm very new to reactjs and using chart-js-rails gem and react-rails gem in a Rails 4 application.  In componentDidMount method I want to essentially create a bar chart.  The data is getting fetched correctly as I can see it in the React chrome dev tools.  </p>

<p>The issue is that I get error <em>chart_container.self-40c721a….js?body=1:17 Uncaught TypeError: barNode.getContext is not a function</em>.  This means somehow the ReactDOM.findDOMNode() is not returning an element that I can perform getContext(""2d"") on.  </p>

<p>1 - Is it possible to use jQuery/Javascript and mix it with React this way to create a Chart.js bar chart in the CView component which will then be rendered in the Container component class?
2 - If no to #1, then what should I do to create a chart?</p>

<pre><code>@Container = React.createClass

  # set initial state before mounting component
  getInitialState: -&gt;
    # set to true once data has been fetched
    getData: false
    # The data JSON array used to display the data in the view
    someData: []

  #some other code here...

  componentDidUpdate: -&gt;
    barNode = ReactDOM.findDOMNode(@refs.barChart)
    barChart = new Chart(barNode.getContext(""2d"")).Bar(@state.someData)

  render: -&gt;
    &lt;div&gt;
      &lt;CView ref=""barChart"" data={@state.someData} /&gt;
    &lt;/div&gt;

@CView = React.createClass
  render: -&gt;
    &lt;p data={@props.data}&gt;&lt;/p&gt;
</code></pre>
","3681199","","","","","2016-04-17 03:25:05","How to use reactjs with chart-js-rails in a Rails 4 application?","<javascript><jquery><ruby-on-rails><reactjs>","0","0","","",""
"45376845","1","","","2017-07-28 15:06:08","","1","303","<p>I am following this hackernoon guide <a href=""https://hackernoon.com/animated-page-transitions-with-react-router-4-reacttransitiongroup-and-animated-1ca17bd97a1a"" rel=""nofollow noreferrer"">https://hackernoon.com/animated-page-transitions-with-react-router-4-reacttransitiongroup-and-animated-1ca17bd97a1a</a> in order to apply enter and leave animations to my react components when a route changes. I have obviously adapted the code to fit my site, and have decided not to use Animated but rather just pure CSS. Right now I'm just testing the code with console.log statements, and I noticed that componentWillEnter and componentWillLeave are not being called on route changes. Also, componentWillAppear only gets called once. </p>

<p>Here is the relevant code for each component, including App.js and index.js:</p>

<p>Animated Wrapper:</p>

<pre><code>import React, {Component} from ""react"";
import styles from '../styles/AnimatedWrapper.css';

const AnimatedWrapper = WrappedComponent =&gt;
  class AnimatedWrapper extends Component {
    componentWillAppear(cb) {
      console.log('componentWillAppear');
      cb();
    }
    componentWillEnter(cb) {
      console.log('componentWillEnter');
      cb();
    }
    componentWillLeave(cb) {
      console.log('componentWillLeave');
      cb();
    }
    render() {
      return (
        &lt;div id=""animated-wrapper"" className={styles.animatedPageWrapper}&gt;
          &lt;WrappedComponent {...this.props}/&gt;
        &lt;/div&gt;
      );}
    };

export default AnimatedWrapper;
</code></pre>

<p>App.js:</p>

<pre><code>import React, { Component } from 'react';
import { Route, Switch } from 'react-router-dom';
import TransitionGroup from ""react-transition-group/TransitionGroup"";

import Navbar from ""./components/Navbar"";
import Footer from ""./components/Footer"";
import Slider from ""./components/Slider"";
import ComingSoon from ""./components/ComingSoon"";

const firstChild = props =&gt; {
  const childrenArray = React.Children.toArray(props.children);
  return childrenArray[0] || null;
}

class App extends Component {
  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;Navbar /&gt;
        &lt;Switch&gt;
          &lt;Route
            path=""/coming-soon""
            children={({ match, ...rest }) =&gt; (
              &lt;TransitionGroup component={firstChild}&gt;
                {match &amp;&amp; &lt;ComingSoon {...rest} /&gt;}
              &lt;/TransitionGroup&gt;
          )}/&gt;
          &lt;Route
             path=""/""
             children={({ match, ...rest }) =&gt; (
               &lt;TransitionGroup component={firstChild}&gt;
                 {match &amp;&amp; &lt;Slider {...rest} /&gt;}
               &lt;/TransitionGroup&gt;
          )}/&gt;
        &lt;/Switch&gt;
        &lt;Footer /&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>

<p>index.js:</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  &lt;BrowserRouter&gt;
     &lt;App /&gt;
   &lt;/BrowserRouter&gt;,
  document.getElementById('root')
);
</code></pre>

<p>Slider.js:</p>

<pre><code>import React, { Component } from 'react';
import _ from 'lodash';

// components
import AnimatedWrapper from './AnimatedWrapper';
import Separator from './Separator';

// styles
import styles from '../styles/Slider.css';

// images
import Apartment from ""../../public/images/apartment.jpg"";
import Floor from ""../../public/images/floor.jpg"";
import Furniture from ""../../public/images/furniture.jpg"";
import Kitchen1 from ""../../public/images/kitchen.jpg"";
import Kitchen2 from ""../../public/images/kitchen-2.jpg"";

class SliderComponent extends Component {
  constructor(props) {
    super(props);

    this.state = {
      currentSlide: 0,
      slides: [Apartment, Floor, Furniture, Kitchen1, Kitchen2]
    };
  }

  componentDidMount() {
    this.zoomAnimation();
    this.slideContentAnimation();

    this.sliderInterval = setInterval(() =&gt; {
      if (this.state.currentSlide === 4) {
        if (this.refs.slider) {
          this.setState({ currentSlide: 0 });
        }
      } else {
        if (this.refs.slider) {
          this.setState({ currentSlide: this.state.currentSlide + 1 });
        }
      }
    }, 6000);
  }

  componentWillUpdate() {
    const currentContent = document.getElementById(`content-${this.state.currentSlide}`);
    setTimeout(() =&gt; {
      currentContent.classList.remove(`${styles.currentContent}`);
    }, 1500);
  }

  componentDidUpdate() {
    this.zoomAnimation();
    this.slideContentAnimation();
  }

  setSlide(number) {
    this.setState({ currentSlide: number });
  }

  zoomAnimation() {
    setTimeout(() =&gt; {
      const currentSlide = document.getElementById(`slide-${this.state.currentSlide}`);
      currentSlide.classList.add(`${styles.slideZoom}`);
    }, 500);
  }

  slideContentAnimation() {
    setTimeout(() =&gt; {
      const currentContent = document.getElementById(`content-${this.state.currentSlide}`);
      if (currentContent) {
        currentContent.classList.add(`${styles.currentContent}`);
      }
    }, 1500);
  }

  renderSlides() {
    return this.state.slides.map((slide, index) =&gt; {
      const isCurrent = index === this.state.currentSlide;

      const slideStyle = {
        backgroundImage: `url(${this.state.slides[index]})`
      }

      return (
        &lt;div
          id={`slide-${index}`}
          key={`slide-${index}`}
          className={`
            ${styles.slide}
            ${isCurrent ? styles.currentSlide : null}
          `}
          style={slideStyle}
          alt=""slide""&gt;
            &lt;div
              id={`content-${index}`}
              key={`content-${index}`}
              className={`
                ${styles.content}
            `}&gt;
              &lt;h1&gt;{`WE SPECIALIZE IN KITCHENS ${index}`}&lt;/h1&gt;
              &lt;Separator
                containerWidth={720}
                circleWidth={5}
                circleHeight={5}
                backgroundColor=""#fff""
                lineWidth={350}
                lineColor=""#fff""
              /&gt;
              &lt;div
                className={`${styles['hvr-sweep-to-top']} ${styles.btn}`}&gt;
                More Information
              &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
      );
    });
  }

  renderNavBar() {
    return (
      &lt;div className={styles.sliderNav}&gt;
        {_.range(5).map((index) =&gt; {
          return (
            &lt;div
              key={index}
              onClick={() =&gt; this.setSlide(index)}
              className={this.state.currentSlide === index ? styles.current : null}&gt;
            &lt;/div&gt;
          )
        })}
      &lt;/div&gt;
    )
  }

  render() {
    return (
      &lt;div className={styles.container} ref=""slider""&gt;
        &lt;div className={styles.slidesContainer}&gt;
          {this.renderSlides()}
        &lt;/div&gt;

        {this.renderNavBar()}
      &lt;/div&gt;
    );
  }
}

const Slider = AnimatedWrapper(SliderComponent);
export default Slider;
</code></pre>

<p>ComingSoon.js:</p>

<pre><code>import React from 'react';
import AnimatedWrapper from './AnimatedWrapper';
import styles from '../styles/ComingSoon.css';

const ComingSoonComponent = function() {
  return (
    &lt;div&gt;
      &lt;div className={styles.mainContent}&gt;
        &lt;div&gt;
          &lt;h1 className={styles.mainTitle}&gt;{`Coming Soon`}&lt;/h1&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

const ComingSoon = AnimatedWrapper(ComingSoonComponent);
export default ComingSoon;
</code></pre>
","4294220","","","","","2017-10-27 06:58:58","Why is react-transition-group not calling componentWillEnter nor componentWillLeave on route change?","<javascript><css3><reactjs><react-router><react-transition-group>","1","0","","",""
"44849949","1","","","2017-06-30 15:24:31","","2","242","<p>I would like to test a component that uses D3 which reports on the competent relative coordinates of a <code>mouseMove</code> event. This component works as expected in the browser -- I have a simple callback that logs the coordinates and the a 'Mouse moved' event is also recorded:</p>

<pre><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import { mouse, select } from 'd3-selection';

class Overlay extends Component {
  _handleMouseMove(coordinates, callback) {
    console.log('Mouse moved');
    callback(coordinates);
  }

  componentDidMount() {
    this.renderD3Move();
  }
  componentDidUpdate() {
    this.renderD3Move();
  }

  renderD3Move() {
    const handleMouseMove = this._handleMouseMove;
    const callback = this.props.callback;
    const node = ReactDOM.findDOMNode(this);
    select(node).on('mousemove', function handleMouse() {
      handleMouseMove(mouse(node), callback);
    });
  }

  render() {
    return (
      &lt;rect
        className=""overlay""
        height={this.props.height}
        width={this.props.width}
      /&gt;
    );
  }
}

export default Overlay;
</code></pre>

<p>Despite this, I am unable to write a test that triggers the callback or even get the 'Mouse moved' message to log:</p>

<pre><code>import chai from 'chai';
chai.should();
import React from 'react';
import { mount } from 'enzyme';
import sinon from 'sinon';
import Overlay from '.';

describe('&lt;Overlay /&gt;', function() {
  var height = 50,
    width = 50;

  it('passes mouse coordinates when mouse moves', function() {
    const callback = sinon.spy();
    var wrapper = mount(
      &lt;Overlay height={height} width={width} callback={callback} /&gt;
    );
    wrapper.find('Overlay').simulate('mousemove');
    wrapper.find('rect').simulate('mousemove');
    wrapper.find('Overlay').simulate('mouseMove');
    wrapper.find('rect').simulate('mouseMove');
    callback.called.should.equal(true);
  });
}
</code></pre>

<p><strong>My questions are:</strong></p>

<ol>
<li>Is there a way to trigger mouseMove in the component from the test?</li>
<li>If so, can I also test the coordinates of the mouseMove event?</li>
<li>If there is a fundamental incompatibility with how I'm implementing the component, is there a best practice for how to determine the coordinates of a mouseMove event relative to the node that can be easily tested?</li>
</ol>

<p><em>Related questions that don't fully address what I'm asking</em></p>

<ul>
<li><a href=""https://stackoverflow.com/questions/31055738/react-testutils-how-can-i-simulate-document-mousemove"">This asks a related question about mouseMove but the dispatchEvent approach doesn't seem to work on nodes</a></li>
<li><a href=""https://stackoverflow.com/questions/16154857/how-can-i-get-the-mouse-co-ordinates-relative-to-a-parent-div-javascript"">This seems to be a solution for determining the position of mouse coordinates but may be challenging to integrate into react</a></li>
<li><a href=""https://stackoverflow.com/questions/40939133/how-do-you-reliably-measure-react-components-for-computed-position-of-popovers-a"">And this one leads me to be more confident that its not trivial to determine coordinates</a></li>
</ul>
","4584809","","","","","2017-06-30 15:24:31","How to simulate mouseMove on d3 component for testing in react","<reactjs><testing><d3.js><enzyme>","0","0","","",""
"49035256","1","","","2018-02-28 17:22:04","","0","29","<p>I am trying to create a react HOC that would render its children, and then after <em>all</em> the children had finished updating BUT BEFORE THE DOM is updated, would decide to raise (or not raise) an error, depending on some flags the children would update.</p>

<pre><code>&lt;Try alternative=... &gt;
  ... do some stuff // if anybody in here sets a flag we will
                    // render alternative instead
&lt;/Try&gt;
</code></pre>

<p>Why?  It would be useful to allow all the children of Try to complete rendering and then if any were waiting on some async callbacks, to render the alternative.  Kind of like an error boundary but it would all the enclosed children to re-rerender first.</p>

<p>Having the first child that hits the condition raise an error doesn't work, since it doesn't allow the rest of the children to finish.</p>

<p>Using an componentDidUpdate handler in Try won't work either, since it won't run unless Try actually changed (I think).</p>

<p>I am hoping somebody will know of a secret, or expermental trick that might work.</p>

<p>Thanks</p>
","859491","","","","","2018-03-01 14:32:44","throw error after everything is rendered in react","<reactjs>","1","2","","",""
"44487215","1","44519912","","2017-06-11 18:22:40","","2","1643","<p>According to the <a href=""https://github.com/tomchentw/react-google-maps/blob/master/src/lib/GoogleMap.js#L125-L131"" rel=""nofollow noreferrer"">React Google Maps library</a>, you can call these four methods from the ref object.</p>

<p>What seems weird, is that these methods are supposed to receive two parameters, a map instance and other arguments, like so:</p>

<pre><code>fitBounds(map, args) { return map.fitBounds(...args); }
</code></pre>

<p>However, when calling fitBounds() this way, nothing happens on the map, no bounds are changed and no errors are thrown. This is the way I have structured the component, calling fitBounds in componentDidUpdate:</p>

<pre><code>import React from 'react'
import { withGoogleMap, GoogleMap, InfoWindow, Marker, OverlayView } from 'react-google-maps'
import InfoBox from 'react-google-maps/lib/addons/InfoBox'
import map from 'lodash/map'

// Higher-Order Component
const AllocatedPlacesMap = withGoogleMap(props =&gt; (
  &lt;GoogleMap
    center={props.center}
    defaultZoom={4}
    options={{ scrollwheel: false, minZoom: 3, maxZoom: 15 }}
    onCenterChanged={props.onCenterChanged}
    ref={props.onMapMounted}&gt;
    {props.markers.map((marker, index) =&gt; (
      &lt;Marker
        key={index}
        position={marker.position}
      /&gt;
    ))}
  &lt;/GoogleMap&gt;
));

class Map extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
    };
  }

  getCenter = () =&gt; {
    this._bounds = new google.maps.LatLngBounds();

    this.props.markers.forEach((marker, index) =&gt; {
      const position = new google.maps.LatLng(marker.lat, marker.lng);
      this._bounds.extend(position);
    });

    return this._bounds.getCenter();
  }

  componentDidUpdate() {
    this._map.fitBounds(this._map, this._bounds);
  }

  handleMapMounted = (map) =&gt; {
    this._map = map;
  }

  render() {
    return (
      &lt;div className=""allocated-places""&gt;
        &lt;AllocatedPlacesMap
          containerElement={
            &lt;div style={{ height: `100%` }} /&gt;
          }
          mapElement={
            &lt;div style={{ height: `100%` }} /&gt;
          }
          center={this.getCenter()}
          markers={props.markers}
          onMapMounted={this.handleMapMounted}
        /&gt;
      &lt;/div&gt;
    )
  }
}

export default Map;
</code></pre>

<p>Any idea of what is the correct way to call fitBounds() in this case? documentation and examples seem to be lacking in this regard.</p>
","309383","","4826457","","2017-09-21 06:10:58","2017-09-26 20:59:23","react-google-maps: how to use fitBounds, panBy, panTo, panToBounds public APIs?","<reactjs><google-maps><google-maps-api-3><react-google-maps>","2","1","1","",""
"45077004","1","","","2017-07-13 09:45:02","","5","1582","<p>I'm using Redux in my app, inside a Component I want to scroll to an specific div tag when a change in the store happens.
I have the Redux part working so it triggers the componentDidUpdate() method (I routed to this compoennt view already).
The problem as far as I can tell, is that the method scrollIntoView() doesn't work properly cos componentDidUpdate() has a default behavior that scrolls to the top overwriting the scrollIntoView().
To work-around it I wrapped the function calling scrollIntoView() in a setTimeout to ensure that happens afeterwards.
What I would like to do is to call a preventDefault() or any other more elegant solution but I can't find where to get the event triggering the 'scrollTop'
I looked through the Doc here: <a href=""https://facebook.github.io/react/docs/react-component.html#componentdidupdate"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/react-component.html#componentdidupdate</a>
and the params passed in this function are componentDidUpdate(prevProps, prevState) ,since there is no event I don't know how to call preventDefault()</p>

<p>I've followd this Docs: <a href=""https://facebook.github.io/react/docs/refs-and-the-dom.html"" rel=""nofollow noreferrer"">https://facebook.github.io/react/docs/refs-and-the-dom.html</a>
And tried different approaches people suggested here: <a href=""https://stackoverflow.com/questions/30495062/how-can-i-scroll-a-div-to-be-visible-in-reactjs"">How can I scroll a div to be visible in ReactJS?</a></p>

<p>Nothing worked though 
Here is my code if anyone has any tip for me, thanks</p>

<pre><code>class PhotoContainer extends React.Component {

  componentDidUpdate(){
    setTimeout(() =&gt; {
     this.focusDiv();
    }, 500);

  }
  focusDiv(){
    var scrolling = this.theDiv;
    scrolling.scrollIntoView();

  }

  render() {
    const totalList = [];
    for(let i = 0; i &lt; 300; i += 1) {
        totalList.push(
            &lt;div key={i}&gt;{`hello ${i}`}&lt;/div&gt;
        );
    }

  return (
      &lt;div &gt;
          {totalList}
          &lt;div ref={(el) =&gt; this.theDiv = el}&gt;this is the div I'm trying to scroll to&lt;/div&gt;
      &lt;/div&gt;
  )
</code></pre>

<p>};
    }</p>
","8069457","","8069457","","2017-07-14 12:10:10","2017-07-14 12:10:10","React, Using Refs to scrollIntoView() doen't work on componentDidUpdate()","<javascript><reactjs><react-redux>","0","6","","",""
"44502039","1","","","2017-06-12 14:32:50","","1","785","<h2>Code Situation</h2>

<p>I have a simple react app setup. The home component should be a image gallery with a masonry layout. I found this library: <a href=""https://github.com/callmecavs/bricks.js"" rel=""nofollow noreferrer"">Bricks.js</a>
I load the data <strong>(name, date, url to image)</strong> of the items from my api with <a href=""https://github.com/github/fetch"" rel=""nofollow noreferrer"">fetch</a>. </p>

<p>Here are some parts of my code in Home.js:</p>

<p>The <strong>constructor()</strong></p>

<pre><code>constructor() {
  super();
  this.state = {
    galleryItems: []
  };
  this.instance = {}
}
</code></pre>

<p>This function loads the data of the items.</p>

<pre><code>getItems(limit){
  fetch('http://localhost:3000/api/posts/next/' + limit)
    .then((response) =&gt; {
      return response.json()
    }).then((data) =&gt; {
      this.setState({galleryItems: data});
    })
}
</code></pre>

<p>I used the <strong>componentDidMount()</strong> function to load 5 items and create the Bricks.js instance.</p>

<pre><code>componentDidMount(){
  this.getItems(5)
  //sizes for Brick.js
  const sizes = [
    { columns: 5, gutter: 3 },
    { mq: '768px', columns: 2, gutter: 3 },
    { mq: '1024px', columns: 3, gutter: 3 }
  ]
  //init instance
  this.instance = Bricks({
    container: '.gallery',
    packed: 'packed',
    sizes: sizes
  })
  this.instance.resize(true);  //&lt;-adds a resize event listener
  if (this.state.galleryItems.length &gt; 0) {
    this.instance.pack() //&lt;- This should create the masonry layout
  }
}
</code></pre>

<p>And for loading more image I wrote this in the <strong>componentDidUpdate()</strong> function.</p>

<pre><code>componentDidUpdate(){
  if (this.state.galleryItems.length &gt; 0) {
    return this.instance.pack()
  }
  else{
    return this.instance.update() //&lt;- updates the layout
  }
}
</code></pre>

<p>The <strong>render()</strong> function converts the data from the server to a <code>&lt;Item&gt;</code> which is just another component that creates a <code>&lt;img&gt;</code> element</p>

<pre><code>render() {
  const items = this.state.galleryItems.map((item, _id) =&gt; {
    return &lt;Item key={_id} url={this.state.url + item.url}&gt;&lt;/Item&gt;
  })
  return (
    &lt;div&gt;
      Home Component
      &lt;div className=""gallery""&gt;
        {items}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<h2>Problem</h2>

<p>If I open my app in firefox it works fine. But in chrome the images are just on top of each other. If I resize the window the masonry layout is created fine. I seems chrome is either too fast or slow.
What is wrong with my code that this can happen?</p>
","5444033","","5444033","","2017-06-12 15:15:57","2017-06-12 15:15:57","Create a masonry with bricks.js and react","<javascript><reactjs><fetch><react-masonry>","0","3","","",""
"37064242","1","37107308","","2016-05-06 04:27:27","","11","639","<p>I've been having a hell of a time getting the comment count script to work on my react pages. To start, they recommend putting the script in my index.html file, at the bottom of the <code>&lt;body&gt;</code> tag. I've done this, and seen no result.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>  &lt;body&gt;
    &lt;div id=""app""&gt;
    &lt;/div&gt;
    &lt;script src=""static/index.js""&gt;&lt;/script&gt;
    &lt;script id=""dsq-count-scr"" src=""//mtg-hunter.disqus.com/count.js"" async&gt;&lt;/script&gt;
  &lt;/body&gt;</code></pre>
</div>
</div>
</p>

<p>I have an index.js file which is loading all my components, including the component (let's call it ResultComponent.js) which I want to have the comment count <code>&lt;span&gt;</code> tags in. The <code>&lt;span&gt;</code> tags themselves look like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var commentCount = &lt;span className=""disqus-comment-count"" onClick={function() {this.setState({currentSelectedTab: 4})}.bind(this)} 
			data-disqus-identifier={idGoesHere}
			style={{fontVariant:""small-caps""}}&gt;0 Comments&lt;/span&gt;</code></pre>
</div>
</div>
</p>

<p>So far, so simple. I'm not using any <code>&lt;a&gt;</code> tags so I haven't got <code>#disqus_thread</code> anywhere. When I load my page, I expect my comment count to go up, but no such luck. To test this, I copied the raw script, unaltered, from the raw count.js script (which is <a href=""https://mtg-hunter.disqus.com/count.js"">located here</a>). I then pasted it straight into Chrome's devtools console, and it worked; all the relevant comment counters went to their appropriate values.</p>

<p><strong>EDIT</strong>: a day later, more prodding; I added breakpoints in the actual code in the disqus.com domain. The script in the script tag is running just fine at the right time, except it's missing variables when it enters the displayCount() function. There's several variables that just aren't given values so it can't go in and populate the comment counts, it always fails out. I have no idea why this fails when it's called from within my index.html but not when I paste the raw count.js code into my console and do it there. No idea why.</p>

<p>To clarify, this is the relevant code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>e.displayCount = function(b) {
        for (var c, a, d, e = b.counts, b = b.text.comments; c = e.shift(); )
            if (a = j[c.id]) {
                switch (c.comments) {
                case 0:
                    d = b.zero;
                    break;
                case 1:
                    d = b.one;
                    break;
                default:
                    d = b.multiple
                }
                c = d.replace(""{num}"", c.comments);
                a = a.elements;
                for (d = a.length - 1; d &gt;= 0; d--)
                    a[d].innerHTML = c
            }
    }
    ;</code></pre>
</div>
</div>

When it runs properly, from my pasting the script into the console, the <code>j</code> variable is defined. When it runs called from index.html, <code>j</code> is undefined, so it fails at the first <code>if</code>. The calling url is exactly the same in both situations: <code>http://mtg-hunter.disqus.com/count-data.js?1=19767&amp;1=235597&amp;1=373322&amp;1=382310&amp;1=382841&amp;1=382866&amp;1=383023&amp;1=397543&amp;1=397682&amp;1=398434</code>. That gives the <code>b</code> parameter, and when I run the script locally it defines <code>j</code> so that the assignment operator in the if can work (which is a really weird way of doing it, but ok).</p>

<p><strong>edit again:</strong> I should point out I'm doing this on a local test server (<code>localhost:3000</code>), not sure if that makes a difference or not?</p>

<p><strong>edit more:</strong> The answer to my above question turns out to be 'no'. I uploaded my code to my server and the production site also showed that the script wasn't running properly. This is absurd... I'm out of ideas by now.</p>

<p><strong>edit again more:</strong> Partial breakthrough... I added this code to ResultComponent.js:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    componentDidMount() {
    	DISQUSWIDGETS.getCount();
    },

    componentDidUpdate() {
    	DISQUSWIDGETS.getCount();
    },</code></pre>
</div>
</div>
</p>

<p>Good news; when I refresh the page, it shows the right comment count! Hooray! Bad news: when I change parts of the page that hide the Result component, and then bring it back (triggering <code>componentDidUpdate</code>), the <code>DISQUSWIDGETS.getCount()</code> call doesn't work. It still gets called, but the <code>displayCount</code> part of the script never does, so the DOM is never updated with the new information. It's yet another example of this horrid script behaving differently despite being called in exactly the same way...</p>
","3234562","","3234562","","2016-05-09 17:20:10","2016-05-09 17:20:10","Disqus's count.js script doesn't run properly in index.html with react.js website","<javascript><reactjs><disqus>","1","3","","",""
"37075461","1","37076553","","2016-05-06 14:52:31","","1","184","<p>In my component I have an <code>componentDidUpdate</code> function where I play a video and on that video I set the <code>video.onended</code> event as noted <a href=""http://www.w3schools.com/tags/av_event_ended.asp"" rel=""nofollow"">HERE</a></p>

<p>Currently my code looks like this: </p>

<pre><code>  componentDidUpdate: function() {
    if(this.state.showVideo){
      this.refs.homeVideo.play();
      // Triggering event on video end
      let homeVideo = document.getElementById(""homeVideo"");
      homeVideo.onended = function(){
        console.log(this.state);
        this.setState({ showVideo: !this.state.showVideo });
      }
    }
  }
</code></pre>

<p>My issue right now is that this.state is undefined in the onended function and so is setState, which is preventing me from updating the state of the component in react so that I can close the video player when it ends. </p>

<p>What is the appropriate react way of handling this?</p>
","1707697","","","","","2016-05-06 15:58:09","How can I set the state of a component on video end in react?","<javascript><video><reactjs><html5-video>","2","0","","",""
"44730057","1","","","2017-06-23 21:16:19","","1","310","<p>I have page which had componentA and on componentDidMount cycle method i am updating state which trigger some animation but if I refresh the page animation doesn't play. Please let know how I can resolve this issue. below is my component code</p>

<pre><code>import React from 'react';
import { findDOMNode } from 'react-dom';
import Nav from ""../nav/nav-component"";
class Mylist extends React.Component{
  constructor(props) {
    super(props);
    this.handleScroll = this.handleScroll.bind(this);
    this.state = { animationClass: '' , transform : 12  };
  }
  componentDidMount() {
      window.addEventListener('scroll', this.handleScroll);
      this.setState({animationClass:'animate'});
  };
  componentDidUpdate() {
      //this.setState({animationClass:''});
  };

  componentWillUnmount() {
      window.removeEventListener('scroll', this.handleScroll);
      this.setState({animationClass:''});
  };
  handleScroll(event){
    const scrollTop = event.srcElement.body.scrollTop,
          ele = findDOMNode(this.refs.toggle), // how to get dom element in react
          childElements = ele.children,
          componentTopPos = ele.getBoundingClientRect();
    //itemTranslate = Math.min(0, scrollTop/3 - 60);

    console.log(""scrollTop"",scrollTop);
    console.log(childElements);
    console.log(""componentTopPos"",componentTopPos);

     console.log(this);
    this.setState({
      transform: ""dsfdf""
    });
  }
  render(){
    return ( 
      &lt;div className={'header '+this.state.animationClass}&gt;
      &lt;Nav /&gt;
      &lt;/div&gt; 
    );
  }
}
export default Mylist;
</code></pre>
","5031236","","","","","2017-06-23 21:16:19","On page refresh which life cycle method called in react?","<javascript><reactjs><ecmascript-6>","0","1","","",""
"45177522","1","","","2017-07-18 21:36:19","","0","41","<p>i have a async fetch that gets values like A001, A002, names and so on from an API. But sometimes i get 3 or more values with 1 api fetch and i loose some because i show only 3 values at a time in my react component.</p>

<p>So i look for a way to continuously show 1 entry from the store for like 2 seconds and then the next entry and so on.</p>

<p>Can someone please help me here?</p>

<p><strong>Actions</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let lastId = 0;
let pathArray = window.location.pathname.split('/');

export const fetchLastId = () =&gt; dispatch =&gt; {
    const url = '/api/display/sites/' + pathArray[3] + '/displays/' + pathArray[5] + '/show';
    fetch(url, {
        method: 'GET',
        mode: 'cors',
        headers: {
            'Authorization': ''
        },
        'Content-Type': 'application/json' 
    }).then(function(response) {
            return response.json();
    }).then(function(data) {
        if (data.length) {
            lastId = data[0].id;
        } else {
            lastId = 0;
        }
        console.log('Die Letzte ID war ' + lastId);
    }).catch(function(error) {
        console.log('Fehler: ', error);
    })
}

export const fetchLastCalls = () =&gt; dispatch =&gt; {
    const url = '/api/display/sites/' + pathArray[3] + '/displays/' + pathArray[5] + '/calls?id_greater_than=' + lastId;
    fetch(url, {
        method: 'GET',
        mode: 'cors',
        headers: {
            'Authorization': ''
        },
        'Content-Type': 'application/json' 
    }).then(function(response) {
            return response.json();
    }).then(function(data) {
        data.reverse();
        if (data.length) {
            for (let item of data) {
                switch (item.service_id) {
                case 24:
                    dispatch({ type: 'SERVICE_1', payload: item })
                    break;
                case 25:
                    dispatch({ type: 'SERVICE_2', payload: item })
                    break;
                default:
                    console.log('Aufruf im Falschen Dienst getätigt.')
                }
                lastId = item.id;
            }
        } else {
            console.log('Keine neuen Aufrufe.');
        }    
    }).catch(function(error) {
        console.log('Fehler: ', error);
    })
}</code></pre>
</div>
</div>
</p>

<p><strong>Reducer</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let initialState = [];

function service1(state = initialState, action) {
    if (action.type === 'SERVICE_1') {
        return [action.payload, ...state];
    }
    return state;
}

export default service1;</code></pre>
</div>
</div>
</p>

<p><strong>Container</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { connect } from 'react-redux';

import { NewCall } from '../components/NewCall';
import { LastCall } from '../components/LastCall';

import { fetchLastId , fetchLastCalls } from '../actions/index';

class Service1 extends React.Component {
    componentWillMount() {
        this.props.onFetchLastId();
    }
    componentDidMount() {
        setInterval(function() {
            this.props.onFetchLastCalls();
        }.bind(this), 1000);
    }
    renderNewTicket() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.ticket}&gt;{call.ticket}&lt;/p&gt;
            );
        });
    }
    renderNewPlace() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.desk_id}&gt;{call.desk_id}&lt;/p&gt;
            );
        });
    }
    renderLastTicket() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.ticket}&gt;{call.ticket}&lt;/p&gt;
            )
        })
    }
    renderLastPlace() {
        return this.props.calls.map(call =&gt; {
            return (
                &lt;p key={call.desk_id}&gt;{call.desk_id}&lt;/p&gt;
            )
        })
    }
    componentDidUpdate() {

    }
    render() {
        return(
            &lt;div&gt;
                &lt;NewCall 
                    call={ this.renderNewTicket() } 
                    place={ this.renderNewPlace() } 
                /&gt;
                &lt;LastCall 
                    call={ this.renderLastTicket() } 
                    place={ this.renderLastPlace() }
                    rollOn={1} 
                /&gt;
                &lt;LastCall 
                    call={ this.renderLastTicket() } 
                    place={ this.renderLastPlace() }
                    rollOn={2} 
                /&gt;
            &lt;/div&gt;
        );
    }
}

function mapStateToProps(state) {
    return {
        calls: state.service1
    };
}

let mapDispatchToProps = {
  onFetchLastId: fetchLastId,
  onFetchLastCalls: fetchLastCalls
}


export default connect(mapStateToProps, mapDispatchToProps)(Service1);</code></pre>
</div>
</div>
</p>

<p><strong>1 Output Component</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { Textfit } from 'react-textfit';

import Blink from './Blink';

const inlineStyle = {
    width: 945,
    height: 249
};

export class NewCall extends React.Component {
    render() {
        return(
            &lt;div&gt;
                &lt;div className=""flex-item-grey ticketNrGr""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyle} className=""textfit"" max={200}&gt;&lt;Blink&gt;{this.props.call[0]}&lt;/Blink&gt;&lt;/Textfit&gt;
                &lt;/div&gt;
                &lt;div className=""flex-item-grey platzNrGr""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyle} className=""textfit"" max={200}&gt;&lt;Blink&gt;{this.props.place[0]}&lt;/Blink&gt;&lt;/Textfit&gt;        
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}</code></pre>
</div>
</div>
</p>

<p><strong>Second Output Component</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React from 'react';
import { Textfit } from 'react-textfit';

const inlineStyleCall = {
    width: 735,
    height: 195
};

const inlineStyleDesk = {
    width: 200,
    height: 195
};

export class LastCall extends React.Component {
    render() {
        return(
            &lt;div className=""flex-container-aufrufKl""&gt;
                &lt;div className=""flex-item-grey ticketNrKl""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyleCall} className=""textfit"" max={200}&gt;{this.props.call[this.props.rollOn]}&lt;/Textfit&gt;
                &lt;/div&gt;
                &lt;div className=""flex-item-grey platzNrKl""&gt;
                    &lt;Textfit mode=""multi"" style={inlineStyleDesk} className=""textfit"" max={200}&gt;{this.props.place[this.props.rollOn]}&lt;/Textfit&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}</code></pre>
</div>
</div>
</p>
","7942350","","7942350","","2017-07-18 21:56:05","2017-07-18 21:56:05","Is there a way to continuously get an value from a redux store one at a time? react redux","<javascript><reactjs><redux>","1","1","","",""
"45611651","1","45612052","","2017-08-10 10:49:58","","1","185","<p>I am trying to mock Facebook feed like scroller in my application with <a href=""https://github.com/bvaughn/react-virtualized"" rel=""nofollow noreferrer"">react-virtualized</a>. I am following the reference from <a href=""https://github.com/bvaughn/tweets/blob/37d0139736346db16b9681d5b859a4e127964518/src/components/TweetList.js#L126-L132"" rel=""nofollow noreferrer"">here</a>. I am trying to load two feeds at a time and after that <code>loadMoreRows</code> would be called to fetch the next two. I have hardcoded my feed size to 10 for testing purpose. It works well till 4th feed. Then I am not able to move after that smoothly. <code>rowRenderer</code> is triggering the numbers again and again which results in vibration effect on the screen. If I somehow move to the 10th feed and I scroll back, <code>rowRenderer</code> starts from 0 again. I assume it is due to varying height. Similar to the reference, I have used <code>CellMeasurerCache</code> and <code>CellMeasurer</code> to find the dynamic <code>height</code> and <code>width</code> and passing that to list. </p>

<pre><code>class Scroller extends React.Component {
  _cache = new CellMeasurerCache({ defaultHeight: 100, fixedWidth: true });
  _resizeAllFlag = false; 
  _mostRecentWidth = 0;
  constructor(props) {
    super(props);
    this.state = {
      localCache: []
    }
  }
  componentDidMount(){
    this._loadData(0); 
  }
  componentDidUpdate(prevProps, prevState) {
    console.log(this._list);
    if(this._resizeAllFlag){
      this._resizeAllFlag = false;
      this._cache.clearAll();
      this._recomputeRowHeights();
    } else if(this.state.localCache !== prevState.localCache) {
      this._cache.clear(index, 0);
      this._recomputeRowHeights(index);
    }
  }
  ._loadData = (offset, callback) =&gt; {
    //Loads data from server and sets it in this.state.localCache
  }
  _recomputeRowHeights = (index) =&gt; {
    if (this._list) {
      console.log('Recomputing');
      this._list.recomputeRowHeights(index);
    }
  }
  _isRowLoaded = ({ index }) =&gt; {
    return !!this.state.localCache[index];
  }
  _loadMoreRows = ({ startIndex, stopIndex }) =&gt; {
    this._loadData(startIndex, (() =&gt; promiseResolver));
    let promiseResolver;
    return new Promise((resolve) =&gt; {
      promiseResolver = resolve;
    });
  }
  rowRenderer = ({ index, key, style, parent }) =&gt; {
    const row = this.state.localCache[index];
    let content;
    if (row) {
      content = (&lt;Feed data={row}/&gt;);
    } else {
      content = (&lt;CustomLoader /&gt;);
    }
    return (
      &lt;CellMeasurer
        cache={this._cache}
        columnIndex={0}
        key={key}
        parent={parent}
        rowIndex={index}
        width={this._mostRecentWidth}
      &gt; 
        {content} 
      &lt;/CellMeasurer&gt;);
  }
  _setListRef = (ref) =&gt; {
    this._list = ref;
    this._registerList(ref);
  };
  _resizeAll = () =&gt; {
    this._resizeAllFlag = false;
    this._cache.clearAll();
    if (this._list) {
      this._list.recomputeRowHeights();
    }
  };
  render() {
    const { localCache } = this.state;
    return (
      &lt;div className=""flex_grow""&gt;
        &lt;InfiniteLoader
          isRowLoaded={this._isRowLoaded}
          loadMoreRows={this._loadMoreRows}
          rowCount={10}
        &gt;
          {({ onRowsRendered, registerChild }) =&gt;
            &lt;AutoSizer disableHeight&gt;
              {({ width, height }) =&gt; {
                if (this._mostRecentWidth &amp;&amp; this._mostRecentWidth !== width) {
                  this._resizeAllFlag = true;
                  setTimeout(this._resizeAll, 0);
                }
                this._mostRecentWidth = width;
                this._registerList = registerChild;
                return (
                  &lt;List
                    deferredMeasurementCache={this._cache}
                    overscanRowCount={1}
                    ref={this._setListRef}
                    height={height}
                    onRowsRendered={onRowsRendered}
                    rowCount={10}
                    rowHeight={this._cache.rowHeight}
                    rowRenderer={this.rowRenderer}
                    width={width}
                  /&gt;
                ) 
              }
              }
            &lt;/AutoSizer&gt;}
        &lt;/InfiniteLoader&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Update</strong></p>

<p>I might have deleted style props in content that is being passed. As per @Adrien's suggestion, I added it. My issues were not solved after adding style props.</p>

<pre><code>rowRenderer = ({ index, key, style, parent }) =&gt; {
  const row = this.state.localCache[index];
  let content;
  if (row) {
    content = (&lt;Feed style={style} data={row}/&gt;);
  } else {
    content = (&lt;CustomLoader style={style}/&gt;);
  }
  return (
    &lt;CellMeasurer
      cache={this._cache}
      columnIndex={0}
      key={key}
      parent={parent}
      rowIndex={index}
      width={this._mostRecentWidth}
    &gt; 
      {content} 
    &lt;/CellMeasurer&gt;);
} 
</code></pre>

<p>And my Feed component</p>

<pre><code>class Feed extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const { style } = this.props;
    return (
      &lt;div className=""flex_grow"" style={style}&gt;
        {/* Feed related JSX */}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>My components seems to be overlapping. What could have been wrong?</p>

<p><strong>AnswerGist</strong>:
<a href=""https://gist.github.com/beb4/cc91f4e9b8982d172613cff248090769"" rel=""nofollow noreferrer"">https://gist.github.com/beb4/cc91f4e9b8982d172613cff248090769</a></p>
","2193672","","2193672","","2017-08-11 05:15:00","2017-08-11 05:15:00","react-virtualized Infinite scroller issues with dynamic height","<reactjs><react-virtualized>","1","0","","",""
"45478329","1","","","2017-08-03 08:05:34","","0","469","<p>I stuck in bit weird situation, I am using ReactJS. I have header container, title bar, title container. Header container has navigation bar. On click of that it effects title bar. I am using react router for that navigation. I am using <code>componentDidMount</code> lifecycle method for that.</p>

<p>Problem with that it triggers only once when title container loads. So I used <code>componentDidUpdate</code>. But in that problem occured when I added title bar component to title container. So now my <code>componentDidUpdate</code> runing in infinite loop. I tried to use <code>shouldComponentUpdate(nextProps, nextState)</code> but I don't know what condition put to return it false.</p>

<pre><code>export class TitleContainer extends React.Component {
    componentDidMount() {
        this.props.dispatch(fetchDetail(this.props.match.params.program_id))
    }
    componentDidUpdate(prevProps, prevState) {

        this.props.dispatch(fetchDetail(this.props.match.params.id))
    }

    shouldComponentUpdate(nextProps, nextState){
        console.log(""current props"",this.props)
        console.log(""next props"",nextProps)
        // if(this.props.name == nextProps.name)
        //     return false;
        return true;
    }
    render() {

        console.log(""data in contaner"", this.props)
        return (
        &lt;div&gt;
         &lt;Title name = { this.props.name }

            /&gt;
            &lt;/div&gt;
        )
    }
}
const mapStateToProps = (state) =&gt; {
    console.log(""update state"", state)

    return {
        programProfileData: state.DetailReducer.Details,

        name: state.DetailReducer.name
    }
}
export default connect(mapStateToProps)(TitleContainer)
</code></pre>
","5913407","","472495","","2017-08-04 07:58:47","2017-08-04 07:58:47","how to stop update in reactjs","<reactjs><react-redux><react-router-v4>","1","0","1","",""
"44527838","1","","","2017-06-13 17:21:11","","0","282","<p>I want to be able to replicate this demo: <a href=""https://bl.ocks.org/danasilver/cc5f33a5ba9f90be77d96897768802ca"" rel=""nofollow noreferrer"">https://bl.ocks.org/danasilver/cc5f33a5ba9f90be77d96897768802ca</a> but instead of standard svg circles I would like to use React components. From all the research I have done the standard fare was usually to wrap d3 code in a React component instead of the other way around. I want to be able to, instead of writing this code:</p>

<pre><code>var circles = svg.selectAll('circle')
    .data(points)
  .enter().append('circle')
    .attr('cx', function(d) { return d.x; })
    .attr('cy', function(d) { return d.y; })
    .attr('r', r)
    .call(drag);
</code></pre>

<p>I would like to write code like this:</p>

<pre><code>var circles = svg.selectAll({{insert react component here}})
    .data({{pass in the props here (or elsewhere)}})
  .enter().append('circle')
    .attr('cx', function(d) { return d.x; })
    .attr('cy', function(d) { return d.y; })
    .attr('r', r)
    .call(drag);
</code></pre>

<p>Essentially I would like to use react components instead of standard svg elements. Please let me know if this is possible to do or if a better solution exists. </p>

<p>I did attempt something like this (it scrolls by the way):</p>

<pre><code>import React, { Component } from 'react'
import './App.css'
import { scaleLinear } from 'd3-scale’
import { max } from 'd3-array'
import { select } from 'd3-selection'

const testcomponent = ({children, ...props}) =&gt; {
    &lt;span&gt; hello &lt;/span&gt;
}

class DragArea extends Component {
   constructor(props){
      super(props)
      this.createDragArea = this.createDragArea.bind(this)
   }
   componentDidMount() {
      this.createDragArea()
   }
   componentDidUpdate() {
      this.createDragArea()
   }
   createDragArea() {
      const node = this.node
      var width = 960,
      height = 500,
      resolution = 20,
      r = 15;

      var points = d3.range(10).map(function() {
          return {
              x: round(Math.random() * width, resolution),
              y: round(Math.random() * height, resolution)
          };
      });

      var drag = d3.behavior.drag()
          .origin(function(d) { return d; })
          .on('drag', dragged);

      var svg = d3.select('body').append('svg')
          .attr('width', width)
          .attr('height', height);

      svg.selectAll('.vertical')
          .data(d3.range(1, width / resolution))
      .enter().append('line')
          .attr('class', 'vertical')
          .attr('x1', function(d) { return d * resolution; })
          .attr('y1', 0)
          .attr('x2', function(d) { return d * resolution; })
          .attr('y2', height);

      svg.selectAll('.horizontal')
          .data(d3.range(1, height / resolution))
      .enter().append('line')
          .attr('class', 'horizontal')
          .attr('x1', 0)
          .attr('y1', function(d) { return d * resolution; })
          .attr('x2', width)
          .attr('y2', function(d) { return d * resolution; });

       var circles = svg.selectAll('testcomponent')
           .data(points)
       .enter().append('circle')
           .attr('cx', function(d) { return d.x; })
           .attr('cy', function(d) { return d.y; })
           .attr('r', r)
           .call(drag);

    function dragged(d) {
        var x = d3.event.x,
            y = d3.event.y,
            gridX = round(Math.max(r, Math.min(width - r, resolution),
            gridY = round(Math.max(r, Math.min(height - r, resolution);

        d3.select(this).attr('cx', d.x = gridX).attr('cy', d.gridY);
    }

    function round(p, n) {
        return p % n &lt; n / 2 ? p - (p % n) : p + n - (p % n);
    }
}
render() {
      return &lt;svg ref={node =&gt; this.node = node}
      width={500} height={500}&gt;
          &lt;testcomponent&gt;&lt;/testcomponent&gt;
      &lt;/svg&gt;
   }
}
export default DragArea
</code></pre>

<p>but it definitely doesn't work. I don't think it recognizes the selector or something of the sort.</p>
","1406443","","1406443","","2017-06-13 19:44:25","2017-06-13 19:44:25","using d3.selectAll with react components","<javascript><reactjs><d3.js><svg>","0","3","","",""
"44939799","1","","","2017-07-06 04:25:50","","0","108","<p>I got error of </p>

<pre><code>Invariant Violation: Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.
</code></pre>

<p>when using 2 lifecycle method of react to call APIs.</p>

<pre><code>componentDidMount() {
    const action_id = this.context.router.params.action_id
    if(action_id) {
        this.getMsg(action_id)
    }
}

componentDidUpdate(prevContext) {
    const action_id = this.context.router.params.action_id
    if(!isEqual(prevContext.params.action_id, action_id)){
        this.getMsg(action_id)
    }
}
</code></pre>

<p>Above step are needed, the code in componentDidMount call an endpoint to get a list msg, the componentDidUpdate detect whether user click back or navigate around, then call the Api. I've no clue how to solve it.</p>
","8224849","","","","","2017-07-06 04:54:05","componentDidMount and componentDidUpdate error: Cannot dispatch in the middle of a dispatch","<javascript><reactjs>","1","0","1","",""
"45657321","1","","","2017-08-13 05:14:49","","0","568","<p>Okay so I've gotten pretty far in creating the React Component for ChartJS, however when testing I get the following error:</p>

<pre><code>FAIL  lib\chart\chart.test.tsx
  ● renders without crashing

    TypeError: Cannot read property 'length' of null

      at Object.acquireContext (node_modules/chart.js/src/platforms/platform.dom.js:189:19)
      at Chart.construct (node_modules/chart.js/src/core/core.controller.js:72:27)
      at new Chart (node_modules/chart.js/src/core/core.js:7:8)
      at Chart.Object.&lt;anonymous&gt;.Chart.renderChart (lib/chart/chart.tsx:233:26)
      at Chart.Object.&lt;anonymous&gt;.Chart.componentDidMount (lib/chart/chart.tsx:42:10)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:264:25
      at measureLifeCyclePerf (node_modules/react-dom/lib/ReactCompositeComponent.js:75:12)
      at node_modules/react-dom/lib/ReactCompositeComponent.js:263:11
      at CallbackQueue.notifyAll (node_modules/react-dom/lib/CallbackQueue.js:76:22)
      at ReactReconcileTransaction.close (node_modules/react-dom/lib/ReactReconcileTransaction.js:80:26)
      at ReactReconcileTransaction.closeAll (node_modules/react-dom/lib/Transaction.js:209:25)
      at ReactReconcileTransaction.perform (node_modules/react-dom/lib/Transaction.js:156:16)
      at batchedMountComponentIntoNode (node_modules/react-dom/lib/ReactMount.js:126:15)
      at ReactDefaultBatchingStrategyTransaction.perform (node_modules/react-dom/lib/Transaction.js:143:20)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactDefaultBatchingStrategy.js:62:26)
      at Object.batchedUpdates (node_modules/react-dom/lib/ReactUpdates.js:97:27)
      at Object._renderNewRootComponent (node_modules/react-dom/lib/ReactMount.js:319:18)
      at Object._renderSubtreeIntoContainer (node_modules/react-dom/lib/ReactMount.js:401:32)
      at Object.render (node_modules/react-dom/lib/ReactMount.js:422:23)
      at Object.&lt;anonymous&gt; (lib/chart/chart.test.tsx:7:12)
          at Promise (&lt;anonymous&gt;)
      at Promise.resolve.then.el (node_modules/p-map/index.js:42:16)
          at &lt;anonymous&gt;
      at process._tickCallback (internal/process/next_tick.js:169:7)

  × renders without crashing (275ms)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.314s, estimated 3s
Ran all test suites related to changed files.
</code></pre>

<p>However, I've spent a long time looking over the code and haven't been able to figure out why it refuses to work properly. The error starts at the <code>renderChart()</code> function at creating a new chart instance. My first guess would be the for some reason it's not registering the canvas element despite being called by its id.  But when the content of renderChart is moved into the render() function it still gives the same error. Here's the code being tested:</p>

<pre><code>import * as React from 'react'
import * as ClassNames from 'classnames'
import * as ChartJS from 'chart.js'
const IsEqual = require('lodash.isequal')
const Find = require('lodash.find')
const subChart = require('chart.js')

interface IChartProps {
  /** The user-defined classes */
  readonly className?: string
  readonly width?: number
  readonly height?: number
  readonly reRender?: boolean

  readonly type: ChartJS.ChartType
  readonly data: ChartJS.ChartData
  readonly options: ChartJS.ChartOptions
  readonly getDatasetAtEvent?: Function
  readonly getElementAtEvent?: Function
  readonly getElementsAtEvent?: Function
  readonly onElementsClick?: Function
  readonly datasetKeyProvider?: Function
}

interface IChartState {
  /** Add your states here */
}

export class Chart extends React.Component&lt;IChartProps, IChartState&gt; {
  // tslint:disable-next-line
  private chartInstance: any
  private shadowData: {}
  constructor(props: IChartProps) {
    super(props)
  }

  public componentWillMount() {
    // this.chartInstance = undefined
  }

  public componentDidMount() {
    this.renderChart()
  }

  // public componentWillReceiveProps(nextProps: IChartProps) {}

  public shouldComponentUpdate(nextProps: IChartProps, nextState: IChartState) {
    const props = this.props
    if (nextProps.reRender === true) {
      return true
    }

    if (props.height !== nextProps.height || props.width !== nextProps.width) {
      return true
    }

    if (props.type !== nextProps.type) {
      return true
    }

    if (!IsEqual(props.options, nextProps.options)) {
      return true
    }

    const nextData = this.transformDataProp(nextProps)

    if (!IsEqual(this.shadowData, nextData)) {
      return true
    }

    return false
  }

  // public componentWillUpdate(nextProps: IChartProps, nextState: IChartState) {}

  public componentDidUpdate(prevProps: IChartProps, prevState: IChartState) {
    if (this.props.reRender) {
      this.chartInstance.destroy()
      this.renderChart()
      return
    }
    this.updateChart()
  }

  public transformDataProp(props: IChartProps) {
    const data = props.data
    if (typeof data === 'function') {
      const node = document.getElementById('bar-chart') as HTMLCanvasElement
      return data(node)
    } else {
      return data
    }
  }

  public memoizeDataProps(props?: IChartProps) {
    if (!this.props.data) {
      return
    }
    const data = this.transformDataProp(this.props)

    this.shadowData = {
      ...data,
      datasets:
        data.datasets &amp;&amp;
        data.datasets.map((set: string[]) =&gt; {
          return { ...set }
        })
    }
    return data
  }

  public updateChart() {
    const options = this.props.options

    const data = this.memoizeDataProps(this.props)

    if (!this.chartInstance) {
      return
    }

    if (options) {
      this.chartInstance.options = subChart.helpers.configMerge(
        this.chartInstance.options,
        options
      )
    }

    let currentDatasets =
      (this.chartInstance.config.data &amp;&amp;
        this.chartInstance.config.data.datasets) ||
      []
    const nextDatasets = data.datasets || []

    const currentDatasetKeys = currentDatasets.map(
      this.props.datasetKeyProvider
    )
    const nextDatasetKeys = nextDatasets.map(this.props.datasetKeyProvider)
    const newDatasets = nextDatasets.filter(
      (d: object) =&gt;
        currentDatasetKeys.indexOf(this.props.datasetKeyProvider(d)) === -1
    )

    for (let idx = currentDatasets.length - 1; idx &gt;= 0; idx -= 1) {
      const currentDatasetKey = this.props.datasetKeyProvider(
        currentDatasets[idx]
      )
      if (nextDatasetKeys.indexOf(currentDatasetKey) === -1) {
        // deleted series
        currentDatasets.splice(idx, 1)
      } else {
        const retainedDataset = Find(
          nextDatasets,
          (d: object) =&gt; this.props.datasetKeyProvider(d) === currentDatasetKey
        )
        if (retainedDataset) {
          // update it in place if it is a retained dataset
          currentDatasets[idx].data.splice(retainedDataset.data.length)
          retainedDataset.data.forEach((point: number, pid: number) =&gt; {
            currentDatasets[idx].data[pid] = retainedDataset.data[pid]
          })
          // const { data, ...otherProps } = retainedDataset
          currentDatasets[idx] = {
            data: currentDatasets[idx].data,
            ...currentDatasets[idx],
            ...retainedDataset.otherProps
          }
        }
      }
    }
    // finally add any new series
    newDatasets.forEach((d: object) =&gt; currentDatasets.push(d))
    const { datasets, ...rest } = data

    this.chartInstance.config.data = {
      ...this.chartInstance.config.data,
      ...rest
    }

    this.chartInstance.update()
  }

  public componentWillUnmount() {
    this.chartInstance.destroy()
  }

  public onClickEvent = (event: React.MouseEvent&lt;HTMLCanvasElement&gt;) =&gt; {
    // this.props.getDatasetAtEvent &amp;&amp;
    this.props.getDatasetAtEvent(
      this.chartInstance.getDatasetAtEvent(event),
      event
    )

    // this.props.getElementAtEvent &amp;&amp;
    this.props.getElementAtEvent(
      this.chartInstance.getElementAtEvent(event),
      event
    )

    // this.props.getElementsAtEvent &amp;&amp;
    this.props.getElementsAtEvent(
      this.chartInstance.getElementsAtEvent(event),
      event
    )

    // this.props.onElementsClick &amp;&amp;
    this.props.onElementsClick(
      this.chartInstance.getElementsAtEvent(event),
      event
    )
  }

  public render() {
    const className = ClassNames('chart', this.props.className)

    // bar.update()
    return (
      &lt;div className={className}&gt;
        &lt;canvas
          id=""chart-instance""
          width={this.props.width ? this.props.width : '400'}
          height={this.props.height ? this.props.height : '400'}
          onClick={this.onClickEvent}
        /&gt;
      &lt;/div&gt;
    )
  }

  public renderChart() {
    const { options, type, data } = this.props
    const node = document.getElementById('chart-instance') as HTMLCanvasElement
    // const data = this.memoizeDataProps()

    this.chartInstance = new ChartJS(node, {
      type,
      data,
      options
    })
  }
}
</code></pre>

<p>can someone help me figure out why this won't work properly?</p>
","5198972","","","","","2017-08-13 08:27:07","TypeError: Cannot read property 'length' of null in react component","<reactjs><typescript><chart.js><jest>","1","2","","",""
"45178122","1","","","2017-07-18 22:25:39","","1","369","<p>In my <code>App.js</code> file I'm importing a <code>Page.js</code> component and placing it on the page using <code>&lt;Page /&gt;</code>. In the page component I'm setting a state relative that component. I'm then using <code>react-router</code> when the user selects a new page. </p>

<p>The state I'm setting is being passed from page to page and I need to reset that of my state when the page changes. I've tried doing <code>this.setState({archive:[]})</code> inside <code>componentDidMount()</code>, <code>componentWillMount()</code>, <code>componentWillUnmount()</code>, and <code>componentDidUpdate()</code> but they either didn't work or caused errors.</p>

<p>Update:</p>

<p>I've updated the code a bit. I set <code>this.archiveData</code> in my <code>constructor</code>.</p>

<p>constructor(props) {
    super(props);</p>

<pre><code>this.state = {
    title: 'David Powell',
    nav: {},
    currentPage: """",
    pageContent: """",
    pageTitle: """",
    pageTemplate: """",
    pageId: 0,
    pageCustomMeta: {},
    archiveData: []
}
</code></pre>

<p>}</p>

<p>When a page is called I set the values based on what the api returns I'm resetting the <code>archivedData</code> since that is filled based on what gets passed to the <code>page component</code> as a prop.</p>

<p>getPageData(slug){
    console.log(this.state);
    axios.get('<a href=""http://admin.sitedata.co/pages?slug="" rel=""nofollow noreferrer"">http://admin.sitedata.co/pages?slug=</a>'+slug)
    .then((response) => {
        console.log(response.data);</p>

<pre><code>    this.setState({
        pageContent:response.data[0].content.rendered,
        currentPage:slug,
        pageTitle:response.data[0].title.rendered,
        pageTemplate:response.data[0].template,
        pageId:response.data[0].id,
        pageCustomMeta:response.data[0].post_meta,
        archiveData:[]
    },function(){
        console.log(this.state);
        /*
        *   set the page title
        *   check if the page is at home
        *   get page custom meta
        */
        document.title = this.state.pageTitle;
        this.isHome();
        //this.getPageCustomMeta(this.state.pageId);
    });

})
.catch((error) =&gt; {
    console.log(error);
});
</code></pre>

<p>}</p>

<p>Everything gets updated correct: the page content changes, the title updates, etc. The <code>console.log</code> shows the <code>archiveData</code> is empty but it doesn't get updated on the page itself, it still persists.</p>
","249316","","249316","","2017-07-19 02:32:23","2017-07-19 02:32:23","Changing a state with the route changes in ReactJS and react-router?","<javascript><reactjs>","0","4","","",""
"37627648","1","37632765","","2016-06-04 07:30:55","","0","103","<p>What is the correct way to fetch data when switching route on same level?
Because, according to <a href=""https://github.com/reactjs/react-router/blob/master/docs/guides/ComponentLifecycle.md"" rel=""nofollow"">this</a>, switching route on same level will
only call <code>componentWillReceiveProps</code> and <code>componentDidUpdate</code>.
And <code>componentDidMount</code> is only called the first time route is entered.</p>

<p>With route configuration like this:</p>

<pre><code>render((
  &lt;Provider store={store}&gt;
    &lt;Router&gt;
      &lt;Route path=""/"" component={App}&gt;
        &lt;Route path=""/:userId"" component={Profile}/&gt;
      &lt;/Route&gt;
    &lt;/Router&gt;
  &lt;/Provider&gt;
), document.getElementById('root'));
</code></pre>

<p>The Profile component is:</p>

<pre><code>class Profile extends React.Component {
  componentDidMount() {
    // initial data
    this.fetchUserData();
  }
  componentWillReceiveProps(nextProps) {
    if (this.props.params.userId !== nextProps.params.userId) {
      this.fetchUserData();
    }
  }
  shouldComponentUpdate(nextProps) {
    return this.props.params.userId !== nextProps.params.userId;
  }
  render() {
    return (
      &lt;div className=""profile""&gt;&lt;/div&gt;
    );
  }
}
</code></pre>

<p>The data will be stored in application state field (<code>props.userData</code>). But,
that's obviously will mess up with rendering cycle because route is
switched before fetch data is finished.</p>

<p>But, if I change to this:</p>

<pre><code>// deepEqual is function to check object equality recursively
componentWillReceiveProps(nextProps) {
  if (!deepEqual(this.props.userData, nextProps.userData)) {
    this.fetchUserData();
  }
}
shouldComponentUpdate(nextProps) {
  return !deepEqual(this.props.userData, nextProps.userData);
}
</code></pre>

<p>This won't work because before <code>userData</code> is fetched, those props is
deeply equal.</p>

<p>So, how to fetch data when switching route on same route level?</p>
","4019871","","4019871","","2016-06-04 07:40:03","2016-06-04 16:53:48","Correct way to fetch data when switching route on same level in react-router?","<javascript><reactjs>","1","0","","",""
"49060982","1","","","2018-03-02 00:33:48","","0","62","<p>I have a array and I want to render the this array into a few redux forms. I found out that all the forms are rerendered. the code looks like the following:</p>

<p>Form.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { Link, Events, scrollSpy } from 'react-scroll';
import styles from './Form.css';
import MultipleForm from './MultipleForm';

class Form extends Component {
  constructor(props) {
    super(props);
    const {
      workflows,
    } = this.props;
    this.state = {
      curTab: workflows.length &gt; 0 ? workflows[0] : '',
      curForm: '',
    };
  }

  componentDidMount() {
    Events.scrollEvent.register('begin');
    Events.scrollEvent.register('end');
    scrollSpy.update();
  }
  componentWillReceiveProps(nextProps) {
    const {
      workflows,
    } = nextProps;
    if (workflows &amp;&amp; workflows.length &gt; this.props.workflows) {
      this.setState({
        curTab: workflows[0],
      });
    }
  }
  componentWillUnmount() {
    Events.scrollEvent.remove('begin');
    Events.scrollEvent.remove('end');
  }
  handleChangeTab = (value) =&gt; {
    this.setState({
      curTab: value,
    });
  }

  handleActiveTab = (workflow) =&gt; {
    console.log(workflow);
  }


  render() {
    const {
      workflows,
      schemaNames,
      ...rest
    } = this.props;
    return (
      &lt;div className={styles.container}&gt;
        &lt;header&gt;
          &lt;PerspectiveBar
            value={this.state.curTab}
            onChange={this.handleChangeTab}
            style={{
              position: 'fixed',
              left: '0',
              top: '48px',
              width: '100vw',
              zIndex: '1380',
            }}
          &gt;
            {workflows.map(wf =&gt; (
              &lt;PerspectiveTab
                key={wf}
                label={wf}
                value={wf}
                onActive={() =&gt; this.handleActiveTab(wf)}
              /&gt;
          ))}
          &lt;/PerspectiveBar&gt;
        &lt;/header&gt;
        &lt;div className={styles.formContainer}&gt;
          &lt;Paper className={styles.paperContainer}&gt;
            &lt;MultipleForm
              workflow={this.state.curTab}
              schemaNames={schemaNames}
              {...rest}
            /&gt;
          &lt;/Paper&gt;
        &lt;/div&gt;
        &lt;Drawer className={styles.drawer} containerStyle={{ height: 'calc(100% - 104px)', top: '104px' }}&gt;
          &lt;div className={styles.drawerContainer}&gt;
            {schemaNames.map(schemaName =&gt; (
              &lt;Link
                onSetActive={(to) =&gt; {
                  this.setState({
                    curForm: to,
                  });
                }}
                to={schemaName}
                duration={500}
                offset={-104}
                spy
                smooth
              &gt;
                &lt;MenuItem
                  checked={this.state.curForm === schemaName}
                &gt;
                  {schemaName}
                &lt;/MenuItem&gt;
              &lt;/Link&gt;
            ))}
          &lt;/div&gt;
        &lt;/Drawer&gt;
      &lt;/div&gt;

    );
  }
}

Form.propTypes = {
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  workflows: PropTypes.arrayOf(PropTypes.string),
  fetchSchemaNames: PropTypes.func.isRequired,
};

Form.defaultProps = {
  schemaNames: [],
  workflows: [],
};

export default Form;
</code></pre>

<p>MultipleForm.jsx</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import FlatButton from 'material-ui/FlatButton';
import { Element } from 'react-scroll';
import SchemaForm from './SchemaForm';

class MultipleForm extends Component {
  componentDidMount() {
    console.log('MultipleForm Mounted');
    const {
      workflow,
      fetchSchemaNames,
    } = this.props;
    if (workflow) fetchSchemaNames(workflow);
  }

  componentWillReceiveProps(nextProps) {
    const {
      workflow,
      fetchSchemaNames,
    } = nextProps;
    if (workflow &amp;&amp; this.props.workflow !== workflow) fetchSchemaNames(workflow);
  }

  componentDidUpdate() {
    const {
      schemaNames,
      schemas,
      initialValues,
      fetchSchemas,
      fetchInitialValues,
    } = this.props;
    const schemasNeedToFetch = this.remainingSchemas(schemaNames, schemas);
    if (schemasNeedToFetch.length !== 0) fetchSchemas(schemasNeedToFetch);
    const initialValuesNeedToFetch = this.remainingInitialValues(schemaNames, initialValues);
    if (initialValuesNeedToFetch.lenght !== 0) fetchInitialValues(initialValuesNeedToFetch, 1);
  }

  remainingSchemas = (schemaNames, schemas) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in schemas === false).sort();

  remainingInitialValues = (schemaNames, initialValues) =&gt;
    schemaNames.filter(schemaName =&gt; schemaName in initialValues === false).sort();

  handleSubmitAll = (event) =&gt; {
    event.preventDefault();
    const {
      submit,
      schemas,
      schemaNames,
    } = this.props;
    schemaNames
      .map(schemaName =&gt; schemas[schemaName].title)
      .forEach((title) =&gt; {
        submit(title);
      });
  }

  render() {
    const {
      schemaNames,
      schemas,
      initialValues,
      postForm,
    } = this.props;
    schemaNames.sort((a, b) =&gt; a.localeCompare(b));
    return (
      &lt;div&gt;
        {schemaNames.map(schemaName =&gt; (
          &lt;Element name={schemaName}&gt;
            &lt;SchemaForm
              key={schemaName}
              schema={schemas[schemaName]}
              initialValue={initialValues[schemaName]}
              schemaName={schemaName}
              postForm={postForm}
            /&gt;
          &lt;/Element&gt;
        ))}
        &lt;div&gt;
          &lt;FlatButton
            label=""Submit""
          /&gt;
          &lt;FlatButton label=""Deploy"" /&gt;
        &lt;/div&gt;
      &lt;/div&gt;);
  }
}

MultipleForm.propTypes = {
  workflow: PropTypes.string.isRequired,
  submit: PropTypes.func.isRequired,
  fetchSchemaNames: PropTypes.func.isRequired,
  schemas: PropTypes.object,
  schemaNames: PropTypes.arrayOf(PropTypes.string),
  initialValues: PropTypes.object,
  fetchSchemas: PropTypes.func.isRequired,
  fetchInitialValues: PropTypes.func.isRequired,
  postForm: PropTypes.func.isRequired,
};

MultipleForm.defaultProps = {
  schemaNames: [],
};

export default MultipleForm;
</code></pre>

<p>SchemaForm</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Liform from 'liform-react';
import theme from './NokiaTheme';
import styles from './Form.css';

class SchemaForm extends Component {
  componentDidMount() {
    console.log('schema mounted');
  }

  shouldComponentUpdate() {
    return false;
  }
  handleSubmit = (value) =&gt; {
    const {
      postForm,
      schemaName,
    } = this.props;
    postForm(value, schemaName, 1);
  }


  render() {
    const {
      schema,
      initialValue,
    } = this.props;
    console.log('props', this.props);
    return (
      &lt;div&gt;
        &lt;h3 id={schema.$id} className={styles.formTitle}&gt;
          {schema.title}
        &lt;/h3&gt;
        &lt;Liform
          schema={schema}
          onSubmit={value =&gt; this.handleSubmit(value)}
          destroyOnUnmount={false}
          theme={theme}
          initialValues={initialValue}
        /&gt;
      &lt;/div&gt;
    );
  }
}

SchemaForm.propTypes = {
  schema: PropTypes.shape({
    $id: PropTypes.string,
  }),
  initialValue: PropTypes.object,
  schemaName: PropTypes.string,
  postForm: PropTypes.func.isRequired,
};

SchemaForm.defaultProps = {
  schema: {},
  initialValue: null,
  schemaName: '',
};

export default SchemaForm;
</code></pre>

<p>the schemaNames will be changed only by adding or deleting some element. for example: the schemaNames will change from <code>['A', 'B', 'C']</code> to <code>['A', 'B', 'D']</code>.  I get the schemaNames from the redux. which I fetch online.</p>

<p>But when I check the ConnectedReduxForm, when I change the schemaNames, the SchemaForm will be unmounted and the react will mount the form again. I have tried with setting the ConnectedReduxForm to be PureComponent. It is not helpful.</p>

<p>Could someone help me with that? I have spent a lot of time of this and nothing helps.</p>

<p><strong>Update</strong>: I have found the problem, the reason of it is that for each time that I for each time I update the workflow, I need to fetch the schemaNames from the server. But I still do not know why this happended. Could someone explain that?</p>
","4812854","","4812854","","2018-03-02 22:05:39","2018-03-02 22:05:39","How to avoid rerendering element in the array in react?","<javascript><reactjs><redux-form>","0","11","","",""
"35566357","1","41876352","","2016-02-23 00:02:18","","9","2001","<p>I'm writing a simple ""console"" that shows messages in a chat-like manner. With messages appearing from the bottom, and moving up. </p>

<p>I have the working code, but I'd like to animate the appearing messages by scrolling the container to the bottom each time a new ""li"" is added.</p>

<p>Current code:</p>

<pre><code>import React from 'react';
import { render, findDOMNode } from 'react-dom';


export default React.createClass({
    componentDidUpdate : function(){
        var node = findDOMNode(this);
        node.scrollTop = node.scrollHeight;
    },
    render() {
        return (
            &lt;ul id=""log""&gt;
            {
                this.props.messages.map(function(message, index){
                    return &lt;li key={index}&gt;[{message.time.format('HH:mm:ss')}] {message.action}&lt;/li&gt;
                })
            }
            &lt;/ul&gt;
        )   
    }
})
</code></pre>

<p>The <code>messages</code> prop comes from the parent component and the store.</p>

<p>I found this velocity plugin: <a href=""https://github.com/twitter-fabric/velocity-react"">https://github.com/twitter-fabric/velocity-react</a> and I can't figure out how to use it in my situation. All the examples don't seem to apply (or maybe I just don't understand them).</p>

<p>I'm quite new to react, and some concepts still confuse me, so please be understanding.</p>

<p>I don't want to use jQuery.</p>
","2550876","","2550876","","2016-03-04 09:20:18","2017-01-26 15:00:36","velocity-react - animating scrollTop after component update","<javascript><animation><reactjs><velocity.js>","1","8","1","",""
"36311406","1","","","2016-03-30 14:10:49","","0","3406","<p>My node.js server sends with socket.io new data each 10s. In my web application I update this.state each time that my server sends data and force to update with forceUpdate()</p>

<p>However, my react component doesn't refresh, I don't know why. I followed the doc but I missed something...</p>

<p><strong>Parent :</strong></p>

<pre><code>class DataAnalytics extends React.Component {
  constructor(props) {
    super(props);
    socket = this.props.socket;
    this.state = {data: []};

    socket.on('dataCharts', (res) =&gt; {
      console.log(""new data charts : ""+res);
      var data = JSON.parse(res);   
      this.setState({data: data});
      this.forceUpdate();
    });
  }

  componentWillUnmount() {
    socket.off('dataCharts');
  }

  render() {
    return (
    &lt;div id=""dataAnalytics""&gt;
      &lt;Stats data={this.state.data}&gt;&lt;/Stats&gt;
    &lt;/div&gt;
    );
  }
}

export default DataAnalytics;
</code></pre>

<p><strong>Child :</strong></p>

<pre><code>class Stats extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      &lt;div className=""stats"" style={{textAlign:'center'}}&gt;
        &lt;h4&gt;Number: &lt;/h4&gt;
      &lt;/div&gt;
    );
  }

  componentDidUpdate() {
    var data = this.props.data;

    if(!jQuery.isEmptyObject(data)) {
      $( "".stats"" ).html(""&lt;h4&gt;Number : data['nb']['counterIn']&lt;/h4&gt;"");
    }
  }
}

export default Stats;
</code></pre>

<p>Anyone know how to refresh automatically my React component.</p>
","5279661","","","","","2016-03-30 14:20:56","Refresh react component","<javascript><reactjs>","1","3","1","",""
"45736082","1","45761640","","2017-08-17 13:12:31","","1","257","<p>I am using this solution to restore the scroll on page change:</p>

<pre><code>ReactDOM.render(
  &lt;Router&gt;
    &lt;ScrollToTop&gt;
      &lt;div className=""App""&gt;
        &lt;Header /&gt;
        &lt;Main /&gt;
        &lt;Footer /&gt;
      &lt;/div&gt;
    &lt;/ScrollToTop&gt;
  &lt;/Router&gt;,
  document.getElementById('root')
);
</code></pre>

<p>This is my <code>ScrollToTop</code> component:</p>

<pre><code>import React, { Component } from 'react';
import {withRouter} from 'react-router';

class ScrollToTop extends Component {
  componentDidUpdate(prevProps) {
    if (this.props.location !== prevProps.location) {
      window.scrollTo(0, 0);
    }
  }

  render() {
    return this.props.children;
  }
}

export default withRouter(ScrollToTop)
</code></pre>

<p>This works fine except for anchor links; in fact, it overrides the behaviour of anchor links and I cannot scroll to the desired section of the page. I know I could create a container and use it just in pages I want to use it; however, I would still have the same problem since the navigation to the same page could be triggering different behaviour (sometimes scrolling the window to top and sometimes scrolling to the anchor link). Is there a way to preserve the desired behaviour in either circumstance?</p>
","2255082","","","","","2017-08-18 17:02:56","react-router 4 scroll restoration prevents native behaviour of anchor links","<javascript><reactjs><react-router>","1","2","1","",""
"46450034","1","","","2017-09-27 14:06:44","","0","476","<p><a href=""https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html"" rel=""nofollow noreferrer"">announce react 16 release blog</a></p>

<p>this blog says </p>

<blockquote>
  <p>setState callbacks (second argument) now fire immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.</p>
</blockquote>

<p>so callback invoked after <code>componentDidMount</code>, and parent's <code>componentDidMount</code> is invoked after its children's. so I think, in current render tree, it is also after all components have rendered.</p>

<p>what is the difference ?</p>
","1889423","","","","","2017-09-27 14:27:47","when setState callback invoke in react 16","<reactjs>","1","0","","",""
"29908050","1","29908338","","2015-04-28 00:06:23","","3","1405","<p>I just started working in react and this is an issue that I haven't seen a good solution to so far. The problem is that I want to set a video playing in a  tag to a location when a user clicks a button.</p>

<p>The current solution I have is as follows:</p>

<pre><code>componentDidUpdate(prevProps, prevState) {
    console.log(""Updating to timestamp: "" + this.props.timestamp);
    var timestamp = this.props.timestamp;
    if (timestamp != prevProps.timestamp) {
        React.findDOMNode(this.refs.theVideo).currentTime = timestamp;
    }
}
</code></pre>

<p>Problem is, this seems really hacky. Now I'm in this situation where the user could click the same button twice and nothing would happen, so I'm looking at adding more state to the component to ensure that case works correctly.</p>

<p>Is this the correct approach? Everything in react so far seems super logical, but this just doesn't quite feel right. Would this be a situation where you'd expose a method on the child to the parent?</p>
","145060","","","","","2015-12-21 18:11:37","React.js + video element: set current play time from react props?","<reactjs>","1","0","","",""
"45971543","1","","","2017-08-31 00:31:31","","4","1630","<p>Why my componentWillReceiveProps not running on my react-native, i using react-navigation and redux. i execute button login in reducer i using immutable. in store already update but componentWillReceiveProps not running just jump to componentWillUpdate and DidUpdate only</p>

<pre><code>import React, { Component } from 'react'

class Main extends Component{
  constructor(props){
    super(props)
    this.state = {
     active : '',
     username: '',
     password: ''
  }
}

componentWillReceiveProps(newProps) {
 console.log(newProps.load(), 'Component WILL RECIEVE PROPS!')
}

componentWillUpdate(nextProps, nextState) {
 console.log(nextProps, nextState, 'Component WILL UPDATE!');
}

componentDidUpdate(prevProps, prevState) {
 console.log(prevProps,'Component DID UPDATE!')
}

handleButtonAction(actions){
 let user = this.state.username
 let pass = this.state.password
 if(actions === 'login'){
   this.props.login(user, pass)
 }
}

render(){
  const {navigation} = this.props;
return(
          &lt;Button block onPress={()=&gt;this.handleButtonAction('login')} style=
   {{marginLeft: 10, marginRight: 10}}&gt;
            &lt;Text&gt;Login&lt;/Text&gt;
          &lt;/Button&gt;
   )}

const mapStateToProps = state =&gt;({
  token: state.token
})

const mapDispatchToProps = dispatch =&gt; ({
 login: (user, pass)=&gt; dispatch({type:""LOGIN"", payload:'testing'}),
})

export default connect(mapStateToProps, mapDispatchToProps)(Main)
</code></pre>

<hr>

<p>In Reducer i already using immutable but why at this update and still receiveProps on component not called</p>

<pre><code>const listProduct = (oldstate, value)=&gt;{
 console.log(oldstate);
 let newState = {...oldstate, data: value.data.data}
 console.log(newState);
 return newState
}

const login = (oldstate, value)=&gt;{
 let newState = {...oldstate, token: value}
 return newState
}

const initialState = {}

const product = (state=initialState, actions)=&gt;{
 switch (actions.type) {
 case ""GET_PRODUCK"": return listProduct(state, actions.payload);
 case ""LOGIN"": return login(state, actions.payload);
 default: return state
}}

export default product
</code></pre>
","8344624","","","","","2017-08-31 05:26:52","componentwillreceiveprops not called on react-native and redux","<reactjs><react-native><redux>","1","0","1","",""
"45428603","1","","","2017-08-01 03:42:54","","0","52","<p>I'm working on a react application. There is a main app which creates child components. 
e.g.</p>

<pre><code>app
rend(){
   &lt;component1/&gt;
   &lt;component2/&gt;
   &lt;component3 sendMethodDown={this.sendMethodDownToChild}/&gt;
   &lt;component4 sendStateDownState={this.state.sendStateDownState}/&gt;
}
</code></pre>

<p>When rendering, a method is sent down to child component3. component3 sends specific data back up to app, and then this data is sent to component4.
The data is used in ag-grid.In component4 the data wont be shown until componentDidUpdate stage of lifecycle. </p>

<p>I only want this data to be applied once, it doesn't seem to work when i apply this in componentwillrecieveprops (infinite loop + doesnt apply properly). i managed to get it working by putting it in componentDidUpdate (and using an if statement with boolean state (boolean switch turns off inside the if statement so it never gets run again)</p>

<p>even though this works if not the best. I was thinking of trying to add this back somewhere higher up the lifecycle</p>

<p>There is currently nothing wrong with my app, but I want to improve it. Can anyone help me understand how the react life cycles works when using child components?</p>

<p>is there a life cycle for each component (including app), where app life cycle is paused while the life cycle for the child components finishes?</p>
","3120554","","","","","2017-08-01 03:42:54","how react lifecycle works for components","<reactjs><ag-grid>","0","4","","",""
"29041034","1","37389433","","2015-03-13 20:05:35","","3","3750","<p>I'm trying to cache the rendered markup of the <code>App</code> component. I know that this is somehow ""against the rules"" but I'm in a server-less environment (chrome-extension). Upon page load i want to inject the cached <code>App</code> markup into the DOM. The expected result is similar to the experience of having the react-component rendererd on a server. Very much as described here: <a href=""http://www.tabforacause.org/blog/2015/01/29/using-reactjs-and-application-cache-fast-synced-app/"" rel=""nofollow"">http://www.tabforacause.org/blog/2015/01/29/using-reactjs-and-application-cache-fast-synced-app/</a>.</p>

<p>To illustrate my usecase, I have updated the <a href=""http://jsfiddle.net/derflocki/fn3f9x02/5/"" rel=""nofollow"">Thinking in react example</a>: </p>

<ul>
<li>App
<ul>
<li>FilterableProductTable
<ul>
<li>SearchBar</li>
<li>ProductTable (containing from <code>reflux</code> store in state)
<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>As is expected, neither <code>componentDidUpdate</code> nor <code>componentWillUpdate</code> are called in <code>App</code>.</p>

<p>Is it possible to detect updated child components in the <code>App</code> component in a sane way? Preferably without modifying the child component classes?</p>

<p>I would like to avoid moving props/state to <code>App</code>.</p>
","274483","","274483","","2015-03-14 08:27:44","2016-05-23 11:10:37","How to detect child renders in a parent component in react.js","<javascript><reactjs><refluxjs>","5","2","","",""
"37587524","1","","","2016-06-02 09:15:14","","6","4687","<p>I am trying to write a fliter for my List View in react native. But It is not working , and I don't know why. 
Here is my Class - </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {
  AppRegistry,
  Image,
  ListView,
  StyleSheet,
  Text,
  TextInput,
  Navigator,
  TouchableHighlight,
  TouchableOpacity,
  filter,
  View
} from 'react-native';
var REQUEST_URL = GLOBAL.STATES_URL + '?apikey=' + GLOBAL.API_KEY;

class MainPage extends Component {
    
  constructor(props) {
    super(props);
    this.state = {
      dataSource: new ListView.DataSource({
        rowHasChanged: (row1, row2) =&gt; row1 !== row2,
      }),
      loaded: false,
      searchText: '',
      state: '',
    };
  }
  
  componentDidMount() {
    this.fetchData();
  }
  
  componentDidUpdate() {
    if (this.state.searchText === '') {
      this.fetchData();
    }
  }
  
  filterStates(searchText, states) {
    var text = searchText.toLowerCase();
    var rows = [];
   
   for (var i=0; i &lt; states.length; i++) {
     var stateName = states[i].name.toLowerCase();
     if(stateName.search(text) !== -1){
         rows.push({
              name : states[i].name,
          });
     }
   }
       
    this.setState({
       dataSource: this.state.dataSource.cloneWithRows(rows),
       loaded : true,
     });
  }
  
  fetchData() {
    fetch(REQUEST_URL)
      .then((response) =&gt; response.json())
      .then((responseData) =&gt; {
        this.setState({
          dataSource: this.state.dataSource.cloneWithRows(responseData),
          loaded: true,
        });
      })
      .done();
  }
 
  setSearchText(event){
    var searchText = event.nativeEvent.text;
    this.setState({searchText});

    fetch(REQUEST_URL)
    .then((data) =&gt; {
          this.filterStates(searchText, data);    
    })
    .done();
 }
  
    
  render() {
    return (
      &lt;Navigator
          renderScene={this.renderScene.bind(this)}
          navigator={this.props.navigator}
          navigationBar={
            &lt;Navigator.NavigationBar style={{backgroundColor: '#246dd5'}}
                routeMapper={NavigationBarRouteMapper} /&gt;
          }
         /&gt;
    );
  }
  
  
  renderScene(route, navigator) {
    if (!this.state.loaded) {
      return this.renderLoadingView();
    }

    return (
      &lt;View style={styles.combo}&gt;
      
       &lt;TextInput
         style={styles.searchBar}
         value={this.state.searchText}
         onChange={this.setSearchText.bind(this)}
         placeholder='Search' /&gt;   
      &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={this.renderState.bind(this)}
        // renderScrollComponent={props =&gt; &lt;RecyclerViewBackedScrollView {...props} /&gt;}
        renderSeparator={(sectionID, rowID) =&gt; &lt;View key={`${sectionID}-${rowID}`} style={styles.separator} /&gt;}
        style={styles.listView}
      /&gt;
      &lt;/View&gt;
      
    );
  }
  
  renderLoadingView() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text&gt;
          Loading States...
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }

  renderState(state,route,navigator) {
    return (
      &lt;TouchableHighlight onPress={this.gotoPersonPage.bind(this,state)}&gt;
         &lt;View style={styles.row}&gt; 
             &lt;View style={styles.container}&gt;
                   &lt;Text style={styles.name}&gt;{state.name}&lt;/Text&gt;
             &lt;/View&gt;
         &lt;/View&gt;
      &lt;/TouchableHighlight&gt;
   
    );
  }
  
  
  gotoPersonPage(state) {
    this.props.navigator.push({
      id: 'PersonPage',
      name: 'PersonPage',
      data: {name:state.name , abbreviation:state.abbreviation},
    });
  }
}</code></pre>
</div>
</div>
</p>

<p>Can Anybody please tell that what is the issue in the above code, and solution for that issue.
Thanks in advance.</p>
","6408068","","","","","2016-06-02 09:31:21","Filter ListView data in react native","<listview><filter><react-native>","1","0","1","",""
"45965712","1","45966254","","2017-08-30 16:40:55","","0","84","<p>I am using normal <code>d3.js</code> in my react application. problem is this code is being executing multiple times if I put my code in <code>componentDidMount</code> it is running only single time. but it is giving my value undefined. if I add <code>componentDidUpdate</code> it is giving value properly but running <code>svg</code> componenet multiple times.  now don't know what to do?
below is my code</p>

<pre><code>componentDidMount(){

    this.processData(this.props);
}
  componentDidUpdate(prevProps,prevState){

    if(this.props.potentialBrandReturn== undefined)
      this.processData(this.props);


    return false;
  }

  processData(props){

    var data = [
      {
        label: 'Return',
        value: props.currentYearReturn,
        potential: props.potentialComReturn,
        color: '#aa3939'
      },
      {
        label: 'Brand',
        value: props.currentYearBrand,
        potential: props.potentialBrandReturn,
        color: '#2c4770'
      }
    ];

    var div = d3.select('body').append('div').attr('class', 'toolTip');

    var axisMargin = 20,
      margin = 40,
      valueMargin = 4,
      width = 550,
      height = 250,
      barHeight = 40,
      barPadding = 30,
      data,
      bar,
      svg,
      scale,
      scaleMark,
      xAxis,
      labelWidth = 0;

    var max = d3.max(data, function(d) {
      return d.potential;
    });

    svg = d3
      .select('#customChart2')
      .classed('svg-container1', true) //container class to make it responsive
      .append('svg')
      //responsive SVG needs these 2 attributes and no width and height attr
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .attr('viewBox', '0 0 600 200')
      //class to make it responsive
      .classed('svg-content-responsive', true);

    scale = d3.scale
      .linear()
      .domain([0, max])
      .range([0, 400 - margin * 2 - labelWidth]);

    bar = svg.selectAll('g').data(data).enter().append('g');

    bar.attr('class', 'bar').attr('cx', 0).attr('transform', function(d, i) {
      return (
        'translate(' +
        margin +
        ',' +
        (i * (barHeight + barPadding) + barPadding) +
        ')'
      );
    });
    //appending lable
    bar
      .append('text')
      .attr('class', 'label')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .text(function(d) {
        return d.label;
      })
      .each(function() {

        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width)) + 5;
      });

    //appending Potential rect

    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', 'transparent')
      .style('stroke', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.potential);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Potential Value is $' + d.potential);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    //appending main bar for the chart
    bar
      .append('rect')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('height', barHeight)
      .style('fill', function(d) {
        return d.color;
      })
      .attr('width', function(d) {
        return scale(d.value);
      })
      .on('mouseover', function() {
        return tooltip.style('visibility', 'visible');
      })
      .on('mousemove', function(d) {
        return tooltip
          .style('top', d3.event.pageY - 10 + 'px')
          .style('left', d3.event.pageX + 10 + 'px')
          .text('Actual Value is $' + d.value);
      })
      .on('mouseout', function() {
        return tooltip.style('visibility', 'hidden');
      });

    // appending text for rect Potential
    bar
      .append('text')
      .attr('transform', 'translate(' + labelWidth + ', 0)')
      .attr('y', barHeight / 2)
      .attr('dy', '.35em') //vertical align middle
      .attr('x', 10)
      .attr('dx', function(d) {
        return scale(d.potential);
      })
      .text(function(d) {
        return '$' + d.potential + ' Potential';
      });

    //appending value in side the rectangle
    bar
      .append('text')
      .attr('class', 'value')
      .attr('y', barHeight / 2)
      .attr('dx', function(d) {
        var temp = scale(d.value) + labelWidth;
        return temp - 10;
      }) //margin right
      //.attr(""dx"", valueMargin + labelWidth + margin) //margin right
      .attr('dy', '.35em') //vertical align middle
      .attr('text-anchor', 'start')
      .text(function(d) {
        return '$' + d.value;
      });

    // for tooltip message
    var tooltip = d3
      .select('body')
      .append('div')
      .attr('class', 'toolTip1')
      .style('position', 'absolute')
      .style('z-index', '10')
      .style('visibility', 'hidden');

    // appending the chart to html
    svg
      .insert('g', ':first-child')
      .attr('class', 'axisHorizontal')
      .attr(
        'transform',
        'translate(' +
          (margin + labelWidth) +
          ',' +
          (height - axisMargin - margin) +
          ')'
      );
    // .call(yAxis);
</code></pre>
","5913407","","5913407","","2017-08-30 17:09:21","2017-08-30 18:02:06","d3 is running in multiple times in react","<javascript><reactjs><d3.js><svg>","1","9","","",""
"45986869","1","","","2017-08-31 17:11:02","","0","326","<p>I am building a chat app and using react-virtualized to manage display / infinite load (through a custom method, not the HOC) of chat messages. I am using Autosizer to fill the container div, and cellmeasurer to calculate row heights. Everything is working great except when I attempt to scroll down to the last/newest message at the bottom of the list, it takes me allllmost there. Typically the next to bottom row is visible and I need to scroll down just a bit more to see the actual bottom row.</p>

<p>Here are relevant snippets:</p>

<p>Render Method:</p>

<pre><code>render() {
    const hasNextPage = this.props.contact ? this.props.contact.messages.length &lt; this.props.contact.totalMessageCount : false
    // const totalMessageCount = this.props.contact ? this.props.contact.totalMessageCount : 0
    const contactMessages = this.props.contact ? sortBy(this.props.contact.messages, ""created_at"") : []
    const rowCount = contactMessages.length // hasNextPage ? contactMessages.length + 1 : contactMessages.length

    // auto resizer copy-spiration
    // https://github.com/bvaughn/tweets/blob/37d0139736346db16b9681d5b859a4e127964518/src/components/TweetList.js#L126-L132
    const _rowRenderer = ({ index, key, parent, style }) =&gt; {
      let content;
      if (index === 0 &amp;&amp; hasNextPage) {
        content = 'Loading...'
      } else {
        content = &lt;ChatMessage message={contactMessages[index]} /&gt;
      }

      return (
        &lt;CellMeasurer
          cache={this._cache}
          columnIndex={0}
          key={key}
          parent={parent}
          rowIndex={index}
          width={this._mostRecentWidth}
        &gt;
          &lt;div
            key={key}
            style={style}
          &gt;
            {content}
          &lt;/div&gt;
        &lt;/CellMeasurer&gt;
      );
    };

    return (
      &lt;div style={{ height: '65vh' }}&gt;
        &lt;AutoSizer&gt;
          {({ height, width }) =&gt; (
            &lt;List
              deferredMeasurementCache={this._cache}
              // eslint-disable-next-line no-return-assign
              ref={ref =&gt; this.chatWindow = ref}
              onRowsRendered={(renderData) =&gt; this.handleRowsRendered(renderData, hasNextPage, rowCount)}
              rowRenderer={_rowRenderer}
              height={height}
              width={width}
              rowHeight={this._cache.rowHeight}
              rowCount={rowCount}
            /&gt;
          )}
        &lt;/AutoSizer&gt;

      &lt;/div&gt;
    )
  }
</code></pre>

<p>And my call to scroll on componentDidUpdate:</p>

<pre><code>componentDidUpdate() {
    if (this.chatWindow &amp;&amp; !this.state.initialized &amp;&amp; this.props.contact) {
      // this.chatWindow.recomputeRowHeights(this.props.contact.messages.length - 10)
      this.chatWindow.scrollToRow(this.props.contact.messages.length || 0)
    }
  }
</code></pre>

<p>Any ideas how I can achieve that list little amount of scroll to make the bottom message visible?</p>
","981573","","981573","","2017-08-31 17:36:31","2017-08-31 17:36:31","scroll to bottom/row on react-virtualized with autosizer and cellmeasurer","<reactjs><react-virtualized>","0","1","","",""
"50334535","1","","","2018-05-14 15:58:09","","0","58","<p>I ran in to a problem the last few days that I just can't seem to crack.</p>

<p><strong>What I'm trying to do:</strong> We have a sidebar, from which you can select a ""<strong>Study</strong>"". This study determines what you see on the main content block, as each <strong>study</strong> has different data and users assosciated with it. In the main content block, I have <strong>forms</strong> set up, one for each user.</p>

<p><strong>The problem:</strong> On first page load, everything works fine. However, if you change the <strong>study</strong>, thus, rendering the page anew with componentWillReceiveProps, the new forms that are loaded are there, but with blank values (no initial values) and an <em>initialized</em> value of <code>false</code>. They're also not selectable in any way - the form itself is one selection dropdown and 3 checkboxes, and you can't select any of them.</p>

<p>Refreshing the page causes the forms to work again, even on the new study. </p>

<p><strong>What I've tried:</strong></p>

<ul>
<li>Manually initializing the forms with <code>this.props.dispatch(initialize(form_name))</code>. This causes the forms to be initialized with the correct values, but there's still no way to interact with them in any way.</li>
<li>Manually updatine (this.forceUpdate) on the parent's study prop change. This changed nothing</li>
<li>Setting <code>enableReinitialize</code> to <code>true</code></li>
<li>Providing a <code>key</code> to the parent page so it renders fresh every time (a hack I thought would work, but either I didn't do it right or it had no effect.)</li>
<li>Destroying the old forms when in the process of switching study props</li>
</ul>

<p>Here's the code of the Parent component and the Form component. This sidebar is in a seperate component, if you want to see that for some reason just ask. There's a lot going on in these files, mostly other extraneous UI stuff for the app, but I noted where the form is rendered in the parent with <code>//FORM IN QUESTION IS RENDERED HERE</code>.</p>

<p><strong>PARENT</strong></p>

<pre><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import IconButton from 'material-ui/IconButton';
import Button from 'material-ui/Button';
import InviteUsersDialog from './InviteUsersDialog';
import SwipeableViews from 'react-swipeable-views';
import AppBar from 'material-ui/AppBar';
import Tabs, { Tab } from 'material-ui/Tabs';

import Avatar from 'material-ui/Avatar';
import tempAvatar from '../../Assets/temp-avatar.jpg';

import ExpansionPanel, {
  ExpansionPanelDetails,
  ExpansionPanelSummary,
} from 'material-ui/ExpansionPanel';

import Typography from 'material-ui/Typography';

import ExpandMoreIcon from 'material-ui-icons/ExpandMore';

import { withRouter } from 'react-router-dom';
import { withStyles } from 'material-ui/styles';
import { connect } from 'react-redux';

import { getUsersAction, getInvestigationPermissionsAction, resetUsersError, destroyFormsAction } from '../../actions/manage';

import { MenuItem } from 'material-ui/Menu';
import { Field, FieldArray, reduxForm, getFormValues, change, reset, destroy } from 'redux-form';

import {
  Checkbox,
  RadioGroup,
  Select,
  TextField,
  Switch,
} from 'redux-form-material-ui'

import PermissionsForm from './PermissionsForm';

import compose from 'recompose/compose';

class Manage extends Component {

    constructor(props) {
        super(props);
        if (this.props.investigation) {
            this.props.getUsersAction(this.props.investigation)
        }
    }

    state = {
        inviteOpen: false,
        expanded: null,
        value: 0
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.investigation !== nextProps.investigation) {
            this.props.getUsersAction(nextProps.investigation)

        }
    }

    handleInviteOpen = () =&gt; {
        this.setState({
            inviteOpen: true
        })
    }

    updateOnSave = () =&gt; {
        this.setState({
            expanded: null
        })
        this.props.getUsersAction(this.props.investigation).then(() =&gt; {
            this.props.getInvestigationPermissionsAction(this.props.investigation)
        })
    }

    closeOnCancel = () =&gt; {
        this.setState({
            expanded: null
        })
    }

    closeDialog = () =&gt; {
        this.setState({
            inviteOpen: false
        })
    }

    handleChange = (event, value) =&gt; {
        console.log(value)
        this.setState({ value });
    };

    handleChangeIndex = index =&gt; {
        this.setState({ value: index });
    };

    handleExpansionChange = panel =&gt; (event, expanded) =&gt; {
        this.setState({
          expanded: expanded ? panel : false,
        });
    }

    render() {
        const { expanded } = this.state;
        let inviteUsers = null;
        if (this.state.inviteOpen === true) {
            inviteUsers = (
                &lt;InviteUsersDialog open={this.state.inviteOpen} updateOnSave={this.updateOnSave} closeDialog={this.closeDialog}/&gt;
            )
        } else {
            inviteUsers = null;
        }

        if (this.props.usersError) {
            this.props.history.push('/dash')
            this.props.resetUsersError()
        }

        let usersList = null;
        if (this.props.users) {
            console.log(""USERS:"", this.props.users)
            usersList = (
                &lt;div className={this.props.classes.usersExpansions}&gt;
                    &lt;ExpansionPanel className={this.props.classes.expansionPanel} expanded={false}&gt;
                      &lt;ExpansionPanelSummary className={this.props.classes.expansionSummary} expandIcon={&lt;ExpandMoreIcon className={this.props.classes.headerExpandMore}/&gt;}&gt;
                        &lt;div className={this.props.classes.headerAvatarContainer}&gt;
                            &lt;div className={this.props.classes.userInfo}&gt;
                                &lt;Typography className={this.props.classes.headingName}&gt;Name&lt;/Typography&gt;
                                &lt;Typography className={this.props.classes.headingEmail}&gt;Email&lt;/Typography&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;Typography className={this.props.classes.headerStatus}&gt;Status&lt;/Typography&gt;
                        &lt;Typography className={this.props.classes.headerPermissions}&gt;Permissions&lt;/Typography&gt;
                      &lt;/ExpansionPanelSummary&gt;
                    &lt;/ExpansionPanel&gt;
                {this.props.users.currentUsers.map((user) =&gt;
                    &lt;ExpansionPanel className={this.props.classes.expansionPanel} expanded={expanded === user.email + '-' + this.props.investigation} onChange={this.handleExpansionChange(user.email + '-' + this.props.investigation)}&gt;
                      &lt;ExpansionPanelSummary className={this.props.classes.expansionSummary} expandIcon={&lt;ExpandMoreIcon /&gt;}&gt;
                        &lt;div className={this.props.classes.avatarContainer}&gt;
                            &lt;Avatar
                                alt={user.name}
                                src={user.avatarImg ? ""data:image/jpeg;base64,"" + user.avatarImg : tempAvatar}
                                className={this.props.classes.avatar}
                                style={{ borderRadius: 2.1 }}
                            /&gt;
                            &lt;div className={this.props.classes.userInfo}&gt;
                                &lt;Typography className={this.props.classes.headingName}&gt;{user.name}&lt;/Typography&gt;
                                &lt;Typography className={this.props.classes.headingEmail}&gt;{user.email}&lt;/Typography&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;Typography className={this.props.classes.status}&gt;{expanded === user.email + '-' + this.props.investigation ? '' : 'Activated'}&lt;/Typography&gt;
                        &lt;Typography className={this.props.classes.headingPermissions}&gt;{expanded === user.email + '-' + this.props.investigation ? '' : user.permissionsArr.join(', ')}&lt;/Typography&gt;
                      &lt;/ExpansionPanelSummary&gt;
                      &lt;ExpansionPanelDetails className={this.props.classes.detailsContainer}&gt;
                        //FORM IN QUESTION IS RENDERED HERE
                        &lt;PermissionsForm 
                         form={`PermissionsForm_${user.identifier + '-' + this.props.investigation}`} 
                         updateOnSave={this.updateOnSave} closeOnCancel={this.closeOnCancel} 
                         loggedInUser={user.email === localStorage.getItem('userEmail') ? true : false} 
                         formName={`PermissionsForm_${user.identifier + '-' + this.props.investigation}`} 
                         initialValues={{identifier: user.identifier, viewPermissions: user.permissions.viewEntries === true ? 'allEntries' : 'ownEntries', addEntriesPermissions: true, exportPermissions: user.permissions.export, manageInvestPermissions: user.permissions.manageInvest}}/&gt;
                      &lt;/ExpansionPanelDetails&gt;
                    &lt;/ExpansionPanel&gt;
                )}
                {this.props.users.pendingUsers.map((user) =&gt;
                    &lt;ExpansionPanel className={this.props.classes.expansionPanel} expanded={false} onChange={this.handleExpansionChange(user.email + '-' + this.props.investigation)}&gt;
                      &lt;ExpansionPanelSummary className={this.props.classes.expansionSummary} expandIcon={&lt;ExpandMoreIcon className={this.props.classes.headerExpandMore}/&gt;}&gt;
                        &lt;div className={this.props.classes.avatarContainer}&gt;
                            &lt;Avatar
                                alt={user.name}
                                src={tempAvatar}
                                className={this.props.classes.avatar}
                                style={{ borderRadius: 0 }}
                            /&gt;
                            &lt;div className={this.props.classes.userInfo}&gt;
                                &lt;Typography className={this.props.classes.headingEmail}&gt;{user.email}&lt;/Typography&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;Typography className={this.props.classes.status}&gt;Pending&lt;/Typography&gt;
                        &lt;Typography className={this.props.classes.headingPermissions}&gt;{user.permissionsArr.join(', ')}&lt;/Typography&gt;
                      &lt;/ExpansionPanelSummary&gt;
                    &lt;/ExpansionPanel&gt;
                )}
                &lt;/div&gt;
            )
        }
        return (
            &lt;div className={this.props.classes.container}&gt;
                &lt;div className={this.props.classes.pageHeaderContainer}&gt;
                    &lt;h2 className={this.props.classes.title}&gt;Manage users&lt;/h2&gt;
                    &lt;Button color=""primary"" raised className={this.props.classes.inviteButton} onClick={this.handleInviteOpen}&gt;Invite user&lt;/Button&gt;
                &lt;/div&gt;
                {inviteUsers}
                &lt;AppBar position=""static"" color=""default"" className={this.props.classes.tabsAppBar}&gt;
                  &lt;Tabs
                    value={this.state.value}
                    onChange={this.handleChange}
                    indicatorColor=""primary""
                    textColor=""primary""
                    fullWidth
                    className={this.props.classes.tabs}
                  &gt;
                    &lt;Tab label=""People"" /&gt;
                    &lt;Tab label=""Groups"" /&gt;
                  &lt;/Tabs&gt;
                &lt;/AppBar&gt;
                &lt;SwipeableViews
                  axis={'x'}
                  index={this.state.value}
                  onChangeIndex={this.handleChangeIndex}
                &gt;
                &lt;div className={this.props.classes.peopleContainer}&gt;
                    {usersList}
                &lt;/div&gt;
                &lt;div&gt;

                &lt;/div&gt;
                &lt;/SwipeableViews&gt;
            &lt;/div&gt;
        );
    }
}


const styles = {
};

function mapStateToProps(state, ownProps) {
  return { 
    investigation: state.manage.savedInvest,
    users: state.manage.authorizedUsers,
    usersError: state.manage.usersError
  };
}


export default compose(
  withRouter,
  connect(mapStateToProps, {getUsersAction, getInvestigationPermissionsAction, resetUsersError, destroyFormsAction}),
  withStyles(styles)
)(Manage);
</code></pre>

<p><strong>FORM</strong></p>

<pre><code>import React from 'react';
import Dialog, {
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
} from 'material-ui/Dialog';

import Button from 'material-ui/Button';
import Input, { InputLabel } from 'material-ui/Input';

import { withStyles } from 'material-ui/styles';

import List, { ListItem, ListItemIcon, ListItemText } from 'material-ui/List';

import Typography from 'material-ui/Typography';

import Divider from 'material-ui/Divider'

import SelectBase from 'material-ui/Select';
import { MenuItem } from 'material-ui/Menu';
import { Field, FieldArray, reduxForm, getFormValues, change, reset, initialize } from 'redux-form';
import { patchPermissionsAction } from '../../actions/manage';
import { resetFormsAction } from '../../actions/dashboard';
import { connect } from 'react-redux';
import { withRouter } from 'react-router-dom';

import Tooltip from 'material-ui/Tooltip';

import PropTypes from 'prop-types';

import compose from 'recompose/compose';

import {
  Checkbox,
  RadioGroup,
  Select,
  TextField,
  Switch,
} from 'redux-form-material-ui'

const required = value =&gt; (value == null ? 'Required' : undefined)

class PermissionsForm extends React.Component {
  constructor(props) {
    super(props);
  }

  static contextTypes = {
    form: PropTypes.string
  }
  submit = (values) =&gt; {
    this.props.patchPermissionsAction(values, this.props.investigation).then(() =&gt; {
      this.props.updateOnSave();
    })
  }

  handleCancel = () =&gt; {
    this.props.closeOnCancel();
    this.props.dispatch(reset(this.props.formName))
  }

  componentDidUpdate() {
    console.log(""!"")
    if(!this.props.initialized) {
      console.log(""!!"")
    }
  }

  componentWillUnmount() {

  }

  render() {
    const { handleSubmit, pristine, reset, submitting } = this.props

    let managePerm = null;
    if (this.props.loggedInUser) {
      managePerm = (
        &lt;Tooltip id=""tooltip-top-start"" title=""Coming soon"" placement=""top""&gt;
          &lt;Typography className={this.props.classes.status}&gt;Manage users&lt;/Typography&gt;
        &lt;/Tooltip&gt;
      )
    } else {
      managePerm = (&lt;Typography className={this.props.classes.status}&gt;Manage users&lt;/Typography&gt;)
    }

    return (
      &lt;div className={this.props.classes.permFormContainer}&gt;
        &lt;Divider /&gt;
        &lt;form onSubmit={ handleSubmit(this.submit) }&gt;
        &lt;div className={this.props.classes.innerFormContainer}&gt;
            &lt;div className={this.props.classes.groupsContainer}&gt;
            &lt;br/&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt;
              &lt;Typography className={this.props.classes.status}&gt;View&lt;/Typography&gt;
              &lt;Field name=""viewPermissions"" component={Select}&gt;
                &lt;MenuItem value=""ownEntries""&gt;View own entries&lt;/MenuItem&gt;
                &lt;MenuItem value=""allEntries""&gt;View all entries&lt;/MenuItem&gt;
              &lt;/Field&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt;
            &lt;Tooltip id=""tooltip-top-start"" title=""Coming soon"" placement=""top""&gt;
              &lt;Typography className={this.props.classes.status}&gt;Add entries&lt;/Typography&gt;
            &lt;/Tooltip&gt;
            &lt;Field
              name=""addEntriesPermissions""
              component={Checkbox}
              normalize={v =&gt; !!v}
              disabled={true}
            /&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt; 
            &lt;Typography className={this.props.classes.status}&gt;Export data&lt;/Typography&gt;
            &lt;Field
              name=""exportPermissions""
              component={Checkbox}
              normalize={v =&gt; !!v}
            /&gt;
            &lt;/div&gt;
            &lt;div className={this.props.classes.fieldContainer}&gt;
            {managePerm}
            &lt;Field
              name=""manageInvestPermissions""
              component={Checkbox}
              normalize={v =&gt; !!v}
              disabled={this.props.loggedInUser === true ? true : false}
            /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;Divider /&gt;
        &lt;div className={this.props.classes.actionButtons}&gt;

          &lt;Tooltip id=""tooltip-top-start"" title=""Coming soon"" placement=""top""&gt;
          &lt;Button color=""error"" className={this.props.classes.deleteButton}&gt;
            Delete account
          &lt;/Button&gt;
          &lt;/Tooltip&gt;
          &lt;div className={this.props.classes.saveAndCancelButtons}&gt;
            &lt;Button onClick={this.handleCancel} className={this.props.classes.cancelButton}&gt;
              Cancel
            &lt;/Button&gt;
            &lt;Button type=""submit"" disabled={submitting} color=""primary"" className={this.props.classes.saveButton}&gt;
              Save
            &lt;/Button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    );
  }
}

function mapStateToProps(state, ownProps) {
  return { 
    investigation: state.manage.savedInvest,
    investTitle: state.manage.savedInvestTitle
  };
}

const styles = theme =&gt; ({
});

const reduxFormmPermissions = reduxForm({
  enableReinitialize : true
})(PermissionsForm);

export default compose(
  withRouter,
  connect(mapStateToProps, {patchPermissionsAction}),
  withStyles(styles)
)(reduxFormmPermissions);
</code></pre>

<p>Thanks much for anybody who can help me get to the bottom of this. Real head-banger.</p>
","5335646","","5335646","","2018-05-14 16:03:30","2018-05-29 17:09:29","Redux form renders in unitialized state (and unable to be initialized) when reactively changing content on page","<reactjs><redux><redux-form>","1","6","","",""
"44280565","1","44280638","","2017-05-31 09:15:27","","0","192","<p>Im using <code>gsap</code> Draggable with <code>reactjs</code> <code>ES6</code>, I create new draggable like this in react component <code>componentDidUpdate</code> lifecycle method</p>

<pre><code>import React, { Component } from 'react'
import Draggable from 'gsap/Draggable'

class DraggableContainer extends Component {

    render(){
        ...
    }
    componentDidUpdate(){
        const draggable = Draggable.create('.box', {
            onPress: ()=&gt;{
                // currentElement suppost to contain dom element of clicked, but its undefined because 'this' is 'DraggableContainer'
                const currentElement = this.target

            }   
        })
    }
}
</code></pre>

<p>inside method body of <code>onPress</code> this.target should give current element but its undefined and <code>this</code> is wrong context.</p>

<p>How can i access current elent inside this method?</p>
","5485491","","5485491","","2017-05-31 09:25:59","2017-05-31 09:29:59","GSAP Draggable with react ES6 actual this","<javascript><reactjs><this><gsap>","1","0","","",""
"45761343","1","45763758","","2017-08-18 16:39:58","","0","386","<p>I have been working on a small todo application to learn and get my head around some react. Everything has been going according to plan up until I started with the completed section of the application. The problem I am trying to solve is probably pretty simple, however, I cannot seem to wrap my head around what is going on. What I am trying to do is invoke my <strong>createCompletedList</strong> method so I can create all of the items that have been completed. Although, when the method is invoked in the <strong>componentDidUpdate</strong> method it creates an infinite loop that crashes the browser. Is there any way that I can call the <strong>createCompletedList</strong> method that is safe from this kind of behaviour? </p>

<p>Any sort of advice or information would be greatly appreciated.</p>

<hr>

<pre><code>import React, { Component } from ""react"";

class Completed extends Component {
  constructor(props) {
    super(props);
    console.log(props);
    this.state = {
      completedItems: []
    };

    this.checkIndex = this.checkIndex.bind(this);
    this.createCompletedList = this.createCompletedList.bind(this);
  }

  checkIndex(event) {
    console.log(""index value is "" + this.props.indexValue);
  }

  createCompletedList() {
    const completedIndex = this.props.indexValue;
    const completedArray = this.state.completedItems;

    if (completedIndex) {
      completedArray.push(this.props.arrayItems[completedIndex]);
      this.setState(prevState =&gt; {
        return { completedItems: completedArray };
      });
    }

    console.log(this.state.completedItems);
  }

  componentDidUpdate() {
    this.createCompletedList();
  }

  render() {
    let completedArray = this.state.completedItems;

    const retrieveList = completedArray.map((elm, index, arr) =&gt; {
      return (
        &lt;div className=""check-list-row checked"" key={index}&gt;
          {elm}
        &lt;/div&gt;
      );
    });
    return (
      &lt;div
        className={this.props.isTaskChecked ? ""completed-container"" : ""hide""}&gt;
        &lt;div className=""completed-row""&gt;
          &lt;h1&gt;Completed&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div&gt;
          {retrieveList}
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
export default Completed;
</code></pre>
","5390249","","","","","2017-08-18 19:24:10","componentDidUpdate causing infiinite loop","<reactjs>","2","8","1","",""
"47471200","1","","","2017-11-24 10:25:24","","2","125","<p>So the main aim of me using refs is so that I can reset the scroll position of a scrollable div, this is an image of the div before adding content <a href=""https://i.stack.imgur.com/ftiV6.png"" rel=""nofollow noreferrer"">this is how it looks before dynamically adding divs to the scrollable container div</a></p>

<p>This is a screenshot of the div after adding boxes to it:
<a href=""https://i.stack.imgur.com/3NEwq.png"" rel=""nofollow noreferrer"">the box is created outside of viewport and is created at the top of the scrollable area</a></p>

<p>So to be able to maintain the viewport at the top of the scrollable area I am hoping to use refs to do ReactDOM.findDOMNode(this.songIdWrapper) and then manipulate the scrollTop or use scrollTo methods.</p>

<p>Please find the code snippet below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {Component} from 'react';
import ReactDOM from 'react-dom';

class AddPlaylist extends Component {
    constructor(props){
        super(props);
        this.state = {
            displaySearch: false,
            id: '',
            playlistName:'',
            playlistTitle:'',
            songs:[]
        }

        this.handleIdSubmit = this.handleIdSubmit.bind(this);
        this.handleIdChange = this.handleIdChange.bind(this);
        this.handleNamechange = this.handleNamechange.bind(this);
        this.handleNameSubmit= this.handleNameSubmit.bind(this);
        this.callback=this.callback.bind(this);
    }
    componentWillUpdate () {
        console.log(ReactDOM.findDOMNode(this.songIdWrapper));
    }
    componentDidUpdate () {
        
    }

    callback (songId) {
        this.songIdWrapper=songId;
    }
    render () {
        return(
            &lt;div className='add-playlist-wrapper'&gt; 
                &lt;div className='form-wrapper container'&gt;
                    &lt;form onSubmit={this.handleNameSubmit} className='playlist-name-wrapper'&gt;
                            &lt;input className={this.state.submittedName ? 'hide-input' : ''} required onChange={this.handleNamechange} value={this.state.playlistName} placeholder='Playlist title'/&gt;
                            {this.state.submittedName ? &lt;p className='title'&gt;{this.state.playlistTitle}&lt;/p&gt; : null}
                    &lt;/form&gt;
                    &lt;form onSubmit={this.handleIdSubmit} className='add-id-wrapper'&gt;
                        &lt;div className='input-add-playlist'&gt;
                            &lt;input required onChange={this.handleIdChange} value={this.state.id} placeholder='Add song...'/&gt;
                            &lt;button type='submit' className='fabutton'&gt;
                                &lt;i className=""add-button fa fa-plus-square-o fa-3x"" aria-hidden=""true""&gt;&lt;/i&gt;
                            &lt;/button&gt;
                        &lt;/div&gt;
                    &lt;/form&gt;
                    &lt;div id='song-id-wrapper' ref={this.callback}&gt;
                    {this.state.songs.map((song, i) =&gt; {
                        return (&lt;div key={i} className='song'&gt;
                                    &lt;p&gt;{song}&lt;/p&gt;
                                &lt;/div&gt;
                        )
                    })}
                &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

    handleIdSubmit (event) {
        event.preventDefault();
        const newState = this.state.songs.slice();
        newState.push(this.state.id);
        this.setState({
            songs:newState
        })
    }

    handleIdChange (event) {
        this.setState({
            id: event.target.value
        })
    }

    handleNamechange (event) {
        this.setState({
            playlistName: event.target.value
        })
    }

    handleNameSubmit (event) {
        event.preventDefault();
        this.setState({
            playlistTitle: this.state.playlistName
        })
    }

}

export default AddPlaylist;</code></pre>
</div>
</div>
</p>

<p>The error message I get is:
<a href=""https://i.stack.imgur.com/ELfRh.png"" rel=""nofollow noreferrer"">this is the error message stating that ref is not a prop</a></p>

<p>So I am quite new to react and as far as I'm aware this is an attribute on a div element not passed as a prop to a component. So I hope you can see my confusion as when I search google/stack-overflow I see a lot of comments relating to child components. I am fully aware string refs have been depreciated and that callbacks should be used but no matter what I try I cannot get rid of this error message.</p>

<p>Any help would be greatly appreciated.</p>
","8635545","","","","","2017-11-24 10:34:47","Error 'ref is not a prop' when using ref on a div inside of a react component","<reactjs><dom><jsx><react-dom><refs>","1","6","","",""
"46039839","1","46040935","","2017-09-04 15:07:12","","0","29","<p>I'm in a problem when update store of my react redux app.
How can I make store update thenable?
As you know, all updates of states are async, so we have to use componentDidUpdate method if I do something as a callback function of state update. But these are sometimes complicated. I'd like to make this simple, by something like making them thenable method. Does have any body any idea?</p>
","6475121","","","","","2017-09-04 16:18:07","Can I make store update thenable in react redux app?","<reactjs><redux><react-redux>","1","1","","",""
"37732034","1","","","2016-06-09 16:57:03","","2","1148","<p>So I'd like to implement a loading bar just like github has. It should start loading on a click to another page and finish when it arrived.</p>

<p>I'm using material-ui and for the loader react-progress-bar-plus.</p>

<p>I tried to use react-router's lifecycle hooks, namely componentDidUpdate and componentWillReceiveProps to set the state to be finished.</p>

<p>For start, I attached an onTouchTap function to the menu items but it just does not want to work properly.</p>

<p>What is the best way to implement this feature?</p>
","5202892","","","","","2016-12-01 17:23:38","React Redux Loading bar for react router navigation","<javascript><reactjs><react-router><material-ui>","1","0","2","",""
"46063351","1","","","2017-09-05 21:06:47","","3","1449","<p>I'm trying to make a simple transition with react on a button click where the body max-height goes to 0 on componentWill update, then back to 500px or 100% on componentDidUpdate. I haven't been abe to quite understand it from the other questions I've seen so could someone show me an example with an explanation of how it works? </p>

<p>I also wouldn't mind an example/explanation using reactcsstransitiongroup.</p>

<p><strong>More Info</strong></p>

<p>I understand that transitionend attaches an event listener but what I'm getting confused with is how to use that to ensure the component doesn't update until the transition is finished (I've taught myself react and pretty much all my coding knowledge so I don't know if this is suppossed to be hard to understand, but its hard for me at the moment). Thanks all!</p>
","7270152","","","","","2017-09-06 03:49:35","Using transitionend event listener with react to create a transition","<javascript><reactjs><transition><transitionend>","1","0","","",""
"29309243","1","","","2015-03-27 20:00:13","","0","238","<p>i am struggling for 2 days on this, i am trying to call imagesLoaded function (which is imported properly in the scripts area), but when calling it from inside a component prop, i get an error that it is indefined.</p>

<p>my code:</p>

<pre><code>    var MasonryContainer = React.createClass({

    imagesLoadedFunc: function() { //omitting the imageloaded call here fix everything
                  this.imagesloaded();
                  this.refs[reference].getDOMNode().imagesLoaded(function() {
                   this.masonry.layout()
                     });

    },
    componentDidMount: function() {
                if (!isBrowser) return;
                this.initializeMasonry();
                this.performLayout();
                this.imagesLoadedFunc();
            },

    componentDidUpdate: function() {
                if (!isBrowser) return;

                this.performLayout();
                this.imagesLoadedFunc(this);
            },

            domChildren: [],

    initializeMasonry: function(force) {
        if (!this.masonry || force) {
            this.masonry = new Masonry(this.refs[reference].getDOMNode(), options);
            this.domChildren = this.getNewDomChildren();
        }
    },

    getNewDomChildren: function () {
        var node = this.refs[reference].getDOMNode();
        var children = options.itemSelector ? node.querySelectorAll(options.itemSelector) : node.children;

        return Array.prototype.slice.call(children);
    },

    diffDomChildren: function() {
        var oldChildren = this.domChildren;
        var newChildren = this.getNewDomChildren();
        var removed = oldChildren.filter(function(oldChild) {
            return !~newChildren.indexOf(oldChild);
        });

        var added = newChildren.filter(function(newChild) {
            return !~oldChildren.indexOf(newChild);
        });

        var moved = [];

        if (removed.length === 0) {
            moved = oldChildren.filter(function(child, index) {
                return index !== newChildren.indexOf(child);
            });
        }
        this.domChildren = newChildren;
        return {
            old: oldChildren,
            'new': newChildren, // fix for ie8
            removed: removed,
            added: added,
            moved: moved
        };
    },

    performLayout: function() {
        var diff = this.diffDomChildren();

        if (diff.removed.length &gt; 0) {
            this.masonry.remove(diff.removed);
            this.masonry.reloadItems();
        }

        if (diff.added.length &gt; 0) {
            this.masonry.appended(diff.added);
        }

        if (diff.moved.length &gt; 0) {
            this.masonry.reloadItems();
        }

        this.masonry.layout();
    },


    componentWillReceiveProps: function() {
        setTimeout(function() {
            this.masonry.reloadItems();
            this.forceUpdate();
        }.bind(this), 0);
    },

    render: function () {
        return (
            &lt;div className=""content"" ref=""masonryContainer""&gt;
                &lt;div className='Item'&gt;
                    &lt;img src=""/img/gallery/3.jpg""&gt;&lt;/img&gt;
                &lt;/div&gt;
                &lt;div className='Item'&gt;
                    &lt;img src=""/img/gallery/11.jpg""&gt;&lt;/img&gt;
                &lt;/div&gt;
                &lt;div className='Item'&gt;
                    &lt;img src=""/img/gallery/12.jpg""&gt;&lt;/img&gt;
                &lt;/div&gt;
                &lt;div className='Item'&gt;
                    &lt;img src=""/img/gallery/12.jpg""&gt;&lt;/img&gt;
                &lt;/div&gt;
                &lt;img src=""/img/gallery/4.jpg""&gt;&lt;/img&gt;
                &lt;img src=""/img/gallery/5.jpg""&gt;&lt;/img&gt;
                &lt;img src=""/img/gallery/6.jpg""&gt;&lt;/img&gt;
                &lt;img src=""/img/gallery/7.jpg""&gt;&lt;/img&gt;
                &lt;img src=""/img/gallery/8.jpg""&gt;&lt;/img&gt;
                &lt;img src=""/img/gallery/9.jpg""&gt;&lt;/img&gt;
            &lt;/div&gt;
        );
    }
});
    React.render(
    &lt;MasonryContainer/&gt;, document.getElementById('reactbody')
    )
&lt;/script&gt;
</code></pre>

<p>if i call the imageloaded constructor outside of the react component, it is working.
any idea what i am missing?</p>

<p>thanks!</p>
","1472580","","","","","2015-03-28 09:57:10","functions are undefind inside react object","<reactjs><imagesloaded>","1","0","","",""
"46135198","1","46135364","","2017-09-09 21:17:56","","0","377","<p><strong>Objective:</strong> When my Game component receives a prop I want <code>componentDidUpdate()</code> to call a function called <code>consolelog</code> which is a child of another function called <code>gamecode()</code>. </p>

<p><strong>Problem:</strong> using <code>this.gameCode.consolelog()</code> always returns an error saying that <code>consolelog</code> is not a function of <code>gameCode</code>.</p>

<p><strong>Note:</strong> <code>Gamecode()</code> is imported into my react component (Game) from a file called <code>gamecode.js</code></p>

<p><strong>Component:</strong></p>

<pre><code>import React, {Component} from 'react';

import {gameCode, showLeaderboard} from '../utility/gamecode';

class Game extends Component{
  constructor(props){
    super();
    this.state = {
      drawL : null
    }
  };

  componentDidMount(){
    this.gameCode();
  };

  componentDidUpdate(){
    //will run when the state changes
    if(this.props.leaderboard){
        var a = this.props.leaderboard;
        this.gameCode.consolelog(a);
    }
  }   

  render(){
    return(
      &lt;div className=""Game""&gt;
        &lt;canvas id=""canvas""&gt;&lt;/canvas&gt;
        &lt;button onClick={this.props.getleaderboard} className=""showleaders""&gt;Show leaderboard&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

export default Game;
</code></pre>

<p><strong>GameCode.js function:</strong></p>

<pre><code>gameCode(){
  //the main function initializes some stuff immediately and start running the update() and draw() functions
  const canvas = document.getElementById('canvas');
  canvas.width = 800;
  canvas.height= 600;
  const ctx = canvas.getContext(""2d"");
  const FPS = 30;
  setInterval(() =&gt; {
      update();
      draw();
  }, 1000/FPS);

  //but sometimes I need to call other functions on demand, but these functions depend on what the parent function and other sibling functions
  function consolelog(a){
    console.log(""success!"");
    console.log(a);
  }
}
</code></pre>
","4497344","","4497344","","2017-09-09 21:39:27","2017-09-09 23:12:28","How to call nested react function","<javascript><reactjs>","3","2","1","",""
"38014095","1","","","2016-06-24 13:01:34","","0","146","<p>Actually, I have to perform heavy operations and set it as state after new data received by react component. so i am little bit worried about performance. Both ""componentWillUpdate"" and ""componentDidUpdate"" can accomplish my requirement. So, what should i use for better performance?</p>
","6453397","","","","","2016-06-24 13:09:15","For better performance, which is better: componentWillUpdate or componentDidUpdate?","<javascript><reactjs>","1","1","","",""
"46600990","1","46616548","","2017-10-06 07:57:36","","2","672","<p>I'm new to Mobx and reactjs in general, I have knowledge in Redux and react native, and in Redux when I used to call an action and the props get updated, the <code>componentDidUpdate</code> life cycle method is triggered.</p>

<p>The scenario I'm having now is login. so the user fills the form, clicks submit, and the submit calls a Mobx action (asynchronous), and when the server responds, an observable is updated, and then it navigates to a main page (navigation happens in the component).</p>

<p>Here is my store code.</p>

<pre><code>import { autorun, observable, action, runInAction, computed, useStrict } from 'mobx';

useStrict(true);

class LoginStore {
    @observable authenticated = false;
    @observable token = '';

    @computed get isAuthenticated() { return this.authenticated; }


    @action login = async (credentials) =&gt; {
        const res = await window.swaggerClient.Auth.login(credentials)l
        // checking response for erros
        runInAction(() =&gt; {
            this.token = res.obj.token;
            this.authenticated = true;
        });
    }
}

const store = new LoginStore();

export default store;

export { LoginStore };
</code></pre>

<p>and this handler is in my component.</p>

<pre><code>handleSubmit = (e) =&gt; {
        e.preventDefault();

        this.props.form.validateFields((err, values) =&gt; {
            if (!err) {
                this.props.store.login(values);
            }
        });
    }

    componentDidUpdate() {
        if (this.props.store.isAuthenticated) {
            const cookies = new Cookies();
            cookies.set('_cookie_name', this.props.store.token);
            this.props.history.push('main');
        }
    }
</code></pre>

<p>It's not the ideal code, I'm just experimenting, but I'm not quite getting it.</p>

<p>Also, if I use the computed value <code>(isAuthenticated)</code> in the <code>render</code> life cycle method, the <code>componentDidUpdate</code> is triggered, but if I didn't use it in the <code>render</code> method, the <code>componentDidUpdate</code> is not triggered.
For example, if I do this</p>

<pre><code>render() {
  if (this.props.store.isAuthenticated) return null
  // .... rest of the code here
}
</code></pre>

<p>the above will trigger the componentDidUpdate.</p>

<p>Am I missing something? is there a better way to do it with Mobx?
Thanks</p>
","1987923","","","","","2017-10-07 11:35:48","React Mobx componentDidUpdate is not updating when observable changes","<reactjs><mobx><mobx-react>","1","2","","",""
"46146824","1","46146831","","2017-09-11 00:40:55","","0","41","<p><strong>Problem:</strong> When the exported function is called by my React component, <code>console.log(this)</code> displays undefined. I was expecting it to return the component since I have bound it in my constructor.</p>

<p><strong>Leaderboard.js:</strong></p>

<pre><code>import React from 'react';
import {leaderboard, createLeaderboard} from '../utility/gamecode';

class Leaderboard extends React.Component{
  constructor(props){
    super(props);
    this.showLeaderboard = showLeaderboard.bind(this);
    this.state = {
    }
  };

  componentDidUpdate(){
    if(this.props.leaderboard){
      showLeaderboard();
    }
  }

  render(){
    return(
      &lt;div className=""leaderboard hidden""&gt;
      &lt;/div&gt;
    )
  }

}

export default Leaderboard;
</code></pre>

<p><strong>gamecode.js:</strong></p>

<pre><code>export function showLeaderboard(){
 console.log(this);
}
//-----------------------
export function createLeaderboard(props){
}
</code></pre>
","4497344","","","","","2017-09-11 00:42:45","""this"" undefined in exported react function","<javascript><reactjs>","1","0","1","",""
"38367248","1","","","2016-07-14 06:45:56","","0","2160","<p>I have a react native component which is connected to the store, whenever there is an update to the store, render method is invoked.<br>
I want to know whether render finished rendering the page.<br>
I tried <code>componentDidUpdate()</code> but is getting invoked for every update from the redux store.</p>
","1431289","","5076405","","2016-07-14 10:28:41","2016-07-14 12:29:09","How to findout whether render is finished in react native","<react-native>","1","1","","",""
"38561660","1","","","2016-07-25 07:10:55","","2","407","<p>One of my components has a <code>div</code> element into which I would like to spill and handle/mutate my own DOM - without React interfering. </p>

<p>I am using d3.js for that manual DOM manipulation, and no I am not looking for react-d3 solutions, I need plain d3 in there. </p>

<p>All works well for me, except the reacts console warnings:</p>

<p><code>
warning.js:44Warning: Unknown prop `xmlns` on &lt;svg&gt; tag. Remove this prop from the element. For details, see
</code></p>

<p>and</p>

<p><code>
warning.js:44 Warning: Unknown DOM property class. Did you mean className?
</code></p>

<p>So It complains about me using <code>class</code> instead of <code>className</code> or about having some html attributes which are not react style etc.. </p>

<p>I'd like to tell React that from this component and below, it shouldn’t interfere, I will manage the DOM below this component manually.</p>

<p>Code looks something like this:</p>

<pre><code>import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import SomeD3CustomComp from '../some-d3-custom-comp.js';

export default class MyComponent extends Component {

  componentDidMount() {
   this.injectChart();
  }

  componentDidUpdate() {
   this.injectChart();
  }

  injectChart() {
    const comp = findDOMNode(this.refs.nonReactContainer);
    const { chart } = this.props;
    const { shouldRender, data } = chart;
    if (shouldRender) {
      SomeD3CustomComp.render(comp, data);
    }
  }

  render() {
    const { chart, someOtherData } = this.props;
    const { shouldRender } = chart;
    return(
      &lt;article&gt;
        {
          shouldRender &amp;&amp;
          &lt;div className=""non-react-element"" ref=""nonReactContainer""&gt;&lt;/div&gt;
        }
        &lt;div className=""react-element""&gt;{someOtherData}&lt;/div&gt;
      &lt;/article&gt;
    );
  }
}
</code></pre>

<hr>

<h2>Update:</h2>

<p>The suggestion of returning <code>false</code> on <code>shouldComponentUpdate</code> doesnt take away the error messages I have stated above, maybe because of the fact that <code>shouldComponentUpdate</code> happens only when there is an update - after the first inject on <code>componentDidMount</code>. </p>

<p>Another problem with that approach is that if return <code>false</code> code never gets to the render method where more logic is implemented such as in the example above where I check if to render the container non react element. This is the way I simply remove all previously injected elements, in the previous state. </p>

<p>So I am still looking for help with that...</p>

<hr>

<h2>Solved!</h2>

<p>false alarm :/ just found out that those warning messages were related to a different part of the code. Was a strange coincidence from the time this new feature was developed and some older problem. Conclusion: look harder at the warning messages! 
So this integration with d3 actually works nice.</p>
","2373504","","2373504","","2016-07-26 05:32:39","2016-07-26 05:32:39","How to tell react.js NOT to reconcile or interfere from a certain element?","<dom><d3.js><svg><reactjs>","0","1","1","",""
"40692336","1","","","2016-11-19 11:27:17","","0","383","<p>I'm using a Modal based on the example code from the docs: <a href=""https://react-bootstrap.github.io/components.html#modals-live"" rel=""nofollow noreferrer"">https://react-bootstrap.github.io/components.html#modals-live</a>. What I want is for a child component to be rendered only when 1) it's data is ready, and 2) when the modal is opened. Also, the child component needs to know how wide the area is it has to work with (because it's doing some d3.js svg drawing inside).</p>

<p>I'm also, btw, using <code>fixed-data-table</code>, so the data (a <code>concept</code>) is put in state and the Model is opened on row click:</p>

<pre><code>onRowClick={(evt, idx, obj)=&gt;{
  let concept = filteredDataList.getObjectAt(idx);
  this.openModal();
  this.setState({concept});
}}
</code></pre>

<p>As per the Modal docs example, the Modal sits there in the render and exists in the DOM in a closed state until something opens it. However, the Modal.Body doesn't seem to exist till the Modal is open. My bright idea is that the child, <code>ConceptDetail</code>, can get the ClientWidth from a ref to its containing div.</p>

<pre><code>let conceptDetail = '';
if (this.state.concept) {
    conceptDetail = &lt;ConceptDetail 
                        containerRefs={this.refs}
                        concept={concept} /&gt;/
}

&lt;Modal&gt;
   ...
  &lt;Modal.Body&gt;
    &lt;div ref=""modalBody"" style={{width:'100%'}}&gt;
        {conceptDetail}
    &lt;/div&gt;
  &lt;/Modal.Body&gt;
  ...
&lt;/Modal&gt;
</code></pre>

<p>This <em>would</em> work, except the ref isn't ready until after the child component is rendered. To figure out what's going on, I did this:</p>

<pre><code>componentWillUpdate(){
  if (this.refs.modalBody) {
    let { clientWidth } = this.refs.modalBody;
    alert(`will update, width: ${clientWidth}`);
  } else {
    alert('will update, no modalBody ref');
  }
}
componentDidUpdate(){
  if (this.refs.modalBody) {
    let { clientWidth } = this.refs.modalBody;
    alert(`did update, width: ${clientWidth}`);
  } else {
    alert('did update, no modalBody ref');
  }
}
</code></pre>

<p>When I click a row, I see the alert <code>will update, no modalBody ref</code>, followed by the alert <code>did update, width: 868</code>, and then the child component displays. But the child didn't get the width (or the updated ref) because it actually renders before the <code>componentDidUpdate</code>. The reason I see the alert first (I assume) is because the Modal is animated and doesn't appear instantly on rendering. When I close the Modal, I actually do see for a quick flash that it has finally received the correct width, but at that point I don't need it anymore.</p>

<p>So, most specifically, my question is: How can a child component of a Modal be informed of the modal body's width? I would be even more grateful if someone might explain the right way to do what I'm trying to do in general: Trigger display of a Modal with a child component that would like to receive data and container dimensions as props.</p>
","1368860","","","","","2016-11-19 13:08:05","react-bootstrap modal, how to handle child component?","<reactjs><react-bootstrap><react-modal>","1","0","","",""
"46195559","1","46196599","","2017-09-13 10:49:55","","4","2323","<p>I've stored <code>url</code> and a <code>token</code> in <code>state</code> in <code>Parent</code> component. I'm passing an <code>url</code> and a <code>token</code> as <code>props</code> from parent <code>Component</code> to child <code>Component</code>. However, if there is some event in parent <code>Component</code>, <code>setState()</code> is triggered and as a result, <code>componentDidUpdate()</code> of child <code>Component</code> gets executed.<br>
As <code>componentDidUpdate()</code> was causing an infinite loop <em>(as it triggers setState() inside child component)</em>, I've placed condition. But this does not prevent the error.<br>
Child Component ie <code>DisplayRevenue</code> is as follows:       </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import ListData from './listdata.js'
var axios = require('axios');

class DisplayRevenue extends Component {

  constructor(props){
    super(props);
    this.state = { data:[], url:"""" }
  console.log(this.props.url);
  }

  componentWillMount() {
    this.loadRevenue(this.props.url, this.props.token);
 }

  componentDidUpdate(){    //creates infinite loop
  //  console.log(this.props.url);
    this.loadRevenue(this.props.url, this.props.token);
  }

  setData(data){
    //if(this.state.url != this.props.url){
    if(this.state.data != data.data){
      console.log(data.data);                     //(1)
  //    console.log(this.state.url);              //(2)
      this.setState(data:data);             
      console.log(this.state.data);               //(3)
  //    console.log(this.props.url);              //(4)
    }     //(1) &amp; (3) yields exactly same value so does (2) &amp; (4)
  }

  loadRevenue(url,token){
    axios({
      method:'get',
      url:url,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
     .then( (response) =&gt; {
    //   console.log(response.data);
       this.setData(response.data);
     })
     .catch(function (error) {
       console.log(""Error in loading Revenue ""+error);
     });
  }

  render() {
    return (
      &lt;ListData data={this.state.data}/&gt;
    );
  }
};

export default DisplayRevenue;
</code></pre>

<p>Parent Component ie MonthToDate is as below:     </p>

<pre><code>import React, { Component } from 'react';
import '../App.css';
import DisplayRevenue from './displayRevenue'
var axios = require('axios');

class MonthToDate extends Component {

  constructor(props){
    super(props);
    this.state = {
      data:null,
      url:""http://localhost:3000/api/monthtodate""
    }
    //console.log(this.props.location.state.token);
  }

  groupBySelector(event){
    if ((event.target.value)===""invoice""){
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    } else if ((event.target.value)===""customer"") {
      this.setState({url:""http://localhost:3000/api/monthtodate?group-by=customerNumber""})
    } else if ((event.target.value)===""month"") {
      this.setState({url:""http://localhost:3000/api/invoices?group-by=month""})
    } else {
      this.setState({url:""http://localhost:3000/api/monthtodate""})
    }
    console.log(this.state.url);
  }

  render() {
    return (
      &lt;div&gt;
      &lt;select onChange={(event)=&gt;this.groupBySelector(event)}&gt;
        &lt;option value=""invoice""&gt;GROUP BY INVOICE&lt;/option&gt;
        &lt;option value=""customer""&gt;GROUP BY CUSTOMER&lt;/option&gt;
        &lt;option value=""month""&gt;GROUP BY MONTH&lt;/option&gt;
      &lt;/select&gt;
        &lt;DisplayRevenue url={this.state.url} token={this.props.location.state.token}/&gt;
      &lt;/div&gt;
    );
  }
}

export default MonthToDate;
</code></pre>

<ul>
<li>What am I missing?</li>
<li>Also, after I've received the <code>url</code> in the child component I want to render different component based on that <code>url</code>. For example <code>&lt;ListData /&gt;</code> component can handle only one type of <code>url</code>. How can I render another component within <code>render()</code> based on the <code>url</code> type??</li>
</ul>
","8494729","","1951708","","2017-09-13 10:54:07","2017-09-15 04:58:44","Why does componentDidUpdate() create an infinite loop?","<reactjs><ecmascript-6>","1","9","1","",""
"30769240","1","","","2015-06-10 23:48:23","","1","886","<p>In react, how do I do something if this.props have been loaded?? I tried componentDidUpdate to check to see if @props are different to prevProps but I found that they are always the same thing :-/</p>

<p>I want to call the function below when @props.account.subbableProperties is not blank.</p>

<pre><code>uiActions.curliesPropertyReplacement
  element: @textarea
  words: @props.account.subbableProperties
  _this: @
  replaceProperty: true
  selectOnTop: true
  maxCount: 3
  callback: (e, value, strategy) =&gt;
    @setState text:@textarea.text()
</code></pre>

<p>When I put the above function in componentDidMount, @props.account.subbableProperties is blank (hasn't yet loaded) so I can't put it there.</p>

<p>I tried using componentDidUpdate but for some reason this alert never triggers!</p>

<pre><code>componentDidUpdate (prevProps, prevState) -&gt;
 if !(_.isEqual(prevProps.account.subbableProperties, @props.account.subbableProperties))
     alert(""they do differ!"")
</code></pre>

<p>I also tried it in componentWillReceiveProps:</p>

<pre><code>  componentWillReceiveProps: (newProps) -&gt;
    console.log ""newProps"", newProps.account.subbableProperties
    console.log ""newProps"", newProps.account.subbableProperties.length
    console.log ""props"", @props.account.subbableProperties
    console.log ""props"", @props.account.subbableProperties.length

    if !(_.isEqual(newProps.account.subbableProperties, @props.account.subbableProperties))
      alert(""it happens in willReceiveProps!"")
</code></pre>

<p>It seems like newProps and @props update at the same time:
<img src=""https://i.stack.imgur.com/7qtKS.png"" alt=""Logs"">
What am I doing wrong?</p>
","4263123","","4263123","","2015-06-11 00:50:51","2015-06-11 00:56:50","React props not loaded in componentDidUpdate","<javascript><reactjs>","1","2","","",""
"47536736","1","","","2017-11-28 16:44:11","","1","82","<p>I have a react component that maps over an array of objects whose content is then displayed on screen. This works perfectly, however when I check the <code>ul</code> children in the <code>componentDidMount</code> lifecycle method it is an empty array, however, a second later it contains all the items. </p>

<p>Does anyone know how I can wait until everything has been rendered?</p>

<p>I have tried <code>componentDidUpdate</code> but as there is a <code>setInterval</code> method running regularly this is firing too often.</p>

<pre><code>componentDidMount() {
    // this is an empty array here
    console.log(this.items.children);

    setInterval(() =&gt; {
        this.setState((prevState) =&gt; {
            return {
                left:  prevState.left - 1
            };
        });
    }, 20);
}


render() {

    let items = this.props.itemss.map(item =&gt; {
        return (
            &lt;Item left={this.state.left} content={item.content} key={item.date} /&gt;
        );
    });

    return (
        &lt;div&gt;
            &lt;ul ref={(el) =&gt; { this.items = el; }} &gt;
                { items }
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}
</code></pre>
","4756106","","4756106","","2017-11-28 16:49:44","2017-11-28 17:20:59","wait until all elements in map function have been rendered react","<javascript><reactjs><ecmascript-6>","1","6","","",""
"47566695","1","47570395","","2017-11-30 05:49:48","","1","513","<p>i am using react-redux with react bootstrap table . my UI is given in picture . when i add payment the data is saved in database. i have used componentdidupdate and componentdidUpdate to render the props data . but nothing is working .  the table does not render the data without refresh . please help......................................................................................................</p>

<p><a href=""https://i.stack.imgur.com/7HWW7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7HWW7.png"" alt=""my UI ""></a></p>

<pre><code>import React from 'react';
import { connect } from 'react-redux';
// import {bindActionCreators} from 'redux'
import { Link } from 'react-router';
import Messages from '../Messages';
import classnames from 'classnames';
import { BootstrapTable, TableHeaderColumn } from 'react-bootstrap-table';
import { getCrmOneCustomer, saveStatus, getCrmStatus } from '../../actions/crmAction';
//--------------------------------------------------------------------------
class CrmStatus extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            name: '', shop_name: '', crm_id: '', status: ''
        };

        this.props.dispatch(getCrmOneCustomer(this.props.params.id));
        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
    }


    componentDidMount() {
         this.props.dispatch(getCrmStatus(this.props.params.id));

    }

    //--------------------------------------------------------------------------
    componentWillReceiveProps(newProps) {
        console.log('componentWillReceiveProps............ from edit');
        console.log(newProps)
        this.setState({
            name: newProps.CrmOne.name,
            shop_name: newProps.CrmOne.shop_name,
            status: newProps.CrmOne.status, 

        })
      }
    //--------------------------------------------------------------------------
    handleChange(event) {
        this.setState({
            [event.target.name]: event.target.value
        });
    }
    //--------------------------------------------------------------------------
    handleSubmit(event) {
        event.preventDefault();
        var Id = this.props.params.id;
        var obj = {};
        obj[""crm_id""] = Id
        obj[""name""] = this.state.name
        obj[""shop_name""] = this.state.shop_name
        obj[""status""] = this.state.status
        console.log(obj)

        this.props.dispatch(saveStatus(obj))
    }
    //--------------------------------------------------------------------------

    componentDidUpdate(){

        this.products = this.props.CrmOneStatus
    }

    render() {


        return (
            &lt;div className=""container ca-container""&gt;

                &lt;div className=""row""&gt;
                    &lt;div className=""col-md-12""&gt;
                    &lt;h2&gt;CRM Status&lt;/h2&gt;


                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=""row""&gt;
            &lt;div className=""col-md-12""&gt;

            &lt;div className =""col-md-8""&gt;
            &lt;BootstrapTable data={this.products} striped hover pagination={true} search&gt;
            &lt;TableHeaderColumn isKey dataField='name'&gt;Name&lt;/TableHeaderColumn&gt;
            &lt;TableHeaderColumn dataField='status'&gt;status&lt;/TableHeaderColumn&gt;
            &lt;TableHeaderColumn dataField='createdAt'&gt;Date&lt;/TableHeaderColumn&gt;
            &lt;/BootstrapTable&gt;
            &lt;/div&gt;
            &lt;div className =""col-md-4""&gt;
            &lt;h4&gt; Add Payment  &lt;/h4&gt;

            &lt;form onSubmit={this.handleSubmit} encType=""multipart/form-data""&gt;

            &lt;div className=""form-group""&gt;
                  &lt;label&gt;
                    Name:
               &lt;/label&gt;
                  &lt;input disabled type=""text"" className=""form-control"" name=""name"" value={this.state.name} onChange={this.handleChange} placeholder=""Zahid Hasan"" /&gt;
                &lt;/div&gt;
                &lt;div className=""form-group""&gt;
                  &lt;label&gt;
                  shop name:
                &lt;/label&gt;
                  &lt;input  type=""text"" className=""form-control"" name=""shop_name"" value={this.state.shop_name} onChange={this.handleChange} placeholder=""amount"" /&gt;
                &lt;/div&gt;

              &lt;div className=""form-group""&gt;
              &lt;label&gt;
              Status:
              &lt;/label&gt;
              &lt;textarea  rows=""8"" cols=""50""  type=""text"" className=""form-control"" name=""status"" value={this.state.status} onChange={this.handleChange} placeholder=""comment"" /&gt;
              &lt;/div&gt;
              &lt;div className=""btn-group"" role=""group""&gt;
              &lt;button type=""submit"" className=""btn btn-success btn-lg""&gt;Submit&lt;/button&gt;



             &lt;/div&gt;
             &lt;/form&gt;


             &lt;/div&gt;
             &lt;/div&gt;
             &lt;/div&gt;


            &lt;/div&gt;
        );
    }
}
// ======================== REDUX CONNECTORS ========================
const mapStateToProps = (state) =&gt; {
    return {
        CrmOne: state.crmCustomer.CrmOne,
        CrmOneStatus: state.crmCustomer.CrmOneStatus
    };
};

export default connect(mapStateToProps)(CrmStatus);
</code></pre>
","6741241","","","","","2017-11-30 09:50:49","react bootstrap table not rendering data without refresh","<reactjs><react-bootstrap-table>","2","5","1","",""
"47382591","1","","","2017-11-19 22:16:48","","1","304","<p>I have a react component that wraps a class that renders WebGL using three.js with the DOM and connects mobx store value and it changes with the class lifecycle methods.</p>

<p>The passed in mobx store is only used outside of the components render function in lifecycle functions <em>(componentDidMount,  componentDidUpdate, ..)</em>. Noticed that when the store changes, the component doesn't trigger a rerender. But I make a useless read within the render functions, such as in the example below passing a <code>triggerRerenderListenerProp={this.props.store.debugSettings.showStats}</code> prop to the div, the component becomes active only to <code>store.debugSettings.showStats</code> changes.</p>

<p><strong>Is there a way of making the component listen to store changes wihtout using the store itself in the render function?</strong></p>

<pre><code>import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {observer} from 'mobx-react';

import MapPreview from 'classes/MapPreview';

import style from './Preview.css';

class Preview extends Component {
  static propTypes = {
    store: PropTypes.object.isRequired,
    imageUrl: PropTypes.string.isRequired
  };

  constructor (props) {
    super(props);

    this.containerEl = null;
  }

  componentDidMount () {
    const options = {
      debugSettings: this.props.store.debugSettings,
      previewSettings: this.props.store.previewSettings
    };

    this.preview = new MapPreview(this.containerEl, options);
    this.preview.setImage(imageUrl);
  }

  componentDidUpdate () {
    this.preview.updateOptions({
      debugSettings: this.props.store.debugSettings,
      previewSettings: this.props.store.previewSettings
    });
  }

  render () {
    return (
      &lt;div
        className={style.normal}
        ref={(el) =&gt; { this.containerEl = el; }}
        triggerRerenderListenerProp={this.props.store.debugSettings.showStats}
      /&gt;
    );
  }
}

export default observer(Preview);
</code></pre>
","1378261","","","","","2017-11-20 16:24:36","Using mobx store only outside of the react components render function","<javascript><reactjs><mobx><mobx-react><mobx-state-tree>","1","0","","",""
"46629977","1","","","2017-10-08 10:18:28","","1","221","<p>How do you add components such as charts in google trends in reactjs?</p>

<pre><code>componentDidUpdate() {
    const that = this
    const keyword = ""your keyword""

    conts script = document.createElement(""script"")
    script.src = ""https://ssl.gstatic.com/trends_nrtr/760_RC08/embed_loader.js""
    script.async = true

    ReactDOM.findDOMNode(this.refs.trendsWrapper1).appendChild(script)

    script.onload = function () {
       trends.embed.renderExploreWidgetTo(ReactDOM.findDOMNode(that.refs.trendsWrapper1), ""TIMESERIES"", {""comparisonItem"":[{""keyword"":keyword,""geo"":"""",""time"":""today 5-y""}],""category"":0,""property"":""""}, {""exploreQuery"":""q=%2Fm%2F0rfgxy2"",""guestPath"":""https://www.google.co.uk:443/trends/embed/""})
    }

}
</code></pre>

<p>I tried this and didn't work. Please try to suggest a much easier method than this as well.</p>
","6208328","","7248342","","2017-10-08 10:24:20","2018-01-23 07:22:13","Add google trends in react","<reactjs><google-trends>","1","0","","",""
"46722599","1","","","2017-10-13 04:36:15","","0","82","<p>I am creating interview form using <code>reactjs</code>, in which I am using the route to accessing different links. I am using <code>firebase</code> for storing the data.</p>

<p><a href=""https://i.stack.imgur.com/LxCga.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LxCga.png"" alt=""enter image description here""></a></p>

<pre class=""lang-js prettyprint-override""><code> class Contact extends React.Component {
          constructor() {
            super();
            this.state = {
              arr: [],
              records:[],
              Address:'',
              printabledata:[],
              singledata:{},
              date:'',
              iround:''

            };
            self = this;
              this.printAllRecord = this.printAllRecord.bind(this);
              this.filterByInterviewer = this.filterByInterviewer.bind(this);
              this.filterByDate = this.filterByDate.bind(this);
              this.handleChangedate = this.handleChangedate.bind(this);
              this.handleChangeiround = this.handleChangeiround.bind(this);
                      }
                       handleChangedate(event) {
                          this.setState({date: event.target.value.toUpperCase()});
                        }
                         handleChangeiround(event) {
                          this.setState({iround: event.target.value});
                        }


          componentWillMount() {  
          var formdata2 = firebase.database().ref(""vishal-aaede/"");
            formdata2.on(""value"", function (snap) {
                data = snap.val();
                self.setState({arr: data});
            });
          }

          componentDidUpdate(){
            var data=this.state.arr,
              headerArray=[];
              for (var key in data){
                headerArray.push(key);
              }console.log(headerArray);


           headerArray.forEach(function(val){
            self.printAllRecord(data[val]);
            self.state.records.push(data[val]);
              console.log(data[val].Address);
           });
           self.state.singledata=data[headerArray[0]];       
          }
          printAllRecord(param,index) {         
            self.state.printabledata.push(&lt;tr&gt;
              &lt;td&gt;{param.Name}&lt;/td&gt;
              &lt;td&gt;{param.Round}&lt;/td&gt;
              &lt;td&gt;{param.Email}&lt;/td&gt;
              &lt;td&gt;{param.Date}&lt;/td&gt;
              &lt;td&gt;{param.Phone}&lt;/td&gt;
              &lt;td&gt;{param.Address}&lt;/td&gt;
              &lt;td&gt;{param.Gender}&lt;/td&gt;
              &lt;td&gt;{param.Fresh}&lt;/td&gt;
              &lt;td&gt;{param.time}&lt;/td&gt;
            &lt;/tr&gt;);     
          }
        filterByInterviewer(){
           self.state.records.forEach(function(val){
           if(val.Round==self.state.iround){
             self.printAllRecord(val);
             console.log(val.Round+"" - ""+val.Name);
           }
         });
        }
        filterByDate(){
         self.state.records.forEach(function(val){
           if(val.Date==self.state.date){
             self.printAllRecord(val);
             console.log(val.Date+"" - ""+val.Name);
           }
         });
        }
           render() {
               return (
                 &lt;div&gt;
                   &lt;h2&gt;Candidate RECORD !!!!&lt;/h2&gt;
                   &lt;div&gt;
                      &lt;div&gt;
                        &lt;div className = ""container""&gt;
                          &lt;form classNameName = ""form-horizontal"" name = ""record_form"" id = ""record_form""&gt;            
                            &lt;div className = ""form-group row""&gt;
                              &lt;label className = ""control-label col-lg-4"" htmlFor = ""filterdatetxt""&gt;Date:&lt;/label&gt;
                              &lt;div className = ""col-lg-5""&gt;
                              &lt;input type = ""date"" className = ""form-control"" ref = ""filterdatetxt"" name = ""filterdatetxt"" id = ""filterdatetxt"" placeholder = ""Enter Date"" onChange={this.handleChangedate} /&gt;
                              &lt;/div&gt;
                             &lt;div className = ""col-lg-3""&gt;
                              &lt;button name = ""filter_date_btn"" id = ""filter_date_btn"" type = ""button"" className = ""btn btn-danger"" onClick={this.filterByDate}&gt;Filter By Date&lt;/button&gt;
                             &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className = ""form-group row""&gt;
                              &lt;label className = ""control-label col-lg-4"" htmlFor = ""interview_round""&gt;Feedback By Interviewer:&lt;/label&gt;
                              &lt;div className = ""col-lg-5""&gt;
                              &lt;select className = ""form-control"" ref = ""interview_round"" onChange={this.handleChangeiround} id = ""interview_round"" name = ""interview_round""  &gt;
                                &lt;option value = ""1""&gt;Select Round&lt;/option&gt;
                                     &lt;option value = ""HR""&gt;HR&lt;/option&gt;
                                     &lt;option value = ""TR""&gt;Technical Round&lt;/option&gt;
                                     &lt;option value = ""FR""&gt;Final Round&lt;/option&gt;
                              &lt;/select&gt;
                              &lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;
                              &lt;button name = ""filter_date_btn"" id = ""filter_date_btn"" type = ""button"" className = ""btn btn-danger""  onClick={this.filterByInterviewer} &gt;Filter By Interviewer&lt;/button&gt;
                            &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className = ""row""&gt;
                            &lt;div className = ""col-lg-3""&gt;&lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;

                            &lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;
                            &lt;Link to=""/contact""&gt;
                              &lt;button name = ""view_all_btn"" id = ""view_all_btn"" type = ""button"" className = ""btn btn-danger""  &gt;View All Record&lt;/button&gt;
                              &lt;/Link&gt;
                            &lt;/div&gt;
                            &lt;div className = ""col-lg-3""&gt;
                               &lt;IndexLink to=""/"" activeClassName=""active""&gt;
                              &lt;button name = ""back_btn"" id = ""back_btn"" type = ""button"" className = ""btn btn-danger"" &gt;Go Back&lt;/button&gt;
                              &lt;/IndexLink&gt;
                            &lt;/div&gt;
                            &lt;/div&gt;
                          &lt;/form&gt;
                          &lt;div className=""blank_div""&gt;&lt;/div&gt;
                        &lt;/div&gt;        
                      &lt;/div&gt;
                      &lt;div className=""row""&gt; 

                        &lt;div className=""col-sm-12""&gt;
                          &lt;div className = ""container-fluid table-responsive""&gt;            
                            &lt;table className = ""table table-bordered""&gt;
                              &lt;thead&gt;
                                &lt;tr&gt;
                                 &lt;th&gt;Name&lt;/th&gt;
                                 &lt;th&gt;Interview Round&lt;/th&gt;
                                 &lt;th&gt;Email&lt;/th&gt;
                                 &lt;th&gt;Date&lt;/th&gt;
                                 &lt;th&gt;Phone Number&lt;/th&gt;
                                 &lt;th&gt;Address&lt;/th&gt;
                                 &lt;th&gt;Gender&lt;/th&gt;  
                                 &lt;th&gt;Experience&lt;/th&gt;
                                 &lt;th&gt;Time&lt;/th&gt;
                               &lt;/tr&gt;
                              &lt;/thead&gt;
                             &lt;tbody&gt;
                              {this.state.printabledata}
                             &lt;/tbody&gt;
                          &lt;/table&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;

                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
               )
             }
            }
</code></pre>

<p>Here is the image in which you can see the users data. When users fill the interview form and submit the data that data go to firebase I fetch that data in the table.</p>

<p>So here 2 filter buttons. The main issue is that when I click on the date that time data filter and print all data on that date. Same for interviewer round.</p>

<p>I do all thing and all filter data are so on console but I want it to on my table</p>
","8740191","","534943","","2017-10-13 06:18:48","2017-10-13 06:18:48","Print the filter data by data and interviewer in table using reactjs?","<javascript><reactjs><firebase-database>","1","0","","",""
"47616124","1","47616244","","2017-12-03 07:07:04","","0","190","<p>I'm trying to trigger a redirect if a user is logged in. A successful login triggers an update of this.state.user so I'd like to handle the redirect in componentDidUpdate() or another lifecycle method.</p>

<p>The if statement is getting called when I intend for it to, but the redirect does nothing. Any idea as to how I can fix this? I just want this to update the url so it doesn't necessarily need to use Redirect.</p>

<p>I'm not using user authentication currently and don't intend to add it yet.</p>

<pre><code>import React, { Component } from ""react"";
import ""./App.css"";

import { BrowserRouter as Router, Route, Redirect } from ""react-router-dom"";
import AuthContainer from ""./components/AuthContainer"";
import ChatSelector from ""./components/ChatSelector"";
import { debug } from ""util"";
// import ChatRoomContainer from './components/ChatRoomContainer';

class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      user: {}
    };
  }

  setUser = user =&gt; {
    console.log(""setting user"");
    this.setState({ user });
  };

  componentDidUpdate() {
    // if a user is logged in, redirect them to chat-selector
    if (Object.keys(this.state.user).length &gt; 0) {
      console.log(this.state.user);
      &lt;Router&gt;
        &lt;Redirect to=""/chat-selector"" /&gt;;
      &lt;/Router&gt;;
    }
  }

  render() {
    return (
      &lt;Router&gt;
        &lt;div&gt;
          &lt;Route
            exact
            path=""/""
            render={props =&gt; (
              &lt;AuthContainer {...props} setUser={this.setUser} /&gt;
            )}
          /&gt;
          &lt;Route
            exact
            path=""/chat-selector""
            render={props =&gt; &lt;ChatSelector {...props} user={this.state.user} /&gt;}
          /&gt;
          {/* &lt;Route exact path='/chatroom' component={ChatRoomContainer}/&gt; */}
        &lt;/div&gt;
      &lt;/Router&gt;
    );
  }
}

export default App;
</code></pre>
","8985352","","","","","2018-03-29 08:51:35","React Router (v4) not redirecting in componentDidUpdate()","<reactjs><redirect>","2","2","1","",""
"39626921","1","39679672","","2016-09-21 21:33:16","","8","425","<p>I'm using react-three-renderer (<a href=""https://www.npmjs.com/package/react-three-renderer"">npm</a>, <a href=""https://github.com/toxicFork/react-three-renderer"">github</a>) for building a scene with <a href=""http://threejs.org/"">three.js</a>.</p>

<p>I'm having a problem that I've boiled down to an MVCE. Refs aren't updating in the sequence I expect them to. First, here's the main code to look at:</p>

<pre><code>var React = require('react');
var React3 = require('react-three-renderer');
var THREE = require('three');
var ReactDOM = require('react-dom');

class Simple extends React.Component {
  constructor(props, context) {
    super(props, context);

    // construct the position vector here, because if we use 'new' within render,
    // React will think that things have changed when they have not.
    this.cameraPosition = new THREE.Vector3(0, 0, 5);

    this.state = {
      shape: 'box'
    };

    this.toggleShape = this.toggleShape.bind(this);
  }

  toggleShape() {
    if(this.state.shape === 'box') {
      this.setState({ shape: 'circle' });
    } else {
      this.setState({ shape: 'box' });
    }
  }

  renderShape() {
    if(this.state.shape === 'box') {
      return &lt;mesh&gt;
        &lt;boxGeometry
          width={1}
          height={1}
          depth={1}
          name='box'
          ref={
            (shape) =&gt; {
              this.shape = shape;
              console.log('box ref ' + shape);
            }
          }
        /&gt;
        &lt;meshBasicMaterial
          color={0x00ff00}
        /&gt;
      &lt;/mesh&gt;;
    } else {
      return &lt;mesh&gt;
        &lt;circleGeometry
          radius={2}
          segments={50}
          name='circle'
          ref={
            (shape) =&gt; {
              this.shape = shape;
              console.log('circle ref ' + shape);
            }
          }
        /&gt;
        &lt;meshBasicMaterial
          color={0x0000ff}
        /&gt;
      &lt;/mesh&gt;
    }
  }

  componentDidUpdate() {
    console.log('componentDidUpdate: the active shape is ' + this.shape.name);
  }

  render() {
    const width = window.innerWidth; // canvas width
    const height = window.innerHeight; // canvas height

    var position = new THREE.Vector3(0, 0, 10);
    var scale = new THREE.Vector3(100,50,1);

    var shape = this.renderShape();

    return (&lt;div&gt;
        &lt;button onClick={this.toggleShape}&gt;Toggle Shape&lt;/button&gt;
        &lt;React3
          mainCamera=""camera""
          width={width}
          height={height}
          onAnimate={this._onAnimate}&gt;
          &lt;scene&gt;
            &lt;perspectiveCamera
              name=""camera""
              fov={75}
              aspect={width / height}
              near={0.1}
              far={1000}
              position={this.cameraPosition}/&gt;
            {shape}
          &lt;/scene&gt;
        &lt;/React3&gt;
    &lt;/div&gt;);
  }
}

ReactDOM.render(&lt;Simple/&gt;, document.querySelector('.root-anchor'));
</code></pre>

<p>This renders a basic scene with a green box, a fork of the example on react-three-renderer's github landing page. The button on the top left toggles the shape in the scene to be a blue circle, and if clicked again, back to the green box. I'm doing some logging in the ref callbacks and in <code>componentDidUpdate</code>. Here's where the core of the problem I'm encountering occurs. After clicking the toggle button for the first time, I expect the ref for the shape to be pointing to the circle. But as you can see from the logging, in <code>componentDidUpdate</code> the ref is still pointing to the box:</p>

<blockquote>
  <p>componentDidUpdate: the active shape is box</p>
</blockquote>

<p>Logging in lines after that reveals the ref callbacks are hit</p>

<blockquote>
  <p>box ref null [React calls null on the old ref to prevent memory leaks]</p>
  
  <p>circle ref [object Object]</p>
</blockquote>

<p>You can drop breakpoints in to verify and to inspect. I would expect these two things to happen before we enter <code>componentDidUpdate</code>, but as you can see, it's happening in reverse. Why is this? Is there an underlying issue in react-three-renderer (if so, can you diagnose it?), or am I misunderstanding React refs?</p>

<p>The MVCE is available in <a href=""https://github.com/ParagonTruss/Refs-Availability-Test"">this github repository</a>. Download it, run <code>npm install</code>, and open _dev/public/home.html.</p>

<p>Thanks in advance.</p>
","4046605","","","","","2016-09-24 18:32:22","React-Three-Renderer refs not current in componentDidUpdate (MVCE included)","<javascript><reactjs><lifecycle><refs>","1","1","","",""
"48023263","1","48031465","","2017-12-29 13:20:56","","1","135","<p>I'm trying to learn react router (v4) in depth by building a simple app with firebase, what i am doing is when a user login with google using firebase they will be redirected to another component and when they go to the root path again '/' they will no longer see the login ( i am doing this by redirecting based on state )</p>

<p>I have two problems</p>

<p>My first problem is on successful authentication the user will be redirected to the /dashboard as expected but if i go back or type the root path again the login page will be shown briefly and then redirect.. i think because my method is not fast enough which is the <code>componentWillMount();</code></p>

<p>My second problem is i want to pass in some props to the dashboard but i don't know how, i've been looking and searching in the internet but i have no idea how to implement it... </p>

<p>this is my login.js, i want to pass the currentUser to dashboard and also when user goes back to the login path and if they are logged in i want to redirect them fast enough without showing the login page...</p>

<pre><code>  state = {
        currentUser: null,
        successLogin: false
    }

    googleAuth = () =&gt; {
        auth.signInWithPopup(provider).then(response =&gt; {
            const token = response.credential.accessToken;
            const currentUser = response.user;
        }).catch(error =&gt; {
            console.log(error.code , 'occured');
        })
    }

    // firebase.auth().signInWithPopup(provider).then(function(result) {
    //   var token = result.credential.accessToken;
    //   var user = result.user;
    // }).catch(function(error) {
    //   var errorCode = error.code;
    //   var errorMessage = error.message;
    //   var email = error.email;
    //   var credential = error.credential;
    // });

    componentDidMount() {
        auth.onAuthStateChanged(user =&gt; {
            if(user) {
                console.log('a user was successfuly logged in')
                this.setState({
                    currentUser: user.displayName,
                    successLogin: true
                })
            } else {
                console.log('eerror')
            }
        })
    }

    componentDidUpdate() {
        if(this.state.successLogin){
            this.props.history.replace(""/dashboard"");
        } else {
            console.log('not a successful login');
        }
    }

    componentWillMount() {
        if(this.state.successLogin){
            &lt;Redirect to=""/dashboard""/&gt;
        }
    }
</code></pre>

<p>here is my dashboard im creating new state for the user since i don't know how to get the currentUser state from the login...</p>

<pre><code> state = {
        user: null
    }

    componentDidMount(){
       auth.onAuthStateChanged(user =&gt; {
            this.setState({
                user: user.displayName
            })
       })
    }
    render(){
        const { user } = this.state;
        return (
            &lt;h1&gt; DashBoard {user}&lt;/h1&gt;
            )
    }
}
</code></pre>

<p>this is my routes.js</p>

<pre><code>&lt;BrowserRouter&gt;
     &lt;div&gt;
          &lt;Switch&gt;
            &lt;Route path='/' exact component={Login} /&gt;
            &lt;Route path='/register' component={Register} /&gt; 
            &lt;Route path='/dashboard' component={MainDashBoard} /&gt;
          &lt;/Switch&gt;
      &lt;/div&gt;
&lt;/BrowserRouter&gt;
</code></pre>

<p>I know that i can use redux but i don't want to jump into redux yet....</p>
","4344549","","4387980","","2017-12-30 10:46:57","2017-12-30 10:46:57","How do I pass a prop into a react-router Route?","<reactjs><firebase><react-router><firebase-authentication><react-router-v4>","1","0","","",""
"31963803","1","31982979","","2015-08-12 11:23:24","","7","14200","<p>I am looking to add a timer to my app which is built using react native.</p>

<p>I have looked at the link to the <a href=""https://facebook.github.io/react-native/docs/timers.html#content"" rel=""noreferrer"">timer mixin</a> in the documentation however I have built the rest of the app using es6 so this won't be compatible.</p>

<p>I have tried the below.</p>

<p>In my Main class I have a function called <code>getTimerCountDown</code></p>

<pre><code>getTimerCountDown() {
    setTimeout(() =&gt; {
      this.setTimeRemaining(this.getTimeRem()-1);
    }, 1000);
}

getTimeRem() {
    return this.state.timeRemaining;
}
</code></pre>

<p>I have tried calling this in <code>componentDidUpdate</code> as shown below. This works as I want it to if I don't make any other interactions with the UI.</p>

<p>If I do (eg I have a button I can click on the view.) as `componentDidUpdate gets called again the conunter gets really quick (as it is getting called x number of times)</p>

<pre><code>componentDidUpdate(){
    this.getTimerCountDown();
}
</code></pre>

<p>I am not sure if I am completly on the wrong track here or a small change to what I have done can get me what I want.
What is the best way to get a countdown timer working in react native using es6?</p>

<p>Timer Class 
on main page</p>

<pre><code>&lt;Timer timeRem={this.getTimeRem()} /&gt;
</code></pre>

<p>returns</p>

<pre><code>render(){
    return (
        &lt;View style={styles.container}&gt;
            &lt;Text&gt; This is the Timer : {this.props.setTimer}  - {this.props.timeRem} &lt;/Text&gt;
        &lt;/View&gt;
    )
}
</code></pre>
","737114","","","","","2016-03-22 20:32:27","create timer with react native using es6","<javascript><ios><facebook><reactjs><react-native>","2","2","","",""
"48037387","1","","","2017-12-30 19:58:02","","0","266","<p>Hello I'm trying to learn react native from Stephen Grider's react-native course.I'm stuck to load data from my webservice and list them by using redux and lodash .I can successfully get data and can see it in render (console.log) ,and  but my props always is null  in componentDidUpdate or componentWillMount .
 Any help is appreciated,thanks.
Reducer is like this;</p>

<pre><code>    import { TEST_FETCH, TEST_LOAD } from ""../actions/types"";

const INITIAL_STATE = { dataSource: [] };

export default (state = INITIAL_STATE, action) =&gt; {
  switch (action.type) {
    case TEST_FETCH:
      return { ...state, loading: false, dataSource: action.payload.data };
    case TEST_LOAD:
      return { ...state, loading: true, error: """" };
    default:
      return state;
  }
};
</code></pre>

<p>and action is ;</p>

<pre><code>    import { TEST_LOAD, TEST_FETCH } from ""./types"";
export  const  getdata = ( ) =&gt; {
  return  dispatch =&gt; {
    dispatch({ type: TEST_LOAD });
     fetch(""http://myserver/getdata"", {
      method: ""GET"",
      headers: {
        Accept: ""application/json"",
        ""Content-Type"": ""application/json""
      }
    })
      .then(response =&gt; {
        return response.json();
      })
      .then(responseData =&gt; {
        return responseData;
      })

      .then(data =&gt; {
        // return data;
        dispatch({ type: TEST_FETCH, payload: data });
      });
  };
};
</code></pre>

<p>and page is ;</p>

<pre><code>       import _ from 'lodash';
    import React, { Component } from ""react"";
    import { View, Text, ListView } from ""react-native"";
    import { connect } from ""react-redux"";
    import { getdata } from ""../actions"";

    class testList extends Component {
      componentWillMount() {
       this.props.getdata();
      }
      componentDidMount() {
       console.log(this.props.myarray ); // myarray is empty
        this.createDataSource(this.props.myarray);
      }

      componentDidUpdate() {
       console.log(this.props.myarray ); // I tried this but still myarray is empty
        this.createDataSource(this.props.myarray);
      }
      createDataSource({ dtsource }) {
// sure dtsource is null too
         const ds = new ListView.DataSource({
          rowHasChanged: (r1, r2) =&gt; r1 !== r2});
         this.dataSource = ds.cloneWithRows(dtsource);
      }
      render() {
    console.log(this.props.myarray); // if I write here,I can see my json's output
        return &lt;View&gt;
            &lt;Text&gt;Employee List&lt;/Text&gt;
            &lt;ListView dataSource={this.props.myarray} renderRow={rowData =&gt; &lt;Text
                &gt;
                  {rowData}
                &lt;/Text&gt;} /&gt;
          &lt;/View&gt;;
      }
    }

    const mapStateToProps = state =&gt; {
      const myarray= _.map(state.testForm.dataSource, function(v) {
        return { ...v };
      });
          return { myarray};
    };
    export default connect(mapStateToProps , { getdata })(testList);
</code></pre>
","69963","","69963","","2017-12-30 20:41:24","2017-12-30 21:38:30","Fetch data is empty in componentwillMount in react native redux","<react-native><react-redux>","1","7","","",""
"46305768","1","","","2017-09-19 16:44:59","","0","145","<p>First of all, I would like to provide a gif animation and description of the goal.<br>
<a href=""https://i.stack.imgur.com/TvWMu.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TvWMu.gif"" alt=""enter image description here""></a></p>

<p>I'd like to see elements running their own animation when the user enters or leaves particular page. For example, some elements on the page may come from the right side and some from the left side, when the user leaves page - their position would be transitioned in reverse direction.</p>

<p>In other words - flow could look like this:</p>

<ol>
<li>User enters page</li>
<li>Elements animation runs.</li>
<li>Animation finished.</li>
<li>User clicks some link which leads to another page.</li>
<li>Specific ""onLeave"" animation runs for each particular element.</li>
<li>When animation is over - user gets navigated to desired location described in the link.</li>
</ol>

<p>Source: <a href=""https://github.com/eko24ive/react-router-animate-childrens"" rel=""nofollow noreferrer"">react-router-animate-childrens</a><br>
Demo: <a href=""https://eko24ive.github.io/react-router-animate-childrens/"" rel=""nofollow noreferrer"">https://eko24ive.github.io/react-router-animate-childrens/</a></p>

<p>For gif demonstration example I've created two dummy pages. react-router v4 is for routing, react-motion take care of animations. I was wondering if there was any way to run these animations by the means of react router.</p>

<p>According to their <a href=""https://github.com/ReactTraining/react-router/blob/c60af989573d023b58311c3ab1153043de3efe9f/packages/react-router/docs/guides/migrating.md#on-properties"" rel=""nofollow noreferrer"">documentation</a> regarding events for entering/leaving page was available for v3 as <code>onEnter</code> and <code>onLeave</code>. For v4 they say:</p>

<blockquote>
  <p>With v4, you should use the lifecycle methods of the component rendered by a <code>&lt;Route&gt;</code>. Instead of <code>onEnter</code>, you would use componentDidMount or componentWillMount. Where you would use <code>onUpdate</code>, you can use <code>componentDidUpdate</code> or <code>componentWillUpdate</code> (or possibly <code>componentWillReceiveProps</code>). <code>onLeave</code> can be replaced with <code>componentWillUnmount</code>.</p>
</blockquote>

<p>I've tried that, but react life-cycle methods don't provide any ability to postpone/prevent component mount/unmount even with help of react-router.</p>

<p>Furtherly searching through my issue I've discovered that it is possible to block <code>history</code> of react-router which results in preventing component unmount. One of unpleasant side effects - it prompt confirmation message for user (asking if user wants to leave currently opened page), so I've tried to search something on customizing prompt message and found this <a href=""https://github.com/ReactTraining/react-router/issues/4635"" rel=""nofollow noreferrer"">issue</a> where collaborator of react-router <a href=""https://github.com/ReactTraining/react-router/issues/4635#issuecomment-287197704"" rel=""nofollow noreferrer"">posted</a> link to codepen demonstrating ability to <a href=""http://codepen.io/pshrmn/pen/MpOpEY"" rel=""nofollow noreferrer"">change prompt message</a>.</p>

<p>So using codepen example code, I've modified custom <code>&lt;Prompt/&gt;</code> element to make it hidden and fire callback to accept location change with the timeout of few milliseconds. In my code I'm using state with boolean flag <code>willUnmount</code> to decide should Page run animation for it's childrens in forward or in reverse. This state of page changed right before creating timeout for Prompt component via custom event. </p>

<p>And the problem is - when I navigate through this two pages several times I get this error:
<code>
Warning: setState(...): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the SubPage component.
</code></p>

<p>At this point - whatever I tried to fix this I couldn't succeed further. So my question is what I'm doing in this case or maybe there is another way to achieve such animations ?</p>

<p>Many thanks in advance !</p>
","3472702","","","","","2017-09-19 16:44:59","Animate children components of page with react-router v4","<reactjs><animation><react-router-v4><react-motion>","0","0","","",""
"38928525","1","38928560","","2016-08-13 02:08:22","","1","175","<p>Given this component : </p>

<pre><code>import React, { Component } from 'react';
import TrackerReact from 'meteor/ultimatejs:tracker-react';

export default class SubscriptionView extends TrackerReact(Component) {

  constructor(props) {
    super(props);

    let params = props.params || [];

    if (!Array.isArray(params)) {
      params = [params];
    }

    this.state = {
      subscription: {
        collection: Meteor.subscribe(props.subscription, ...params)
      }
    };
  }

  componentWillUnmount() {
    this.state.subscription.collection.stop();
  }


  render() {
    let loaded = this.state.subscription.collection.ready();

    if (!loaded) {
      return (
        &lt;section className=""subscription-view""&gt;
          &lt;h3&gt;Loading...&lt;/h3&gt;
        &lt;/section&gt;
      );
    }

    return (
      &lt;section className=""subscription-view""&gt;
        { this.props.children }
      &lt;/section&gt;
    );
  }
};
</code></pre>

<p>And another component :</p>

<pre><code>import SubscriptionView from './SubscriptionView.jsx';

export const Foo = () =&gt; (
  &lt;SubscriptionView subscription=""allFoo""&gt;
    &lt;SubscriptionView subscription=""singleBar"" params={ 123 }&gt;
      &lt;div&gt;Rendered!&lt;/div&gt;
    &lt;/SubscriptionView&gt;
  &lt;/SubscriptionView&gt;
);
</code></pre>

<p>The first <code>Subscription</code> is re-rendered when the data is available, however the second one is rendered only once and nothing more. If I place a <code>console.log(this.props.subscription, ready);</code> inside the render function of <code>SubscriptionView</code>, I see</p>

<pre><code>allFoo false
allFoo true
singleBar false
</code></pre>

<p>and that's it.</p>

<p>On the server side, both publish methods are</p>

<pre><code>Meteor.publish('allFoo', function () {
  console.log(""Subscribing foos"");
  return Foos.find();
});

Meteor.publish('singleBar', function (id) {
  console.log(""Subscribing bar"", id);
  return Bars.find({ _id: id });
});
</code></pre>

<p>Both of the publish methods are being called.</p>

<p>Why isn't the second <code>SubscriptionView</code> reactive?</p>

<hr>

<h3><strong>* Solution *</strong></h3>

<p>This is based on <a href=""https://stackoverflow.com/questions/38928525/react-does-not-render-recursive-reactive-components/38928560?noredirect=1#comment65214011_38928560"">alexi2</a>'s comment :</p>

<pre><code>import React, { Component } from 'react';
import TrackerReact from 'meteor/ultimatejs:tracker-react';

export default class SubscriptionLoader extends TrackerReact(Component) {

  constructor(props) {
    super(props);

    let params = props.params || [];

    if (!Array.isArray(params)) {
      params = [params];
    }

    this.state = {
      done: false,
      subscription: {
        collection: Meteor.subscribe(props.subscription, ...params)
      }
    };
  }

  componentWillUnmount() {
    this.state.subscription.collection.stop();
  }

  componentDidUpdate() {
    if (!this.state.done) {
      this.setState({ done: true });

      this.props.onReady &amp;&amp; this.props.onReady();
    }
  }


  render() {
    let loaded = this.state.subscription.collection.ready();

    if (!loaded) {
      return (
        &lt;div&gt;Loading...&lt;/div&gt;
      );
    }

    return null;
  }
};
</code></pre>

<p>Then, inside the parent component's <code>render</code> method :</p>

<pre><code>&lt;section className=""inventory-item-view""&gt;
  &lt;SubscriptionLoader subscription='singleBar' params={ this.props.id } onReady={ this.setReady.bind(this, 'barReady') } /&gt;
  &lt;SubscriptionLoader subscription='allFoos' onReady={ this.setReady.bind(this, 'foosReady') } /&gt;
  { content }
&lt;/section&gt;
</code></pre>

<p>Where <code>setReady</code> merely sets the component's state, and <code>content</code> has a value only if <code>this.state.barReady &amp;&amp; this.state.foosReady</code> is true.</p>

<p>It works!</p>
","320700","","-1","","2017-05-23 11:44:24","2016-08-13 03:36:22","React does not render recursive reactive components","<javascript><reactjs><ecmascript-6>","1","0","","",""
"47213527","1","","","2017-11-09 23:45:55","","0","25","<p>I'm trying to use React Virtualized Select <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> for drop down and my react component code is here We are not able to select the option from drop down</p>

<p>this is before selecting the option 
<a href=""https://i.stack.imgur.com/KvPqD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KvPqD.png"" alt=""enter image description here""></a></p>

<p>this is after selecting the option 
<a href=""https://i.stack.imgur.com/ZIMG8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZIMG8.png"" alt=""enter image description here""></a></p>

<p>please find my react component code below</p>

<pre><code>var React = require('react');
var ReactDOM = require('react-dom');
var SearchActions = require('../actions/SearchActions');
var AppStore = require('../stores/AppStore');
var AppActions = require('../actions/AppActions');
var Utils = require('../utils/Utils');
var SearchAccountSelector = require('./SearchAccountSelector');
var queryString = require('query-string');
var SearchHint = require('./SearchHint');
var VirtualizedSelect = require('react-virtualized-select').default;
module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: [],
            selectedPartner: null

        };
    },

    componentDidMount () {
        let self = this;
        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
        var qS = queryString.parse(location.search);
        AppActions.getPartnersAllowed();
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

    },
    componentDidUpdate: function () {
        let self = this;
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

    [AppStore.events.onSecurityCheck] () {
        console.log('onSecurityCheck', arguments);
        this.setState(function (prev, cur) {
            var st = {
                authenticated: AppStore.authenticated
            };
            if (!AppStore.authenticated) {
                st.async = false;
            }
            return st;
        });
    },

    [AppStore.events.onAccountSearch] (data) {

        var accountsNum = data.errorMessage ? 0 : this.numberOfAccountsFound(data);
        var state = {
            async: false,
            data: data.errorMessage ? {} : data,
            showAccountSelection: false,
            selected: null,
            error: null
        };
        console.log('[' + accountsNum + '] accounts found when search completed', data);

        if (accountsNum == 0) {
            state.error = data.errorMessage ? data.errorMessage : 'No accounts found';

        } else if (accountsNum == 1) {
            // if there is single account found selecting it and closing search panel
            state.selected = this.getFirstKey(data);
            state.visible = false;
            AppActions.selectAccount(state.selected);// auto select account if there is no ambiguites
            SearchActions.cDVR({query: state.selected});
        } else {
            // if multiple account found lets user select a correct one
            state.showAccountSelection = true;

        }

        this.setState(state);
    },

    [AppStore.events.onSelectAccount]() {
        if (AppStore.isValidUserProfile()) {
            this.setState({
                visible: false
            });
        }
    },

    [AppStore.events.onLogin]() {
        //Handling properly case when session is timed out so user will return to previos screen
        if (!this.state.selected) {
            this.setState({
                visible: true
            });
        }
    },

    [AppStore.events.onLogout](event) {
        if(!event || !event.byTimeout){
            this.setState({   data: null,
                showAccountSelection: false,
                selected: null,
                search: ''
            });
        }
    },
    [AppStore.events.onResized](windowSize){
        this.setState({width: windowSize.innerWidth, height: innerHeight})
    },


    numberOfAccountsFound(data) {
        var size = 0, key;
        if (!data) {
            return size;
        }
        for (key in data) {
            if (data.hasOwnProperty(key)) size++;
        }
        return size;
    },

    getFirstKey(data){
        for (let key in data) {
            if (data.hasOwnProperty(key)) return key;
        }
    },

    handleClick(event) {
        event.preventDefault();
        this.refs.searchHint.removePopover();
        console.log('clicked event', event);
        this.setState({
                data: null,
                async: true,
                error: null
            }
        );
        var query = this.refs.inputSearch.value.trim();
        this.setState({search: query});
        if (query &amp;&amp; this.state.selectedPartner) {
            //extract receiver Id from Recording Id, by extracting string between V&amp;L or A&amp;L
            let selectedPartner = this.state.selectedPartner;
            AppActions.resetFieldsForNewSearch();
            var receiverIdPattern = new RegExp('(V|A)(.*?)L');
            var parsedReceiverId = receiverIdPattern.exec(query);
            if (parsedReceiverId != null &amp;&amp; parsedReceiverId[2] != null) {
                let receiverId = parsedReceiverId[2];
                AppActions.setSearchQuery(query);
                //use receiverId to perform search
                query = receiverId;
            } else {
                AppActions.clearRecIdSearch();
            }
            SearchActions.cDVR({query: query});
            AppStore.selectedPartner = selectedPartner.value;
            SearchActions.search({query: query, selectedPartner: selectedPartner.value});
            Utils.updateQueryString('search', query);
        } else {
            this.setState({async: false, error: 'Invalid Input'});
        }
    },

    openNav(){
        this.setState({visible: true});
        AppActions.hideBodyScrollBar();
    },
    closeNav(){
        this.refs.searchHint.refs.popover.close();
        this.setState({visible: false});
        AppActions.showBodyScrollBar();
    },

    searchIcon(){
        if (this.state.authenticated) {
            return (&lt;span id=""search"" onClick={this.openNav}&gt;&lt;i className=""fa fa-search search-icon pointer"" style={{fontSize: '1.4em'}}/&gt;&lt;/span&gt;);
        }
    },

    setPartnerList(partnerList) {
        let partnerOptionsList = this.getOptions(partnerList);
        this.setState({optionPartnerList : partnerOptionsList})

    },

    getOptions(partnerList) {
        let options = partnerList.map( x =&gt; ({value :x,label: x}));
        return options;
    },

    errorRender() {
        let style = this.state.error ? {visibility: 'visible'} : {visibility: 'hidden'};
        return (
            &lt;div style={style} className=""alert alert-danger"" role=""alert""&gt;
                &lt;i className=""fa fa-exclamation-triangle""&gt;&lt;/i&gt; {this.state.error}
            &lt;/div&gt;);
    },

    toggleOverlayStyle(state){
        this.setState({overlayOverflowY : state});
    },
    [AppStore.events.onResized](windowSize) {
        let state = AppStore.innerHeight &lt; 900 &amp;&amp; this.refs.searchHint &amp;&amp; this.refs.searchHint.state.showSearchHint ? 'auto' : 'hidden';
        this.toggleOverlayStyle(state);
    },
    [AppStore.events.onPartnersAllowedUpdated](partnerList) {
        this.setPartnerList(partnerList);
    },

    render: function () {
        var self= this;


        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (
            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                        &lt;VirtualizedSelect
                            placeholder=""Select Partner""
                            options={self.state.optionPartnerList}
                            onChange={(selectValue) =&gt; this.setState({selectedPartner: selectValue})}
                            value={this.state.selectedPartner}
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
});
</code></pre>

<p>Except for the highlighted part i don't know what the issue is whether css or js 
<a href=""https://i.stack.imgur.com/CtSor.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CtSor.png"" alt=""enter image description here""></a></p>
","2359997","","2359997","","2017-11-10 14:26:41","2017-11-10 14:26:41","react-virtualized: Drop down is unresponsive suddenly with no error code in the console","<javascript><css><reactjs><react-native><react-redux>","0","0","","",""
"48070546","1","48120229","","2018-01-03 02:52:20","","1","112","<p>I have an app in React which uses material-ui's responsive drawer component. Let's call it ResponsiveDrawer. In this component I have a state variable called ""loading"".</p>

<pre><code>class ResponsiveDrawer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            loading:false
        }
        this.setLoading = this.setLoading.bind(this);
    }
    setLoading(loading) {
        this.setState({loading:loading});
    }
    ...
</code></pre>

<p>I want to display a LinearProgress component at the top of the page, depending on the <code>loading</code> state variable.</p>

<pre><code>    ...
    render() {
        return (
            &lt;div className={classes.root}&gt;
                {this.state.loading ? &lt;LinearProgress/&gt; : """"} 
                ...
</code></pre>

<p>Inside ResponsiveDrawer I am also using react router to render some child components.</p>

<pre><code>                ...
                &lt;main className={classes.content}&gt;
                    &lt;div className={classes.contentWrapper}&gt;
                        &lt;Switch&gt;
                            &lt;Route
                                exact
                                path=""/investments""
                                component={InvestmentsComponent}
                            /&gt;
                            ...
                        &lt;/Switch&gt;
                     &lt;/div&gt;
               &lt;/main&gt;
          &lt;/div&gt;
</code></pre>

<p>Inside Investments component, I am doing a fetch from an API.
What I would like to do, is to set the loading state in the ResponsiveDrawer component to <code>true</code> and then set it back to <code>false</code> upon successful fetch.</p>

<p>So I passed the setLoading function of the ResponsiveDrawer into InvestmentsComponent as props:</p>

<pre><code> InvestmentsComponent = &lt;Investments setLoading={this.setLoading} /&gt;
</code></pre>

<p>And then tried to set it to true on <code>componentDidMount()</code></p>

<pre><code>    componentDidMount() {
        this.props.setLoading(true);
        fetchInvestments(); // sets loading to false upon completion
    }

     fetchInvestments() {
        fetch(""/api/investments"", {
            credentials: ""same-origin"",
            headers: {
                ""Cache-Control"": ""no-cache""
            }
        })
            .then(res =&gt; {
                if (!res.ok) throw Error(res.status);
                return res.json();
            })
            .then(responseJson =&gt; {
                this.props.setLoading(false);
                this.setState({ investments: responseJson });
            })
            .catch(err =&gt; {
                console.error(""Unable to fetch investments""); // show error message
            });
    }
</code></pre>

<p>However, when I do this, react goes into infinite loop - I assume that when the state of <code>loading</code> changes, it also reloads the investments component route which then sets the loading state again.</p>

<p>I end up with:</p>

<blockquote>
  <p>Maximum update depth exceeded. This can happen when a component
  repeatedly calls setState inside componentWillUpdate or
  componentDidUpdate. React limits the number of nested updates to
  prevent infinite loops.</p>
</blockquote>

<p>What could be a potential solution to this conundrum?</p>
","903015","","903015","","2018-01-03 03:01:37","2018-01-05 19:39:20","Managing state for a loading bar in react with react-router","<javascript><reactjs><react-router><state><infinite-loop>","1","5","","",""
"39609325","1","39612226","","2016-09-21 06:50:22","","0","484","<p>hi guys im new in reactjs
i just want to know the react way, method/lifecycle that can render component (notification component) when ajax data result is different with previous state?</p>

<pre><code>var NewsList = React.createClass({
  getInitialState: function() {
    return ({
      data: [],
      showNotif: false,
      showLoading: false
    });
  },
  showNotification: function() {
    return (
      &lt;Notification msg=""new data"" /&gt;
    );
  },
  ajaxRequest: function() {
  //do ajax request, load the result to this.state.data
  },
  componentWillMount: function() {
    this.setState({showLoading: true});
  },
  componentDidMount: function() {
    this.ajaxRequest();
    setInterval(this.ajaxRequest, 2000);
  },
  componentDidUpdate: function(prevProps, prevState) {
    if (this.state.data != prevState.data) {
      //this.setState({showNotif: !this.state.showNotif});
    }
  },
  render: function() {
    var loadingElement, notifElement;
    if (this.state.showLoading) {
      loadingElement = &lt;Loader /&gt;
    }
    if(this.state.showNotif) {
      notifElement = this.showNotification();
    }
    return (
      &lt;div&gt;
        {notifElement}
        {loadingElement}
        &lt;NewsItem data={this.state.data} /&gt;
      &lt;/div&gt;
    );
});
</code></pre>

<p>so if you can see i expect the <code>ComponentDidUpdate</code> will read the changed state.data and if it's changed (meaning the ajax result has new updated), it will set <code>this.state.showNotif</code> to <code>true</code> and  render will call <code>showNotification()</code> but it's not (it's blinking, true-false set back and forth, so it's called many times)</p>

<p>what should i do to achieve it and make it right?</p>
","6856833","","6856833","","2016-09-21 07:04:09","2016-09-21 09:12:32","reactjs: how to detect data changed and show notification","<ajax><reactjs><notifications>","1","3","","",""
"31119786","1","31122169","","2015-06-29 15:34:22","","5","13301","<p>Where do I have to put the <code>window.scrollTo(0,0)</code> call in a react component?</p>

<p>I tried to put it directly into <code>render</code> and also tried <code>componentDidUpdate</code> (to wait till everything is rendered), but somehow the the scrollbars always stay at the same position.</p>

<p>-- Edit --</p>

<p>The problem was CSS height/overflow of the window and body.</p>

<p>See: <a href=""https://stackoverflow.com/a/18573599/1016383"">https://stackoverflow.com/a/18573599/1016383</a></p>
","1016383","","-1","","2017-05-23 12:32:29","2015-06-29 18:45:25","window.scrollTo() in react components?","<reactjs>","1","1","0","",""
"47865588","1","","","2017-12-18 09:41:04","","0","128","<p>I have this react component: <a href=""https://gist.github.com/emilevictor/007a10aa1669829feb940b9548e582a1"" rel=""nofollow noreferrer"">https://gist.github.com/emilevictor/007a10aa1669829feb940b9548e582a1</a></p>

<p>I shoot off a redux saga to go fetch some data from the server. It is successfully set in this.props.statistics, and a re-render is triggered. The functions are correctly called in the following order when the state is changed in redux:</p>

<p>componentWillUpdate(...)
render(...)
componentDidUpdate(...)</p>

<p>That having been said, the DOM doesn't change to reflect the new numbers in this.props.statistics. Does anyone know what might be going wrong?</p>
","462554","","","","","2017-12-18 09:50:08","componentWillUpdate() and componentDidUpdate() called with correct contents, render doesn't update","<reactjs><redux><react-redux>","1","0","","",""
"48639336","1","48639457","","2018-02-06 09:16:22","","-1","484","<p>I am using React's <code>componentDidUpdate</code> lifecycle method.</p>

<p>I am trying to determine whether or not two arrays are the same.</p>

<p>My <code>prevState</code> array looks like this:</p>

<pre><code>prevState.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>and the <code>this.state</code> array looks like this:</p>

<pre><code>this.state.players = [
  {
    name: 'Wayne Rooney',
    age: 31
  }, 
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];
</code></pre>

<p>As you can see if you expand the snippet below they are not equal:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let playersOne = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

let playersTwo = [{
    name: 'Wayne Rooney',
    age: 31
  },
  {
    name: 'Lionel Messi',
    age: 29
  },
  {
    name: 'Robbie Fowler',
    age: 42
  }
];

console.log(playersOne == playersTwo)</code></pre>
</div>
</div>
</p>

<p>And here is my react lifecycle code.</p>

<pre><code>  componentDidUpdate(prevProps, prevState) {
    if(prevState.players != this.state.players) {
      this.updatePlayers(this.state);
    }
  }
</code></pre>

<p>can anyone advise as to the best way to determine if the arrays are equal?</p>
","4756106","","","","","2018-02-06 09:26:46","check if two arrays contain identical objects - react componentDidUpdate","<javascript><reactjs><ecmascript-6>","4","5","","2018-02-06 09:24:27",""
"48641707","1","48642672","","2018-02-06 11:14:06","","0","66","<p>I am passing an event handler <code>showSpinner()</code> from parent component. This method displays the activity Indicator in my app, the method when called from the parent class, works. But when I pass it down to a child component and then call it from the child as <code>this.props.showSpinner()</code>, I am getting the error </p>

<pre><code>TypeError: undefined is not an object
(evaluating 'Object.keys(this.state.data)')
</code></pre>

<p>I am also not able to <code>console.log</code> the method at the child's props
Please note, I have already bound the function at the parent.</p>

<p>Here is a part of my code.
This is the parent component.</p>

<pre><code>import React from 'react';
import { View, Button, Alert, Image, ScrollView, BackHandler, TouchableOpacity,Text, ActivityIndicator } from 'react-native';
import ProductListingItem from '../ProductCategories/ProductListingItemCategories.js';
import PusherColumnCategories from '../ProductCategories/PusherColumnCategories.js';
import NavRightButton from '../NavButton/NavRightButton.js';
import ActivitySpinner from '../ActivitySpinner.js';

const TAG = 'PRODUCTCATEGORIESPAGE';
export default class ProductCategoriesPage extends React.Component {
  constructor(props) {
    super(props);
    /*this._getResponseFromApi = this._getResponseFromApi.bind(this);*/
    this._onPressGoToCart=this._onPressGoToCart.bind(this);
    if(props){
      /*console.log(TAG,'constructor()','props available');*/
      console.log(TAG,'constructor()','props JSON stringified = '+JSON.stringify(props));
      /*this.setState({dataMain : (props.navigation.state.params.categories)});*/
    }
    this.state = {
      dataMain: props.navigation.state.params.categories,
      showIndicator: false,
    };
    console.log(TAG,'constructor','this.state.dataMain = '+this.state.dataMain );

  }
  static navigationOptions = ({navigation}) =&gt; {
    return{
      title: 'Categories',
      headerLeft: null,
      headerStyle: {
        backgroundColor: '#EE162C',
      },
      /*headerBackTitleStyle: {
        color: 'white',
      },*/
      headerTintColor: 'white',
      headerRight: &lt;NavRightButton navigation= {navigation}/&gt;,
      gesturesEnabled:false,
    };
  };
  _onPressGoToCart(){
    console.log(TAG,'_onPressGoToCart');
    console.log(TAG,'_onPressGoToCart','navigation props ='+JSON.stringify(this.props));
    const { navigate } = this.props.navigation;
    navigate('CartPage');
  }
  componentWillReceiveProps(newProps){
    console.log(TAG+'componentWillReceiveProps');
    if(newProps){
      console.log(TAG,'componentWillReceiveProps()','props available');
      console.log(TAG,'componentWillReceiveProps()','props = '+newProps.navigation.state.params.categories);
    }
  }
  _OnAlert(title,message){
    console.log(TAG,'_onAlert');
    Alert.alert(
      title,
      message,
      [
        {text:'done',onPress: () =&gt; { }}
      ]
    );
  }
  componentDidMount () {
    console.log(TAG,'componentDidMount');
    /*this._getResponseFromApi();*/
    BackHandler.addEventListener('hardwareBackPress',() =&gt; {return true});
  }
  componentWillMount () {
    console.log(TAG,'componentWillMount');
  }
  _showSpinner(){
    console.log(TAG,'_showSpinner');
    this.setState({
      showIndicator:true,
    });
  }
   _hideSpinner(){
   console.log(TAG,'_hideSpinner');
    this.setState({
      showIndicator:false,
    });
  }
  render(){
    console.log(TAG,'render');
    console.log(TAG,'render','dataMain = '+this.state.dataMain[0].id);
    // console.log(TAG,'render','showSpinner = '+JSON.stringify(this.showSpinner()));
    // var tempshowspinner = this.showSpinner.bind(this);
    // console.log(TAG,'render','tempshowspinner = '+JSON.stringify(tempshowspinner));
    return(
      &lt;View
        style={{
          flex:1,
        }}&gt;
        &lt;ScrollView style = {{flex:1,
          backgroundColor:'#F2F2F2',
          }}&gt;
          &lt;View style = {{
            flex:1,
            flexDirection:'column',
          }}&gt;
          &lt;PusherColumnCategories style = {{
            flex:1,
          }}
          data = {this.state.dataMain}
          navigate = {this.props.navigation}
          showSpinner = {this._showSpinner}
          hideSpinner = {this._hideSpinner}/&gt;
          &lt;/View&gt;
        &lt;/ScrollView&gt;
        &lt;ActivitySpinner showIndicator={this.state.showIndicator}/&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>

<p>This is the corresponding child component.</p>

<pre><code>import React from 'react';
import {View, Component, Button} from 'react-native';
import ProductListingItem from './ProductListingItemCategories';
  const TAG = ""PUSHERCOLUMNCATEGORIES"";
export default class PusherColumnCategories extends React.Component {
  constructor(props){
    super(props);
    if(props){
      console.log(TAG,'props ='+JSON.stringify(props));
      /*console.log(TAG,'props data length = '+Object.keys(props.dataMain).length);*/
      console.log(TAG,'Props = '+ JSON.stringify(props.data));
      console.log(TAG,'Navigation Props = '+JSON.stringify(props.navigate));
    }

    this.state = {
      data: props.data,
      propsAvailable: false,
      navigate: props.navigation,
    };
  };
  componentDidMount(){
    console.log(TAG,'componentDidMount');
  }
  componentWillReceiveProps(newProps){
    console.log(TAG,'componentWillReceiveProps',newProps.data);
    this.setState({
      /*data: JSON.parse(JSON.stringify(newProps.data)),*/
      data: (newProps.dataMain),
    }, function() {
      console.log(TAG,'componentWillReceiveProps','this.setState()','data = '+(Object.keys(this.state.data)));
    });
  }
  componentDidUpdate(){
    console.log(TAG,'componentDidUpdate');
  }

  render(){
    console.log(TAG,'render()');
    if(this.state.data){
      console.log(TAG,'render()','state not empty');
      console.log(TAG,'render()','data product_code = '+this.state.data[1].product_code);
      return(
        &lt;View style = {{
          flex:1,
          flexDirection: 'column',
        }}&gt;
        &lt;Button
          style = {{
            flex:1,
          }}
          title = 'presshere'
          onClick = {this.props.showSpinner}
          /&gt;
        &lt;RenderColumn style = {{
          flex:1,
        }}
         data = {this.state.data}
         navigate = {this.props.navigate}
         showSpinner = {this.props.showSpinner}
         hideSpinner = {this.props.hideSpinner}/&gt;
        &lt;/View&gt;
      );
    } else {
      console.log(TAG,'render()','state empty');
      return(
        &lt;View style = {{
          flex:1,
          flexDirection: 'column',
        }}/&gt;
      );
    }
  };
}
</code></pre>
","6113287","","6113287","","2018-02-06 12:28:30","2018-02-06 13:02:49","Event Handler (prop) passed to child component cannot be called react native","<javascript><reactjs><react-native><event-handling>","1","2","","",""
"48449116","1","","","2018-01-25 17:54:38","","0","187","<p>I am trying check if has cookies (login) and redirect to /dashboard. I added a Switch on arround Route, but it is not render the component. If I remove Switch, the page dont load: <em>""Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.""</em></p>

<p>My code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import { BrowserRouter as Router, Route, Redirect, Switch } from 'react-router-dom';
import Layout from '../../components/Layout.js';
import './Login.scss';

const Auth = () =&gt; (
  	&lt;Router&gt;
   		&lt;div id=""login"" className=""height100""&gt;
	   		&lt;Switch&gt;
	      		&lt;Route  path=""/"" component={Login}/&gt;
	      		&lt;PrivateRoute exact path=""/dashboard"" component={Protected}/&gt;
	      	&lt;/Switch&gt;
    	&lt;/div&gt;
  	&lt;/Router&gt;
)

const fakeAuth = {
  	isAuthenticated: false,
  	authenticate(cb) {
  		this.isAuthenticated = true
    	setTimeout(cb, 100) // fake async
	}
}

const PrivateRoute = ({ component: Component, ...rest }) =&gt; (
  	&lt;Route {...rest} render={props =&gt; (
    	fakeAuth.isAuthenticated ? (
      		&lt;Component {...props}/&gt;
    ) : (
      	&lt;Redirect to={{
       		pathname: '/',
        	state: { from: props.location }
      	}}/&gt;
    )
  	)}/&gt;
)

const Protected = () =&gt; &lt;Layout /&gt;

class Login extends Component {
 	state = {
    	redirectToReferrer: false
  	}

	setCookie = (cname,cvalue,exdays) =&gt; {
	    var d = new Date();
	    d.setTime(d.getTime() + (exdays*24*60*60));
	    var expires = ""expires="" + d.toGMTString();
	    document.cookie = cname + ""="" + cvalue + "";"" + expires + "";path=/"";
	}

	getCookie = (cname) =&gt; {
 	    var name = cname + ""="";
	    var decodedCookie = decodeURIComponent(document.cookie);
	    var ca = decodedCookie.split(';');
	    for(var i = 0; i &lt; ca.length; i++) {
	        var c = ca[i];
	        while (c.charAt(0) === ' ') {
	            c = c.substring(1);
	        }
	        if (c.indexOf(name) === 0) {
	            return c.substring(name.length, c.length);
	        }
	    }
	    return """";
	}

	// checkCookie() {
	//     var redirect = this.getCookie(""redirectToReferrer"");
	//     if (redirect) {
	//     } else {
	//         this.setCookie(""redirectToReferrer"", true, 30);
	//     }
	// }

 	login = (e) =&gt; {
 		e.preventDefault();
 		const that = this;

		const data = {
			'username': this.username.value,
			'password': this.password.value
		}

		const checkLogin = function(e) {
			if(e.username === data.username &amp;&amp; e.password === data.password) {
			    fakeAuth.authenticate();
				that.setState({ redirectToReferrer: true });
				that.setCookie(""redirectToReferrer"", true, 30);
			} else {
				alert('fail');
			}
		}

		fetch('http://maiconfurtado.com.br/test.json').then(r =&gt; r.json())
			.then(e =&gt; checkLogin(e))
			.catch(e =&gt; alert(e.message));
  	}

  	render() {
	    const { from } = this.props.location.state || { from: { pathname: '/dashboard' } };
	    const { redirectToReferrer } = this.state;
	    const redirect = this.getCookie(""redirectToReferrer"");

	    if (redirectToReferrer || redirect) {
	      	return (
	        	&lt;Redirect to={from} /&gt;
	      	)
	    }

	    return (
			&lt;div className=""box-login col-10 col-10-sm center-block""&gt;
				&lt;form className=""col-9 col-10-xs center-block"" onSubmit={this.login}&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""username""&gt;E-mail&lt;/label&gt;
						&lt;input type=""text"" className=""input"" id=""username"" name=""username"" ref={node =&gt; this.username = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;label htmlFor=""password""&gt;Password&lt;/label&gt;
						&lt;input type=""password"" className=""input"" id=""password"" name=""password"" ref={node =&gt; this.password = node} required /&gt;
					&lt;/div&gt;
					&lt;div className=""input-group""&gt;
						&lt;input type=""submit"" id=""submit"" value=""Log in"" /&gt;
					&lt;/div&gt;
				&lt;/form&gt;
			&lt;/div&gt;
	    )
	}
}

export default Auth</code></pre>
</div>
</div>
</p>

<p>I have another problem too: <em>Warning: You tried to redirect to the same route you're currently on: ""/dashboard""</em></p>
","5322552","","","","","2018-01-25 18:01:04","Switch is not render react component","<javascript><reactjs><cookies><render>","1","3","","",""
"40964705","1","40979812","","2016-12-04 22:56:12","","0","211","<p>I'm using material design lite and react. I managed to add dynamically tab when using separate layout and tabs but when I try to use mdl-layout__tab-bar mdl-js-ripple-effect I can't update the layout so the tab isn't working.</p>

<pre><code>&lt;div className=""mdl-layout mdl-js-layout mdl-layout--fixed-header""&gt;
        &lt;header className=""mdl-layout__header""&gt;
            &lt;div className=""mdl-layout__header-row""&gt;
                &lt;span className=""mdl-layout-title""&gt;Title&lt;/span&gt;
            &lt;/div&gt;
            &lt;div className=""mdl-layout__tab-bar mdl-js-ripple-effect""&gt;
                {
                    this.state.tabs.map((tab, i) =&gt; {
                        let tabId = '#' + tab.id;
                        let className = 'mdl-layout__tab';
                        tab.active ? className += ' is-active' : className + '';

                        return &lt;a key={i} href={tabId} className={className}&gt;{tab.name}&lt;/a&gt;
                    })
                }
                &lt;a key={this.state.tabs.length} href='#add-new'
                   className={'mdl-layout__tab ' + ADD_NEW}&gt;+&lt;/a&gt;
            &lt;/div&gt;
        &lt;/header&gt;
        &lt;div className=""mdl-layout__drawer""&gt;
            &lt;span className=""mdl-layout-title""&gt;Title&lt;/span&gt;
            &lt;nav className=""mdl-navigation""&gt;
                &lt;a className=""mdl-navigation__link"" href=""""&gt;Link&lt;/a&gt;
                &lt;a className=""mdl-navigation__link"" href=""""&gt;Link&lt;/a&gt;
                &lt;li&gt;
                    &lt;hr/&gt;
                &lt;/li&gt;
                &lt;span className=""asdf""&gt;
                    &lt;a className=""mdl-navigation__link"" href=""""&gt;Add new&lt;/a&gt;
                &lt;/span&gt;
            &lt;/nav&gt;
        &lt;/div&gt;
        &lt;main className=""mdl-layout__content""&gt;
            {
                this.state.tabs.map((tab, i) =&gt; {
                    return &lt;Tab key={i} id={tab.id} active={tab.active} content={tab.content}/&gt;
                })
            }
            &lt;Tab key={this.state.tabs.length} id='add-new' active={false}&gt;&lt;/Tab&gt;
        &lt;/main&gt;
    &lt;/div&gt;;
</code></pre>

<p>This is my render function and the tab  element is added properly, but when I click on it the tabs panel isn't shown.</p>

<pre><code>componentDidUpdate() {
    if (!this.layout) {
        this.layout = MaterialLayout.apply(MaterialLayout.prototype,[document.getElementsByClassName('mdl-layout')[0]]);
    }
    let id = this.state.tabs[this.state.tabs.length - 1].id;
    let tabs = document.getElementsByClassName('mdl-layout__tab-bar')[0].getElementsByTagName('a');
    let panels = document.getElementsByClassName('mdl-layout__content')[0].getElementsByClassName('mdl-layout__tab-panel ');
    MaterialLayoutTab(document.getElementsByTagName(""a[href="" + id + ""]""), tabs, panels, this.layout);
    this.registerListener();
    componentHandler.upgradeDom();
}
</code></pre>

<p>I tried anything but still can't upgrade the tabs ;/ 
Any suggestions will be highly appreciated.</p>
","3568791","","","","","2016-12-05 17:20:28","Dynamically add scrollable tab mdl react ?","<reactjs><layout><dynamic><tabs><material-design>","1","0","","",""
"48766539","1","","","2018-02-13 12:09:54","","0","183","<p>I am trying to insert a marker when the animation start. the animation draws a polygon component along route.  i am checking when the animation start and trying to insert the marker component at first postion but it showing me this errors . ........................................................................................................................................................</p>

<pre><code> Uncaught Error: Couldn't autodetect L.Icon.Default.imagePath, set it 
 manually.

 Uncaught TypeError: Cannot set property '_leaflet_pos' of undefined
</code></pre>

<p>/// the code part<br>
........................................................................................................................................................</p>

<pre><code>import React from ""react"";
import {
  Circle,
  Mapcontrol,
  Map,
  Marker,
  Popup,
  Polyline,
  CircleMarker, 
  TileLayer,
  LayersControl,
  Tooltip
} from ""react-leaflet"";
import { alertMessage } from ""./../../helper/alert-message.js"";
import { divIcon, map, marker } from ""leaflet"";
import { GoogleLayer } from ""react-leaflet-google"";
import { observer, inject } from ""mobx-react"";
import {
  distanceTo,
  toRad,
  toDegrees,
  distVincenty,
  bearings
} from ""./../../helper/distanceCalculation.js"";
import { Button, Grid } from ""semantic-ui-react"";
import index from ""antd/lib/dropdown"";

import LandMarkPopUp from ""./LandMarkPopUp"";
import SpeedLayout from ""./SpeedLayout"";
import { platform } from ""os"";

const { BaseLayer } = LayersControl;

const key = ""AIzaSyBevgZ_HK4t08KmW23EqO-aacqqGQxnAR4"";
const road = ""ROADMAP"";
const hybrid = ""HYBRID"";
const terrain = ""TERRAIN"";
const satellite = ""SATELLITE"";

const time = new Date().toString();

@inject(""assets"")
@observer
class Maps extends React.Component {
  constructor(props) {
    super(props);
    this.index = 0;
    this.intervalId = null;
    this.intervalTimer = 400;
    this.cardata = [];
    this.polyAnim = [];
    this.state = {
      markers: [],
      position: [24.146754, 90.499477],
      zoom: 3,
      minZoom: 6,
      maxZoom: 18,
      circle: [0, 0],
      name: ""Your Asset Name"",
      time: time,
      mapBounds: [[26.273714, 87.434692], [21.912471, 94.092407]],
      polylines: [[0, 0], [0, 0]],
      bearing: 0,
      routeColor: ""#000"",
      assetLiveMode: true,
      nearLanMark: [],
      isAnimationRunning: false,
      icon: ""pause"",
      content: ""Pause"",
      mymarkers: [[23.4545, 89.264]]
    };
  }

  getChunkedPositions = markerObj =&gt; {
    let latlngs = [];
    markerObj.map((pos, idx) =&gt; {
      latlngs.push(pos.position);
    });

    var i,
      len = latlngs.length,
      distance = 1,
      chunkedLatLngs = [];

    for (i = 1; i &lt; len; i++) {
      var cur = latlngs[i - 1],
        next = latlngs[i],
        dist = distVincenty(cur, next),
        factor = distance / dist,
        dLat = factor * (next[0] - cur[0]),
        dLng = factor * (next[1] - cur[1]);

      if (dist &gt; distance) {
        while (dist &gt; distance) {
          cur = [cur[0] + dLat, cur[1] + dLng];
          (dist = distVincenty(cur, next)), chunkedLatLngs.push(cur);
        }
      } else {
        chunkedLatLngs.push(cur);
      }
    }
    chunkedLatLngs.push(latlngs[len - 1]);

    return chunkedLatLngs;
  };

  playAnimation = () =&gt; {
    if (this.intervalId !== null) {
      clearInterval(this.intervalId);
    }
    this.props.sendAnimationTime(false);
    this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
  };

  runAnimation = () =&gt; {
    const cardata = this.cardata;

    if (this.index === cardata.length) {
      console.log(""Animation Finished"");
      alertMessage(""Animation Finished"");
      this.props.sendAnimationTime(true);
      this.setState({ polylines: [], isAnimationRunning: false });
    }

    if (this.index &lt; cardata.length) {
      if (cardata[this.index].position[0] != 0) {
        this.polyAnim.push(cardata[this.index].position);
      }
      this.setState({
        markers: [cardata[this.index]],
        polylines: [this.polyAnim],
        circle: [...this.state.circle, cardata[this.index].position],
        mapBounds: [
          [
            cardata[this.index].position[0] - 0.02,
            cardata[this.index].position[1] + 0.02
          ],
          [
            cardata[this.index].position[0] + 0.02,
            cardata[this.index].position[1] - 0.02
          ]
        ],
        bearing: cardata[this.index].children[0].bearing,
        isAnimationRunning: true,
        icon: ""pause"",
        content: ""Pause""
      });
    }
    this.index += 1;
  };

  animationOnOffButton = () =&gt; {
    console.log(""Animation Buttion"", this.state.isAnimationRunning);
    if (this.state.isAnimationRunning) {
      clearInterval(this.intervalId);
      this.setState({
        isAnimationRunning: false,
        icon: ""play"",
        content: ""Play""
      });
    } else {
      console.log(""stop"");
      this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
      this.setState({
        icon: ""pause"",
        content: ""Pause""
      });
    }
  };

  animationBackwardSpeedBtn = () =&gt; {
    clearInterval(this.intervalId);
    this.intervalTimer = 100;
    this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
  };

  animationForwardSpeedBtn = () =&gt; {
    clearInterval(this.intervalId);
    this.intervalTimer = 100;
    this.intervalId = setInterval(this.runAnimation, this.intervalTimer);
  };

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.currentAsset !== this.props.currentAsset) {
      this.circleBound(this.props.currentAsset);
    } else if (prevProps.animate !== this.props.animate) {
      var markerInfo = this.props.animate;

      var bounds = [];
      for (var i in markerInfo) {
        if (markerInfo[i].position[0] != 0 || markerInfo[i].position[1] != 0) {
          bounds.push(markerInfo[i].position);
        }
      }
      this.setState({
        mapBounds: bounds
      });

      var result = [];

      markerInfo.map((x, i) =&gt; {
        result.push({
          key: i,
          position: markerInfo[i].position,
          children: [markerInfo[i].children[3], markerInfo[i].children[2]],
          time: markerInfo[i].children[4]
        });
      });

      this.cardata = result;


      ///////////////////////////////////////////////////

      console.log(""this.cardata ----&gt;"", result);

      //////////////////////////////////////////////////////

      const first_lat = result[0].position[0] 
      const first_long = result[0].position[1] 

      const second_lat = result[result.length -1 ].position[0]
      const second_long = result[result.length - 1].position[1] 


      const f_marker = [first_long, first_lat]


      console.log(""this first point long ----&gt;"", first_long);  /// this first point long
      console.log(""this first point lat ----&gt;"", first_lat);  /// this first point lat

      console.log(""this last point long ----&gt;"", second_long); // this last point long
      console.log(""this last point lat ----&gt;"", second_lat); // this last point lat

      const l_marker = [ second_long, second_lat ]



      //////////////////////////////////////////////////////////

      this.playAnimation();
      this.props.sendAnimationTime(true);
    } else if (prevProps.route !== this.props.route) {
      var markerInfo = this.props.route;

      var bounds = [];
      for (var i in markerInfo) {
        if (markerInfo[i].position[0] != 0 || markerInfo[i].position[1] != 0) {
          bounds.push(markerInfo[i].position);
        }
      }
      this.setState({
        // markers: markerInfo,
        polylines: bounds,
        mapBounds: bounds
      });
    } else if (prevProps.data !== this.props.data) {
      const nearLm = this.props.data;

      var markerPromise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve(this.props.data);
        }, 1500);
      });

      markerPromise.then(markerInfo =&gt; {
        var bounds = [];
        var nearLanMark = [];
        for (var i in markerInfo) {
          if (
            markerInfo[i].position[0] != 0 ||
            markerInfo[i].position[1] != 0
          ) {
            bounds.push(markerInfo[i].position);
          }
        }
        if (bounds.length == 0) {
          this.setState({
            markers: markerInfo,
            polylines: [[0, 0], [0, 0]],
            mapBounds: this.state.mapBounds
          });
        } else {
          this.setState({
            markers: markerInfo,
            polylines: [[0, 0], [0, 0]],
            mapBounds: bounds
          });
        }
      });
    }
  }

  markerClick(id) {
    this.props.sendToDetails(id, true);
  }

  circleBound = value =&gt; {
    if (value !== null) {
      let Xc = value.info.position[0],
        Yc = value.info.position[1],
        R = value.radius;

      this.setState({
        mapBounds: [
          [Xc, Yc],
          [Xc, Yc + 0.03],
          [Xc, Yc - 0.03],
          [Xc - 0.03, Yc],
          [Xc + 0.03, Yc]
        ]
      });
    }
  };

  liveModeOn = () =&gt; {
    this.setState({
      assetLiveMode: false
    });

    this.props.passRouteData(this.state.assetLiveMode);
  };

  render() {
    const {
      position,
      zoom,
      minZoom,
      maxZoom,
      markers,
      time,
      mapBounds,
      polylines,    /// add marker to polyline component
      bearing,
      assetLiveMode,
      nearLanMark
    } = this.state;


    const result = markers;
    let isAnimating;
    let layoutData = {};

    if (markers.length &gt; 0 &amp;&amp; markers[0].assetId === undefined) {
      isAnimating = true;

      const animateDate = new Date(markers[0].time.time.$date);
      layoutData.speed = markers[0].children[1].speed;
      layoutData.date = `${animateDate.getDate()}-${animateDate.getMonth()}-${animateDate.getFullYear()}`;
      layoutData.time = `${animateDate.getHours()}-${animateDate.getMinutes()}-${animateDate.getSeconds()}`;
    } else {
      isAnimating = false;
    }

    const icon = (bearing, speed) =&gt; {
      return divIcon({
        className: ""my-div-icon animated-icon"",
        iconSize: [10, 10],
        iconAnchor: [12, 22],
        popupAnchor: [10, 10],
        shadowSize: [155, 150],
        html: `
            &lt;img src=""../../assets/car.png"" style=""-webkit-transform: rotate(${bearing}deg);"" width=""20""/&gt;
            &lt;div style=""z-index:-1"" class=""gps-ring""&gt;&lt;/div&gt;`
      });
    };

    const AssetIconMarker = ({ id, map, position, children, bearing }) =&gt; {
      const carbearing = !bearing ? children[0].bearing : bearing;
      const speed = children[1].speed;

      return (
        &lt;div&gt;
          &lt;Marker
            map={map}
            position={position}
            icon={icon(carbearing, speed)}
            onClick={this.markerClick.bind(this, id)}
          /&gt;
        &lt;/div&gt;
      );
    };

    const AssetIcon = ({ map, markers }) =&gt; {
      const items = markers.map(({ key, ...props }, id) =&gt; {
        return &lt;AssetIconMarker key={key} id={id} map={map} {...props} /&gt;;
      });
      return &lt;div style={{ display: ""none"" }}&gt;{items}&lt;/div&gt;;
    };

    return (
      &lt;div&gt;
        &lt;Map
          id=""map""
          ref=""leaflet""
          bounds={mapBounds}
          boundsOptions={{ padding: [10, 10] }}
          center={position}
          zoom={this.state.zoom}
          minZoom={this.state.minZoom}
          maxZoom={this.state.maxZoom}
        &gt;
          &lt;LayersControl position=""topright""&gt;
            &lt;LayersControl.BaseLayer name=""OpenStreetMap""&gt;
              &lt;TileLayer url=""http://{s}.tile.osm.org/{z}/{x}/{y}.png"" /&gt;
            &lt;/LayersControl.BaseLayer&gt;
            &lt;LayersControl.BaseLayer name=""Google Streets"" checked={true}&gt;
              &lt;GoogleLayer googlekey={key} maptype={road} /&gt;
            &lt;/LayersControl.BaseLayer&gt;
          &lt;/LayersControl&gt;




          &lt;Polyline
            color=""#111B24""
            weight=""4""
            lineCap=""round""
            positions={polylines}
            smoothFactor={1}
          /&gt;

          { this.props.currentAsset !== null ? (

            &lt;Circle
              center={this.props.currentAsset.info.position}
              radius={this.props.currentAsset.radius * 1000}
            /&gt;

          ) : null} 

          &lt;AssetIcon markers={markers} /&gt;
          &lt;LandMarkPopUp landMarkList={markers} /&gt;

          {/* {isAnimating ? (

            &lt;LandMarkPopUp landMarkList={f_markers} /&gt;


          ) : null} */}


          {this.state.mymarkers.map((position) =&gt;
            &lt;Marker 

            position={position}&gt;

            &lt;/Marker&gt;
          )}


        &lt;/Map&gt;




        {isAnimating ? (

          &lt;div className=""mapOverLay""&gt;
            &lt;Grid&gt;
              &lt;Grid.Column floated=""left"" width={5}&gt;
                &lt;div&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Speed: &lt;/strong&gt;{"" ""}
                    {layoutData.speed} km/h
                  &lt;/h3&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Date: &lt;/strong&gt;{"" ""}
                    {layoutData.date}
                  &lt;/h3&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Time: &lt;/strong&gt;{"" ""}
                    {layoutData.time}
                  &lt;/h3&gt;
                &lt;/div&gt;
              &lt;/Grid.Column&gt;
              &lt;Grid.Column width={10}&gt;
                &lt;Button.Group&gt;
                  &lt;Button
                    icon=""backward""
                    content=""Slow Speed""
                    onClick={this.animationBackwardSpeedBtn}
                  /&gt;

                  &lt;Button
                    icon={this.state.icon}
                    content={this.state.content}
                    onClick={this.animationOnOffButton}
                  /&gt;

                  &lt;Button
                    icon=""forward""
                    content=""Fast Speed""
                    onClick={this.animationForwardSpeedBtn}
                  /&gt;
                &lt;/Button.Group&gt;
              &lt;/Grid.Column&gt;
            &lt;/Grid&gt;
          &lt;/div&gt;
        ) : null}




      &lt;/div&gt;
    );
  }
}

export default Maps;
</code></pre>
","6741241","","","","","2018-02-13 12:09:54","react leaflet marker not showing when animation start","<javascript><react-leaflet>","0","0","","",""
"49449527","1","","","2018-03-23 12:20:23","","6","1820","<p>As read in <a href=""https://github.com/facebook/react/issues/12310"" rel=""noreferrer"">this React Github issue</a> I see more and more that</p>

<blockquote>
  <p>the cost of <code>render()</code> is relatively small</p>
</blockquote>

<p><strong>In React 16.3</strong>, I'm wondering why one would use the new getDerivedStateFromProps instead of componentDidUpdate?</p>

<p>Imagine this example:</p>

<pre><code>getDerivedStateFromProps(nextProps, prevState) {
  if (!prevState.isModalOpen &amp;&amp; nextProps.isReady) {
       return { isModalOpen: true };
  }
}
</code></pre>

<p>versus</p>

<pre><code>componentDidUpdate(prevProps, prevState) {
  if (!prevState.isModalOpen &amp;&amp; this.props.isReady) {
        this.setState({ isModalOpen: true });
  }
}
</code></pre>

<p>The later seems simpler just because it's using only existing API and looks just like what we used to do in componentWillReceiveProps so I don't see why users would go for getDerivedStateFromProps? What's the benefit?</p>

<p>Thanks!</p>
","757461","","","","","2018-03-23 14:17:00","Why use getDerivedStateFromProps instead of componentDidUpdate?","<reactjs>","2","2","","",""
"47104177","1","","","2017-11-03 20:47:43","","0","204","<p>Trying to use 'react-virtualized-select' as per <a href=""https://github.com/bvaughn/react-virtualized-select"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select</a> </p>

<p>we are using require.js in our application <strong>imported after getting it from npm and didn't the import css ....as mentioned here</strong> <a href=""https://github.com/bvaughn/react-virtualized-select#simple-example"" rel=""nofollow noreferrer"">https://github.com/bvaughn/react-virtualized-select#simple-example</a></p>

<p><a href=""https://i.stack.imgur.com/6znNc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6znNc.png"" alt=""enter image description here""></a></p>

<p><strong>Note : posting full code to make easy to understand context Please ignore any short coming's in rest of code as the error disappears if i remove the VirtualizedSelect tag</strong></p>

<pre><code>    var React = require('react');
var ReactDOM = require('react-dom');
var VirtualizedSelect = require('react-virtualized-select');

module.exports = React.createClass({
    componentName: 'Search',
    getDefaultProps() {
        return {};
    },
    getInitialState() {
        return {
            error: false,
            authenticated: false,
            visible: true,
            data: null,
            showAccountSelection: false,
            selected: null,
            search: '',
            optionPartnerList: []

        };
    },
    componentDidMount () {
        var qS = queryString.parse(location.search);
        if (qS &amp;&amp; qS.search) {
            this.setState({search: qS.search, visible: true});
        }

        this._unsubscribe = AppStore.listen(Utils.createRefluxComponentDispatcher(this));
    },
    componentDidUpdate: function () {
        if (this.refs.inputSearch) {
            this.refs.inputSearch.focus();
            this.refs.inputSearch.select()
        }
    },

    componentWillUnmount () {
        this._unsubscribe();
    },

render: function () {
        var self= this;
        if (!this.state.authenticated) {
            return null;
        }
        let componentDisabled = this.state.async ? true : false;
        let buttonIcon;
        let closeButton = AppStore.selectedAccount ?
            &lt;a href=""#"" className=""closebtn"" onClick={this.closeNav}&gt;&amp;times;&lt;/a&gt; :
            (&lt;a key=""-1"" className=""logout-link dropdown-item t-font"" onClick={AppActions.logout} href=""#""&gt;
                &lt;i className=""fa fa-sign-out m-r-10""&gt;&lt;/i&gt;Logout&lt;/a&gt;);

        let overlayStyle = {width: this.state.visible ? '100%' : '0px', display: this.state.visible ? 'block' : 'none', 'overflowX': 'hidden', 'overflowY': this.state.overlayOverflowY};
        if (this.state.visible) {
            AppActions.hideBodyScrollBar();
        } else {
            AppActions.showBodyScrollBar();
        }

        if (!this.state.async) {
            buttonIcon = &lt;i className=""fa fa-search""&gt;&lt;/i&gt;
        } else {
            buttonIcon = &lt;i className=""fa fa-cog fix fa-spin""&gt;&lt;/i&gt;
        }
        //TODO: refactor this make it css driven using flex box
        let style = {top: '37%'};
        if (this.state.data &amp;&amp; Object.keys(this.state.data).length &gt; 1) {
            style = {top: '10%'};
        }
        return (

            &lt;div style={{float:'left'}} className=""search-div""&gt;
                {this.searchIcon()}
                &lt;div className=""overlay"" style={overlayStyle}&gt;
                    {closeButton}
                    &lt;div className=""global-search center-content-wrapper"" style={style}&gt;
                        &lt;form id=""searchFormComponent"" ref={function(){$('#searchFormComponent').show('fast')}}
                              className=""global-search"" onSubmit={this.handleClick} style={{height: '500px'}}&gt;
                            {this.errorRender()}
                            &lt;div className=""f-row f-center""&gt;
                                &lt;input id=""searchbox"" type=""text"" ref=""inputSearch"" className=""form-control f-9 searchbox""
                                       placeholder=""SEARCH FOR ACCOUNT"" required
                                       style={{marginBottom:'1px'}} disabled={componentDisabled}
                                       defaultValue={this.state.search}&gt;
                                &lt;/input&gt;
                                &lt;VirtualizedSelect
                                    options={self.optionPartnerList}
                                    onChange={(selectValue) =&gt; this.setState({ selectValue })}
                                    value={this.state.selectValue}
                                /&gt;
                                &lt;button id=""searchbutton"" className=""btn btn-lg btn-primary btn-block t-font f-1""
                                        disabled={componentDisabled}
                                        onClick={this.handleClick}
                                        style={{ paddingLeft: '4px',paddingRight: '4px', fontSize:'1.1em',marginLeft:'4px'}}&gt;
                                    {buttonIcon}
                                &lt;/button&gt;
                                &lt;SearchHint ref={""searchHint""} toggleOverlayStyle={this.toggleOverlayStyle}/&gt;
                            &lt;/div&gt;
                            &lt;SearchAccountSelector data={this.state.search == ''? {}: this.state.data}/&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}); 
</code></pre>

<p>getting this exception </p>

<pre><code>Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. Check the render method of `exports`.     at invariant (bundle.c81618e7.js:5333)     at instantiateReactComponent (bundle.c81618e7.js:27936)     at Object.updateChildren (bundle.c81618e7.js:17273)     at ReactDOMComponent._reconcilerUpdateChildren (bundle.c81618e7.js:23289)     at ReactDOMComponent._updateChildren (bundle.c81618e7.js:23393)     at ReactDOMComponent.updateChildren (bundle.c81618e7.js:23380)     at ReactDOMComponent._updateDOMChildren (bundle.c81618e7.js:19340)     at ReactDOMComponent.updateComponent (bundle.c81618e7.js:19154)     at ReactDOMComponent.receiveComponent (bundle.c81618e7.js:19116)     at Object.receiveComponent (bundle.c81618e7.js:24009)
</code></pre>

<p>Not able to find the mistake i made any help in this regard will be greatly appreciated please find my package.json entries </p>

<pre><code>""react"": ""^15.6.2"",
""react-dimensions"": ""^1.3.0"",
""react-dom"": ""^15.6.2"",
""react-virtualized-select"": ""3.1.0"",
</code></pre>
","2359997","","2359997","","2017-11-03 21:41:59","2017-11-03 21:50:29","Error while using react-virtualized-select","<javascript><node.js><reactjs><react-redux>","2","10","","",""
"47599513","1","","","2017-12-01 18:34:55","","7","818","<p>I profiled the performance of my application using react redux by following  <a href=""https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad"" rel=""noreferrer"">this article by Ben Schwarz</a>.</p>

<p>In the user timing section, i get these warnings (with a no entry sign): </p>

<p><a href=""https://i.stack.imgur.com/JZtsX.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/JZtsX.png"" alt=""enter image description here""></a></p>

<p>There is two messages:</p>

<ul>
<li><code>(Committing Changes) Warning: Lifecycle hook scheduled a cascading update</code></li>
<li><code>Connect(MyComponent).componentDidUpdate Warning: Scheduled a cascading update</code> </li>
</ul>

<p>I made some search but i found nothing special. It seems related to the <code>componentDidUpdate</code> function of the connect HOC of react-redux.</p>

<p><strong>What does these messages means ?</strong></p>
","1594933","","","","","2017-12-01 18:46:02","React 16 : componentDidUpdate Warning: Scheduled a cascading update","<performance><reactjs><redux><react-redux><google-chrome-devtools>","1","0","3","",""
"47980540","1","47980867","","2017-12-26 15:23:00","","1","154","<p>I have react aplication. I would like to switch between id in url. Every click in the tab should show different kind of product list. I used from method componentDidUpdate. The problem is, when I click in the next tab, the list is jumping from previous list to the present list several times. I have read that it might be a problem with using setState in method componentDidUpdate and it can cause a infinite loop. I've tried something different things to do, but I have no idea, what I should change in my code. 
Could you have any idea, how to fix this jumping thing?</p>

<pre><code>  constructor(props) {
    super(props);
    this.state = {
      food: []
    };
    var ingredient_type = this.props.params.id;

    fetch('/food/type/'+ingredient_type)
      .then(res =&gt; res.json())
      .then(food=&gt; this.setState({food}));
  }


   componentDidUpdate(){
   var ingredient_type = this.props.params.id;

    return fetch('/food/type/'+ingredient_type)
      .then(res =&gt; res.json())
      .then(food=&gt; this.setState({food}));
  }



    render() { 
      let product_list = this.state.food.map((product, id) =&gt; &lt;div className=""row"" key={id}&gt; 
                                  &lt;p  className=""cal_list col-lg-4 col-md-4 col-sm-4"" &gt;{product.name}&lt;/p&gt; 
                                  &lt;p  className=""cal_list1 col-lg-2 col-md-2 col-sm-2"" &gt;{product.calories}&lt;/p&gt; 
                                  &lt;p  className=""cal_list2 col-lg-2 col-md-2 col-sm-2"" &gt;{product.protein}&lt;/p&gt; 
                                  &lt;p  className=""cal_list3 col-lg-2 col-md-2 col-sm-2"" &gt;{product.fat}&lt;/p&gt;
                                  &lt;p  className=""cal_list4 col-lg-2 col-md-2 col-sm-2"" &gt;{product.carb}&lt;/p&gt; &lt;/div&gt;)
</code></pre>
","9141923","","","","","2017-12-26 15:53:36","React app, componentDidUpdate - jumping list, infinite loop","<javascript><reactjs><components><infinite-loop>","1","0","2","",""
"41781836","1","","","2017-01-21 16:40:41","","2","796","<p>I am trying to display the user location on the map using google-maps-react. I followed the fullstack tutorial, but I just can't seem to display the user location.  I will display my Map.js  Component below.  Please help me point out what I am doing wrong. Thank you.</p>

<pre><code>import React, { Component } from 'react'
import ReactDOM from 'react-dom';

class Map extends Component {
  constructor(props) {
    super(props);

    const {lat, lng} = this.props.initialCenter;
    this.state = {
      currentLocation: {
        lat: lat,
        lng: lng
      }
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.google !== this.props.google) {
      this.loadMap();
    }
    if (prevState.currentLocation !== this.state.currentLocation) {
      this.recenterMap();
    }
  }
  recenterMap() {
    const map = this.map;
    const curr = this.state.currentLocation;

    const google = this.props.google;
    const maps = google.maps;

    if (map) {
        let center = new maps.LatLng(curr.lat, curr.lng)
        map.panTo(center)
    }
  }
  componentDidMount() {
    if (this.props.centerAroundCurrentLocation) {
        if (navigator &amp;&amp; navigator.geolocation) {
            navigator.geolocation.getCurrentPosition((pos) =&gt; {
                const coords = pos.coords;
                this.setState({
                    currentLocation: {
                        lat: coords.latitude,
                        lng: coords.longitude
                    }
                })
            })
        }
    }
    this.loadMap();
  }
  loadMap() {
    if (this.props &amp;&amp; this.props.google) {
      // google is available
      const {google} = this.props;
      const maps = google.maps;

      const mapRef = this.refs.map;
      const node = ReactDOM.findDOMNode(mapRef);

      let {initialCenter, zoom} = this.props;
      const {lat, lng} = initialCenter;
      const center = new maps.LatLng(lat, lng);
      const mapConfig = Object.assign({}, {
        center: center,
        zoom: zoom
      })
      this.map = new maps.Map(node, mapConfig);
    }
  }
  render() {
    const style = {
      width: '100vw',
      height: '100vh'
    }
    return (
      &lt;div ref='map' style={style}&gt;
        Loading map...
      &lt;/div&gt;
    )
  }
}

Map.propTypes = {
  google: React.PropTypes.object,
  zoom: React.PropTypes.number,
  initialCenter: React.PropTypes.object,
  centerAroundCurrentLocation: React.PropTypes.bool
}
Map.defaultProps = {
  zoom: 13,
  // San Francisco, by default
  initialCenter: {
    lat: 37.774929,
    lng: -122.419416
  },
  centerAroundCurrentLocation: false
}


export default Map
</code></pre>
","6650932","","","","","2017-01-21 16:40:41","google-maps-react user location not working","<javascript><google-maps><reactjs><components>","0","1","2","",""
"40849677","1","","","2016-11-28 17:01:29","","1","128","<p>I'm using <a href=""https://github.com/orgsync/react-list"" rel=""nofollow noreferrer"">react-list</a> to display lists data within Material-UI <a href=""http://www.material-ui.com/#/components/tabs"" rel=""nofollow noreferrer"">Tab</a> components. </p>

<p>I'm using the <code>simple</code> <code>type</code> in the list, e.g.</p>

<pre><code>&lt;ReactList itemRenderer={::this.renderItem}
           length={this.props.contacts.length}
           pageSize={20}
           type=""simple""
           useTranslate3d={true} /&gt;
</code></pre>

<p>I have to use <code>simple</code> as I don't know the size of the rendered items.</p>

<p>This means I can't use <code>scrollTo</code> fully. From the docs</p>

<blockquote>
  <p>Note that if you aren't using type='uniform' or an itemSizeGetter, you will only be able to scroll to an element that has already been rendered.</p>
</blockquote>

<p>When I'm work with the list on one tab and scrolled, say, half way down, when I switch to another tab, I'm scrolled some way down the list that has been updated with the new data.</p>

<p>What I'd like is to have the react-list reset to display the first item when I switch tabs.</p>

<p>I've tried putting a <code>ref</code> in <code>ReactList</code> component and then calling <code>scrollTo</code>---like this</p>

<pre><code>ref={c =&gt; this.list = c}

componentDidUpdate() {
    this.list.scrollTo(0, 0);
}
</code></pre>

<p>Had no effect.</p>
","75701","","75701","","2016-11-28 17:24:17","2016-11-28 17:24:17","How can I scroll to to the top of a ""simple"" react-list when it's redisplayed?","<reactjs>","0","8","","",""
"48560366","1","48560480","","2018-02-01 10:22:17","","1","84","<p>The official documentation of react ( <a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a> ) says that an update in props results in the child being updated, but it does not happen in my code. Am I missing something?</p>

<p>I created a parent component (Y) and a child component (X). The parent passes currentTime to the child as props. Even though after the props change in the parent after 3 seconds (due to setTimeout), the value in the h2 tag in the child does not change. </p>

<p>I found on the official page of react though ( <a href=""https://reactjs.org/docs/react-component.html"" rel=""nofollow noreferrer"">https://reactjs.org/docs/react-component.html</a> ) that ""An update can be caused by changes to props or state."" (I'm attaching a screenshot as well of the text on the official site below) Moreover I found that there that ""These methods are called when a component is being re-rendered:""</p>

<pre><code>componentWillReceiveProps()
shouldComponentUpdate()
componentWillUpdate()
render()
componentDidUpdate()
</code></pre>

<p>But in my case the change in props does not cause the value in h2 tag in the child to change. The official documentation says that an update in props results in the child being updated, but it does not happen in my code. Am I missing something? </p>

<p>I've pasted my code here for reference.</p>

<pre><code>const Y = () =&gt; {

    let currentTime=""09:00"";
    setTimeout(()=&gt; {
            currentTime = ""10:00:""
        }, 3000);

    return (
        &lt;X time={currentTime}/&gt;
    );
};


class X extends Component {
    time = ""11:00"";

    render = () =&gt; {
        return (
            &lt;h2&gt;{this.props.time}&lt;/h2&gt;
        );
    };
}
</code></pre>

<p>Screenshot:
<a href=""https://prnt.sc/i8kvaw"" rel=""nofollow noreferrer"">https://prnt.sc/i8kvaw</a></p>

<p><strong>Update:
The comment from Shubham Khatri ""The props for the child will only change if the parent re-renders"", really helped me understand. :)</strong></p>
","8882300","","8882300","","2018-02-01 16:37:35","2018-02-01 16:37:35","In react, will change in props in parent result in a corresponding updation in the child?","<reactjs><react-props>","2","1","","",""
"49222113","1","","","2018-03-11 16:10:58","","0","1228","<p>I'm making this Conway's game of life react project and it was working just fine but when I added the last couple of buttons to clear the board and some other functionalities react gave me this error </p>

<pre><code>Maximum update depth exceeded. This can happen when a component 
repeatedly calls setState inside componentWillUpdate or 
componentDidUpdate. React limits the number of nested updates to 
prevent infinite loops. 
</code></pre>

<p>From the code snippets it's been showing me it seems that the clear() function is the problem here, but I don't think I did set state inside a render() to trigger an infinite loop. Here are all the code for the clear and <code>componentDidMount</code>, I don't have a <code>componentWillUpdate</code> or <code>componentDidUpdate</code> in my app. </p>

<p>the clear() and Play function in the main class</p>

<p>EDIT 1 : It's telling me that there's something wrong with the setState inside the play() function, however, I always implemented the play function this way and it was always working since the beginning....</p>

<pre><code>clear = ()=&gt;{
    var g = Array(this.rows).fill().map(()=&gt; Array(this.cols).fill(false));

    this.setState({
        generations:0,
        fullGrid: g
    })
}

.....

play = () =&gt; {

    let g1 = this.state.fullGrid;
    let g2 = arrayClone(this.state.fullGrid);

    for (let i = 0; i &lt; this.rows; i++) {
        for (let j = 0; j &lt; this.cols; j++) {
            let count = 0;

            if (i &gt; 0)
                if (g1[i - 1][j]) count++;
            if (i &gt; 0 &amp;&amp; j &gt; 0)
                if (g1[i - 1][j - 1]) count++;
            if (i &gt; 0 &amp;&amp; j &lt; this.cols - 1)
                if (g1[i - 1][j + 1]) count++;
            if (j &lt; this.cols - 1)
                if (g1[i][j + 1]) count++;
            if (j &gt; 0)
                if (g1[i][j - 1]) count++;
            if (i &lt; this.rows - 1)
                if (g1[i + 1][j]) count++;
            if (i &lt; this.rows - 1 &amp;&amp; j &gt; 0)
                if (g1[i + 1][j - 1]) count++;
            if (i &lt; this.rows - 1 &amp;&amp; this.cols - 1)
                if (g1[i + 1][j + 1]) count++;
            if (g1[i][j] &amp;&amp; (count &lt; 2 || count &gt; 3)) g2[i][j] = false;
            if (!g1[i][j] &amp;&amp; count === 3) g2[i][j] = true;
        }
    }

    this.setState({
        fullGrid: g2,
        generations: this.state.generations + 1
    });

}


playButton = ()=&gt;{
    clearInterval(this.intervalId);
    this.intervalId = setInterval(this.play, this.speed);
}

pauseButton = ()=&gt;{
    clearInterval(this.intervalId);
}

slow = ()=&gt;{
    this.speed = 1000;
    this.playButton();
}

fast = ()=&gt;{
    this.speed = 100;
    this.playButton();
}

clear = ()=&gt;{
    var g = Array(this.rows).fill().map(()=&gt; Array(this.cols).fill(false))

    this.setState({
        generations:0,
        fullGrid: g
    })
}
</code></pre>

<p>The Button Class</p>

<pre><code>class Buttons extends React.Component{

handleSelect = (evt) =&gt;{
    this.props.gridSize(evt);
}

render(){
    return (
        &lt;div className=""center""&gt;
            &lt;ButtonToolbar&gt;
                &lt;button className='btn btn-info'  onClick={this.props.playButton}&gt;
                    PLAY
                &lt;/button&gt;
                &lt;button className='btn btn-info'  onClick={this.props.pauseButton}&gt;
                    PAUSE
                &lt;/button&gt;
                &lt;button className='btn btn-info'  onClick={this.props.clear}&gt;
                    CLEAR
                &lt;/button&gt;
                &lt;button className='btn btn-info'  onClick={this.props.slow}&gt;
                    SLOW
                &lt;/button&gt;
                &lt;button className='btn btn-info'  onClick={this.props.fast}&gt;
                    FAST
                &lt;/button&gt;
                &lt;button className='btn btn-info'  onClick={this.props.seed}&gt;
                    SEED
                &lt;/button&gt;
                &lt;DropdownButton
                    title=""Grid Size""
                    id=""size-menu""
                    onSelect={this.handleSelect}
                &gt;
                    &lt;MenuItem eventKey=""1""&gt;20x10&lt;/MenuItem&gt;
                    &lt;MenuItem eventKey=""2""&gt;50x30&lt;/MenuItem&gt;
                    &lt;MenuItem eventKey=""3""&gt;70x50&lt;/MenuItem&gt;
                &lt;/DropdownButton&gt;
            &lt;/ButtonToolbar&gt;
        &lt;/div&gt;
    )
}
</code></pre>

<p>}</p>
","8925572","","8925572","","2018-03-11 16:49:12","2018-03-11 16:49:12","Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate","<javascript><reactjs><render><infinite-loop><setstate>","1","4","","",""
"48270226","1","48271390","","2018-01-15 20:29:16","","5","165","<p>I am writing a React (ES6, v16) (typescript) application with react-router v4. I am observing a very strange behavior. Here is my render code (very much simplified): </p>

<pre><code>render() {
   &lt;Switch&gt;

      &lt;Route
         path=""/foo/add""
         render={ props =&gt; {
                return (
                   &lt;FormEntry title=""add new"" /&gt;
                );
         }}
      /&gt;

      &lt;Route
         path=""/foo/edit/:id""
         render={ props =&gt; {
                 return (
                    &lt;FormEntry title=""edit item"" /&gt;
                 );
         }}
      /&gt;
   &lt;/Switch&gt;
}
</code></pre>

<p>And here is the FormEntry component (simplified):</p>

<pre><code>class FormEntry extends React.Component&lt; { title: string }, any &gt; {
    render() {
       return (
          &lt;div&gt;
             {this.props.title}
          &lt;/div&gt;
       );
    }

    componentDidMount() {
       // code goes here
    }

    componentDidUpdate() {
       // code goes here
    }
}
</code></pre>

<p>Now when, inside the application, I click a link ""/foo/add"", the handler in the first ""Route"" component is fired (as expected) and the component ""FormEntry"" is mounted. The method componentDidMount is rightfully fired. </p>

<p>Now I click the link ""foo/edit/1"". The handler of the second Route is fired. </p>

<p>This time, inside the ""FormEntry"" component, the lifecycle method ""componentDidMount"" is not fired, the method ""componentDidUpdate"" is called. But this is cleary a different ""instance"" of the FormEntry which is being mounted. I was expecting the see of the lifecycle methods kicked off... </p>

<p>It looks like there is only one instance of ""FormEntry"" in my application. So why in the second case (when Route handler for url ""foo/edit:id"") this instance does not go through the all lifecycle methods??</p>

<p>Is it a breaking change in the v16 version of React? ( I have not observed this behavior in previous versions of react).</p>

<p>Your insight will be very much appreciated</p>
","1747336","","","","","2018-01-15 22:19:37","React: is componentDidUpdate same for 2 different instances of a component?","<javascript><reactjs><lifecycle>","1","3","","",""
"49248680","1","49256944","","2018-03-13 05:08:47","","0","285","<p>I've started using Flow type on top of a project created with create-react-app tool. I struggle to make a simple scenario work where a class property is filled with element reference in render method but throws 2 errors. What am I doing wrong? All the checks should prevent those warnings.</p>

<pre><code>class MyComponent extends React.Component&lt;*&gt; {
  input: ?HTMLInputElement;

  componentDidUpdate = () =&gt; {
    if (this.input) {
        this.input.focus();
        if (this.input.value) {
            const valueLength = this.input.value.length;
            this.input.setSelectionRange(valueLength, valueLength);
        }
    }
  };

  render() {
    return &lt;input ref={ref =&gt; (this.input = ref)} /&gt;;
  }
}

     Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ src/todo/index.js:38:28

 Property value is missing in null or undefined [1].

  [1] 33│     input: ?HTMLInputElement;
      34│
      35│     componentDidUpdate = () =&gt; {
      36│         if (this.input) {
      37│             this.input.focus();
      38│             if (this.input.value) {
      39│                 const valueLength = this.input.value.length;
      40│                 this.input.setSelectionRange(valueLength, valueLength);
      41│             }


 Error ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ src/todo/index.js:40:28

 Cannot call this.input.setSelectionRange because property setSelectionRange is missing in null or undefined [1].

  [1] 33│     input: ?HTMLInputElement;
      34│
      35│     componentDidUpdate = () =&gt; {
      36│         if (this.input) {
      37│             this.input.focus();
      38│             if (this.input.value) {
      39│                 const valueLength = this.input.value.length;
      40│                 this.input.setSelectionRange(valueLength, valueLength);
      41│             }
      42│         }
      43│     };
</code></pre>
","1081525","","","","","2018-03-13 13:02:39","Flow Type complains about class property assigned via react ref","<reactjs><flowtype>","1","0","","",""
"40890362","1","","","2016-11-30 14:02:24","","0","231","<p>I have this strage case, maybe I am missing something from how react <code>componentDidMount</code> works, or maybe it is a strange behaviour (right know I can't provide a real fiddle with the jQuery plug in, but I am pretty sure the problem is wider than the plug in itself).</p>

<pre><code>var Hello = React.createClass({
  getInitialState() {
    return {content: '&lt;div id=""target""&gt;ciao!&lt;/div&gt;'}
  },

  componentDidMount() {
    const target = $('#target').init();
    this.target = target;
  },

  componentWillReceiveProps(nextProps) {
    if (condition) {
        this.target.destroy(); // this remove even the DOM node
    }
  },

  componentDidUpdate() {
    const target = $('#target').init(); // HERE PROBLEM! can't find the #target element
    this.target = target;
  }

  render: function() {
    return &lt;div&gt;Hello {this.state.content}&lt;/div&gt;;
  }
});
</code></pre>

<p>I can't understand why after the ´condition´ is true and the dom node are destroyed by the plug in, the <code>componentDidUpdate</code> does not find the <code>#target</code> that in my mind should have been ""re-rendered"" in the first render after <code>componentWillReceiveProps</code>. I expect to be there because it reads it from the initial state that never change.</p>

<p>What am I missing?</p>
","4898937","","4898937","","2016-11-30 15:18:45","2016-12-01 07:09:12","Why does componentDidUpdate not see newly inserted dom nodes?","<javascript><reactjs>","2","2","","",""
"48871455","1","48871873","","2018-02-19 17:40:20","","0","37","<p>I have a prototype chat app in react that I can currently show sent messages in both viewers windows (Agent and User). However, I'm having trouble figuring out how to only show a sent message as sent in one window and received in the other and vice versa. So if the Agent sends a message, it will show with their name and the message in both windows. I'm thinking I need to pass the ""author"" into each ""User messages"" and ""Agent messages"" within App.js, but this doesn't work.</p>

<p><strong>App.js</strong></p>

<pre><code>class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      messages: []
    }
    this.handleNewMessage = this.handleNewMessage.bind(this);
  }

  static propTypes = {
    messages: PropTypes.arrayOf(PropTypes.object)
  }

  handleNewMessage = (text) =&gt; {
    this.setState({
      messages: [...this.state.messages, { me: true, author: ""Me"", body: text},{ me: true, author: ""Agent"", body: text}]
    })
  }
  render() {
    return (
      &lt;div className=""App""&gt;
        &lt;div className=""agentWindow""&gt;
          &lt;Agent messages={this.state.messages} handleNewMessage={this.handleNewMessage} /&gt;
        &lt;/div&gt;
        &lt;div className=""userWindow""&gt;
          &lt;User messages={this.state.messages} handleNewMessage={this.handleNewMessage} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Agent.js</strong>(User.js is the same)</p>

<pre><code>class Agent extends Component {
  render() {
    return (
      &lt;div className=""Agent""&gt;
        &lt;header&gt;
          &lt;p&gt;Agent&lt;/p&gt;
        &lt;/header&gt;
        &lt;MessageList messages={this.props.messages} /&gt;
        &lt;MessageForm onMessageSend={this.props.handleNewMessage} /&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><strong>Message.js</strong></p>

<pre><code>class Message extends Component {
  static propTypes = {
    author: PropTypes.string,
    body: PropTypes.string.isRequired,
    me: PropTypes.bool
  }

  render() {
    const classes = classNames('Message', {
      log: !this.props.author,
      me: this.props.me
    })

    return (
      &lt;div className={classes}&gt;
        {this.props.author &amp;&amp; (
          &lt;span className=""author""&gt;{this.props.author}:&lt;/span&gt;
        )}
        {this.props.body}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p><strong>MessageList.js</strong></p>

<pre><code>class MessageList extends Component {
  static propTypes = {
    messages: PropTypes.arrayOf(PropTypes.object)
  }

  static defaultProps = {
    messages: [],
  }

  componentDidUpdate = () =&gt; {
    this.node.scrollTop = this.node.scrollHeight
  }

  render() {
    return (
      &lt;div className=""MessageList"" ref={(node) =&gt; (this.node = node)}&gt;
        {this.props.messages &amp;&amp; this.props.messages.map((message, i) =&gt; (
            &lt;Message key={i} {...message} /&gt;
        ))}
      &lt;/div&gt;
    )
  }
}
</code></pre>

<p><strong>MessageForm.js</strong></p>

<pre><code>class MessageForm extends Component {
  static propTypes = {
    onMessageSend: PropTypes.func.isRequired,
  }

  componentDidMount = () =&gt; {
    this.input.focus()
  }

  handleFormSubmit = (event) =&gt; {
    event.preventDefault()
    this.props.onMessageSend(this.input.value)
    this.input.value = """"
  }

  render() {
    return (
      &lt;form className=""MessageForm"" onSubmit={this.handleFormSubmit}&gt;
        &lt;div className=""input-container""&gt;
          &lt;input
            type=""text""
            ref={(node) =&gt; (this.input = node)}
            placeholder=""Enter Message...""
          /&gt;
        &lt;/div&gt;
        &lt;div className=""button-container""&gt;
          &lt;button type=""submit""&gt;
            Send
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
","350305","","350305","","2018-02-19 19:48:06","2018-02-19 21:36:41","Show message as sent/received in other users window with react","<javascript><reactjs>","1","2","","",""
"49249563","1","","","2018-03-13 06:24:35","","1","112","<p>Hello I'm trying to have a generic ""component"" that toggles a class, think of it as tabs but I dont want a fixed markup on it, so I was thinking to use attributes to manage the initialization.</p>

<p>For example this code should initialize on the , clicking on it will toggle the .active class on .target.</p>

<pre><code>&lt;button data-toggle="".active"" data-target="".target""&gt;button&lt;/button&gt;
&lt;div class=""target""&gt;&lt;/div&gt;
</code></pre>

<p>The problem is that I need to initialize the data attributes with componentDidMount() and componentDidUpdate() but I can't specify it on all components, is it possible to have a global componentDidMount() for all the app? or is it possible to assign a ""generic component"" with the attribute? What's the best way to proceed?</p>

<p>I want to use attributes because I need to keep it generic, I don't want to setup a component with  etc..</p>

<p>EDIT</p>

<p>I was thinking about using componentDidMount and componentDidUpdate on the main component app, since this methods seems to fire after all chidrens have done mounting or updating, there maybe I can query the attributes.. More to come</p>

<p>EDIT2</p>

<p>Well I think the right solution is to use react components and inside them initialize the vanilla js classes imported inside the component, it should work I don't know why I didn't think about that before</p>
","2838890","","2838890","","2018-03-30 15:24:34","2018-03-30 15:24:34","react generic component or component as attribute","<javascript><reactjs><components>","1","0","","",""
"33440604","1","33440735","","2015-10-30 16:24:33","","1","612","<p>I am actually updating <a href=""https://github.com/ezequiel/react-typeahead-component"" rel=""nofollow"">https://github.com/ezequiel/react-typeahead-component</a> this component to be compatible to react >= 0.14 but while changing the methods I just run into one error:</p>

<p>Exchange <code>this.getDOMnode</code> for the reason it is deprecated with <code>this.findDOMnode</code> it occurs an error: <code>Uncaught TypeError: this.findDOMNode is not a function</code></p>

<p>So I tried a lot about that React isn't binding <code>this</code> automatically in 0.14 to several functions. But it did not really helped me out.</p>

<pre class=""lang-js prettyprint-override""><code>module.exports = React.createClass({
  displayName: 'Aria Status',

  propTypes: process.env.NODE_ENV === 'production' ? {} : {
    message: React.PropTypes.string
  },

  componentDidMount: function() {
    var _this = this;

    _this.setTextContent(_this.props.message).bind(this);
  },

  componentDidUpdate: function() {
    var _this = this;

    _this.setTextContent(_this.props.message).bind(this);
  },

  render: function() {
    return (
      React.createElement(""span"", {
        role: ""status"",
        ""aria-live"": ""polite"",
        style: {
          left: '-9999px',
          position: 'absolute'
        }
      })
    );
  },

  setTextContent: function(textContent) {
    this.findDOMNode().textContent = textContent || '';
  }
});
</code></pre>

<p>Maybe someone can point me somewhere to go ahead!</p>
","3318813","","","","","2015-10-30 16:39:36","reactjs - this is not a function error on upgrade","<javascript><function><reactjs><deprecated><typeahead>","1","1","","",""
"32198502","1","32198691","","2015-08-25 07:55:58","","3","2256","<p>In this example, when I try to update the state during the <code>componentDidUpdate</code> life cycle callback, I get a <code>too much recursion</code> error. How should I be updating the state?</p>

<pre><code>import React from 'react';

class NotesContainer extends React.Component {
  constructor(props) {
    super(props);
    this.state = { listOfShoppingItems: [] };
  }

  componentDidUpdate(nextProps, nextState) {
    let newShoppingItems = this.calculateShoppingItems();
    this.setState({ listOfShoppingItems: newShoppingItems });
  }

  calculateShoppingItems() {
    let shoppingItemsCart = []

    if (this.props.milk &lt; 3) {
      let value = ""Buy some milk"";
      shoppingItemsCart.push(value);
    }

    if (this.props.bread &lt; 2) {
      let value = ""Buy some bread"";
      shoppingItemsCart.push(value);
    }

    if (this.props.fruit &lt; 10) {
      let value = ""Buy some fruit"";
      shoppingItemsCart.push(value);
    }

    if (this.props.juice &lt; 2) {
      let value = ""Buy some juice"";
      shoppingItemsCart.push(value);
    }

    if (this.props.sweets &lt; 5) {
      let value = ""Buy some sweets"";
      shoppingItemsCart.push(value);
    }

    return shoppingItemsCart;
  }

  render() {
    return (
      &lt;div&gt;
        Etc...
      &lt;/div&gt;
    );
  }
}

export default NotesContainer;
</code></pre>
","521411","","764371","","2017-08-16 15:45:08","2017-08-16 15:45:08","Too much recursion when updating state in react","<javascript><reactjs>","1","0","2","",""
"41098489","1","41098652","","2016-12-12 10:14:37","","2","495","<p>From my parent react component's render method I am creating a list of child radio button components.</p>

<p>I need to call a method once the render is completed, i.e., children components are also rendered completely.</p>

<p>I tried following mechanism:</p>

<ol>
<li>passed a callback: It didn't worked. It was called before rendering.</li>
<li>called the method directly in componentDidMount. Same issue </li>
<li>called the method in componentDidUpdate. Same issue</li>
</ol>

<p>I am passing all the data through props to parent -> child and there is no redux involved.</p>

<p>How I can achieve this ?</p>
","2416451","","","","","2016-12-12 10:23:44","react ComponentDidMount","<reactjs><react-jsx>","1","1","1","",""
"48871499","1","48893567","","2018-02-19 17:42:36","","0","48","<p>This application works perfectly fine in Chrome. When it is run in Firefox the referenced global variables give an error of undefined. I do not understand why nor how to fix it.</p>

<p>If you click the play button after the song loads it plays in Chrome. In Firefox it gives the aforementioned errors. Online version: 
<a href=""http://wktdev.github.io/react_record/"" rel=""nofollow noreferrer"">http://wktdev.github.io/react_record/</a></p>

<pre><code>    let audioContext,
    song,
    mic,
    recorder,
    soundFile,
    audioRecordings = [];

    //__________________________BEGIN helpers


    function stopAllSoundFiles(arr,prop){ // @Stop all sound recordings from playing
        arr.forEach((val)=&gt;{
           val[prop].stop()
        })
    }





    //__________________________END helpers





    //__________________________BEGIN load sound via p5.js


    function preload() { // @preload is required by P5.js
        audioContext = getAudioContext();  
        soundFormats('mp3', 'ogg');
        song = loadSound('audio/song.mp3');
        console.log(song);
    }

    function setup() { // @setup is required by P5.js
        song.setVolume(0.1);

    }

   //___________________________END load sound via p5.js


 //____________________________________BEGIN Timer

    const leftPad = (width, n) =&gt; {

        if ((n + '').length &gt; width) {
            return n;
        }
        const padding = new Array(width).join('0');
        return (padding + n).slice(-width);
    };


    class TimeElapsed extends React.Component {
        getUnits() {
            const seconds = this.props.timeElapsed / 1000;
            return {
                min: Math.floor(seconds / 60).toString(),
                sec: Math.floor(seconds % 60).toString(),
                msec: (seconds % 1).toFixed(3).substring(2)
            };
        }
        render() {
            const units = this.getUnits();
            return (
                &lt;div&gt;
        &lt;span&gt;{leftPad(2, units.min)}:&lt;/span&gt;
        &lt;span&gt;{leftPad(2, units.sec)}.&lt;/span&gt;
        &lt;span&gt;{units.msec}&lt;/span&gt;
        &lt;/div&gt;
            );
        }
    }






    class TimeDisplay extends React.Component {

        constructor(props) {
            super(props)
            this.timer = undefined;
            this.startTime = undefined;


            this.state = {
                isRunning: false,
                timeElapsed: 0
            };

        }

        componentDidMount() {
            this.startCounter();

        }

        componentDidUpdate(prevProps) {
            if (prevProps.isPlaying !== this.props.isPlaying) {
                this.startCounter();
            }
        }

        startCounter() {

            if (this.props.isPlaying) {
                console.log(this.props.isPlaying);
                this.startTime = Date.now();
                this.timer = setInterval(() =&gt; { this.update() }, 10);


            } else {
                console.log(this.props.isPlaying);
                clearInterval(this.timer);
                this.setState({ timeElapsed: 0 });
            }
        }

        update() {
            const delta = Date.now() - this.startTime;
            this.setState({ timeElapsed: this.state.timeElapsed + delta });
            this.startTime = Date.now();
        }





        render() {


            return (
            &lt;div id=""time-display""&gt;   
              &lt;TimeElapsed  timeElapsed={this.state.timeElapsed} /&gt;
            &lt;/div&gt;
            )
        }

    }


    //______________________________________END Timer


    class Button extends React.Component {
        constructor(props) {
            super(props)
        }

        render() {

            let recordingButton = {

            }

            let changeColor = {
                color: ""red"",

            }

            if (this.props.isRecording) {
                recordingButton = changeColor
            } else {
                recordingButton = {}
            }


            return (&lt;button style={recordingButton} onClick={this.props.onClick}&gt;{this.props.buttonText}&lt;/button&gt;)
        }
    }




    class App extends React.Component {

        constructor(props) {
            super(props)
            this.playStartCurrentTime;
            this.recordStartCurrentTime;
            this.recordEndCurrentTime;

            this.toggleSongPlaying = this.toggleSongPlaying.bind(this);
            this.toggleRecording = this.toggleRecording.bind(this);
            this.checkedToPlay = this.checkedToPlay.bind(this);
            this.cueSelectedRecordingsToPlay = this.cueSelectedRecordingsToPlay.bind(this);


            this.state = {
                audioRecordings:[], // {timestamp: 0, sound: p5.SoundFile, checkedToPlay: false}
                isPlaying: false,
                isRecording: false,
                recordButtonText: ""Start Recording"",
                playButtonText: ""Play Song"",
            }

        }

        cueSelectedRecordingsToPlay(arr = this.state.audioRecordings){

            arr.forEach((val)=&gt;{
                console.log(""Time stamps: "" + val.timestamp);
               if(val.checkedToPlay){
                   val.sound.play(val.timestamp)
               }
            })
        }



        toggleSongPlaying() {
            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });

               this.playStartCurrentTime = audioContext.currentTime;
               console.log(this.playStartCurrentTime);
               this.cueSelectedRecordingsToPlay();
               song.play()

            } else {

                this.setState({
                    isPlaying: false,
                    playButtonText: ""Play Song""
                })

                //___________________________BEGIN if recording when playing stops... then stop recording too

                if(this.state.isRecording){
                      this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();






                //_____________________________BEGIN update state
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state



                //___________________________END if recording when playing stops... then stop recording too


                }

                stopAllSoundFiles(this.state.audioRecordings,'sound');



                song.stop();

            }

        }


        toggleRecording() {

            var isRecording = this.state.isRecording;
            if (!isRecording) {

                this.setState({
                    isRecording: true,

                    recordButtonText: ""Stop Recording"",
                });

               this.cueSelectedRecordingsToPlay();

                // audioRecorder.record();
                mic = new p5.AudioIn();
                mic.start();
                recorder = new p5.SoundRecorder();
                recorder.setInput(mic);
                soundFile = new p5.SoundFile();
                this.recordStartCurrentTime = audioContext.currentTime
                recorder.record(soundFile);




            } else {

                this.setState({
                    isRecording: false,
                    recordButtonText: ""Start Recording""
                });

                recorder.stop();

                console.log();
                let timeStamp =  Math.abs(this.recordStartCurrentTime - this.playStartCurrentTime);


                //_____________________________BEGIN update state

                let tempAudioRecordings = this.state.audioRecordings;
                tempAudioRecordings.push({timestamp:timeStamp,sound:soundFile,checkedToPlay:false});
                this.setState({
                    audioRecordings:tempAudioRecordings 
                });


                //_____________________________END update state


                // save(soundFile, 'mySound.wav');
            }


            var isPlaying = this.state.isPlaying;

            if (!isPlaying) {

                this.setState({
                    isPlaying: true,
                    playButtonText: ""Stop Song"",
                });


                this.playStartCurrentTime = audioContext.currentTime;
                console.log(this.playStartCurrentTime);
                song.play();
            }
        }

        checkedToPlay(index){
            let arrayTemp = this.state.audioRecordings;
            if(!arrayTemp[index].checkedToPlay){
                arrayTemp[index].checkedToPlay = true;
            }else{
                arrayTemp[index].checkedToPlay = false;
            }

            this.setState({
                audioRecordings:arrayTemp
            })

            console.log(this.state.audioRecordings[index].checkedToPlay);

        }



        render() {

            console.log(this.state.audioRecordings);
            const mainContainer = {
                width: ""700px"",
                margin: ""0 auto"",
                height: ""300px"",
                outlineStyle: ""solid""
            }

           let listRecordings = this.state.audioRecordings.map((val,index)=&gt;{
                   return &lt;li key={index}&gt;recording number: {index+1} timestamp: {val.timestamp} | PLAY &lt;input type='checkbox' onChange={()=&gt;this.checkedToPlay(index)}&gt;&lt;/input&gt;&lt;/li&gt;
           })

            return (
            &lt;main style = {mainContainer}&gt; 

                 &lt;section&gt;
                    &lt;div className=""buttonContainer""&gt;
                      &lt;TimeDisplay isPlaying = {this.state.isPlaying}/&gt;
                      &lt;Button buttonText = {this.state.recordButtonText} onClick={this.toggleRecording} isRecording={this.state.isRecording}/&gt; 
                      &lt;Button buttonText = {this.state.playButtonText} onClick={this.toggleSongPlaying} /&gt;
                    &lt;/div&gt;
                 &lt;/section&gt;

                 &lt;ul&gt;
                  {listRecordings}
                 &lt;/ul&gt;

            &lt;/main&gt;

            )
        }
    }



    ReactDOM.render(
        &lt;div&gt;
        &lt;App/&gt;
    &lt;/div&gt;,
        document.getElementById(""root""))
</code></pre>
","1152980","","","","","2018-02-20 20:19:54","I have a working Chrome react web-audio app. When run in Firefox variables are listed as undefined.Why?","<javascript><reactjs><web-audio><p5.js>","1","3","","",""
"49410221","1","","","2018-03-21 15:21:12","","0","41","<p>I have a small app using google-maps-react, I have added a rightclick event on map, but I m stuck now and I do not think I am in the right direction. My addNewMarker method has a InfoWindow with a button, which I want to use to call web api with a POST request. Is there a way to refactor the code in a pure react? </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';


export default class MapContainer extends Component {

    state = {
        locations: [
            { name: ""New York County Supreme Court"", location: { lat: 40.7143033, lng: -74.0036919 } },
            { name: ""Queens County Supreme Court"", location: { lat: 40.7046946, lng: -73.8091145 } },
            { name: ""Kings County Supreme Court"", location: { lat: 40.6940226, lng: -73.9890967 } },
            { name: ""Richmond County Supreme Court"", location: { lat: 40.6412336, lng: -74.0768597 } },
            { name: ""Bronx Supreme Court"", location: { lat: 40.8262388, lng: -73.9235238 } }
        ]
    }

    componentDidUpdate() {
        this.loadMap(); // call loadMap function to load the google map
    }



    loadMap() {
        if (this.props &amp;&amp; this.props.google) { // checks to make sure that props have been passed
            const { google } = this.props; // sets props equal to google
            const maps = google.maps; // sets maps to google maps props

            const mapRef = this.refs.map; // looks for HTML div ref 'map'. Returned in render below.
            const node = ReactDOM.findDOMNode(mapRef); // finds the 'map' div in the React DOM, names it node

            const mapConfig = Object.assign({}, {
                center: { lat: 40.7485722, lng: -74.0068633 }, // sets center of google map to NYC.
                zoom: 11, // sets zoom. Lower numbers are zoomed further out.
                mapTypeId: 'roadmap' // optional main map layer. Terrain, satellite, hybrid or roadmap--if unspecified, defaults to roadmap.
            })

            this.map = new maps.Map(node, mapConfig); // creates a new Google map on the specified node (ref='map') with the specified configuration set above.
            this.map.addListener('rightclick', (evt) =&gt; {
                this.addNewMarker(this.map, maps, evt);
            })

            // ==================
            // ADD MARKERS TO MAP
            // ==================
            this.state.locations.forEach(location =&gt; { // iterate through locations saved in state
                const marker = new maps.Marker({ // creates a new Google maps Marker object.
                    position: { lat: location.location.lat, lng: location.location.lng }, // sets position of marker to specified location
                    map: this.map, // sets markers to appear on the map we just created on line 35
                    title: location.name // the title of the marker is set to the name of the location
                });
            })

        }
    }

    addNewMarker(map, maps, e) {
        const latitude = e.latLng.lat();
        const longitude = e.latLng.lng();
        console.log(latitude + ', ' + longitude);
        var marker = new maps.Marker({
            position: e.latLng,
            map: map
        });
        var infowindow = new maps.InfoWindow({
            content: `&lt;div class=""btn-group btn-group-toggle"" data-toggle=""buttons""&gt;
            &lt;label class=""btn btn-primary active""&gt;&lt;input type=""radio"" name=""options"" id=""option1"" autocomplete=""off"" checked&gt;Патрул&lt;/label&gt;
            &lt;label class=""btn btn-primary active""&gt;&lt;input type=""radio"" name=""options"" id=""option2"" autocomplete=""off""&gt;Камера&lt;/label&gt;
            &lt;label class=""btn btn-primary active""&gt;&lt;input type=""radio"" name=""options"" id=""option3"" autocomplete=""off""&gt;Пешак&lt;/label&gt;
          &lt;/div&gt;
            &lt;h4&gt;${(new Date()).toString()}&lt;/h4&gt;
            &lt;div&gt;&lt;a class=""btn btn-large btn-success"" onclick=""postInfo();""&gt;Share&lt;/a&gt;
            &lt;/div&gt;`
        });
        infowindow.addListener('closeclick', function(){
            marker.setMap(null);
        });
        marker.addListener('click', function() {
            infowindow.open(this.map, marker);
        });
        infowindow.open(this.map, marker);
        }

    render() {
        const style = { // MUST specify dimensions of the Google map or it will not work. Also works best when style is specified inside the render function and created as an object
            width: '100vw', // 90vw basically means take up 90% of the width screen. px also works.
            height: '75vh' // 75vh similarly will take up roughly 75% of the height of the screen. px also works.
        }

        return ( // in our return function you must return a div with ref='map' and style.
            &lt;div ref=""map"" style={style}&gt;
                loading map...
      &lt;/div&gt;
        )
    }
}</code></pre>
</div>
</div>
</p>

<p>Thanks in advance!</p>
","9529546","","","","","2018-03-21 15:21:12","google-maps-react and how to transform javascript code in react Components","<reactjs><google-maps-react>","0","0","1","",""
"49261175","1","","","2018-03-13 16:25:00","","1","121","<p>I have a problem with react. I'd create 2 files : </p>

<p>select.js :</p>

<pre><code>import React, { Component } from 'react';
import PropTypes from 'prop-types';
import reactDOM from 'react-dom';
import Select from 'react-select';
import Media from '../media/media';
import Form from '../fields/form.js';

class Select_galery extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input : ''
    }
    this.handleChange = this.handleChange.bind(this);
    this.state.selectValue = this.props.value ? this.props.value.select : 'true';
  }

  handleChange(event){
  this.setState({selectValue:event.target.value});
}



  render() {
    let url_youtube = this.props.name+'[url]';
    let id_youtube = this.props.id+'[url]';
    let value_youtube = this.props.value ? this.props.value.url : '';
    let name_select = this.props.name+'[select]';
    let name_img = this.props.name+'[image]';
    let id_img = this.props.id+'[image]';
    // let url_img = this.props.url+'[image][url]';
    if(this.state.selectValue == 'true'){
      this.state.input = &lt;Media name={name_img} id={id_img} /&gt;;
    }else{
      this.state.input = &lt;div&gt;&lt;label htmlFor={id_youtube}&gt;Url Video&lt;/label&gt;&lt;input id={id_youtube} type='text' name={url_youtube} defaultValue={value_youtube} className=""widefat""/&gt;&lt;/div&gt;;
    }
    return (
      /* NE PAS OUBLIER LE FOR !!!! */
       &lt;label htmlFor={this.props.id}&gt;{this.props.label}
          {this.state.selectValue}
         &lt;select defaultValue={this.state.selectValue}  id={this.props.id} className=""widefat"" name={name_select} onChange={this.handleChange.bind(this)}&gt;
           &lt;option value=""true""&gt;Image&lt;/option&gt;
           &lt;option value=""false""&gt;Video&lt;/option&gt;
         &lt;/select&gt;
        {this.state.input}
       &lt;/label&gt;
    );
  }
}
export default Select_galery;
</code></pre>

<p>And Media.js :</p>

<pre><code>import React from 'react';
import './media.scss';

class Media extends React.Component {
    constructor(props) {
        super(props);

        /*
         * Default state.
         * We can set the default state based on given props.
         */
        let hasMedia = false;

        if (props.value) {
            hasMedia = !!props.value.id;
        }

        this.state = {
            hasMedia: hasMedia,
            media: {
                id: props.value ? props.value.id : '',
                url: props.value ? props.value.url : '',
                name: props.value ? props.value.name : ''
            },
        };

        /*
         * Bindings.
         */
        this.addImage = this.addImage.bind(this);
        this.removeImage = this.removeImage.bind(this);
        this.select = this.select.bind(this);

        /*
         * Get a WordPress media frame.
         */
        this.wpframe = wp.media({
            // Define behaviour of the media window.
            // 'post' if related to a WordPress post.
            // 'select' if use outside WordPress post.
            frame: 'select',
            // Allow or not multiple selection.
            multiple: false,
            // The displayed title.
            title: 'Insérer Media',
            // The button behaviour
            button: {
                text: 'Insérer',
                close: true
            },
            // Type of files shown in the library.
            // 'image', 'application' (pdf, doc,...)
            /*library:{
                type: props.type ? props.type : 'image'
            }*/
        });

        // Attach an event on select. Runs when ""insert"" button is clicked.
        this.wpframe.on('select', this.select);
    }


    /**
     * Handle click on the button and open the WordPress
     * media library modal in order to fetch an image from
     * the media library. The returned ""attachment id"" value
     * is then set to the hidden input value attribute.
     *
     */
    addImage() {
        /*
         * Open the media modal.
         */
        this.wpframe.open();
    }

    /**
     * Return the selected attachment object.
     */
    select() {
        let selection = this.wpframe.state().get('selection').first(),
            type = selection.get('type'),
            id = selection.get('id'),
            thumbUrl = selection.get('icon'), // Default image url to icon.
            sizes = selection.get('sizes');

        /*
         * We receive a BackboneJs Model instance (selection).
         * Now we need to update the component in order to show the selected
         * thumbnail and populate the hidden field value with the ""id"" of the attachment.
         */
        if ('image' === type)
        {
            if (typeof sizes.thumbnail !== 'undefined') {
                thumbUrl = sizes.thumbnail.url;
            }
        }

        /*
         * We need to change the state in order
         * to force React to render the component.
         */
        this.setState({
            hasMedia: true,
            media: {
                id: id,
                url: thumbUrl,
                name: selection.get('filename')
            }
        });
    }

    /**
     * Remove the chosen image.
     * This reset the component state and force re-rendering.
     */
    removeImage() {
        this.setState({
            hasMedia: false,
            media: {
                id: '',
                url: '',
                name: ''
            }
        });
    }

    /**
     * Render a label if defined.
     *
     * @returns {*}
     */
    renderHeader() {
        if (this.props.label) {
            return (
                &lt;div className=""media-component-header""&gt;
                    &lt;h4&gt;{this.props.label}&lt;/h4&gt;
                &lt;/div&gt;
            );
        }

        return '';
    }

    /**
     * Render the media component footer.
     *
     * @returns {*}
     */
    renderFooter() {
        if (!this.props.info) {
            return '';
        }

        return (
            &lt;div className=""media-component-footer""&gt;
                &lt;p className=""description""&gt;{this.props.info}&lt;/p&gt;
            &lt;/div&gt;
        );
    }

    /**
     * Render the media component.
     * If there is a media, show the media details with a preview,
     * else only display an ""Add Image"" button.
     *
     * @returns {XML}
     */
    render() {
        if (this.state.hasMedia) {
            return (
                &lt;div ref={(domElem) =&gt; { this.domElem = domElem; }} className=""media-component""&gt;
                    {this.renderHeader()}
                    &lt;div&gt;
                        &lt;div className=""media-inner-wrapper""&gt;
                            &lt;div className=""media-preview""&gt;
                                &lt;div className=""centered""&gt;
                                    &lt;img className=""media-thumbnail"" alt=""Media Thumbnail"" src={this.state.media.url}/&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div className=""media-tools""&gt;
                                &lt;div className=""media-infos""&gt;
                                    &lt;h4&gt;Nom du fichier&lt;/h4&gt;
                                    &lt;p className=""media-filename""&gt;{this.state.media.name}&lt;/p&gt;
                                &lt;/div&gt;
                                &lt;div className=""media-buttons""&gt;
                                    &lt;button type=""button""
                                            className=""button button-remove""
                                            onClick={this.removeImage}&gt;Supprimer&lt;/button&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[id]`} value={this.state.media.id}/&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[url]`} value={this.state.media.url}/&gt;
                        &lt;input type=""hidden"" name={`${this.props.name}[name]`} value={this.state.media.name}/&gt;
                    &lt;/div&gt;
                    {this.renderFooter()}
                &lt;/div&gt;
            );
        }
        return (
            &lt;div className=""media-component""&gt;
                {this.renderHeader()}
                &lt;button type=""button""
                        className=""button button-primary""
                        onClick={this.addImage}&gt;Ajouter&lt;/button&gt;
                {this.renderFooter()}
            &lt;/div&gt;
        );
    }

    /**
     * We update the DOM hidden inputs define into the parent
     * container of our media component.
     *
     * @param prevProps
     * @param prevState
     */
    componentDidUpdate(prevProps, prevState) {
        /*
         * The ""this.domElem"" property is only defined
         * when we add an image... otherwise it is null.
         *
         * We the user add/attach an image, we need to update the
         * dom hidden inputs next to our component.
         */
        if (this.domElem) {
            let parent = this.domElem.parentElement.parentElement,
                idInput = parent.querySelector('input.image-id'),
                urlInput = parent.querySelector('input.image-url'),
                nameInput = parent.querySelector('input.image-name');

            /*
             * Let's update the value attribute of each DOM hidden input.
             */
            if (idInput || urlInput || nameInput) {
                idInput.setAttribute('value', this.state.media.id);
                urlInput.setAttribute('value', this.state.media.url);
                nameInput.setAttribute('value', this.state.media.name);
            }
        }
    }
}

export default Media;
</code></pre>

<p>When I select an image in Worpdress and save it, i've got the error message : </p>

<p>Uncaught TypeError: Cannot read property 'addEventListener' of null</p>

<p><a href=""https://i.stack.imgur.com/TyaSU.png"" rel=""nofollow noreferrer"">When I select the image</a></p>

<p><a href=""https://i.stack.imgur.com/LSDHd.png"" rel=""nofollow noreferrer"">When I updated my post</a></p>

<p><a href=""https://i.stack.imgur.com/6TfoV.png"" rel=""nofollow noreferrer"">In the Database</a></p>

<p>If you need more informations, ask me ;)</p>
","8952306","","","","","2018-03-13 16:36:05","Uncaught TypeError: Cannot read property 'addEventListener' of null on react","<reactjs>","1","0","","",""
"50674295","1","","","2018-06-04 06:10:16","","0","42","<p>I am new to redux and react. I have React container and component which gets data from the api request call. My question in basically, what is the best way to handle asyc functons of redux in react. I need help to get the data in react component.</p>

<p>Container.js: (incomplete, here I need help)</p>

<pre><code>class Container extends React.Component {

  state = {
    userList: ''
  }

  componentDidMount() {
    this.props.loadUserDetails();
  }

  render() {
    return (
      &lt;div className=""app""&gt;
       &lt;Component userList={this.state.userList}/&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  userList: state.auth.userList
});

const mapDispatchToProps = (dispatch) =&gt; bindActionCreators({
  loadUserDetails
}, dispatch);

export default withRouter(connect(
  mapStateToProps,
  mapDispatchToProps
)(Container));
</code></pre>

<p>Componet.js: (Pure component, here I need to render the data) </p>

<pre><code>class Component extends React.Component {

  render() {
    return (
      &lt;div className=""component""&gt;
       {this.props.userList}
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>modules/auth/index.js</p>

<pre><code>export const loadUserDetails = () =&gt; {
  return dispatch =&gt; {
    dispatch({
      type: types.LOAD_USER_REQUEST
    });
    request.get('/api/v1/auth', dispatch)
    .then(({ data }) =&gt; {
      if (data.success) {
        dispatch({
          type: types.LOAD_USER_SUCCESS
      payload: data.data
        });
      } else {
        dispatch({
          type: types.LOAD_USER_FAILURE,
          payload: data.message
        });
      }
    })
    .catch((err) =&gt; {
      dispatch({
        type: types.LOAD_USER_FAILURE,
        payload: 'Something went wrong, please try again.'
      });
    });
  };
};
</code></pre>

<p>modules/auth/actions.js: </p>

<pre><code>export const LOAD_USER_REQUEST = 'auth/LOAD_USER_REQUEST';
export const LOAD_USER_SUCCESS = 'auth/LOAD_USER_SUCCESS';
export const LOAD_USER_FAILURE = 'auth/LOAD_USER_FAILURE';
</code></pre>

<p>modules/auth/reducers.js: </p>

<pre><code>state ={
    loading: false,
    error: null,
    userList: null
}


case types.LOAD_USER_REQUEST: 
      return Object.assign({}, state, {
    loading: true
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: false,
        userList: payload,
      });
    case types.LOAD_USER_REQUEST:
      return Object.assign({}, state, {
    loading: flase,
    error: payload
      });
</code></pre>

<p>I actually need help to get the userList in Container and pass it to the Component. because it's an asyc function I am not able to get the data in Container before Component renders. How to handle such situations? </p>

<p>As I am passing <code>userList</code> in Child component, for the first time I don't have the  <code>userList</code> data. So my problem is with the cycles of Reactjs, Where should I call <code>loadUserList</code> ? In componentDidMount? Or componentDidUpdate? If so, how can I get the data?</p>

<p>I am not able to render the <code>userList</code> it's value is <code>null</code> when the Component mounts. How to solve this?</p>
","5946125","","5946125","","2018-06-04 06:25:23","2018-06-04 07:04:09","How to get data from async functions in react components, react-redux?","<javascript><reactjs><react-native><redux>","1","11","","",""
"42799133","1","","","2017-03-15 00:36:14","","0","338","<p><strong>Requirements</strong></p>

<p>I have a list of links. Every link has an unique URL through an ID. Every link should open or update a window. Only one window should be open at any time, no multiple windows</p>

<p><strong>Solution</strong></p>

<pre><code>import React from 'react';

let PopUp = React.createClass({
    propTypes: {
        id: React.PropTypes.string
    },

    getInitialState: function() {
        return {
            id: null,
            popUp: null
        };
    },

    componentDidUpdate: function() {
        let url = 'http://test.com/' + this.props.id;

        if(this.state.popUp) {
            this.state.popUp.close();
        }

        this.setState({
            popUp: window.open(url, '_blank'),
            id: this.props.id
        });
    },

    shouldComponentUpdate: function(nextProps, nextState) {
        //If no id
        if(!nextProps.id) {
            return false;
        }

        //If same id and open window
        if(nextProps.id === nextState.id &amp;&amp; nextState.popUp &amp;&amp; !nextState.popUp.closed) {
            return false;
        }

        return true;
    },

    render: function() {
        return null;
    }
});

export default PopUp;
</code></pre>

<p>This works. But the problem with this is that I have to use <strong>setState</strong> inside <strong>componentDidUpdate</strong>. This will cause another loop through the life cycle.</p>

<p>Can this be avoided? Is there a better solution? Should I use a global <a href=""https://medium.freecodecamp.com/where-do-i-belong-a-guide-to-saving-react-component-data-in-state-store-static-and-this-c49b335e2a00#3c46"" rel=""nofollow noreferrer"">variable</a> or the <a href=""https://facebook.github.io/react/docs/context.html"" rel=""nofollow noreferrer"">context</a>?</p>

<p>Thanks</p>
","782390","","782390","","2017-03-15 02:26:43","2017-03-15 02:26:43","Avoid Using setState On componentDidUpdate","<javascript><facebook><reactjs><redux><react-redux>","0","2","","",""
"50690351","1","50690690","","2018-06-05 00:09:25","","1","68","<p>I am using the componentDidUpdate() method and for the most part, it is doing what it should. It runs the function to get the data from the API as well as logs it to the console. The problem is that it does not render the new data on the front end. The only time it renders the new data is if the component actually mounts (if the page is refreshed). I feel like I'm very close, but have hit a dead end. Here is my code:</p>

<pre><code>import React from 'react';
import Nav from './Nav';

class List extends React.Component {
constructor(props) {
super(props);
this.state = {
  APIData: []
}
}

getAPIData() {
const url = `http://localhost:3001${this.props.location.pathname}`;
return fetch(url, {
  method: 'GET',
  mode: 'CORS',
  headers: {
    'Accept': 'application/json'
  }
})
  .then(response =&gt; response.json())
  .then(data =&gt; {
    console.log(data);
    return data;
  }).catch(err =&gt; { console.log('Error: ', err) });
};

dataList() {
return (
  &lt;div&gt;
  {this.state.APIData.map((APIData) =&gt; (
    &lt;p&gt; And the data returned is -&gt; {APIData.firstName} 
{APIData.lastName} !&lt;/p&gt;
  )
  )}
  &lt;/div&gt;
) 
}

componentDidMount() {
console.log(this.props.location.pathname);

this.getAPIData()
  .then(data =&gt; {
    console.log('in List.js ', data);
    this.setState({
      APIData: data
    });
  });
}

componentDidUpdate(prevProps, prevState) {
console.log(this.props.location.pathname);
// only update if the data has changed
this.getAPIData()
.then(data =&gt; {
  if (prevProps.data !== this.props.data) {
    this.setState({
      APIData: data
    });
  }
  console.log(data);
});
}

render() {
return (
  &lt;div&gt;
    &lt;Nav /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;div&gt;
      {/* {this.state.APIData.map((APIData) =&gt; (
        &lt;p&gt; And the data returned is -&gt; {APIData.firstName} 
 {APIData.lastName} !&lt;/p&gt;
      )
      )} */}
      {this.dataList()}

    &lt;/div&gt;

  &lt;/div&gt;
 );
 }
 }



 export default List;
</code></pre>
","9757042","","","","","2018-06-05 01:07:47","componentDidUpdate() working mostly, but not rendering new data","<javascript><reactjs><lifecycle-hook>","1","1","","",""
"48784977","1","","","2018-02-14 10:32:40","","0","88","<p>i want to add Two marker after componentDidUpdate method in react.the marker is not at first. I get the position of marker in componentDidUpate method. the problem is whenn i try to conditionally add the the marker after playing the animation . it shows me different error in different situation .</p>

<p>here is my main render component</p>

<pre><code> return (
      &lt;div&gt;
        &lt;Map
          id=""map""
          ref=""leaflet""
          bounds={mapBounds}
          boundsOptions={{ padding: [10, 10] }}
          center={position}
          zoom={this.state.zoom}
          minZoom={this.state.minZoom}
          maxZoom={this.state.maxZoom}
        &gt;
          &lt;LayersControl position=""topright""&gt;
            &lt;LayersControl.BaseLayer name=""OpenStreetMap""&gt;
              &lt;TileLayer url=""http://{s}.tile.osm.org/{z}/{x}/{y}.png"" /&gt;
            &lt;/LayersControl.BaseLayer&gt;
            &lt;LayersControl.BaseLayer name=""Google Streets"" checked={true}&gt;
              &lt;GoogleLayer googlekey={key} maptype={road} /&gt;
            &lt;/LayersControl.BaseLayer&gt;
          &lt;/LayersControl&gt;

          &lt;Polyline
            color=""#111B24""
            weight=""4""
            lineCap=""round""
            positions={polylines}
            smoothFactor={1}
          /&gt;

          {this.props.currentAsset !== null ? (
            &lt;Circle
              center={this.props.currentAsset.info.position}
              radius={this.props.currentAsset.radius * 1000}
            /&gt;
          ) : null}

          &lt;AssetIcon markers={markers} /&gt;
          &lt;LandMarkPopUp landMarkList={markers} /&gt;




        &lt;/Map&gt;



        {isAnimating ? (
          &lt;div className=""mapOverLay""&gt;
            &lt;Grid&gt;
              &lt;Grid.Column floated=""left"" width={5}&gt;
                &lt;div&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Speed: &lt;/strong&gt;{"" ""}
                    {layoutData.speed} km/h
                  &lt;/h3&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Date: &lt;/strong&gt;{"" ""}
                    {layoutData.date}
                  &lt;/h3&gt;
                  &lt;h3&gt;
                    &lt;strong className=""overlayHead""&gt;Time: &lt;/strong&gt;{"" ""}
                    {layoutData.time}
                  &lt;/h3&gt;
                &lt;/div&gt;
              &lt;/Grid.Column&gt;
              &lt;Grid.Column width={10}&gt;
                &lt;Button.Group&gt;
                  &lt;Button
                    icon=""backward""
                    content=""Slow Speed""
                    onClick={this.animationBackwardSpeedBtn}
                  /&gt;

                  &lt;Button
                    icon={this.state.icon}
                    content={this.state.content}
                    onClick={this.animationOnOffButton}
                  /&gt;

                  &lt;Button
                    icon=""forward""
                    content=""Fast Speed""
                    onClick={this.animationForwardSpeedBtn}
                  /&gt;
                &lt;/Button.Group&gt;
              &lt;/Grid.Column&gt;
            &lt;/Grid&gt;
          &lt;/div&gt;
        ) : null}
      &lt;/div&gt;
    );
</code></pre>

<p>in my component did update method i get the postion value of marker</p>

<pre><code> componentDidUpdate(prevProps, prevState) {
    if (prevProps.currentAsset !== this.props.currentAsset) {
      this.circleBound(this.props.currentAsset);
    } else if (prevProps.animate !== this.props.animate) {
      var markerInfo = this.props.animate;
      console.log(""markerInfo"");
      var bounds = [];
      for (var i in markerInfo) {
        if (markerInfo[i].position[0] != 0 || markerInfo[i].position[1] != 0) {
          bounds.push(markerInfo[i].position);
        }
      }
      this.setState({
        mapBounds: bounds
      });

      var result = [];

      markerInfo.map((x, i) =&gt; {
        result.push({
          key: i,
          position: markerInfo[i].position,
          children: [markerInfo[i].children[3], markerInfo[i].children[2]],
          time: markerInfo[i].children[4]
        });
      });

      this.cardata = result;

      console.log(""carData"", result);

      const MyFirstmarker = result[0].position;  ///marker one

      const MyLastmarker = result[result.length - 1].position;  ///marker two

      console.log(""animation start point "", MyFirstmarker);

      console.log(""animation last point "", MyLastmarker);


      this.playAnimation();

      this.props.sendAnimationTime(true);


    } else if (prevProps.route !== this.props.route) {


      var markerInfo = this.props.route;

      var bounds = [];
      for (var i in markerInfo) {
        if (markerInfo[i].position[0] != 0 || markerInfo[i].position[1] != 0) {
          bounds.push(markerInfo[i].position);
        }
      }
      this.setState({
        // markers: markerInfo,
        polylines: bounds,
        mapBounds: bounds
      });
    } else if (prevProps.data !== this.props.data) {
      const nearLm = this.props.data;

      var markerPromise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve(this.props.data);
        }, 1500);
      });

      markerPromise.then(markerInfo =&gt; {
        var bounds = [];
        var nearLanMark = [];
        for (var i in markerInfo) {
          if (
            markerInfo[i].position[0] != 0 ||
            markerInfo[i].position[1] != 0
          ) {
            bounds.push(markerInfo[i].position);
          }
        }
        if (bounds.length == 0) {
          this.setState({
            markers: markerInfo,
            polylines: [[0, 0], [0, 0]],
            mapBounds: this.state.mapBounds
          });
        } else {
          this.setState({
            markers: markerInfo,
            polylines: [[0, 0], [0, 0]],
            mapBounds: bounds
          });
        }
      });
    }
  }
</code></pre>

<p>i want that myFirstMarker and MylastMarker value to be shown as a marker in the Map Component at the start of the animation. how can i do that ?</p>

<p>if any illustration needed i will describe. thanks .</p>
","6741241","","","","","2018-02-14 10:32:40","how to render Two marker in react leaflet","<reactjs><leaflet><react-leaflet>","0","0","","",""
"42149206","1","","","2017-02-10 00:00:42","","1","27","<p>I'm looking for a way to get render metrics from ag-grid(-react) and publish them to a New Relic dashboard. Currently I'm using New Relic Browser SPA API to create and end an interaction. The point is that I'm not able to find the correct ""place"" (methods/callback/events) where doing it.</p>

<p>At first I instrumented my component's <code>componentWillUpdate</code> and <code>componentDidUpdate</code> lifecycle methods but a colleague told me it would not work because ag-grid renders ""disconnected"" from React. ag-grid offers <code>onRowDataChanged</code> event but I'm not sure if this method is called before the rendering starts of after it ends. And, anyway, I would need a pair of methods where to start New Relic's interaction and end it.</p>

<p>Is there a way to do it?</p>

<p>Thanks!</p>
","95117","","","","","2017-02-10 00:00:42","Is it possible to get render metrics (time) from ag-grid-react?","<newrelic><ag-grid-react>","0","0","1","",""
"50894897","1","","","2018-06-17 08:18:31","","0","35","<p>I'm trying to show a popup on the place I clicked every time I click on the map (only one popup needs to show).</p>

<p>The first time it works but any time I click after that it won't:</p>

<pre><code>import React, { Component, createRef } from 'react';
import { Map as LeafletMap, TileLayer, Marker,Popup } from 'react-leaflet';


const newPopup = props =&gt; (
  &lt;Popup position={props.newCoords}&gt;
    &lt;h1&gt;You clicked here&lt;/h1&gt;
  &lt;/Popup&gt;
);

export default class Map extends Component {
  mapRef = createRef()

  handleClick (e) {
    const coords = this.mapRef.current.leafletElement.mouseEventToLatLng(e.originalEvent);
    console.log(coords);
    this.setState({
      ...this.state,
      showNewPopup:true,
      newName:"""",
      newCoords:coords
    })
  }
  constructor() {
    super()
    this.state = {
      lat: 52.369730195560706,
      lng: 4.901275634765625,
      zoom: 10,
      showNewPopup:false,
      newName:"""",
      newCoords:{lat:0,lng:0}
    }
  }

  render() {
    const position = [this.state.lat, this.state.lng];
    return (
      &lt;LeafletMap 
        center={position}
        zoom={this.state.zoom}
        style={{width:""100%"",height:""100%""}}
        onClick={(e)=&gt;this.handleClick(e)}
        ref={this.mapRef}
      &gt;
        &lt;TileLayer
          attribution='&amp;copy; &lt;a href=""http://osm.org/copyright""&gt;OpenStreetMap&lt;/a&gt; contributors'
          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'
        /&gt;
        {
          (this.state.showNewPopup)
            ? newPopup(this.state)
            : """"
        }
      &lt;/LeafletMap&gt;
    );
  }
}
</code></pre>

<p>Popup cannot be extended, when you try there is an error:</p>

<blockquote>
  <blockquote>
    <p>TypeError: Super expression must either be null or a function, not object</p>
  </blockquote>
</blockquote>

<pre><code>class MyPopup extends Popup {

}

const newPopup = props =&gt; (
  &lt;MyPopup position={props.newCoords}&gt;
    &lt;h1&gt;You clicked here&lt;/h1&gt;
  &lt;/MyPopup&gt;
);
</code></pre>

<p>Probably because of <a href=""https://github.com/PaulLeCam/react-leaflet/blob/master/src/Popup.js#L99"" rel=""nofollow noreferrer"">this</a></p>

<pre><code>export default withLeaflet(Popup)
</code></pre>

<p>Tried to wrap the component and get a ref to the leaflet popup</p>

<pre><code>class NewPopup extends Component {
  popRef = createRef()
  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log(""lll"",prevProps.position,this.props.position);
    this.popRef.current.leafletElement.openPopup(this.props.position);
    // this.popRef.current.leafletElement.update();
    // this.popRef.current.leafletElement.bringToFront();
    // debugger;
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Popup position={this.props.position} ref={this.popRef}&gt;
          &lt;h1&gt;You clicked here&lt;/h1&gt;
        &lt;/Popup&gt;
      &lt;/div&gt;
    );
  }
};
</code></pre>

<p>No error but same behavior, never opens a popup after the first click.</p>

<p>Dependencies in package.json:</p>

<pre><code>""dependencies"": {
  ""leaflet"": ""^1.3.0"",
  ""react"": ""^16.4.1"",
  ""react-dom"": ""^16.4.1"",
  ""react-leaflet"": ""^2.0.0-rc.1"",
  ""react-scripts"": ""1.1.4""
},
</code></pre>
","1641941","","1641941","","2018-06-17 09:19:54","2018-06-17 09:19:54","react-leaflet keep opening popup on click instead of opening only once","<javascript><babel><react-leaflet>","0","0","","",""
"49450876","1","","","2018-03-23 13:34:21","","0","72","<p>[1]How to make a stopwatch app like this <a href=""https://www.online-stopwatch.com/countdown/"" rel=""nofollow noreferrer"">https://www.online-stopwatch.com/countdown/</a> in reactjs...?</p>

<pre><code>import React,{Component} from 'react';

export default class StopWatch extends Component{
  constructor(props){
    super(props);
    this.state={
      time2: ''
    }
  }
  timeCount(){
    this.time= setInterval(() =&gt; {
      this.setState({ time2:this.state.time2 - 1});
    },1000);
  }
  stopTimer() {
    clearInterval(this.time);
  }
  componentDidUpdate(){
    console.log(this.state.time2);
    if(this.state.count===0){
      clearInterval(this.time);
    }
  }
  componentWillUnmount(){
    clearInterval(this.time);
  }

  toggle(key){
    if(this.state.time2.length &lt; 6) {
      this.setState({ time2: `${this.state.time2}` + `${key}` });
    }
  }
</code></pre>

<p>[2]:Value of timer is not changing after trigger buttons.Provide me the 
     best method to achieve this.</p>

<p>Reference Link: <a href=""https://www.online-stopwatch.com/countdown/"" rel=""nofollow noreferrer"">https://www.online-stopwatch.com/countdown/</a></p>
","9540479","","","","","2018-03-23 13:34:21","How to make a Stopwatch app in reactjs?","<stopwatch>","0","0","","",""
"49840031","1","49840111","","2018-04-15 08:35:05","","3","151","<p>In a react component, normally you should not mutate props inside it. Also, the parent can only change the props, not the state directly. Based on these two facts, is it correct to assume that in any call of componentDidUpdate e.g.,</p>

<p>componentDidUpdate(prevProps: Readonly>, prevState: Readonly) </p>

<p>this.props could be different from prevProps, OR this.state could be different from prevState, but both situation cannot occur at the same time?</p>
","761861","","","","","2018-04-15 08:45:04","In React componentDidUpdate, can props and state change at the same time?","<javascript><reactjs><components>","1","0","","",""
"49895162","1","","","2018-04-18 08:47:37","","0","55","<p>window.print() doesn't seem to work in IE. I am using react.js with react-pdf library being used.</p>

<p>Below is my sample code:</p>

<pre><code>import { Document, Page } from ""react-pdf/build/entry.noworker"";

class PrintFile extends React.Component {
  constructor(props) {
    super(props);
  }

  componentDidUpdate() {
    window.print();
  }

  render() {
    const {
      pdfFile,
    } = this.props;
    return (
      &lt;DocumentTitle title={pdfFile.name}&gt;
        &lt;div id=""printable""&gt;
          &lt;Document
            file={pdfFile}
          &gt;
            ...
          &lt;/Document&gt;
        &lt;/div&gt;
      &lt;/DocumentTitle&gt;
    );
  }
}

PrintFile.propTypes = {
    pdfFile: PropTypes.object,
};

export default PrintFile;
</code></pre>

<p>I have removed the logic and just put the basic stuff required here..</p>

<p><a href=""https://www.npmjs.com/package/react-pdf"" rel=""nofollow noreferrer"">PDF Library Link</a></p>
","5218497","","","","","2018-04-18 08:47:37","window.print() not working in IE 11 using react.js with react-pdf library","<reactjs>","0","2","","",""
"50530634","1","","","2018-05-25 13:44:49","","0","132","<p>I am somewhat new to React. I've been working on a React project for some time but never messed with packages and dependencies. And I think this is what my issue is related to.</p>

<p>I have a project where I use Semantic-UI-React Menu + Router for navigation. Up until last night it worked fine. Then I ran <code>npm install</code> and everything started failing. I was digging into the specifics to find the root cause and identified that <code>&lt;Menu /&gt;</code> was causing the issue. So I created a new fresh app using the <strong>create-new-app</strong> package and confirmed that the newly created app worked. Then I added the <strong>semantic-ui-react</strong> package to it and confirmed that it worked properly. After that I tried to render <code>&lt;Menu /&gt;</code> again and saw the same issue that I was seeing in my project. I'm suspicious that something is up with the versions of the packages but I cannot figure out what it is.</p>

<p>The Node.js version is 10.0.0.</p>

<p>The npm version is 5.6.0.</p>

<p>Here is my package.json:</p>

<pre><code>{
    ""name"": ""my-app"",
    ""version"": ""0.1.0"",
    ""private"": true,
    ""dependencies"": {
        ""react"": ""^16.4.0"",
        ""react-dom"": ""^16.4.0"",
        ""react-scripts"": ""1.1.4"",
        ""semantic-ui-react"": ""^0.80.1""
    },
    ""scripts"": {
        ""start"": ""react-scripts start"",
        ""build"": ""react-scripts build"",
        ""test"": ""react-scripts test --env=jsdom"",
        ""eject"": ""react-scripts eject""
    }
}
</code></pre>

<p>Here is my App.js (the menu example is copied from semantic-ui-react reference as is):</p>

<pre><code>import React, { Component } from 'react';
import logo from './logo.svg';
import { Menu } from 'semantic-ui-react';
import './App.css';

const items = [
    { key: 'editorials', active: true, name: 'Editorials' },
    { key: 'review', name: 'Reviews' },
    { key: 'events', name: 'Upcoming Events' },
]

const MenuExampleProps = () =&gt; (
    &lt;Menu items={items} /&gt;
)

export default MenuExampleProps
</code></pre>

<p>When I run <code>yarn start</code>, I see this:</p>

<pre><code>1 of 2 errors on the page
TypeError: instance.render is not a function
finishClassComponent
node_modules/react-dom/cjs/react-dom.development.js:13085

  13082 | } else {
  13083 |   {
  13084 |     ReactDebugCurrentFiber.setCurrentPhase('render');
&gt; 13085 |     nextChildren = instance.render();
  13086 |     if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode &amp;&amp; workInProgress.mode &amp; StrictMode) {
  13087 |       instance.render();
  13088 |     }

updateClassComponent
node_modules/react-dom/cjs/react-dom.development.js:13047

  13044 |   } else {
  13045 |     shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
  13046 |   }
&gt; 13047 |   return finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime);
  13048 | }
  13049 | 
  13050 | function finishClassComponent(current, workInProgress, shouldUpdate, hasContext, renderExpirationTime) {

beginWork
node_modules/react-dom/cjs/react-dom.development.js:13715

  13712 | case FunctionalComponent:
  13713 |   return updateFunctionalComponent(current, workInProgress);
  13714 | case ClassComponent:
&gt; 13715 |   return updateClassComponent(current, workInProgress, renderExpirationTime);
  13716 | case HostRoot:
  13717 |   return updateHostRoot(current, workInProgress, renderExpirationTime);
  13718 | case HostComponent:

performUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js:15741

  15738 |   startBaseRenderTimer();
  15739 | }
  15740 | 
&gt; 15741 | next = beginWork(current, workInProgress, nextRenderExpirationTime);
  15742 | 
  15743 | if (workInProgress.mode &amp; ProfileMode) {
  15744 |   // Update ""base"" time if the render wasn't bailed out on.

workLoop
node_modules/react-dom/cjs/react-dom.development.js:15780

  15777 | if (!isAsync) {
  15778 |   // Flush all expired work.
  15779 |   while (nextUnitOfWork !== null) {
&gt; 15780 |     nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  15781 |   }
  15782 | } else {
  15783 |   // Flush asynchronous work until the deadline runs out of time.

callCallback
node_modules/react-dom/cjs/react-dom.development.js:100

   97 |   // nested call would trigger the fake event handlers of any call higher
   98 |   // in the stack.
   99 |   fakeNode.removeEventListener(evtType, callCallback, false);
&gt; 100 |   func.apply(context, funcArgs);
  101 |   didError = false;
  102 | }
  103 | 

invokeGuardedCallbackDev
node_modules/react-dom/cjs/react-dom.development.js:138

  135 | // Synchronously dispatch our fake event. If the user-provided function
  136 | // errors, it will trigger our global error handler.
  137 | evt.initEvent(evtType, false, false);
&gt; 138 | fakeNode.dispatchEvent(evt);
  139 | 
  140 | if (didError) {
  141 |   if (!didSetError) {

invokeGuardedCallback
node_modules/react-dom/cjs/react-dom.development.js:187

  184 |  * @param {...*} args Arguments for function
  185 |  */
  186 | invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
&gt; 187 |   invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);
  188 | },
  189 | 
  190 | /**

replayUnitOfWork
node_modules/react-dom/cjs/react-dom.development.js:15194

  15191 | // Replay the begin phase.
  15192 | isReplayingFailedUnitOfWork = true;
  15193 | originalReplayError = thrownValue;
&gt; 15194 | invokeGuardedCallback$2(null, workLoop, null, isAsync);
  15195 | isReplayingFailedUnitOfWork = false;
  15196 | originalReplayError = null;
  15197 | if (hasCaughtError()) {

renderRoot
node_modules/react-dom/cjs/react-dom.development.js:15840

  15837 | 
  15838 | var failedUnitOfWork = nextUnitOfWork;
  15839 | if (true &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) {
&gt; 15840 |   replayUnitOfWork(failedUnitOfWork, thrownValue, isAsync);
  15841 | }
  15842 | 
  15843 | // TODO: we already know this isn't true in some cases.

performWorkOnRoot
node_modules/react-dom/cjs/react-dom.development.js:16437

  16434 |   completeRoot(root, finishedWork, expirationTime);
  16435 | } else {
  16436 |   root.finishedWork = null;
&gt; 16437 |   finishedWork = renderRoot(root, expirationTime, false);
  16438 |   if (finishedWork !== null) {
  16439 |     // We've completed the root. Commit it.
  16440 |     completeRoot(root, finishedWork, expirationTime);

performWork
node_modules/react-dom/cjs/react-dom.development.js:16358

  16355 |   }
  16356 | } else {
  16357 |   while (nextFlushedRoot !== null &amp;&amp; nextFlushedExpirationTime !== NoWork &amp;&amp; (minExpirationTime === NoWork || minExpirationTime &gt;= nextFlushedExpirationTime)) {
&gt; 16358 |     performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);
  16359 |     findHighestPriorityRoot();
  16360 |   }
  16361 | }

performSyncWork
node_modules/react-dom/cjs/react-dom.development.js:16330

  16327 | }
  16328 | 
  16329 | function performSyncWork() {
&gt; 16330 |   performWork(Sync, false, null);
  16331 | }
  16332 | 
  16333 | function performWork(minExpirationTime, isAsync, dl) {

requestWork
node_modules/react-dom/cjs/react-dom.development.js:16230

  16227 | 
  16228 | // TODO: Get rid of Sync and use current time?
  16229 | if (expirationTime === Sync) {
&gt; 16230 |   performSyncWork();
  16231 | } else {
  16232 |   scheduleCallbackWithExpiration(expirationTime);
  16233 | }

scheduleWork$1
node_modules/react-dom/cjs/react-dom.development.js:16096

  16093 | !isWorking || isCommitting$1 ||
  16094 | // ...unless this is a different root than the one we're rendering.
  16095 | nextRoot !== root) {
&gt; 16096 |   requestWork(root, nextExpirationTimeToWorkOn);
  16097 | }
  16098 | if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) {
  16099 |   invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');

scheduleRootUpdate
node_modules/react-dom/cjs/react-dom.development.js:16663

  16660 |   }
  16661 |   enqueueUpdate(current, update, expirationTime);
  16662 | 
&gt; 16663 |   scheduleWork$1(current, expirationTime);
  16664 |   return expirationTime;
  16665 | }
  16666 | 

updateContainerAtExpirationTime
node_modules/react-dom/cjs/react-dom.development.js:16690

  16687 |     container.pendingContext = context;
  16688 |   }
  16689 | 
&gt; 16690 |   return scheduleRootUpdate(current, element, expirationTime, callback);
  16691 | }
  16692 | 
  16693 | function findHostInstance(component) {

updateContainer
node_modules/react-dom/cjs/react-dom.development.js:16717

  16714 |   var current = container.current;
  16715 |   var currentTime = recalculateCurrentTime();
  16716 |   var expirationTime = computeExpirationForFiber(currentTime, current);
&gt; 16717 |   return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
  16718 | }
  16719 | 
  16720 | function getPublicRootInstance(container) {

./node_modules/react-dom/cjs/react-dom.development.js/ReactRoot.prototype.render
node_modules/react-dom/cjs/react-dom.development.js:17000

  16997 |   if (callback !== null) {
  16998 |     work.then(callback);
  16999 |   }
&gt; 17000 |   updateContainer(children, root, null, work._onCommit);
  17001 |   return work;
  17002 | };
  17003 | ReactRoot.prototype.unmount = function (callback) {

legacyRenderSubtreeIntoContainer/&lt;
node_modules/react-dom/cjs/react-dom.development.js:17140

  17137 |     if (parentComponent != null) {
  17138 |       root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
  17139 |     } else {
&gt; 17140 |       root.render(children, callback);
  17141 |     }
  17142 |   });
  17143 | } else {

unbatchedUpdates
node_modules/react-dom/cjs/react-dom.development.js:16557

  16554 |       isUnbatchingUpdates = false;
  16555 |     }
  16556 |   }
&gt; 16557 |   return fn(a);
  16558 | }
  16559 | 
  16560 | // TODO: Batching should be implemented at the renderer level, not within

legacyRenderSubtreeIntoContainer
node_modules/react-dom/cjs/react-dom.development.js:17136

  17133 |   };
  17134 | }
  17135 | // Initial mount should not be batched.
&gt; 17136 | unbatchedUpdates(function () {
  17137 |   if (parentComponent != null) {
  17138 |     root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
  17139 |   } else {

render
node_modules/react-dom/cjs/react-dom.development.js:17195

  17192 |   return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
  17193 | },
  17194 | render: function (element, container, callback) {
&gt; 17195 |   return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
  17196 | },
  17197 | unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
  17198 |   !(parentComponent != null &amp;&amp; has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;

./src/index.js
src/index.js:7

   4 | import App from './App';
   5 | import registerServiceWorker from './registerServiceWorker';
   6 | 
&gt;  7 | ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
   8 | registerServiceWorker();
   9 | 
  10 | 

This screen is visible only in development. It will not appear if the app crashes in production.
Open your browser’s developer console to further inspect this error
</code></pre>
","3538088","","3538088","","2018-05-25 15:44:05","2018-05-26 08:29:04","semantic-ui-react Menu returns TypeError: instance.render is not a function","<javascript><reactjs><semantic-ui-react>","2","0","","",""
"50876815","1","","","2018-06-15 13:41:02","","0","23","<p>hi all im trying to use google-maps-react to display a simple map with markers ,but am getting a blank screen with no map for some reason. ALso am getting no errors in the console.
 I provided api key in the index.html file. Any my other google maps librarires are working fine.   ANy help is greatly appreciated ! 
 Rating.js </p>

<pre><code>import React, { Component } from 'react';
import styles from './App.css';
import Map from './Map.js';

import { GoogleApiWrapper } from 'google-maps-react'

import MapContainer from './Map.js'
export default class Rating extends React.Component {
    render(){
        return(


&lt;section classname=""feature""&gt;
          &lt;div id=""banner"" &gt;
            &lt;div classname=""banner__text""&gt;
              &lt;div classname=""l-container""&gt;
                &lt;h2 classname=""heading-1""&gt;
                  &lt;span id=""li""&gt;Take the uncertainty out of planning&lt;/span&gt;

                &lt;/h2&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;
                 &lt;h3 id=""fish""&gt; Never get lost finding the trail. With just one click, get the link right to the trail head. Access has never been so easy.&lt;/h3&gt;
                                  &lt;h3 id=""fish""&gt; Search for trails in any place you like ! Or use your current location to search!!!&lt;/h3&gt;
              &lt;/div&gt;

              &lt;div&gt;
            &lt;MapContainer google={this.props.google} /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div classname=""feature__main feature__main--centered l-container""&gt;
            &lt;div classname=""feature__device feature__device--laptop""&gt;
            &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt; &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;   &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt; &lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt; 
              &lt;div id=""device""&gt;
                &lt;img src=""http://www.downloadmaps.org/wp-content/uploads/2016/03/maps-laptop.jpg"" alt=""Trail Details Page""/&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;div classname=""l-inner-container""&gt;
              &lt;h2 classname=""feature__heading heading-3""&gt;Know the details before you go.&lt;/h2&gt;
              &lt;p&gt;Browse hand-curated trail maps as well as trail reviews, photos and activity recordings &lt;br&gt;&lt;/br&gt; contributed by a
                community of hikers, mountain bikers, trail runners and more.&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;


        );

   }
}
</code></pre>

<p>Map.js </p>

<pre><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom'


export default class MapContainer extends Component {

  // ======================
  // ADD LOCATIONS TO STATE
  // ======================
  state = {
    locations: [
      { name: ""New York County Supreme Court"", location: {lat: 40.7143033, lng: -74.0036919} },
      { name: ""Queens County Supreme Court"", location: {lat: 40.7046946, lng: -73.8091145} },
      { name: ""Kings County Supreme Court"", location: {lat: 40.6940226, lng: -73.9890967} },
      { name: ""Richmond County Supreme Court"", location: {lat: 40.6412336, lng: -74.0768597} },
      { name: ""Bronx Supreme Court"", location: {lat: 40.8262388, lng: -73.9235238} }
    ]
  }

  componentDidUpdate() {
    this.loadMap(); // call loadMap function to load the google map
  }

  loadMap() {
    if (this.props &amp;&amp; this.props.google) { // checks to make sure that props have been passed
      const {google} = this.props; // sets props equal to google
      const maps = google.maps; // sets maps to google maps props

      const mapRef = this.refs.map; // looks for HTML div ref 'map'. Returned in render below.
      const node = ReactDOM.findDOMNode(mapRef); // finds the 'map' div in the React DOM, names it node

      const mapConfig = Object.assign({}, {
        center: {lat: 40.7485722, lng: -74.0068633}, // sets center of google map to NYC.
        zoom: 11, // sets zoom. Lower numbers are zoomed further out.
        mapTypeId: 'roadmap' // optional main map layer. Terrain, satellite, hybrid or roadmap--if unspecified, defaults to roadmap.
      })

      this.map = new maps.Map(node, mapConfig); // creates a new Google map on the specified node (ref='map') with the specified configuration set above.

  // ==================
  // ADD MARKERS TO MAP
  // ==================
      this.state.locations.forEach( location =&gt; { // iterate through locations saved in state
        const marker = new google.maps.Marker({ // creates a new Google maps Marker object.
          position: {lat: location.location.lat, lng: location.location.lng}, // sets position of marker to specified location
          map: this.map, // sets markers to appear on the map we just created on line 35
          title: location.name // the title of the marker is set to the name of the location
        });
      })

    }
  }

  render() {
    const style = { // 
      width: '100%', // 9h screen. px also works.
      height: '100%' // 
    }

    return ( // in our return function h ref='map' and style.

      &lt;div ref=""map"" style={style}&gt;

        loading map...
      &lt;/div&gt;
    )
  }
}
</code></pre>
","6646194","","","","","2018-07-17 23:12:49","react.js google maps not shwoing up","<reactjs>","1","0","","",""
"50996256","1","","","2018-06-22 22:22:50","","0","24","<p>I'm trying to put React, Mapbox and d3 together. React for DOM manipulation, Mapbox for map rendering and d3 for drawing on the map. While I have gotten to the stage where I am able to draw a line on the map, I wanted to redraw the line when the user decides to zoom or move in the map. I am quite stuck, as I don't know exactly how to implement this event listener. Here is my code so far:</p>

<pre><code>import React, { Component } from 'react';
import MapboxGl from 'mapbox-gl/dist/mapbox-gl.js';
import MapPoints from './MapPoints.jsx';
import { geoMercator, geoPath, geoTransform, geoProjection } from 'd3-geo';
import './App.css';
import 'mapbox-gl/dist/mapbox-gl.css';

export default class Map extends Component {
    constructor(props) {
        super(props);
        this.d3Draw = [];
        this.box_measures = {
            bottom: 244,
            height: 220,
            left: 0,
            right: 1321,
            top: 24,
            width: 1321,
            x: 0,
            y: 24
        };
    }
    componentDidMount() {
        MapboxGl.accessToken =
            'pk.eyJ1Ijoiam9zZWNvdG8iLCJhIjoiY2l2OGZxZWNuMDAxODJ6cGdhcGFuN2IyaCJ9.7szLs0lc_2EjX6g21HI_Kg';

        this.map = new MapboxGl.Map({
            container: this.mapContainer,
            style: 'mapbox://styles/mapbox/streets-v9'
        });

        this.map.jumpTo({ center: [13.29, 52.51], zoom: 10 });
        this.map.addControl(new MapboxGl.NavigationControl());
        this.box_measures = document.getElementsByClassName('mapboxgl-canvas')[0].getBoundingClientRect();
    }

    componentWillUnmount() {
        this.map.remove();
    }

    componentDidUpdate() {
        this.d3Draw = this.props.dataPoints.map(x =&gt;
            this.map.project(new MapboxGl.LngLat(x.geometry.coordinates[0], x.geometry.coordinates[1]))
        );
    }

    render() {
        const style = {
            position: 'absolute',
            top: 100,
            bottom: 0,
            width: '80%'
        };

        return (
            &lt;div&gt;
                &lt;div className=""map"" style={style} ref={el =&gt; (this.mapContainer = el)} /&gt;
                &lt;MapPoints drawPoints={this.d3Draw} measures={this.box_measures} /&gt;
            &lt;/div&gt;
        );
    }
}
</code></pre>

<p>Your help will be greatly appreciated!</p>
","6463630","","","","","2018-06-22 22:22:50","Re rendering points when resizing map (mapbox + react + d3)","<javascript><reactjs><d3.js><mapbox-gl-js>","0","1","","",""
"51066954","1","","","2018-06-27 15:52:03","","1","54","<p>I'm trying to use fullcalendar-react-wrapper-scheduler in my project.</p>

<p>The documentation shows an example of passing events into the FullCalendar component, however it does not show how to pass in resources.</p>

<p>I'm attempting to pass in ""resources"" by mimicking how ""events"" are being passed in. But that does not display any resources on the DOM. </p>

<p>Has anyone successfully used this package that can provide guidance for passing in resources?</p>

<p>Documentation:
<a href=""https://www.npmjs.com/package/fullcalendar-reactwrapper-scheduler#examples"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/fullcalendar-reactwrapper-scheduler#examples</a></p>

<p>Here's a code snippet showing how I am passing in events (successfully) and resources (not successfully):
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, { Component } from 'react';
import ReactDOM from 'react-dom';

import { connect } from 'react-redux';

import Nav from '../../components/Nav/Nav';



import { USER_ACTIONS } from '../../redux/actions/userActions';

import { LOGIN_ACTIONS } from '../../redux/actions/loginActions';



//START CALENDAR LIBRARY IMPORTS//
import FullCalendar from 'fullcalendar-reactwrapper-scheduler';
import 'fullcalendar-reactwrapper-scheduler/dist/css/fullcalendar.min.css';
//END CALENDAR LIBRARY IMPORTS//



const mapStateToProps = state =&gt; ({
    user: state.user,
});

class ExampleComponent extends Component {
    constructor(props) {
        super(props);
        this.state = {
            events: [
                {
                    resourceId: 'a',
                    id: 1,
                    title: 'Shoot 1',
                    start: '2017-06-27T08:00:00',
                    end: '2017-06-27T09:00:00'
                },
                {
                    resourceId: 'b',
                    id: 2,
                    title: 'Shoot 2',
                    start: '2017-06-27T10:00:00',
                    end: '2017-06-27T11:00:00'
                },
                {
                    resourceId: 'a',
                    id: 3,
                    title: 'Shoot 3',
                    start: '2017-06-27T13:00:00',
                    end: '2017-06-27T14:00:00'
                },
                {
                    resourceId: 'c',
                    id: 4,
                    title: 'Shoot 4',
                    start: '2017-06-27T08:00:00',
                    end: '2017-06-27T09:00:00'
                },
                {
                    resourceId: 'd',
                    id: 5,
                    title: 'Shoot 5',
                    start: '2017-06-27T012:00:00',
                    end: '2017-06-27T13:00:00'
                },
            ],
            resources: [
                { id: 'a', title: 'Room A' },
                { id: 'b', title: 'Room B' },
                { id: 'c', title: 'Room C' },
                { id: 'd', title: 'Room D' },
            ]
        }
    }

    componentDidMount() {
        this.props.dispatch({
            type: USER_ACTIONS.FETCH_USER
        });
    }

    componentDidUpdate() {
        if (!this.props.user.isLoading &amp;&amp; this.props.user.userName === null) {
            this.props.history.push('home');
        }
    }

    logout = () =&gt; {
        this.props.dispatch({
            type: LOGIN_ACTIONS.LOGOUT
        });
        // this.props.history.push('home');
    }

    render() {
        let content = null;

        if (this.props.user.userName) {
            content = (
                &lt;div id=""example-component""&gt;
                    &lt;FullCalendar
                        id=""your-custom-ID""
                        header={{
                            left: 'prev,next today myCustomButton',
                            center: 'title',
                            right: 'month,basicWeek,basicDay'
                        }}
                        defaultDate={'2017-06-27'}
                        navLinks={true} // can click day/week names to navigate views
                        editable={true}
                        eventLimit={true} // allow ""more"" link when too many events
                        events={this.state.events}
                        resources={this.state.resources}
                        defaultView='agendaDay'

                    /&gt;
                &lt;/div&gt;
            );
        }

        return (
            &lt;div&gt;
                &lt;Nav /&gt;
                {content}
            &lt;/div&gt;
        );
    }
}

// this allows us to use &lt;App /&gt; in index.js
export default connect(mapStateToProps)(ExampleComponent);</code></pre>
</div>
</div>
</p>
","10000930","","","","","2018-06-27 16:09:25","fullcalendar react wrapper scheduler passing events","<reactjs><wrapper><fullcalendar-scheduler>","1","0","","",""
"49825323","1","49825426","","2018-04-13 21:24:30","","1","124","<h1>Summary</h1>

<ol>
<li>I created a custom HOC that checks for a user being authenticated by checking if the redux store has a user.id property</li>
<li>I am using react navigation and react native</li>
<li>When I wrap my screen component in my HOC, the navigation header appears but is blanked out (and conversely if I DON'T wrap my screen component in my HOC, the navigation header appears properly)</li>
<li>There is also react-redux connect in the mix in both the HOC and the wrapped component and I'm wondering if that is making things break</li>
</ol>

<p>Why is my react navigation header not showing properly when I wrap the screen component in my custom HOC?</p>

<p>I wonder if I'm wrapping things in the wrong order--these are the possibly offending lines of code from the screen component (one or the other is commented out when I'm testing):</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// export default connect(mapStateToProps, mapDispatchToProps)(EntityPage); &lt;--this renders the header fine

  export default connect(mapStateToProps, mapDispatchToProps)(withAuthentication(EntityPage)); &lt;--this renders the header blank</code></pre>
</div>
</div>
</p>

<h1>Code</h1>

<h2>Custom HOC I made that checks for authentication</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import React, {
  Component
} from 'react';
import PropTypes from 'prop-types';
import {
  Alert
} from 'react-native';
import {
  connect
} from 'react-redux';

function withAuthentication(Comp) {
  class AuthenticatedScreen extends Component {
    componentDidUpdate(prevProps) {
      if (this.props.user &amp;&amp; !this.props.user.id) {
        Alert.alert('you\'re not logged in anymore');
      }
    }

    render() {
      return &lt;Comp { ...this.props
      }
      /&gt;;
    }
  }

  function mapStateToProps(state) {
    return {
      user: state.user,
    };
  }

  AuthenticatedScreen.propTypes = {
    user: PropTypes.object,
    component: PropTypes.object,
  };

  return connect(mapStateToProps)(AuthenticatedScreen);
}

export default withAuthentication;</code></pre>
</div>
</div>
</p>

<h2>Screen component I am wrapping with custom authentication HOC</h2>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import withAuthentication from '../User/AuthorizedHOC'; &lt;--my custom HOC import

class EntityPage extends Component {
    static navigationOptions = ({navigation}) =&gt; {
      return {
        title: 'My Entities',
        headerRight: (
&gt;&gt;        &lt;Button type='action' title='Add New Entity' onPress={()=&gt;navigation.navigate('EntityCreate')}&gt;
          &lt;/Button&gt;),
        headerStyle: {paddingRight: (Platform.OS === 'ios') ? 0 : 8},
      };
    };

    componentDidMount() {
      this.props.loadEntities();
    }

    render() {
      const {
        entities,
      } = this.props;

      return (
        &lt;FullscreenView&gt;
          &lt;EntityList entities={entities}/&gt;
        &lt;/FullscreenView&gt;
      );
    }
  }

  function mapStateToProps(state) {
    return {
      entities: getSortedEntityList(state),
        };
  }

  function mapDispatchToProps(dispatch) {
    return {
      loadEntities: () =&gt; dispatch(loadEntities()),
      deleteEntity: (entity) =&gt; dispatch(deleteEntity(entity)),
    };
  }

  // export default connect(mapStateToProps, mapDispatchToProps)(EntityPage); &lt;--this renders the header fine

  export default connect(mapStateToProps, mapDispatchToProps)(withAuthentication(EntityPage)); &lt;--this renders the header blank</code></pre>
</div>
</div>
</p>
","1750195","","","","","2018-04-13 22:10:14","react navigation header for StackNavigator screen doesn't render if screen wrapped in HOC","<reactjs><react-native><stack><react-navigation>","1","0","","",""
"49854097","1","49854153","","2018-04-16 09:38:19","","1","55","<p>I'm trying to fetch data from a public API with Axios, and display what I get through a React app. But I can't find a condition in my componentDidUpdate() to make it render only once, when the user modifies input. Anyone'd have an idea ?</p>

<p>Here's my code :</p>

<pre><code>import React, { Component } from 'react';
import axios from ""axios"";
import './App.css';

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      input: """",
      output: []
    }
  }

  componentDidUpdate() {
    axios.get(`https://geo.api.gouv.fr/communes?nom=${this.state.input}`)
      .then(response =&gt; {
        this.setState((prevState) =&gt; {
          if (prevState.input !== this.state.input) {
            return { output: response.data };
          }
        });
      })
      .catch(function (error) {
        console.log(error);
      })
  }

  handleInput = (event, input) =&gt; {
    this.setState({input: event.target.value});
  }

  render() {
    return (
      &lt;React.Fragment&gt;
        &lt;label&gt;Recherche : &lt;input type=""text"" onChange={this.handleInput} /&gt;&lt;/label&gt;
        &lt;div&gt;
          {this.state.output.map((value, index) =&gt; &lt;p key={index}&gt;{value.nom}&lt;/p&gt;)}
        &lt;/div&gt;
      &lt;/React.Fragment&gt;
    );
  }
}

export default App;
</code></pre>

<p>Thanks for helping.</p>
","8258216","","","","","2018-04-16 12:45:27","Can't get componentDidUpdate() stop looping","<javascript><reactjs><axios>","5","1","","",""
"50591533","1","","","2018-05-29 19:23:46","","0","41","<p>I am very new to jest so i don't know how to proceed with jest. I have write test case using jest for input on change and button click for the below component. But it failed. issue with  'Method “props” is only meant to be run on a single node. 0 found instead.' please help me</p>

<p>code: </p>

<pre><code>import React from 'react';
import { Col } from 'react-bootstrap';

class FITB extends React.Component {
  constructor(props) {
    super(props);
    this.String = String;
    this.defaultTextSize = 8;
    this.state = {
      inputList: [],
      splitList: [],
      count: 0,
      isValid: false
    };
    this.onInputChange = this.onInputChange.bind(this);
    this.onClickSend = this.onClickSend.bind(this);
    this.checkInputValidations = this.checkInputValidations.bind(this);
  }

  componentDidMount() {
    this.initialize();
  }

  onInputChange(index) {
    return (event) =&gt; {
      const inputList = this.state.inputList;
      let isValid = true;
      inputList[index] = event.target.value;
      if (!this.isValidInput(inputList[index])) {
        isValid = false;
      }
      this.setState({
        inputList,
        isValid
      });
      // console.log('onInputChange fib state', this.state);
    };
  }

  onClickSend() {
    const {
      splitList,
      inputList,
      count
    } = this.state;
    // console.log('onClickSend fib before state', this.state);
    const onReply = this.props.onReply;
    let fullText = '';
    splitList.map((text, index) =&gt; {
      fullText += text;
      if ((index &lt; count - 1) &amp;&amp; inputList[index]) {
        fullText += inputList[index];
      }
      return true;
    });

    if (onReply) {
      onReply(fullText);
    }
    // console.log('onClickSend fib after state', this.state);
  }

  isValidInput(text) {
    const regex = /^[\u0020-\u007e]*$/;
    const replaceChar160RegExp = new RegExp(this.String.fromCharCode(160), 'g');
    return regex.test(text.replace(replaceChar160RegExp, ' '));
  }

  initialize() {
    let text = '';
    this.props.messages.map((element) =&gt; {
      if (element.type &amp;&amp; (typeof element.type === 'string') &amp;&amp; (element.type === 'FILL_IN_THE_BLANK')) {
        text = element.message;
      }
      // console.log('inside fib', text);
      return text;
    });
    const splitList = text.split(/_+/g);
    this.setState({
      splitList,
      count: splitList.length
    });
    // console.log('init fib state', this.state);
  }

  checkInputValidations() {
    const {
      inputList,
      count,
      isValid
    } = this.state;
    let i;
    let flag = false;
    for (i = 0; i &lt; count - 1; i += 1) {
      if (!inputList[i] || inputList[i].trim() === '') {
        flag = true;
      }
    }
    // console.log('checkInputValidations', this.state);
    return flag || !isValid;
  }

  render() {
    const {
      splitList,
      count,
      inputList
    } = this.state;
    // console.log('reder fitb', this.state);
    return (
      &lt;Col lg={12} className=""rply-block""&gt;
        &lt;Col lg={11} className=""textarea-block""&gt;
          &lt;div className=""fitb-wrap""&gt;
            { splitList &amp;&amp; splitList.map((item, index) =&gt; (
              &lt;span&gt;
                &lt;span className=""fitb-text""&gt;{item}&lt;/span&gt;
                { (index &lt; count - 1) &amp;&amp; (
                  &lt;input
                    className=""fitb-input""
                    type=""text""
                    maxLength=""40""
                    size={(inputList[index] &amp;&amp; inputList[index].length &gt; this.defaultTextSize &amp;&amp; inputList[index].length) || this.defaultTextSize}
                    value={inputList[index]}
                    onChange={this.onInputChange(index)}
                    autoFocus={index === 0}
                    aria-describedby={count &gt; 1 ? `Missing word ${index + 1} of ${count - 1}` : 'Missing word'}
                    aria-label=""Fill in missing words""
                  /&gt;
                )}
              &lt;/span&gt;
            ))}
          &lt;/div&gt;
        &lt;/Col&gt;
        &lt;Col lg={1} className=""""&gt;
          &lt;button
            className=""btn-info-dm""
            role=""button""
            tabIndex=""0""
            onClick={this.onClickSend}
            disabled={this.checkInputValidations()}
          &gt;Send&lt;/button&gt;
        &lt;/Col&gt;
      &lt;/Col&gt;
    );
  }
}

FITB.propTypes = {
  onReply: React.PropTypes.isRequired,
  messages: React.PropTypes.array
};

export default FITB;
</code></pre>

<p>test files for the input and button click</p>

<pre><code>import React from 'react';
import FITB from '../components/dialogManager/fitb';
import { shallow } from 'enzyme';
import renderer from 'react-test-renderer';

describe('FITB', () =&gt; {
  let component;
  const mockFn = jest.fn();
  beforeEach(() =&gt; {
    component = shallow(&lt;FITB onReply={mockFn} /&gt;);
  });
  test('Should initialize the FITB content', () =&gt; {
    expect(component.find('.rply-block')).toHaveLength(1);
  });

  test('Should have been called send', () =&gt; {
    component.find('.btn-info-dm').simulate('click');
    expect(mockFn).toHaveBeenCalled();
  });
  test('Should render the text box', () =&gt; {
    expect(component.state().inputList).toEqual([]);
    expect(component.state().isValid).toEqual(false);
    // expect(component.find('input.fitb-input')).toBeDefined();
    console.log('state== ', component.state());
    console.log('input == ', component.find('.fitb-input'));
    component.find('.fitb-input').simulate('change', { target: { value: 'Qualitative data includes detailed interviews, direct _____, and historical records.' } });
    console.log('fitb-input onchange== ', component.find('.fitb-input'));
    expect(component.state().inputList).toEqual('Qualitative data includes detailed interviews, direct _____, and historical records.');
    expect(component.state().isValid).toEqual(true);
  });
  // test('Should check the input label', () =&gt; {
  //   const expectedFitbTextLabel = 'Fill in missing words';
  //   const fitbTextList = [];
  //   console.log('span fitb txt== ', component.find('.fitb-text').instance().label);
  //   component.find('.fitb-text').map((elem) =&gt; {
  //     fitbTextList.push(elem.text().trim());
  //   });
  //   expect(component.find('.fitb-text').instance().label).toEqual(expectedFitbTextLabel);
  // });
  test('Should render the fitbText ', () =&gt; {
    const expectedFitbText = 'Qualitative data includes detailed interviews, direct _____, and historical records.';
    const fitbTextList = [];
    console.log('span fitb txt== ', component.find('.fitb-text').text());
    // fitbTextList.push(expectedFitbText.split(/_+/g));
    // console.log('fitbTextList= ', fitbTextList);
    component.find('.fitb-text').map((elem) =&gt; {
      fitbTextList.push(elem.text().trim());
    });
    expect(fitbTextList).toEqual(expectedFitbText);
  });
  test('Should check the fitbText ', () =&gt; {
    const expectedFitbText = 'Qualitative data includes detailed interviews, direct _____, and historical records.';
    const fitbTextList = [];
    fitbTextList.push(expectedFitbText.split(/_+/g));
    expect(component.state().inputList).toEqual([]);
    console.log('input list init== ', component.state().inputList);
    component.find('input.fitb-input').simulate('change', { target: { value: 'test' } });
    console.log('input list== ', component.state().inputList);
    // component.find('input').instance().onInputChange(0);
    // expect(component.state().inputList).toEqual('test');
  });
});
</code></pre>

<p>for the another component on button click to send the details</p>

<pre><code>import React from 'react';

class ReplyButtons extends React.Component {
  constructor(props) {
    super(props);
    this.replyBtnWrap = '';
    this.replyBtnList = '';
    this.state = {
      list: [],
      isLeftArrowEnabled: false,
      isRightArrowEnabled: false
    };

    this.onClickLeftArrow = this.onClickLeftArrow.bind(this);
    this.onClickRightArrow = this.onClickRightArrow.bind(this);
    this.onClickReplyBtn = this.onClickReplyBtn.bind(this);
  }

  componentDidMount() {
    this.initializeList();
  }

  componentDidUpdate() {
    this.checkElementOffset();
  }

  onClickRightArrow() {
    const wrapElement = this.replyBtnWrap;
    const listElement = this.replyBtnList;
    const wrapWidth = wrapElement.offsetWidth;
    const listWidth = listElement.offsetWidth;
    let listLeft = wrapElement.scrollLeft;
    let listOverflowWidth = 0;
    listLeft += 400;
    listOverflowWidth = listWidth - listLeft;
    if (listOverflowWidth &lt; 0) {
      listLeft = listWidth - wrapWidth;
    }
    wrapElement.scrollLeft = listLeft;
    this.checkElementOffset();
  }

  onClickLeftArrow() {
    const wrapElement = this.replyBtnWrap;
    let listLeft = wrapElement.scrollLeft;

    listLeft -= 400;

    if (listLeft &lt; 0) {
      listLeft = 0;
    }
    wrapElement.scrollLeft = listLeft;
    this.checkElementOffset();
  }

  onClickReplyBtn(item) {
    return () =&gt; {
      const onReply = this.props.onReply;
      if (onReply) {
        onReply(item);
      }
    };
  }

  checkElementOffset() {
    const wrapElement = this.replyBtnWrap;
    const listElement = this.replyBtnList;
    const wrapWidth = wrapElement.offsetWidth;
    const listWidth = listElement.offsetWidth;
    const listLeft = wrapElement.scrollLeft;
    let listOverflowWidth = 0;
    let isLeftArrowEnabled = false;
    let isRightArrowEnabled = false;
    if (listLeft &gt; 0) {
      isLeftArrowEnabled = true;
    }
    listOverflowWidth = listWidth - listLeft - wrapWidth;
    if (listOverflowWidth &gt; 0) {
      isRightArrowEnabled = true;
    }
    if (this.state.isLeftArrowEnabled !== isLeftArrowEnabled || this.state.isRightArrowEnabled !== isRightArrowEnabled) {
      this.setState({
        isLeftArrowEnabled,
        isRightArrowEnabled
      });
    }
  }

  initializeList() {
    // this.setState({
    //   list: [{
    //     type: 'MENU_ITEM',
    //     text: 'what is quantitative research?',
    //     return_value: 'what is quantitative research?'
    //   }, {
    //     type: 'MENU_ITEM',
    //     text: 'what is mixed method research?',
    //     return_value: 'what is mixed method research?'
    //   }, {
    //     type: 'MENU_ITEM',
    //     text: 'what is qualitative research?',
    //     return_value: 'what is qualitative research?'
    //   }, {
    //     type: 'MENU_ITEM',
    //     text: 'I had a different question',
    //     return_value: 'I had a different question'
    //   }, {
    //     type: 'MENU_ITEM',
    //     text: 'That was actually my answer',
    //     return_value: 'That was actually my answer'
    //   }]
    // });
    const replyButtonText = [];
    // console.log('reply btns props = ', this.props);
    if (this.props.messages) {
      this.props.messages.map((element) =&gt; {
        if (element.type &amp;&amp; (typeof element.type === 'string') &amp;&amp; (element.type === 'MENU_ITEM')) {
          replyButtonText.push(element);
        }
        return this.setState({ list: replyButtonText });
      });
    }
  }

  render() {
    const btnList = this.state.list;
    const {
      isLeftArrowEnabled,
      isRightArrowEnabled
    } = this.state;
    return (
      &lt;div className=""r-wrap""&gt;
        { isLeftArrowEnabled &amp;&amp; (
          &lt;button className=""r-btn-left-arrow"" onClick={this.onClickLeftArrow} role=""button"" tabIndex=""0""&gt;
            &lt;i className=""glyphicon glyphicon-menu-left"" /&gt;
          &lt;/button&gt;
        )}
        &lt;div className=""r-btn-wrap"" ref={(e) =&gt; { this.replyBtnWrap = e; }}&gt;
          &lt;div className=""r-btn-list"" ref={(e) =&gt; { this.replyBtnList = e; }}&gt;
            {
              btnList &amp;&amp; btnList.map(btnItem =&gt; &lt;button
                className=""r-btn""
                role=""button""
                tabIndex=""0""
                onClick={this.onClickReplyBtn(btnItem)}
                title={btnItem.text}
              &gt;{btnItem.text}&lt;/button&gt;)
            }
          &lt;/div&gt;
        &lt;/div&gt;
        { isRightArrowEnabled &amp;&amp; (
          &lt;button className=""r-btn-right-arrow"" onClick={this.onClickRightArrow} role=""button"" tabIndex=""0""&gt;
            &lt;i className=""glyphicon glyphicon-menu-right"" /&gt;
          &lt;/button&gt;
        )}
      &lt;/div&gt;
    );
  }
}

ReplyButtons.propTypes = {
  onReply: React.PropTypes.isRequired,
  messages: React.PropTypes.array
};

export default ReplyButtons;
</code></pre>

<p>test file:</p>

<pre><code>import React from 'react';
import ReplyButtons from '../components/dialogManager/replybuttons';
import { shallow } from 'enzyme';
import renderer from 'react-test-renderer';

const mockOutputObj = [{
  type: 'MENU_ITEM',
  text: 'what is quantitative research?',
  return_value: 'what is quantitative research?'
}, {
  type: 'MENU_ITEM',
  text: 'what is mixed method research?',
  return_value: 'what is mixed method research?'
}];

describe('ReplyButtons', () =&gt; {
  let component;
  const mockFn = jest.fn();
  beforeEach(() =&gt; {
    component = shallow(&lt;ReplyButtons onReply={mockFn} /&gt;);
  });

  test('Should initialize the ReplyButtons content', () =&gt; {
    expect(component.find('.r-wrap')).toHaveLength(1);
  });

  test('Should check the ReplyButtons click', () =&gt; {
    console.log('r-btn==&gt; ', component.find('button.r-btn'));
    component.find('.r-btn').simulate('click');
    expect(mockFn).toHaveBeenCalled();
  });
});
</code></pre>

<p>Please help me.</p>
","2119252","","","","","2018-05-31 21:03:40","jest test case for input change and button in reactjs","<java><reactjs><sinon><jest>","1","1","","",""
"50665943","1","","","2018-06-03 11:34:11","","0","37","<p>I used an editable data Table of prime-react , and it worked mouse click. But Problem is tab key not work.I want to enable editable mode one cell to another cell using tab key. I use Prime react version 1.4.0</p>

<p>A full code are given below:-</p>

<p><strong>index.js</strong> 
 <em>where my editable table code contains</em></p>

<pre><code>import React from 'react';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import { FormattedMessage } from 'react-intl';
import { createStructuredSelector } from 'reselect';
import { compose } from 'redux';
import injectSaga from 'utils/injectSaga';
import injectReducer from 'utils/injectReducer';
import reducer from './reducer';
import saga from './saga';
import messages from './messages';
import { Messages } from 'primereact/components/messages/Messages';
import { Growl } from 'primereact/components/growl/Growl';
import { Panel } from 'primereact/components/panel/Panel';
import { Button } from 'primereact/components/button/Button';
import { DataTable } from 'primereact/components/datatable/DataTable';
import { Column } from 'primereact/components/column/Column';
import { InputText } from 'primereact/components/inputtext/InputText';
import { Dropdown } from 'primereact/components/dropdown/Dropdown';
import CustomDataTable from 'components/CustomDataTable';
import { makeSelectSelectedStudent, makeSelectSectionName, makeSelectStudentUpdateBasicInformation, makeSelectSectionList, makeSelectStdBasicInfo, makeSelectEditorStudent, makeSelectSetMessage, makeSelectSetErrMessage, makeSelectLoaderOff, makeSelectLoaderOn } from './selectors';
import { selectStudent, setEditorData, submitUpdate, getMessage, getErrMessage, submitForm, changeSectionName, getLoaderOn, getLoaderOff } from './actions';
import AppPrivateLayout from '../AppPrivateLayout';

export class StudentUpdateBasicInformation extends React.Component {
  componentDidUpdate() {
    this.props.changeMessage('');
  }

  rollBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.studentRoll} /&gt;;
  }

  nameBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.studentName} /&gt;;
  }

  fatherNameBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.fatherName} /&gt;;
  }

  motherNameBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.motherName} /&gt;;
  }

  contactBody(rowData) {
    return &lt;InputText type=""text"" value={rowData.guardianMobile} /&gt;;
  }

  genderBody(rowData) {
    let gender = [
      { label: 'Male', value: 'Male' },
      { label: 'Female', value: 'Female' },
      { label: 'Others', value: 'Others' }
    ];

    return &lt;Dropdown value={rowData.studentGender} options={gender} style={{ width: '100%' }} placeholder=""Select"" /&gt;
  }

  religionBody(rowData) {
    let religion = [
      { label: 'Islam', value: 'Islam' },
      { label: 'Hindu', value: 'Hindu' },
      { label: 'Buddhist', value: 'Buddhist' },
      { label: 'Christian', value: 'Christian' },
      { label: 'Others', value: 'Others' }
    ];
    return &lt;Dropdown value={rowData.studentReligion} options={religion} style={{ width: '100%' }} placeholder=""Select"" /&gt;
  }

  bloodBody(rowData) {
    let blood = [
      { label: 'A+', value: 'A+' },
      { label: 'A-', value: 'A-' },
      { label: 'B+', value: 'B+' },
      { label: 'B-', value: 'B-' },
      { label: 'O+', value: 'O+' },
      { label: 'O-', value: 'O-' }

    ];
    return &lt;Dropdown value={rowData.bloodGroup} options={blood} style={{ width: '100%' }} placeholder=""Select"" /&gt;
  }

  render() {
    let rollEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Roll"" value={row.rowData.studentRoll} /&gt;
    }

    let nameEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Student name"" value={row.rowData.studentName} /&gt;
    }

    let fatherNameEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Father name"" value={row.rowData.fatherName} /&gt;
    }

    let motherNameEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Mother name"" value={row.rowData.motherName} /&gt;
    }

    let contactEditor = (row) =&gt; {
      return &lt;InputText onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.target.value); }} placeholder=""Contact Number"" value={row.rowData.guardianMobile} /&gt;
    }

    let genderEditor = (row) =&gt; {
      let gender = [
        { label: 'Male', value: 'Male' },
        { label: 'Female', value: 'Female' },
        { label: 'Others', value: 'Others' }
      ];

      return &lt;Dropdown value={row.rowData.gender} options={gender} onChange={(evt) =&gt; this.props.onEditorValueChange(row, evt.value)} style={{ width: '100%' }} placeholder=""Select"" /&gt;
    }

    let religionEditor = (row) =&gt; {
      let religion = [
        { label: 'Islam', value: 'Islam' },
        { label: 'Hindu', value: 'Hindu' },
        { label: 'Buddhist', value: 'Buddhist' },
        { label: 'Christian', value: 'Christian' },
        { label: 'Others', value: 'Others' }
      ];
      return &lt;Dropdown value={row.rowData.religion} options={religion} onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.value); }} style={{ width: '100%' }} placeholder=""Select"" /&gt;
    }

    let bloodEditor = (row) =&gt; {
      let blood = [
        { label: 'A+', value: 'A+' },
        { label: 'A-', value: 'A-' },
        { label: 'B+', value: 'B+' },
        { label: 'B-', value: 'B-' },
        { label: 'O+', value: 'O+' },
        { label: 'O-', value: 'O-' }

      ];
      return &lt;Dropdown value={row.rowData.blood} options={blood} onChange={(evt) =&gt; { this.props.onEditorValueChange(row, evt.value); }} style={{ width: '100%' }} placeholder=""Select"" /&gt;
    }

    let msg = """";
    if (this.props.setMessage) {
      msg = { severity: 'success', detail: this.props.setMessage.message };
      this.growl.show(msg);
    }
    else if (this.props.setErrMessage) {
      msg = { severity: 'error', summary: 'Failed', detail: this.props.setErrMessage };
      this.growl.show(msg);
    }
    if(this.props.loaderOn){
      if(this.props.loaderOn === 'On') {
      $('.loaderDiv').show();
    } else if(this.props.loaderOn === 'Off'){
      $('.loaderDiv').hide();
    }
  }
    let content = '';
    if (this.props.stdBasicInfo &amp;&amp; this.props.stdBasicInfo.length) {
      $('#UpdateBtnID').show();
      let selectedStudentArr = [];
      if (this.props.selectedStudent.length) {
        Array.prototype.push.apply(selectedStudentArr, this.props.selectedStudent);
      }
      let columnData = [
        &lt;Column selectionMode=""multiple"" header=""Mark"" style={{ width: '3em' }} /&gt;,
        &lt;Column field=""studentRoll"" header=""Roll No."" editor={rollEditor} body={this.rollBody} style={{ width: '55px' }} /&gt;,
        &lt;Column field=""studentName"" header=""Name"" editor={nameEditor} body={this.nameBody} style={{ width: '170px' }} /&gt;,
        &lt;Column field=""fatherName"" header=""Father Name"" editor={fatherNameEditor} body={this.fatherNameBody} style={{ width: '145px' }} /&gt;,
        &lt;Column field=""motherName"" header=""Mother Name"" editor={motherNameEditor} body={this.motherNameBody} style={{ width: '145px' }} /&gt;,
        &lt;Column field=""guardianMobile"" header=""Contact No."" editor={contactEditor} style={{ width: '100px' }} body={this.contactBody} /&gt;,
        &lt;Column field=""studentGender"" header=""Gender"" editor={genderEditor} body={this.genderBody} style={{ width: '85px' }} /&gt;,
        &lt;Column field=""studentReligion"" header=""Religion"" editor={religionEditor} body={this.religionBody} style={{ width: '85px' }} /&gt;,
        &lt;Column field=""bloodGroup"" header=""Blood Group"" editor={bloodEditor} style={{ width: '80px' }} body={this.bloodBody} /&gt;
      ];
      content = &lt;CustomDataTable
        info={this.props.stdBasicInfo}
        onSelectionChange={this.props.onSelectionChange}
        selectedData={selectedStudentArr}
        columnData={columnData}
        isSelectionOn={true}
        editable={true}
        header={'Student List'}
        rows={10}
      /&gt;
    }

    //FOR SECTION LIST
    let sectionListOptions = [];
    if (this.props.sectionList &amp;&amp; this.props.sectionList.length) {
      sectionListOptions = this.props.sectionList.map((item) =&gt; ({
        value: item.classConfigId,
        label: item.classShiftSection,
      }))
    }

    return (
      &lt;div&gt;
        &lt;AppPrivateLayout&gt;
        &lt;Panel header=""Student Information Update""&gt;
          &lt;form method=""post"" onSubmit={this.props.onSubmitForm} &gt;
            &lt;div className='ui-g form-group'&gt;

              &lt;div className='ui-g-2 ui-lg-2 ui-md-2'&gt;&lt;/div&gt;
              &lt;div className='ui-g-2 ui-lg-2 ui-md-2 ui-sm-12 netiLabel'&gt;
                &lt;label&gt; Section &lt;span className=""required""&gt; * &lt;/span&gt;&lt;/label&gt;
              &lt;/div&gt;
              &lt;div className='ui-g-3 ui-lg-3 ui-md-4 ui-sm-12 ui-fluid'&gt;
                &lt;Dropdown value={this.props.sectionname} onChange={this.props.onChangeSectionList} options={sectionListOptions} placeholder=""Select Section"" autoWidth={false} /&gt;
              &lt;/div&gt;
              &lt;div className='ui-g-2 ui-lg-2 ui-md-3 ui-sm-12 ui-fluid'&gt;
                &lt;Button icon=""ui-icon-search"" title=""Search"" label='Search'&gt;&lt;/Button&gt;
              &lt;/div&gt;
              &lt;div className='ui-g-2 ui-lg-2 ui-fluid'&gt;&lt;/div&gt;
            &lt;/div&gt;
          &lt;/form&gt;
          {content}
          &lt;div className='ui-g'&gt;
            &lt;Growl ref={(el) =&gt; this.growl = el} /&gt;
            &lt;div className='ui-g-4 ui-lg-4 ui-md-4 ui-sm-12 ui-fluid'&gt;

            &lt;/div&gt;
            &lt;div className='ui-g-6 ui-lg-6 ui-md-5 ui-sm-12 ui-fluid'&gt;&lt;/div&gt;
            &lt;div className='ui-g-2 ui-lg-2 ui-md-3 ui-sm-12 ui-fluid'&gt;
              &lt;Button id=""UpdateBtnID"" style={{ display: 'none' }} onClick={this.props.onUpdate} icon='ui-icon-autorenew' label='Update'&gt;&lt;/Button&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/Panel&gt;
        &lt;div class=""loaderDiv"" style={{display: 'none'}}&gt;
            &lt;img className=""sticky"" src=""https://loading.io/spinners/harmony/lg.harmony-taiji-spinner.gif"" /&gt;
          &lt;/div&gt;
        &lt;/AppPrivateLayout&gt;
      &lt;/div&gt;
    );
  }
}

StudentUpdateBasicInformation.propTypes = {
  stdBasicInfo: PropTypes.any,
  onSubmitForm: PropTypes.func,
  onEditorValueChange: PropTypes.func,
  value: PropTypes.any,
  onUpdate: PropTypes.func,
  setMessage: PropTypes.any,
  setErrMessage: PropTypes.any,
  changeMessage: PropTypes.func,
  sectionList: PropTypes.any,
  onChangeSectionList: PropTypes.func,
  sectionname: PropTypes.any,
  loaderOn: PropTypes.any,
};

const mapStateToProps = createStructuredSelector({
  stdBasicInfo: makeSelectStdBasicInfo(),
  selectedStudent: makeSelectSelectedStudent(),
  value: makeSelectEditorStudent(),
  setMessage: makeSelectSetMessage(),
  setErrMessage: makeSelectSetErrMessage(),
  sectionList: makeSelectSectionList(),
  sectionname: makeSelectSectionName(),
  loaderOn: makeSelectLoaderOn(),
});

function mapDispatchToProps(dispatch) {
  return {
    changeMessage: (evt) =&gt; {
      dispatch(getMessage());
      dispatch(getErrMessage());
      dispatch(getLoaderOn(evt));
    },

    onSubmitForm: (evt) =&gt; {
      if (evt !== undefined &amp;&amp; evt.preventDefault)
        evt.preventDefault();
      dispatch(submitForm());
    },
    onSelectionChange: (evt) =&gt; dispatch(selectStudent(evt.data)),
    onEditorValueChange: (row, value) =&gt; {
      dispatch(setEditorData(row, value));
    },
    onUpdate: (evt) =&gt; dispatch(submitUpdate()),
    onChangeSectionList: (evt) =&gt; dispatch(changeSectionName(evt.value)),
  };
}

const withConnect = connect(mapStateToProps, mapDispatchToProps);
const withReducer = injectReducer({ key: 'studentUpdateBasicInformation', reducer });
const withSaga = injectSaga({ key: 'studentUpdateBasicInformation', saga });

export default compose(
  withReducer,
  withSaga,
  withConnect,
)(StudentUpdateBasicInformation);
</code></pre>

<p><strong>constants.js</strong></p>

<pre><code>export const DEFAULT_ACTION = 'app/StudentUpdateBasicInformation/DEFAULT_ACTION';

export const SUBMIT_FORM = 'app/StudentUpdateBasicInformation/SUBMIT_FORM';
export const SET_STD_BASIC_INFO = 'app/StudentUpdateBasicInformation/SET_STD_BASIC_INFO';
export const SELECT_STUDENT = 'app/StudentUpdateBasicInformation/SELECT_STUDENT';
export const SET_EDITOR_DATA = 'app/StudentUpdateBasicInformation/SET_EDITOR_DATA';
export const GET_MESSAGE = 'app/StudentUpdateStudentId/GET_MESSAGE';
export const GET_ERR_MESSAGE = 'app/StudentUpdateStudentId/GET_ERR_MESSAGE';
export const SUBMIT_UPDATE = 'app/StudentUpdateBasicInformation/SUBMIT_UPDATE';
export const SET_SECTION_LIST = 'app/StudentUpdateBasicInformation/SET_SECTION_LIST';
export const CHANGE_SECTIONNAME = 'app/StudentUpdateBasicInformation/CHANGE_SECTIONNAME';
export const GET_LOADER_ON = 'app/StudentUpdateBasicInformation/GET_LOADER_ON';
</code></pre>

<p><strong>actions.js</strong></p>

<pre><code>import {
  DEFAULT_ACTION, SUBMIT_FORM, SET_STD_BASIC_INFO, SELECT_STUDENT, SET_EDITOR_DATA, SUBMIT_UPDATE, GET_MESSAGE, GET_ERR_MESSAGE, CHANGE_SECTIONNAME, SET_SECTION_LIST, GET_LOADER_OFF, GET_LOADER_ON
} from './constants';

export function defaultAction() {
  return {
    type: DEFAULT_ACTION,
  };
}

export function setStdBasicInfo(item) {
  return {
    type: SET_STD_BASIC_INFO,
    item,
  }
}

export function selectStudent(data) {
  return {
    type: SELECT_STUDENT,
    data,
  };
}

export function setEditorData(row, value) {
  return {
    type: SET_EDITOR_DATA,
    row, 
    value,
  };
}


export function submitForm() {
  return {
    type: SUBMIT_FORM,
  };
}

export function submitUpdate() {
  return {
    type: SUBMIT_UPDATE,
  };
}

export function getMessage(message) {
  return {
    type: GET_MESSAGE,
    message,
  }
}

export function getErrMessage(errmessage) {
  return {
    type: GET_ERR_MESSAGE,
    errmessage,
  }
}

export function setSectionList(sectionList) {
  return {
    type: SET_SECTION_LIST,
    sectionList,
  };
}
export function changeSectionName(sectionname) {
  return {
    type: CHANGE_SECTIONNAME,
    sectionname,
  };
}


export function getLoaderOn(loaderOn){
  return{
    type: GET_LOADER_ON,
    loaderOn,
  }
}
</code></pre>

<p><strong>reducer.js</strong></p>

<pre><code>import { fromJS } from 'immutable';
import {
  DEFAULT_ACTION, SET_STD_BASIC_INFO, SELECT_STUDENT, SET_EDITOR_DATA, GET_MESSAGE, GET_ERR_MESSAGE, SET_SECTION_LIST, CHANGE_SECTIONNAME, GET_LOADER_ON, GET_LOADER_OFF
} from './constants';

const initialState = fromJS({
  selectedStudent: [],
  value: [],
  sectionList: {},
  sectionname: '',
});

function studentUpdateBasicInformationReducer(state = initialState, action) {
  switch (action.type) {
    case DEFAULT_ACTION:
      return state;
    case SET_STD_BASIC_INFO:
      return state.set('stdBasicInfo', action.item);
    case SELECT_STUDENT:
      return state.set('selectedStudent', action.data);
    case SET_EDITOR_DATA:
      let updatedInfost = [...action.row.value];
      updatedInfost = [...action.row.value];
      updatedInfost[action.row.rowIndex][action.row.field] = action.value;
      return state.set('stdBasicInfo', updatedInfost);
    case GET_MESSAGE:
      return state.set('setMessage', action.message);
    case GET_ERR_MESSAGE:
      return state.set('setErrMessage', action.errmessage);
    case SET_SECTION_LIST:
      return state.set('sectionList', action.sectionList);
    case CHANGE_SECTIONNAME:
      return state.set('sectionname', action.sectionname);
      case GET_LOADER_ON:
      return state.set('loaderOn', action.loaderOn);
      // case GET_LOADER_OFF:
      // return state.set('loaderOff', action.loaderOff);
    default:
      return state;
  }
}

export default studentUpdateBasicInformationReducer;
</code></pre>

<p><strong>selectors.js</strong></p>

<pre><code>import { createSelector } from 'reselect';

const selectStudentUpdateBasicInformationDomain = (state) =&gt; state.get('studentUpdateBasicInformation');

const makeSelectStudentUpdateBasicInformation = () =&gt; createSelector(
  selectStudentUpdateBasicInformationDomain,
  (substate) =&gt; substate.toJS()
);

const makeSelectStdBasicInfo = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('stdBasicInfo'));
const makeSelectSelectedStudent = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (substate) =&gt; substate.get('selectedStudent'));
const makeSelectEditorStudent = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (substate) =&gt; substate.get('value'));
const makeSelectSetMessage = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('setMessage'));
const makeSelectSetErrMessage = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('setErrMessage'));
const makeSelectSectionName = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (abc) =&gt; abc.get('sectionname'));
const makeSelectSectionList = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain,(substate) =&gt; substate.get('sectionList'));
const makeSelectLoaderOn = () =&gt; createSelector(selectStudentUpdateBasicInformationDomain, (substate) =&gt; substate.get('loaderOn'));

export {
  selectStudentUpdateBasicInformationDomain,
  makeSelectStdBasicInfo,
  makeSelectSelectedStudent,
  makeSelectEditorStudent,
  makeSelectSetMessage,
  makeSelectSetErrMessage, makeSelectSectionName, makeSelectSectionList, makeSelectLoaderOn, 
  //makeSelectLoaderOff
};
</code></pre>

<p><strong>saga.js</strong></p>

<pre><code>import { take, call, put, select, takeLatest } from 'redux-saga/effects';
import { BASE_URL, FETCH_BASIC_INFO_LIST, UPDATE_ID, GET_CLASS_CONFIGURATION_URL, STUDENT_CONFIG_LIST } from '../../utils/serviceUrl';
import { setStdBasicInfo, getMessage, getErrMessage, selectStudent, setSectionList, changeSectionName, getLoaderOn } from './actions';
import request from '../../utils/request';
import { SUBMIT_FORM, SUBMIT_UPDATE } from './constants';
import { makeSelectEditorStudent, makeSelectSelectedStudent, makeSelectSectionList, makeSelectSectionName  } from './selectors';
import { getTokenData } from '../../utils/authHelper';

//FOR SECTION LIST
export function* fetchSectionList() {
  const tokenData = JSON.parse(getTokenData());
  const requestUrl = BASE_URL.concat(GET_CLASS_CONFIGURATION_URL);
  const options = {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': tokenData.token_type+"" ""+tokenData.access_token,
    },
  };
  try {
    const response = yield call(request, requestUrl, options);
    if (response.item) {
      yield put(setSectionList(response.item));
    }
  } catch (err) {
    console.dir(err);
  }
}

//FOR STUDENT BASIC INFO LIST
export function* fetchStudentBasicInfoList() {
  const tokenData = JSON.parse(getTokenData());
  const classConfigId = yield select(makeSelectSectionName());
  let msgg;
  if (classConfigId == '') {
    let msg = ""An error has occured. Please fill up all required fields"";
    yield put(getErrMessage(msg));

  }
  else {
    msgg = 'On';
    yield put(getLoaderOn(msgg));
  const requestURL = BASE_URL.concat(STUDENT_CONFIG_LIST).concat('?classConfigId=').concat(classConfigId);
  const options = {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': tokenData.token_type+"" ""+tokenData.access_token,
    },
  };
  const info = yield call(request, requestURL,options);
  yield put(setStdBasicInfo(info.item));
  msgg = 'Off';
  yield put(getLoaderOn(msgg));
  }
}


//FOR UPDATE STUDENT INFORMATION
export function* updateStdBasicInfo() {
  const tokenData = JSON.parse(getTokenData());
  const selectedCheckData = yield select(makeSelectSelectedStudent());
  let selectedData = [];
  if (selectedCheckData.length === undefined || selectedCheckData.length === 0) {
    const errresult = ""An error has occured. Please fill up all required fields"";
    yield put(getErrMessage(errresult));
  } else {

    for (const i in selectedCheckData) {
      const DataList = selectedCheckData[i];
      selectedData.push(DataList);
    }

    const requestURL = BASE_URL.concat(UPDATE_ID);
    const options = {
      method: 'PUT',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        'Authorization': tokenData.token_type+"" ""+tokenData.access_token,
      },

      body: JSON.stringify(selectedData),
    }

    try {
      const result = yield call(request, requestURL, options);
      yield put(selectStudent([]));
      yield fetchStudentBasicInfoList();
      yield put(getMessage(result));

    } catch (err) {
      const errresult = ""Something went wrong. Please try again."";
      yield put(setStdBasicInfo(info.item));
      yield put(getErrMessage(errresult));

    }
  }
}


export default function* defaultSaga() {
  yield fetchSectionList();
  yield takeLatest(SUBMIT_FORM, fetchStudentBasicInfoList);
  yield takeLatest(SUBMIT_UPDATE, updateStdBasicInfo);

}
</code></pre>
","6116522","","","","","2018-06-04 06:47:56","Use tab key not working on Prime-react editable Data table","<restful-authentication><redux-saga><primereact>","1","0","","",""
"50703141","1","","","2018-06-05 14:56:33","","1","46","<p>I'm using expandable panels (Material-UI) in rows with a react virtualized list and have been having issues with the heights auto-adjusting. I've read several SO posts and some issues on dynamic row heights on the react-virtualized site, but I have a specific problem where it seems like there's an 'off by one' issue with when the row height is adjusted after panel is expanded/collapsed.</p>

<p>Here's the expected behavior:</p>

<ol>
<li>Row panel expanded by default.</li>
<li>User clicks expandable panel row.</li>
<li>Row panel collapses.</li>
<li>Row height adjusts to panel collapse.</li>
</ol>

<p>Here's the actual behavior <em>FOR THE FIRST CLICK</em>:</p>

<ol>
<li>Row panel expanded by default.</li>
<li>User clicks expandable panel row.</li>
<li>Row panel collapses.</li>
<li>Row height does NOT adjust to panel collapse.</li>
<li>HOWEVER, on subsequent clicks the row height DOES adjust, but to the 'opposite' state, which leads to an inconsistency - i.e when the the row panel is clicked to expand again, the row height is adjusted to the row height as if it were collapsed, and vice versa. So when the panel is collapsed there's a bunch of white space after it, and when it's technically expanded the row height is too small to see the content.</li>
</ol>

<p>I'm not sure what other info to include besides posting code and noting that the onRowClick() IS firing when the panels are collapsed/expanded.</p>

<p>Here's the parent component:</p>

<pre><code>import React, { Component } from 'react';
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer';
import List from 'react-virtualized/dist/commonjs/List';
import { CellMeasurer, CellMeasurerCache } from 'react-virtualized/dist/commonjs/CellMeasurer';
import EquipSummaryRow from './EquipSummaryRow';
import './EquipSummary.css';

class EquipSummary extends Component {
  constructor(props) {
    super(props);

    this.cache = new CellMeasurerCache({
      fixedWidth: true,
    });

    this.rowRenderer = this.rowRenderer.bind(this);
    this.getDatum = this.getDatum.bind(this);
    this.onRowClick = this.onRowClick.bind(this);
  }

  getDatum(index) {
    const list = this.props.equipData;

    return list[index];
  }

  saveRef = (ref) =&gt; this.containerNode = ref;

  saveListRef = (ref) =&gt; {
    this.list = ref;
  }

  componentDidUpdate() {
    console.log('component updated');
    this.cache.clearAll();
    this.list.recomputeRowHeights();
  }

  onRowClick(e, index) {
    e.preventDefault();
    this.cache.clear(index);
    this.list.recomputeRowHeights();
    this.list.forceUpdateGrid();
  }

  rowRenderer({ index, key, parent, style }) {
    const datum = this.getDatum(index);
    return (
      &lt;div key={key} style={style}&gt;
        &lt;CellMeasurer
          cache={this.cache}
          columnIndex={0}
          key={key}
          rowIndex={index}
          parent={parent}
        &gt;
          {({ measure }) =&gt; (
            &lt;EquipSummaryRow
              onClick={(e, idx) =&gt; this.onRowClick(e, idx)}
              measure={measure}
              datum={datum}
              index={index}
            /&gt;
          )}
        &lt;/CellMeasurer&gt;
      &lt;/div&gt;
    );
  }

  render() {
    console.log('rendering..');
    return (
      &lt;div className=""EquipSummary-AutoSizer"" ref={this.saveRef}&gt;
        &lt;AutoSizer&gt;
          {({ width, height }) =&gt; (
            &lt;List
              ref={this.saveListRef}
              width={width}
              height={height}
              rowHeight={this.cache.rowHeight}
              rowCount={this.props.equipData.length}
              rowRenderer={this.rowRenderer}
              deferredMeasurementCache={this.cache}
              equipData={this.props.equipData}
            /&gt;
          )}
        &lt;/AutoSizer&gt;
      &lt;/div&gt;
    );
  }
}

export default EquipSummary;
</code></pre>

<p>And here's the component that represents a row:</p>

<pre><code>import React, { Component } from 'react';
import {
  Table,
  TableBody,
  TableHeader,
  TableHeaderColumn,
  TableRow,
  TableRowColumn,
} from 'material-ui/Table';
import { MuiThemeProvider } from 'material-ui/styles';
import ExpansionPanel from '@material-ui/core/ExpansionPanel';
import ExpansionPanelSummary from '@material-ui/core/ExpansionPanelSummary';
import ExpansionPanelDetails from '@material-ui/core/ExpansionPanelDetails';
import Typography from '@material-ui/core/Typography';


class EquipSummaryRow extends Component {
  render() {
    const { datum } = this.props;

    return (
      &lt;div&gt;
        &lt;ExpansionPanel
          defaultExpanded
          onChange={e =&gt; this.props.onClick(e, this.props.index)}
        &gt;
          &lt;ExpansionPanelSummary expandIcon={&lt;div&gt;|&lt;/div&gt;}&gt;
            &lt;Typography&gt;{`${datum.type}      (id: ${datum.instance}, points: ${datum.points.length})`}&lt;/Typography&gt;
          &lt;/ExpansionPanelSummary&gt;
          &lt;ExpansionPanelDetails&gt;
            &lt;Table&gt;
              &lt;TableHeader
                displaySelectAll={false}
                adjustForCheckbox={false}
              &gt;
                &lt;TableRow&gt;
                  &lt;TableHeaderColumn&gt;Device&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Object ID&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Type&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Name&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Description&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Units&lt;/TableHeaderColumn&gt;
                  &lt;TableHeaderColumn&gt;Value&lt;/TableHeaderColumn&gt;
                &lt;/TableRow&gt;
              &lt;/TableHeader&gt;
              &lt;TableBody
                displayRowCheckbox={false}
              &gt;
                {datum.points.map((row, index) =&gt; (
                  &lt;TableRow key={row.id}&gt;
                    &lt;TableRowColumn&gt;{row.device}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.objectID}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.type}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.name}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.description}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.units}&lt;/TableRowColumn&gt;
                    &lt;TableRowColumn&gt;{row.value}&lt;/TableRowColumn&gt;
                  &lt;/TableRow&gt;
                  ))}
              &lt;/TableBody&gt;
            &lt;/Table&gt;
          &lt;/ExpansionPanelDetails&gt;
        &lt;/ExpansionPanel&gt;
      &lt;/div&gt;
    );
  }
}

export default EquipSummaryRow;
</code></pre>

<p>Could this be an issue with how I'm using the cache? I've been beating my head with this so any suggestions appreciated!</p>
","5724381","","","","","2018-06-06 03:43:53","How to troubleshoot row height adjustment with expandable rows with react virtualized list?","<reactjs><material-ui><react-virtualized>","1","1","","",""
"51033875","1","","","2018-06-26 01:55:11","","1","18","<p>I am using redux saga and react-navigation to build my first react native app. I have successfully dispatched action to store->saga->reducer->mapStateToProps. I am trying to build a signup screen
I need to check if the signup was successful and then redirect the user to the home screen or show error message.
However, after receiving the updated values in mapStateToProps, none of the component update methods are firing,i.e, componentDidUpdate() compoenentWillReceiveProps() etc.(tried them all). I need this to that I can check the state and then navigate the user to another Comoponent (home screen).
Following code snippet might throw some more light:-</p>

<p>Reducer function:-</p>

<pre><code>  const initialState = new Map({
    error:false,
  resp:null,
  errResp:null
});
export default (state=initialState, action) =&gt; {
  switch (action.type) {
    case SIGNUP_SUCCESS:
      return[...state,{
        error:action.error,
        resp:action.resp,
        errResp:action.errResp
      }];
</code></pre>

<p>Map StateToProps:-</p>

<pre><code>const mapStateToProps = (state) =&gt;{
    console.log(""Returning"");
  return {
        error: state.Auth.error,
        resp: state.Auth.resp,
        errResp:state.Auth.errResp

    }
};
</code></pre>
","2373449","","","","","2018-06-26 01:55:11","Unable to navigate in react-native using react navigation since component react component life cycle methods are not firing","<react-native><react-redux><react-navigation><redux-saga>","0","0","","",""
"51174738","1","","","2018-07-04 13:21:04","","0","27","<p>Here is what I want to achieve. My user is typing a text in a react-quill component and each time the user type a hashtag like ""<strong>#S1</strong> "" (the space is important, it allow to detect when the user has finished to type his tag) I want to replace the tag #S1 by a specific text containing some value.</p>

<p>I <strong>don't use delta</strong>, but HTML string for the value of the reat-quill component. So far I have succeed to replace the hastag bug the proper value I need, and add a color to the span inserted. What I want to also add is a title attribute that will allow to show the corresponding tag name (i.e. #S1) and an id that will identify uniquely identify the content of the tag. But when I tried to add these attribute in my span, it's systematically strip.</p>

<p>I understood that I have to create my own parchment, but I' didn't succeed to get it work. Here is my code.</p>

<pre><code>const modules = {
  toolbar: [
    [{header: [1, 2, false]}],
    ['bold', 'italic', 'underline', 'strike', 'blockquote'],
    [{'script': 'sub'}, {'script': 'super'}],
    [{'list': 'ordered'}, {'list': 'bullet'}, {'indent': '-1'}, {'indent': '+1'}],
    ['link', 'image'],
    ['clean'],
    [{color: []}, {background: []}],
  ],
};
const formats = [
  'header',
  'bold', 'italic', 'underline', 'strike', 'blockquote',
  'script', 'sub', 'super',
  'list', 'bullet', 'indent',
  'link', 'image',
  'color', 'background',

];
/**
 * Inline Em Tag from Quill Docs:
 * https://quilljs.com/guides/cloning-medium-with-parchment/
 */
let Inline = ReactQuill.Quill.import('blots/inline');
class EmphBlot extends Inline {
  static create(value) {
    console.log(value);
    let node = super.create();
    node.setAttribute('style', 'color: rgb(230, 0, 0)');
    node.setAttribute('title', value.title);

    return node;
  }

  static value(node) {
    return {
      title: node.getAttribute('title'),
      style: node.getAttribute('style')
    };
  }
}

EmphBlot.blotName = 'tag';
EmphBlot.tagName = 'span';
ReactQuill.Quill.register('formats/em', EmphBlot);

class Editor extends React.Component {
  constructor (props) {
    super(props)
    this.state = { editorHtml: '&lt;p&gt;Start here by typing a hashtag&lt;/p&gt;' }
    this.quillRef = null;
    this.reactQuillRef = null;
    this.handleChange = this.handleChange.bind(this)
    this.handleClickEmbed = this.handleClickEmbed.bind(this)
    this.handleClickFormat = this.handleClickFormat.bind(this)
    this.registerFormats = this.registerFormats.bind(this)
  }

  componentDidMount () {
    this.registerFormats()
    this.setState({
      editorHtml: '' // trigger update
    })
  }

  componentDidUpdate () {
    this.registerFormats()
  }

  registerFormats () {
    // Ensure React-Quill references is available:
    if (typeof this.reactQuillRef.getEditor !== 'function') return;
    // Skip if Quill reference is defined:
    if (this.quillRef != null) return;

    console.log('Registering formats...', this.reactQuillRef)
    const quillRef = this.reactQuillRef.getEditor() // could still be null

    if (quillRef != null) {
      this.quillRef = quillRef;
      // console.log(Quill.imports)
    }
  }

  handleClickFormat () {
    var range = this.quillRef.getSelection();
    if (range) {      
      this.quillRef.format('em', true);
    }
  }

  handleClickEmbed () {
    var range = this.quillRef.getSelection();
    if (range) {      
      this.quillRef.insertEmbed(range.index,""hr"",""null"")
    }
  }

  checkForTag(content, indexPosition){
  let tag = /#(\w+)\s/;
  let find = content.match(tag);
  let indexAfterInsertion = indexPosition;
  let updated = false;
  let comment;
  if (find !== null) {
    indexAfterInsertion = indexPosition - find[0].length;
    let replace = ""My new data (1, 5, 3)""
    indexAfterInsertion += replace.length + 1;
    updated = true;
    if (replace !== '#' + find[1]) {
      let toReplacer = '&lt;span style=""color:red"" title=""tag-' + find[1].toUpperCase() + '""&gt;' + replace + '&lt;/span&gt;&amp;nbsp;';
      // console.log(toReplacer);
      comment = content.replace(/#(\w+)\s/, toReplacer);
    } else {
      comment = content.replace(/#(\w+)\s/, find[1] + ""&amp;nbsp;"");
    }
  }
  // console.log(comment);
  return {content: comment, updated, indexAfterInsertion}
  }

  handleChange (content, delta, source, editor) {
    let editorHtml = content
    let newHtml = this.checkForTag(content);
    if(newHtml.updated === true){
      console.log(newHtml);
      editorHtml = newHtml.content
    }
    console.log(editorHtml)
    this.setState({editorHtml});
  }

  render () {
    return (
      &lt;div&gt;
        &lt;p&gt;Enter a text containing #S1 (or any other tag, the space must be placed after the tag). It sould be replaced by an other data, but missing the attribute title.&lt;/p&gt;

        &lt;ReactQuill 
          ref={(el) =&gt; { this.reactQuillRef = el }}
          value={this.state.editorHtml}
          onChange={this.handleChange.bind(this)}
          modules={modules}
          formats={formats}
          /&gt;
       &lt;/div&gt;
     )
  }
}

Editor.propTypes = {
  placeholder: React.PropTypes.string,
}

ReactDOM.render(
  &lt;div&gt;
    &lt;Editor/&gt;
   &lt;/div&gt;, 
  document.querySelector('.app')
)
</code></pre>

<p>Here is a codepen showing how it work so far <a href=""https://codepen.io/FLCcrakers/pen/JZVeZE?editors=0111"" rel=""nofollow noreferrer"">https://codepen.io/FLCcrakers/pen/JZVeZE?editors=0111</a></p>

<p>I surely miss something, but don't understand what. </p>
","6075767","","","","","2018-07-04 13:21:04","react-quill How to properly add attribute to a specific html tag","<javascript><html><css><reactjs><quilljs>","0","0","","",""
"51176044","1","","","2018-07-04 14:30:53","","0","33","<p>In one of my projects I'm using the <b>html-react-parser</b> module.
In my component I have very simple if/else condition:</p>

<pre><code>import React, {Component}   from 'react';
import {connect}            from 'react-redux';
import HTMLParser           from '../../components/htmlParser'

class Content extends Component {
    render() {
        if( this.props.layout === 'one_column' ){
            return &lt;div className=""one-column""&gt;&lt;HTMLParser parse={this.props.content} /&gt;&lt;/div&gt;
        }
        else {
            return &lt;HTMLParser parse={this.props.content} /&gt;;

        }
     }
 }

function mapStateToProps({reducerContent},ownProps) {
    return {...reducerContent}
}

export default connect(mapStateToProps,null)(Content)
</code></pre>

<p>The funny thing is my first request returns ""two_columns"" and I enter the ""else"" statement. All fine. My HTMLParser component renders and fires the <b>componentDidUpdate</b> event. BUT my second request returns ""one_column"", I enter the ""if"" statement, HTMLParser gets rendered but doesn't fire the componentDidUpdate event. If I remove div that is wrapping him in ""if"" condition, it's all fine. Anyone has any idea why is it happening?</p>
","2348670","","","","","2018-07-04 14:30:53","React Component doesn't fire componentDidUpdate","<javascript><reactjs><components><lifecycle>","0","1","","",""
"50760870","1","","","2018-06-08 12:40:10","","0","30","<p>I have a major performance issue with rendering markers based on active filters on the map.</p>

<p>I have a data structure, which is something like</p>

<pre><code>const businesses = [
  {
    ...location,
    businessType: 'Market'
  },
  ...etc
]
</code></pre>

<p>There's 150 items in that dataset right now. All of the markers are rendered by default. Currently I'm generating the data for markers randomly.</p>

<p>Now, I as well have categories which can be toggled, if category is toggled => render that business type.</p>

<p>Now, whenever I toggle categories my JS thread jumps to 0 fps and the UI thread get's blocked.</p>

<p>Here's my current code:</p>

<pre><code>import React, { PureComponent } from 'react';
import { InteractionManager } from 'react-native';
import generateRandomMapData from 'utils/generateRandomMapData';
import CustomMarker from './CustomMarker';

const CENTER_OF_BERLIN = {
  latitude: 52.5200,
  longitude: 13.4050,
};

const RADIUS = 5000;
const AMOUNT_OF_MARKERS = 150;

class Markers extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      markers: null
    }
  }
  componentDidMount() {
    this.interactionHandle = InteractionManager.runAfterInteractions(() =&gt; {
      this.setState({ markers: generateRandomMapData(CENTER_OF_BERLIN, RADIUS, AMOUNT_OF_MARKERS) }, () =&gt; {
        this.interactionHandle = null;
      })
    })
  }
  componentWillUnmount() {
    if (this.interactionHandle) this.interactionHandle.cancel();
  }
  renderMarkers() {
    const { markers } = this.state;

    if (markers &amp;&amp; markers.length) {
      return markers.map((b, i) =&gt; &lt;CustomMarker location={b.location} key={i} businessType={b.businessType} /&gt;)
    }

    return null;
  }
  render() {
    return this.renderMarkers()
  }
}

export default Markers;
</code></pre>

<p>And the file for individual Markers</p>

<pre><code>import React, { PureComponent } from 'react';
import { View, InteractionManager } from 'react-native'
import { Marker } from 'react-native-maps';
import { connect } from 'react-redux';
import SVG from 'components/svg/SVG'

const BUSINESS_COLORS = {
  market: '#EC6D52',
  farm: '#763DAB',
  restaurant: '#C45D72',
  UrbanFarm: '#4B85DD',
  store: '#65A077',
}

class CustomMarker extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      shouldRender: false
    }
  }
  componentWillMount() {
    const { businessType, categories } = this.props;

    this.interactionHandle = InteractionManager.runAfterInteractions(() =&gt; {
      if (this._getActiveCategories(categories).includes(businessType) !== this.state.shouldRender) {
        this.setState({ shouldRender: this._getActiveCategories(categories).includes(businessType) }, () =&gt; {
          this.interactionHandle = null;
        });
      }
    });
  }
  componentDidUpdate() {
    if (this.interactionHandle) this.interactionHandle.cancel();

    const { businessType, categories } = this.props;
    const { shouldRender } = this.state;

    this.interactionHandle = InteractionManager.runAfterInteractions(() =&gt; {
      if (this._getActiveCategories(categories).includes(businessType) !== shouldRender) {
        this.setState({ shouldRender: this._getActiveCategories(categories).includes(businessType) }, () =&gt; {
          this.interactionHandle = null;
        })
      }
    });
  }
  componentWillUnmount() {
    if (this.interactionHandle) this.interactionHandle.cancel();
  }
  _getActiveCategories(categories) {
    const active = [];

    for (let category of categories) {
      if (category.active) {
        active.push(category.icon)
      }
    }

    return active;
  }
  render() {
    const { businessType, location } = this.props;
    const { shouldRender } = this.state;
    const iconColor = BUSINESS_COLORS[businessType.toLowerCase()];

    const opacity = shouldRender ? 1.0 : 0.0;

    return (
      &lt;Marker coordinate={{ ...location }} opacity={opacity}&gt;
        &lt;View style={{ width: 29, height: 36 }}&gt;
          &lt;SVG icon=""Marker"" width=""29"" height=""36"" fill={iconColor} /&gt;
        &lt;/View&gt;
      &lt;/Marker&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  categories: state.categories
});

export default connect(mapStateToProps, {
})(CustomMarker);
</code></pre>

<p>The categories themselves live in Redux and the Markers are mapped based on that.</p>

<p>It seems that calling <code>setState</code> on like 25 affected markers at the same time is incredibly heavy, even if used <code>InteractionManager</code>.</p>

<p>Any ideas how to optimize this performance?</p>
","3840147","","","","","2018-06-08 12:40:10","Dynamic render of multiple custom markers with react-native-maps","<javascript><reactjs><react-native><react-native-maps>","0","2","","",""
"51019501","1","51022471","","2018-06-25 08:49:18","","0","48","<p>I am using a simple HTML select dropdown and controlling it with react (==> controlled component). Everything fine so far. The Problem is - the select options are updated via an async ajax call every few seconds and empty at the beginning. The selects data list is propagated via props. </p>

<p>So, the select data list changes, the selected options list changes - but no change is fired (afaik by design of react). 
I have found a working way to listen for these changes by listening to ""componentDidUpdate"" and firing a onChange ""by hand"" by reading out the value of the select as reference - but this seems very ""un react-ish"" (code below). Does anyone know the ""react"" way to do this? </p>

<p>Full code:</p>

<pre><code>class Dropdown extends React.Component {
    constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.dropDown = React.createRef();      
    }

    handleChange(event) {
        if (this.props.onChange) this.props.onChange(event.target.value);
    }

    componentDidUpdate(prevProps) {
        if (this.props.options.length != prevProps.options.length) {
            if (this.props.onChange) this.props.onChange(this.dropDown.current.value);
        } else {
            for (let i = 0; i &lt; this.props.options.length; i++) {
                if (this.props.options.value != prevProps.options.value) {
                    if (this.props.onChange) this.props.onChange(this.dropDown.current.value);
                    return;
                }
            }
        }
    }

    render() {
        const optionList = this.props.options.map(option =&gt; &lt;option value={option.value} key={option.value}&gt;{option.name}&lt;/option&gt;);
        return &lt;select value={this.props.value} onChange={this.handleChange} ref={this.dropDown}&gt;{optionList}&lt;/select&gt;;
    }
}
</code></pre>

<p>props.options start as empty list. Some parent node holds this list as a state and updates it every few seconds with a ajax request. </p>

<p>Sandbox code: <a href=""https://codesandbox.io/s/6l927kpx13"" rel=""nofollow noreferrer"">https://codesandbox.io/s/6l927kpx13</a></p>
","9987858","","9987858","","2018-06-25 11:57:52","2018-06-25 11:57:52","(react) Listening to dropdown/select value changes triggered by changed data list propagated as props","<javascript><reactjs><browser>","2","3","","",""